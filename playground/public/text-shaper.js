var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// reference/text-shaper/src/raster/types.ts
var exports_types = {};
__export(exports_types, {
  createBottomUpBitmap: () => createBottomUpBitmap,
  createBitmap: () => createBitmap,
  clearBitmap: () => clearBitmap,
  PixelMode: () => PixelMode,
  FillRule: () => FillRule
});
function createBitmap(width, height, pixelMode = 1 /* Gray */) {
  let bytesPerPixel;
  switch (pixelMode) {
    case 0 /* Mono */:
      bytesPerPixel = 1 / 8;
      break;
    case 1 /* Gray */:
      bytesPerPixel = 1;
      break;
    case 2 /* LCD */:
    case 3 /* LCD_V */:
      bytesPerPixel = 3;
      break;
    case 4 /* RGBA */:
      bytesPerPixel = 4;
      break;
  }
  const pitch = pixelMode === 0 /* Mono */ ? Math.ceil(width / 8) : width * bytesPerPixel;
  return {
    buffer: new Uint8Array(pitch * height),
    width,
    rows: height,
    pitch,
    pixelMode,
    numGrays: pixelMode === 0 /* Mono */ ? 2 : 256
  };
}
function clearBitmap(bitmap) {
  bitmap.buffer.fill(0);
}
function createBottomUpBitmap(width, height, pixelMode = 1 /* Gray */) {
  const bitmap = createBitmap(width, height, pixelMode);
  bitmap.pitch = -bitmap.pitch;
  return bitmap;
}
var PixelMode, FillRule;
var init_types = __esm(() => {
  ((PixelMode2) => {
    PixelMode2[PixelMode2["Mono"] = 0] = "Mono";
    PixelMode2[PixelMode2["Gray"] = 1] = "Gray";
    PixelMode2[PixelMode2["LCD"] = 2] = "LCD";
    PixelMode2[PixelMode2["LCD_V"] = 3] = "LCD_V";
    PixelMode2[PixelMode2["RGBA"] = 4] = "RGBA";
  })(PixelMode ||= {});
  ((FillRule2) => {
    FillRule2[FillRule2["NonZero"] = 0] = "NonZero";
    FillRule2[FillRule2["EvenOdd"] = 1] = "EvenOdd";
  })(FillRule ||= {});
});

// reference/text-shaper/src/font/brotli/context.ts
var CONTEXT_LOOKUP, CONTEXT_LOOKUP_OFFSETS;
var init_context = __esm(() => {
  CONTEXT_LOOKUP = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    4,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    12,
    16,
    12,
    12,
    20,
    12,
    16,
    24,
    28,
    12,
    12,
    32,
    12,
    36,
    12,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    32,
    32,
    24,
    40,
    28,
    12,
    12,
    48,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    52,
    52,
    24,
    12,
    28,
    12,
    12,
    12,
    56,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    60,
    60,
    24,
    12,
    28,
    12,
    0,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    0,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    56,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    9,
    9,
    9,
    9,
    10,
    10,
    10,
    10,
    11,
    11,
    11,
    11,
    12,
    12,
    12,
    12,
    13,
    13,
    13,
    13,
    14,
    14,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    25,
    25,
    25,
    25,
    26,
    26,
    26,
    26,
    27,
    27,
    27,
    27,
    28,
    28,
    28,
    28,
    29,
    29,
    29,
    29,
    30,
    30,
    30,
    30,
    31,
    31,
    31,
    31,
    32,
    32,
    32,
    32,
    33,
    33,
    33,
    33,
    34,
    34,
    34,
    34,
    35,
    35,
    35,
    35,
    36,
    36,
    36,
    36,
    37,
    37,
    37,
    37,
    38,
    38,
    38,
    38,
    39,
    39,
    39,
    39,
    40,
    40,
    40,
    40,
    41,
    41,
    41,
    41,
    42,
    42,
    42,
    42,
    43,
    43,
    43,
    43,
    44,
    44,
    44,
    44,
    45,
    45,
    45,
    45,
    46,
    46,
    46,
    46,
    47,
    47,
    47,
    47,
    48,
    48,
    48,
    48,
    49,
    49,
    49,
    49,
    50,
    50,
    50,
    50,
    51,
    51,
    51,
    51,
    52,
    52,
    52,
    52,
    53,
    53,
    53,
    53,
    54,
    54,
    54,
    54,
    55,
    55,
    55,
    55,
    56,
    56,
    56,
    56,
    57,
    57,
    57,
    57,
    58,
    58,
    58,
    58,
    59,
    59,
    59,
    59,
    60,
    60,
    60,
    60,
    61,
    61,
    61,
    61,
    62,
    62,
    62,
    62,
    63,
    63,
    63,
    63,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  CONTEXT_LOOKUP_OFFSETS = new Uint16Array([
    1024,
    1536,
    1280,
    1536,
    0,
    256,
    768,
    512
  ]);
});

// reference/text-shaper/src/font/brotli/dictionary.ts
var DICTIONARY_OFFSETS_BY_LENGTH, DICTIONARY_SIZE_BITS_BY_LENGTH, DICTIONARY;
var init_dictionary = __esm(() => {
  DICTIONARY_OFFSETS_BY_LENGTH = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    4096,
    9216,
    21504,
    35840,
    44032,
    53248,
    63488,
    74752,
    87040,
    93696,
    100864,
    104704,
    106752,
    108928,
    113536,
    115968,
    118528,
    119872,
    121280,
    122016
  ]);
  DICTIONARY_SIZE_BITS_BY_LENGTH = new Uint8Array([
    0,
    0,
    0,
    0,
    10,
    10,
    11,
    11,
    10,
    10,
    10,
    10,
    10,
    9,
    9,
    8,
    7,
    7,
    8,
    7,
    7,
    6,
    6,
    5,
    5
  ]);
  DICTIONARY = new Uint8Array(122784);
});

// reference/text-shaper/src/font/brotli/transform.ts
function makeTransform(prefix, transform, suffix) {
  const prefixBytes = new Uint8Array(prefix.length);
  const suffixBytes = new Uint8Array(suffix.length);
  for (let i = 0;i < prefix.length; i++)
    prefixBytes[i] = prefix.charCodeAt(i);
  for (let i = 0;i < suffix.length; i++)
    suffixBytes[i] = suffix.charCodeAt(i);
  return { prefix: prefixBytes, transform, suffix: suffixBytes };
}
function toUpperCase(p, i) {
  if (p[i] < 192) {
    if (p[i] >= 97 && p[i] <= 122) {
      p[i] ^= 32;
    }
    return 1;
  }
  if (p[i] < 224) {
    p[i + 1] ^= 32;
    return 2;
  }
  p[i + 2] ^= 5;
  return 3;
}
function transformDictionaryWord(dst, idx, wordOffset, len, transformIdx, dictionary) {
  const transform = TRANSFORMS[transformIdx];
  const t = transform.transform;
  let skip = t < OMIT_FIRST_1 ? 0 : t - (OMIT_FIRST_1 - 1);
  const startIdx = idx;
  if (skip > len)
    skip = len;
  for (let i = 0;i < transform.prefix.length; i++) {
    dst[idx++] = transform.prefix[i];
  }
  const word = wordOffset + skip;
  let wordLen = len - skip;
  if (t <= OMIT_LAST_9) {
    wordLen -= t;
  }
  for (let i = 0;i < wordLen; i++) {
    dst[idx++] = dictionary[word + i];
  }
  let uppercase = idx - wordLen;
  if (t === UPPERCASE_FIRST) {
    toUpperCase(dst, uppercase);
  } else if (t === UPPERCASE_ALL) {
    while (wordLen > 0) {
      const step = toUpperCase(dst, uppercase);
      uppercase += step;
      wordLen -= step;
    }
  }
  for (let i = 0;i < transform.suffix.length; i++) {
    dst[idx++] = transform.suffix[i];
  }
  return idx - startIdx;
}
var IDENTITY = 0, OMIT_LAST_1 = 1, OMIT_LAST_2 = 2, OMIT_LAST_3 = 3, OMIT_LAST_4 = 4, OMIT_LAST_5 = 5, OMIT_LAST_6 = 6, OMIT_LAST_7 = 7, OMIT_LAST_8 = 8, OMIT_LAST_9 = 9, UPPERCASE_FIRST = 10, UPPERCASE_ALL = 11, OMIT_FIRST_1 = 12, OMIT_FIRST_2 = 13, OMIT_FIRST_3 = 14, OMIT_FIRST_4 = 15, OMIT_FIRST_5 = 16, OMIT_FIRST_6 = 17, OMIT_FIRST_7 = 18, OMIT_FIRST_9 = 20, TRANSFORMS;
var init_transform = __esm(() => {
  TRANSFORMS = [
    makeTransform("", IDENTITY, ""),
    makeTransform("", IDENTITY, " "),
    makeTransform(" ", IDENTITY, " "),
    makeTransform("", OMIT_FIRST_1, ""),
    makeTransform("", UPPERCASE_FIRST, " "),
    makeTransform("", IDENTITY, " the "),
    makeTransform(" ", IDENTITY, ""),
    makeTransform("s ", IDENTITY, " "),
    makeTransform("", IDENTITY, " of "),
    makeTransform("", UPPERCASE_FIRST, ""),
    makeTransform("", IDENTITY, " and "),
    makeTransform("", OMIT_FIRST_2, ""),
    makeTransform("", OMIT_LAST_1, ""),
    makeTransform(", ", IDENTITY, " "),
    makeTransform("", IDENTITY, ", "),
    makeTransform(" ", UPPERCASE_FIRST, " "),
    makeTransform("", IDENTITY, " in "),
    makeTransform("", IDENTITY, " to "),
    makeTransform("e ", IDENTITY, " "),
    makeTransform("", IDENTITY, '"'),
    makeTransform("", IDENTITY, "."),
    makeTransform("", IDENTITY, '">'),
    makeTransform("", IDENTITY, `
`),
    makeTransform("", OMIT_LAST_3, ""),
    makeTransform("", IDENTITY, "]"),
    makeTransform("", IDENTITY, " for "),
    makeTransform("", OMIT_FIRST_3, ""),
    makeTransform("", OMIT_LAST_2, ""),
    makeTransform("", IDENTITY, " a "),
    makeTransform("", IDENTITY, " that "),
    makeTransform(" ", UPPERCASE_FIRST, ""),
    makeTransform("", IDENTITY, ". "),
    makeTransform(".", IDENTITY, ""),
    makeTransform(" ", IDENTITY, ", "),
    makeTransform("", OMIT_FIRST_4, ""),
    makeTransform("", IDENTITY, " with "),
    makeTransform("", IDENTITY, "'"),
    makeTransform("", IDENTITY, " from "),
    makeTransform("", IDENTITY, " by "),
    makeTransform("", OMIT_FIRST_5, ""),
    makeTransform("", OMIT_FIRST_6, ""),
    makeTransform(" the ", IDENTITY, ""),
    makeTransform("", OMIT_LAST_4, ""),
    makeTransform("", IDENTITY, ". The "),
    makeTransform("", UPPERCASE_ALL, ""),
    makeTransform("", IDENTITY, " on "),
    makeTransform("", IDENTITY, " as "),
    makeTransform("", IDENTITY, " is "),
    makeTransform("", OMIT_LAST_7, ""),
    makeTransform("", OMIT_LAST_1, "ing "),
    makeTransform("", IDENTITY, `
	`),
    makeTransform("", IDENTITY, ":"),
    makeTransform(" ", IDENTITY, ". "),
    makeTransform("", IDENTITY, "ed "),
    makeTransform("", OMIT_FIRST_9, ""),
    makeTransform("", OMIT_FIRST_7, ""),
    makeTransform("", OMIT_LAST_6, ""),
    makeTransform("", IDENTITY, "("),
    makeTransform("", UPPERCASE_FIRST, ", "),
    makeTransform("", OMIT_LAST_8, ""),
    makeTransform("", IDENTITY, " at "),
    makeTransform("", IDENTITY, "ly "),
    makeTransform(" the ", IDENTITY, " of "),
    makeTransform("", OMIT_LAST_5, ""),
    makeTransform("", OMIT_LAST_9, ""),
    makeTransform(" ", UPPERCASE_FIRST, ", "),
    makeTransform("", UPPERCASE_FIRST, '"'),
    makeTransform(".", IDENTITY, "("),
    makeTransform("", UPPERCASE_ALL, " "),
    makeTransform("", UPPERCASE_FIRST, '">'),
    makeTransform("", IDENTITY, '="'),
    makeTransform(" ", IDENTITY, "."),
    makeTransform(".com/", IDENTITY, ""),
    makeTransform(" the ", IDENTITY, " of the "),
    makeTransform("", UPPERCASE_FIRST, "'"),
    makeTransform("", IDENTITY, ". This "),
    makeTransform("", IDENTITY, ","),
    makeTransform(".", IDENTITY, " "),
    makeTransform("", UPPERCASE_FIRST, "("),
    makeTransform("", UPPERCASE_FIRST, "."),
    makeTransform("", IDENTITY, " not "),
    makeTransform(" ", IDENTITY, '="'),
    makeTransform("", IDENTITY, "er "),
    makeTransform(" ", UPPERCASE_ALL, " "),
    makeTransform("", IDENTITY, "al "),
    makeTransform(" ", UPPERCASE_ALL, ""),
    makeTransform("", IDENTITY, "='"),
    makeTransform("", UPPERCASE_ALL, '"'),
    makeTransform("", UPPERCASE_FIRST, ". "),
    makeTransform(" ", IDENTITY, "("),
    makeTransform("", IDENTITY, "ful "),
    makeTransform(" ", UPPERCASE_FIRST, ". "),
    makeTransform("", IDENTITY, "ive "),
    makeTransform("", IDENTITY, "less "),
    makeTransform("", UPPERCASE_ALL, "'"),
    makeTransform("", IDENTITY, "est "),
    makeTransform(" ", UPPERCASE_FIRST, "."),
    makeTransform("", UPPERCASE_ALL, '">'),
    makeTransform(" ", IDENTITY, "='"),
    makeTransform("", UPPERCASE_FIRST, ","),
    makeTransform("", IDENTITY, "ize "),
    makeTransform("", UPPERCASE_ALL, "."),
    makeTransform("Â ", IDENTITY, ""),
    makeTransform(" ", IDENTITY, ","),
    makeTransform("", UPPERCASE_FIRST, '="'),
    makeTransform("", UPPERCASE_ALL, '="'),
    makeTransform("", IDENTITY, "ous "),
    makeTransform("", UPPERCASE_ALL, ", "),
    makeTransform("", UPPERCASE_FIRST, "='"),
    makeTransform(" ", UPPERCASE_FIRST, ","),
    makeTransform(" ", UPPERCASE_ALL, '="'),
    makeTransform(" ", UPPERCASE_ALL, ", "),
    makeTransform("", UPPERCASE_ALL, ","),
    makeTransform("", UPPERCASE_ALL, "("),
    makeTransform("", UPPERCASE_ALL, ". "),
    makeTransform(" ", UPPERCASE_ALL, "."),
    makeTransform("", UPPERCASE_ALL, "='"),
    makeTransform(" ", UPPERCASE_ALL, ". "),
    makeTransform(" ", UPPERCASE_FIRST, '="'),
    makeTransform(" ", UPPERCASE_ALL, "='"),
    makeTransform(" ", UPPERCASE_FIRST, "='")
  ];
});

// reference/text-shaper/src/font/brotli/decode.ts
var exports_decode = {};
__export(exports_decode, {
  decompress: () => decompress,
  __testing: () => __testing
});

class BitReader {
  data;
  buf;
  pos = 0;
  val = 0;
  bitPos = 0;
  bitEndPos = 0;
  eos = false;
  constructor(data) {
    this.data = data;
    this.buf = new Uint8Array(8224);
    this.fillBuffer();
    for (let i = 0;i < 4; i++) {
      this.val |= this.buf[this.pos] << 8 * i;
      this.pos++;
    }
  }
  fillBuffer() {
    if (this.bitEndPos > 256)
      return;
    if (this.eos) {
      if (this.bitPos > this.bitEndPos) {
        throw new Error("Unexpected end of input");
      }
      return;
    }
    const remaining = this.data.length - this.pos;
    const toRead = Math.min(4096, remaining);
    if (toRead > 0) {
      this.buf.set(this.data.subarray(this.pos, this.pos + toRead), 0);
      this.pos = 0;
    }
    if (toRead < 4096) {
      this.eos = true;
      for (let i = 0;i < 32; i++) {
        this.buf[toRead + i] = 0;
      }
    }
    this.bitEndPos += toRead << 3;
  }
  readMoreInput() {
    if (this.bitEndPos > 256)
      return;
    if (this.eos) {
      if (this.bitPos > this.bitEndPos) {
        throw new Error("Unexpected end of input");
      }
      return;
    }
    const dst = this.pos & 4095;
    const bytesRemaining = Math.min(4096, this.data.length - (this.pos & ~4095));
    if (bytesRemaining > 0) {
      const srcStart = this.pos & ~4095;
      this.buf.set(this.data.subarray(srcStart, srcStart + bytesRemaining), dst === 0 ? 0 : 4096);
    }
    if (bytesRemaining < 4096) {
      this.eos = true;
      for (let i = 0;i < 32; i++) {
        this.buf[dst + bytesRemaining + i] = 0;
      }
    }
    this.bitEndPos += bytesRemaining << 3;
  }
  fillBitWindow() {
    while (this.bitPos >= 8) {
      this.val >>>= 8;
      this.val |= this.buf[this.pos & 8191] << 24;
      this.pos++;
      this.bitPos -= 8;
      this.bitEndPos -= 8;
    }
  }
  readBits(n) {
    if (32 - this.bitPos < n) {
      this.fillBitWindow();
    }
    const val = this.val >>> this.bitPos & (1 << n) - 1;
    this.bitPos += n;
    return val;
  }
  get currentBitPos() {
    return this.bitPos;
  }
  set currentBitPos(v) {
    this.bitPos = v;
  }
  get currentVal() {
    return this.val;
  }
}
function buildHuffmanTable(rootTable, tableOffset, rootBits, codeLengths, codeLengthsSize) {
  const MAX_LENGTH = 15;
  const count = new Int32Array(MAX_LENGTH + 1);
  const offset = new Int32Array(MAX_LENGTH + 1);
  const sorted = new Int32Array(codeLengthsSize);
  for (let i = 0;i < codeLengthsSize; i++) {
    count[codeLengths[i]]++;
  }
  offset[1] = 0;
  for (let len = 1;len < MAX_LENGTH; len++) {
    offset[len + 1] = offset[len] + count[len];
  }
  for (let i = 0;i < codeLengthsSize; i++) {
    if (codeLengths[i] !== 0) {
      sorted[offset[codeLengths[i]]++] = i;
    }
  }
  let tableBits = rootBits;
  let tableSize = 1 << tableBits;
  let totalSize = tableSize;
  if (offset[MAX_LENGTH] === 1) {
    for (let i = 0;i < totalSize; i++) {
      rootTable[tableOffset + i] = { bits: 0, value: sorted[0] & 65535 };
    }
    return totalSize;
  }
  let key = 0;
  let symbol = 0;
  for (let len = 1, step = 2;len <= rootBits; len++, step <<= 1) {
    for (;count[len] > 0; count[len]--) {
      const code = {
        bits: len & 255,
        value: sorted[symbol++] & 65535
      };
      replicateValue(rootTable, tableOffset + key, step, tableSize, code);
      key = getNextKey(key, len);
    }
  }
  const mask = totalSize - 1;
  let low = -1;
  let table = tableOffset;
  for (let len = rootBits + 1, step = 2;len <= MAX_LENGTH; len++, step <<= 1) {
    for (;count[len] > 0; count[len]--) {
      if ((key & mask) !== low) {
        table += tableSize;
        tableBits = nextTableBitSize(count, len, rootBits);
        tableSize = 1 << tableBits;
        totalSize += tableSize;
        low = key & mask;
        rootTable[tableOffset + low] = {
          bits: tableBits + rootBits & 255,
          value: table - tableOffset - low & 65535
        };
      }
      const code = {
        bits: len - rootBits & 255,
        value: sorted[symbol++] & 65535
      };
      replicateValue(rootTable, table + (key >> rootBits), step, tableSize, code);
      key = getNextKey(key, len);
    }
  }
  return totalSize;
}
function getNextKey(key, len) {
  let step = 1 << len - 1;
  while (key & step) {
    step >>= 1;
  }
  return (key & step - 1) + step;
}
function replicateValue(table, offset, step, end, code) {
  do {
    end -= step;
    table[offset + end] = { bits: code.bits, value: code.value };
  } while (end > 0);
}
function nextTableBitSize(count, len, rootBits) {
  let left = 1 << len - rootBits;
  while (len < 15) {
    left -= count[len];
    if (left <= 0)
      break;
    len++;
    left <<= 1;
  }
  return len - rootBits;
}
function readSymbol(table, tableOffset, br) {
  br.fillBitWindow();
  let index = tableOffset + (br.currentVal >>> br.currentBitPos & HUFFMAN_TABLE_MASK);
  const nbits = table[index].bits - HUFFMAN_TABLE_BITS;
  if (nbits > 0) {
    br.currentBitPos += HUFFMAN_TABLE_BITS;
    index += table[index].value;
    index += br.currentVal >>> br.currentBitPos & (1 << nbits) - 1;
  }
  br.currentBitPos += table[index].bits;
  return table[index].value;
}
function decodeVarLenUint8(br) {
  if (br.readBits(1)) {
    const nbits = br.readBits(3);
    if (nbits === 0)
      return 1;
    return br.readBits(nbits) + (1 << nbits);
  }
  return 0;
}
function decodeWindowBits(br) {
  if (br.readBits(1) === 0)
    return 16;
  let n = br.readBits(3);
  if (n > 0)
    return 17 + n;
  n = br.readBits(3);
  if (n > 0)
    return 8 + n;
  return 17;
}
function decodeMetaBlockLength(br) {
  const isLast = br.readBits(1) === 1;
  if (isLast && br.readBits(1)) {
    return {
      length: 0,
      isLast: true,
      isUncompressed: false,
      isMetadata: false
    };
  }
  const sizeNibbles = br.readBits(2) + 4;
  if (sizeNibbles === 7) {
    if (br.readBits(1) !== 0)
      throw new Error("Invalid reserved bit");
    const sizeBytes = br.readBits(2);
    if (sizeBytes === 0)
      return { length: 0, isLast, isUncompressed: false, isMetadata: true };
    let length2 = 0;
    for (let i = 0;i < sizeBytes; i++) {
      const nextByte = br.readBits(8);
      if (i + 1 === sizeBytes && sizeBytes > 1 && nextByte === 0) {
        throw new Error("Invalid size byte");
      }
      length2 |= nextByte << i * 8;
    }
    return {
      length: length2 + 1,
      isLast,
      isUncompressed: false,
      isMetadata: true
    };
  }
  let length = 0;
  for (let i = 0;i < sizeNibbles; i++) {
    const nextNibble = br.readBits(4);
    if (i + 1 === sizeNibbles && sizeNibbles > 4 && nextNibble === 0) {
      throw new Error("Invalid size nibble");
    }
    length |= nextNibble << i * 4;
  }
  length++;
  const isUncompressed = !isLast ? br.readBits(1) === 1 : false;
  return { length, isLast, isUncompressed, isMetadata: false };
}
function readHuffmanCodeLengths(codeLengthCodeLengths, numSymbols, codeLengths, br) {
  const DEFAULT_CODE_LENGTH = 8;
  const CODE_LENGTH_REPEAT_CODE = 16;
  let symbol = 0;
  let prevCodeLen = DEFAULT_CODE_LENGTH;
  let repeat = 0;
  let repeatCodeLen = 0;
  let space = 32768;
  const table = [];
  for (let i = 0;i < 32; i++) {
    table.push({ bits: 0, value: 0 });
  }
  buildHuffmanTable(table, 0, 5, codeLengthCodeLengths, CODE_LENGTH_CODES);
  while (symbol < numSymbols && space > 0) {
    br.readMoreInput();
    br.fillBitWindow();
    const p = br.currentVal >>> br.currentBitPos & 31;
    br.currentBitPos += table[p].bits;
    const codeLen = table[p].value & 255;
    if (codeLen < CODE_LENGTH_REPEAT_CODE) {
      repeat = 0;
      codeLengths[symbol++] = codeLen;
      if (codeLen !== 0) {
        prevCodeLen = codeLen;
        space -= 32768 >> codeLen;
      }
    } else {
      const extraBits = codeLen - 14;
      let newLen = 0;
      if (codeLen === CODE_LENGTH_REPEAT_CODE) {
        newLen = prevCodeLen;
      }
      if (repeatCodeLen !== newLen) {
        repeat = 0;
        repeatCodeLen = newLen;
      }
      const oldRepeat = repeat;
      if (repeat > 0) {
        repeat -= 2;
        repeat <<= extraBits;
      }
      repeat += br.readBits(extraBits) + 3;
      const repeatDelta = repeat - oldRepeat;
      if (symbol + repeatDelta > numSymbols) {
        throw new Error("Symbol overflow");
      }
      for (let i = 0;i < repeatDelta; i++) {
        codeLengths[symbol + i] = repeatCodeLen;
      }
      symbol += repeatDelta;
      if (repeatCodeLen !== 0) {
        space -= repeatDelta << 15 - repeatCodeLen;
      }
    }
  }
  if (space !== 0) {
    throw new Error("Invalid code lengths");
  }
  for (;symbol < numSymbols; symbol++) {
    codeLengths[symbol] = 0;
  }
}
function readHuffmanCode(alphabetSize, tables, tableOffset, br) {
  const codeLengths = new Uint8Array(alphabetSize);
  br.readMoreInput();
  const simpleCodeOrSkip = br.readBits(2);
  if (simpleCodeOrSkip === 1) {
    let maxBitsCounter = alphabetSize - 1;
    let maxBits = 0;
    while (maxBitsCounter) {
      maxBitsCounter >>= 1;
      maxBits++;
    }
    const symbols = new Int32Array(4);
    const numSymbols = br.readBits(2) + 1;
    for (let i = 0;i < numSymbols; i++) {
      symbols[i] = br.readBits(maxBits) % alphabetSize;
      codeLengths[symbols[i]] = 2;
    }
    codeLengths[symbols[0]] = 1;
    switch (numSymbols) {
      case 2:
        if (symbols[0] === symbols[1])
          throw new Error("Invalid symbols");
        codeLengths[symbols[1]] = 1;
        break;
      case 4:
        if (br.readBits(1)) {
          codeLengths[symbols[2]] = 3;
          codeLengths[symbols[3]] = 3;
        } else {
          codeLengths[symbols[0]] = 2;
        }
        break;
    }
  } else {
    const codeLengthCodeLengths = new Uint8Array(CODE_LENGTH_CODES);
    let space = 32;
    let numCodes = 0;
    const huff = [
      { bits: 2, value: 0 },
      { bits: 2, value: 4 },
      { bits: 2, value: 3 },
      { bits: 3, value: 2 },
      { bits: 2, value: 0 },
      { bits: 2, value: 4 },
      { bits: 2, value: 3 },
      { bits: 4, value: 1 },
      { bits: 2, value: 0 },
      { bits: 2, value: 4 },
      { bits: 2, value: 3 },
      { bits: 3, value: 2 },
      { bits: 2, value: 0 },
      { bits: 2, value: 4 },
      { bits: 2, value: 3 },
      { bits: 4, value: 5 }
    ];
    for (let i = simpleCodeOrSkip;i < CODE_LENGTH_CODES && space > 0; i++) {
      const codeLenIdx = CODE_LENGTH_CODE_ORDER[i];
      br.fillBitWindow();
      const p = br.currentVal >>> br.currentBitPos & 15;
      br.currentBitPos += huff[p].bits;
      const v = huff[p].value;
      codeLengthCodeLengths[codeLenIdx] = v;
      if (v !== 0) {
        space -= 32 >> v;
        numCodes++;
      }
    }
    if (!(numCodes === 1 || space === 0)) {
      throw new Error("Invalid code length codes");
    }
    readHuffmanCodeLengths(codeLengthCodeLengths, alphabetSize, codeLengths, br);
  }
  return buildHuffmanTable(tables, tableOffset, HUFFMAN_TABLE_BITS, codeLengths, alphabetSize);
}

class HuffmanTreeGroup {
  alphabetSize;
  numHTrees;
  codes = [];
  htrees;
  constructor(alphabetSize, numHTrees) {
    this.alphabetSize = alphabetSize;
    this.numHTrees = numHTrees;
    this.htrees = new Uint32Array(numHTrees);
    const maxSize = this.getMaxTableSize();
    for (let i = 0;i < numHTrees + numHTrees * maxSize; i++) {
      this.codes.push({ bits: 0, value: 0 });
    }
  }
  getMaxTableSize() {
    const sizes = [
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ];
    const idx = this.alphabetSize + 31 >>> 5;
    return sizes[Math.min(idx, sizes.length - 1)];
  }
  decode(br) {
    let next = 0;
    for (let i = 0;i < this.numHTrees; i++) {
      this.htrees[i] = next;
      const tableSize = readHuffmanCode(this.alphabetSize, this.codes, next, br);
      next += tableSize;
    }
  }
}
function decodeContextMap(contextMapSize, br) {
  br.readMoreInput();
  const numHTrees = decodeVarLenUint8(br) + 1;
  const contextMap = new Uint8Array(contextMapSize);
  if (numHTrees <= 1) {
    return { numHTrees, contextMap };
  }
  const useRleForZeros = br.readBits(1) === 1;
  let maxRunLengthPrefix = 0;
  if (useRleForZeros) {
    maxRunLengthPrefix = br.readBits(4) + 1;
  }
  const table = [];
  for (let i = 0;i < MAX_HUFFMAN_TABLE_SIZE; i++) {
    table.push({ bits: 0, value: 0 });
  }
  readHuffmanCode(numHTrees + maxRunLengthPrefix, table, 0, br);
  for (let i = 0;i < contextMapSize; ) {
    br.readMoreInput();
    const code = readSymbol(table, 0, br);
    if (code === 0) {
      contextMap[i++] = 0;
    } else if (code <= maxRunLengthPrefix) {
      const reps = 1 + (1 << code) + br.readBits(code);
      for (let j = 1;j < reps && i < contextMapSize; j++) {
        contextMap[i++] = 0;
      }
    } else {
      contextMap[i++] = code - maxRunLengthPrefix;
    }
  }
  if (br.readBits(1)) {
    const mtf = new Uint8Array(256);
    for (let i = 0;i < 256; i++)
      mtf[i] = i;
    for (let i = 0;i < contextMapSize; i++) {
      const idx = contextMap[i];
      contextMap[i] = mtf[idx];
      if (idx) {
        const value = mtf[idx];
        for (let j = idx;j > 0; j--)
          mtf[j] = mtf[j - 1];
        mtf[0] = value;
      }
    }
  }
  return { numHTrees, contextMap };
}
function readBlockLength(table, tableOffset, br) {
  const code = readSymbol(table, tableOffset, br);
  const prefix = BLOCK_LENGTH_PREFIX[code];
  return prefix.offset + br.readBits(prefix.nbits);
}
function translateShortCodes(code, ringBuffer, index) {
  if (code < NUM_DISTANCE_SHORT_CODES) {
    const idx = index + DISTANCE_SHORT_CODE_INDEX_OFFSET[code] & 3;
    return ringBuffer[idx] + DISTANCE_SHORT_CODE_VALUE_OFFSET[code];
  }
  return code - NUM_DISTANCE_SHORT_CODES + 1;
}
function decompress(data) {
  const br = new BitReader(data);
  const windowBits = decodeWindowBits(br);
  const maxBackwardDistance = (1 << windowBits) - 16;
  const ringBufferSize = 1 << windowBits;
  const ringBufferMask = ringBufferSize - 1;
  const ringBuffer = new Uint8Array(ringBufferSize + 578);
  let pos = 0;
  let maxDistance = 0;
  const distRb = [16, 15, 11, 4];
  let distRbIdx = 0;
  let prevByte1 = 0;
  let prevByte2 = 0;
  const output = [];
  while (true) {
    br.readMoreInput();
    const meta = decodeMetaBlockLength(br);
    if (meta.length === 0 && meta.isLast) {
      break;
    }
    if (meta.isMetadata) {
      br.currentBitPos = br.currentBitPos + 7 & ~7;
      for (let i = 0;i < meta.length; i++) {
        br.readMoreInput();
        br.readBits(8);
      }
      continue;
    }
    let metaBlockRemaining = meta.length;
    if (metaBlockRemaining === 0)
      continue;
    if (meta.isUncompressed) {
      br.currentBitPos = br.currentBitPos + 7 & ~7;
      for (let i = 0;i < metaBlockRemaining; i++) {
        br.readMoreInput();
        const byte = br.readBits(8);
        ringBuffer[pos & ringBufferMask] = byte;
        if ((pos & ringBufferMask) === ringBufferMask) {
          output.push(...ringBuffer.slice(0, ringBufferSize));
        }
        pos++;
      }
      continue;
    }
    const numBlockTypes = [1, 1, 1];
    const blockLength = [1 << 28, 1 << 28, 1 << 28];
    const blockType = [0, 0, 0];
    const blockTypeRb = [0, 1, 0, 1, 0, 1];
    const blockTypeRbIndex = [0, 0, 0];
    const blockTypeTrees = [];
    const blockLenTrees = [];
    for (let i = 0;i < 3 * MAX_HUFFMAN_TABLE_SIZE; i++) {
      blockTypeTrees.push({ bits: 0, value: 0 });
      blockLenTrees.push({ bits: 0, value: 0 });
    }
    for (let i = 0;i < 3; i++) {
      numBlockTypes[i] = decodeVarLenUint8(br) + 1;
      if (numBlockTypes[i] >= 2) {
        readHuffmanCode(numBlockTypes[i] + 2, blockTypeTrees, i * MAX_HUFFMAN_TABLE_SIZE, br);
        readHuffmanCode(NUM_BLOCK_LENGTH_CODES, blockLenTrees, i * MAX_HUFFMAN_TABLE_SIZE, br);
        blockLength[i] = readBlockLength(blockLenTrees, i * MAX_HUFFMAN_TABLE_SIZE, br);
        blockTypeRbIndex[i] = 1;
      }
    }
    br.readMoreInput();
    const distancePostfixBits = br.readBits(2);
    const numDirectDistanceCodes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distancePostfixBits);
    const distancePostfixMask = (1 << distancePostfixBits) - 1;
    const numDistanceCodes = numDirectDistanceCodes + (48 << distancePostfixBits);
    const contextModes = new Uint8Array(numBlockTypes[0]);
    for (let i = 0;i < numBlockTypes[0]; i++) {
      br.readMoreInput();
      contextModes[i] = br.readBits(2) << 1;
    }
    const literalContextMap = decodeContextMap(numBlockTypes[0] << 6, br);
    const distContextMap = decodeContextMap(numBlockTypes[2] << 2, br);
    const hgroup = [
      new HuffmanTreeGroup(NUM_LITERAL_CODES, literalContextMap.numHTrees),
      new HuffmanTreeGroup(NUM_INSERT_AND_COPY_CODES, numBlockTypes[1]),
      new HuffmanTreeGroup(numDistanceCodes, distContextMap.numHTrees)
    ];
    for (let i = 0;i < 3; i++) {
      hgroup[i].decode(br);
    }
    let contextMapSlice = 0;
    let distContextMapSlice = 0;
    let contextMode = contextModes[blockType[0]];
    let contextLookupOffset1 = CONTEXT_LOOKUP_OFFSETS[contextMode];
    let contextLookupOffset2 = CONTEXT_LOOKUP_OFFSETS[contextMode + 1];
    let htreeCommand = hgroup[1].htrees[0];
    while (metaBlockRemaining > 0) {
      br.readMoreInput();
      if (blockLength[1] === 0) {
        const typeCode = readSymbol(blockTypeTrees, MAX_HUFFMAN_TABLE_SIZE, br);
        let bt;
        if (typeCode === 0) {
          bt = blockTypeRb[2 + (blockTypeRbIndex[1] & 1)];
        } else if (typeCode === 1) {
          bt = blockTypeRb[2 + (blockTypeRbIndex[1] - 1 & 1)] + 1;
        } else {
          bt = typeCode - 2;
        }
        if (bt >= numBlockTypes[1])
          bt -= numBlockTypes[1];
        blockType[1] = bt;
        blockTypeRb[2 + (blockTypeRbIndex[1] & 1)] = bt;
        blockTypeRbIndex[1]++;
        blockLength[1] = readBlockLength(blockLenTrees, MAX_HUFFMAN_TABLE_SIZE, br);
        htreeCommand = hgroup[1].htrees[blockType[1]];
      }
      blockLength[1]--;
      const cmdCode = readSymbol(hgroup[1].codes, htreeCommand, br);
      const rangeIdx = cmdCode >> 6;
      let distanceCode;
      if (rangeIdx >= 2) {
        distanceCode = -1;
      } else {
        distanceCode = 0;
      }
      const insertCode = INSERT_RANGE_LUT[rangeIdx] + (cmdCode >> 3 & 7);
      const copyCode = COPY_RANGE_LUT[rangeIdx] + (cmdCode & 7);
      const insertLength = INSERT_LENGTH_PREFIX[insertCode].offset + br.readBits(INSERT_LENGTH_PREFIX[insertCode].nbits);
      const copyLength = COPY_LENGTH_PREFIX[copyCode].offset + br.readBits(COPY_LENGTH_PREFIX[copyCode].nbits);
      prevByte1 = ringBuffer[pos - 1 & ringBufferMask];
      prevByte2 = ringBuffer[pos - 2 & ringBufferMask];
      for (let j = 0;j < insertLength; j++) {
        br.readMoreInput();
        if (blockLength[0] === 0) {
          const typeCode = readSymbol(blockTypeTrees, 0, br);
          let bt;
          if (typeCode === 0) {
            bt = blockTypeRb[blockTypeRbIndex[0] & 1];
          } else if (typeCode === 1) {
            bt = blockTypeRb[blockTypeRbIndex[0] - 1 & 1] + 1;
          } else {
            bt = typeCode - 2;
          }
          if (bt >= numBlockTypes[0])
            bt -= numBlockTypes[0];
          blockType[0] = bt;
          blockTypeRb[blockTypeRbIndex[0] & 1] = bt;
          blockTypeRbIndex[0]++;
          blockLength[0] = readBlockLength(blockLenTrees, 0, br);
          const contextOffset = blockType[0] << 6;
          contextMapSlice = contextOffset;
          contextMode = contextModes[blockType[0]];
          contextLookupOffset1 = CONTEXT_LOOKUP_OFFSETS[contextMode];
          contextLookupOffset2 = CONTEXT_LOOKUP_OFFSETS[contextMode + 1];
        }
        const context = CONTEXT_LOOKUP[contextLookupOffset1 + prevByte1] | CONTEXT_LOOKUP[contextLookupOffset2 + prevByte2];
        const literalHtreeIndex = literalContextMap.contextMap[contextMapSlice + context];
        blockLength[0]--;
        prevByte2 = prevByte1;
        prevByte1 = readSymbol(hgroup[0].codes, hgroup[0].htrees[literalHtreeIndex], br);
        ringBuffer[pos & ringBufferMask] = prevByte1;
        if ((pos & ringBufferMask) === ringBufferMask) {
          output.push(...ringBuffer.slice(0, ringBufferSize));
        }
        pos++;
      }
      metaBlockRemaining -= insertLength;
      if (metaBlockRemaining <= 0)
        break;
      if (distanceCode < 0) {
        br.readMoreInput();
        if (blockLength[2] === 0) {
          const typeCode = readSymbol(blockTypeTrees, 2 * MAX_HUFFMAN_TABLE_SIZE, br);
          let bt;
          if (typeCode === 0) {
            bt = blockTypeRb[4 + (blockTypeRbIndex[2] & 1)];
          } else if (typeCode === 1) {
            bt = blockTypeRb[4 + (blockTypeRbIndex[2] - 1 & 1)] + 1;
          } else {
            bt = typeCode - 2;
          }
          if (bt >= numBlockTypes[2])
            bt -= numBlockTypes[2];
          blockType[2] = bt;
          blockTypeRb[4 + (blockTypeRbIndex[2] & 1)] = bt;
          blockTypeRbIndex[2]++;
          blockLength[2] = readBlockLength(blockLenTrees, 2 * MAX_HUFFMAN_TABLE_SIZE, br);
          distContextMapSlice = blockType[2] << 2;
        }
        blockLength[2]--;
        const context = (copyLength > 4 ? 3 : copyLength - 2) & 255;
        const distHtreeIndex = distContextMap.contextMap[distContextMapSlice + context];
        distanceCode = readSymbol(hgroup[2].codes, hgroup[2].htrees[distHtreeIndex], br);
        if (distanceCode >= numDirectDistanceCodes) {
          distanceCode -= numDirectDistanceCodes;
          const postfix = distanceCode & distancePostfixMask;
          distanceCode >>= distancePostfixBits;
          const nbits = (distanceCode >> 1) + 1;
          const offset = (2 + (distanceCode & 1) << nbits) - 4;
          distanceCode = numDirectDistanceCodes + (offset + br.readBits(nbits) << distancePostfixBits) + postfix;
        }
      }
      const distance = translateShortCodes(distanceCode, distRb, distRbIdx);
      if (distance < 0) {
        throw new Error("Invalid distance");
      }
      if (pos < maxBackwardDistance && maxDistance !== maxBackwardDistance) {
        maxDistance = pos;
      } else {
        maxDistance = maxBackwardDistance;
      }
      let copyDst = pos & ringBufferMask;
      if (distance > maxDistance) {
        if (copyLength >= 4 && copyLength <= 24) {
          const offset = DICTIONARY_OFFSETS_BY_LENGTH[copyLength];
          const wordId = distance - maxDistance - 1;
          const shift2 = DICTIONARY_SIZE_BITS_BY_LENGTH[copyLength];
          const mask = (1 << shift2) - 1;
          const wordIdx = wordId & mask;
          const transformIdx = wordId >> shift2;
          const wordOffset = offset + wordIdx * copyLength;
          if (transformIdx < TRANSFORMS.length) {
            const len = transformDictionaryWord(ringBuffer, copyDst, wordOffset, copyLength, transformIdx, DICTIONARY);
            copyDst += len;
            pos += len;
            metaBlockRemaining -= len;
            if (copyDst >= ringBufferSize) {
              output.push(...ringBuffer.slice(0, ringBufferSize));
              for (let i = 0;i < copyDst - ringBufferSize; i++) {
                ringBuffer[i] = ringBuffer[ringBufferSize + i];
              }
            }
          } else {
            throw new Error("Invalid backward reference");
          }
        } else {
          throw new Error("Invalid backward reference");
        }
      } else {
        if (distanceCode > 0) {
          distRb[distRbIdx & 3] = distance;
          distRbIdx++;
        }
        if (copyLength > metaBlockRemaining) {
          throw new Error("Invalid backward reference");
        }
        for (let j = 0;j < copyLength; j++) {
          ringBuffer[pos & ringBufferMask] = ringBuffer[pos - distance & ringBufferMask];
          if ((pos & ringBufferMask) === ringBufferMask) {
            output.push(...ringBuffer.slice(0, ringBufferSize));
          }
          pos++;
          metaBlockRemaining--;
        }
      }
      prevByte1 = ringBuffer[pos - 1 & ringBufferMask];
      prevByte2 = ringBuffer[pos - 2 & ringBufferMask];
    }
    if (meta.isLast)
      break;
  }
  output.push(...ringBuffer.slice(0, pos & ringBufferMask));
  return new Uint8Array(output);
}
var MAX_HUFFMAN_TABLE_SIZE = 1080, CODE_LENGTH_CODES = 18, NUM_LITERAL_CODES = 256, NUM_INSERT_AND_COPY_CODES = 704, NUM_BLOCK_LENGTH_CODES = 26, NUM_DISTANCE_SHORT_CODES = 16, HUFFMAN_TABLE_BITS = 8, HUFFMAN_TABLE_MASK = 255, CODE_LENGTH_CODE_ORDER, DISTANCE_SHORT_CODE_INDEX_OFFSET, DISTANCE_SHORT_CODE_VALUE_OFFSET, BLOCK_LENGTH_PREFIX, INSERT_LENGTH_PREFIX, COPY_LENGTH_PREFIX, INSERT_RANGE_LUT, COPY_RANGE_LUT, __testing;
var init_decode = __esm(() => {
  init_context();
  init_dictionary();
  init_transform();
  CODE_LENGTH_CODE_ORDER = new Uint8Array([
    1,
    2,
    3,
    4,
    0,
    5,
    17,
    6,
    16,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15
  ]);
  DISTANCE_SHORT_CODE_INDEX_OFFSET = new Uint8Array([
    3,
    2,
    1,
    0,
    3,
    3,
    3,
    3,
    3,
    3,
    2,
    2,
    2,
    2,
    2,
    2
  ]);
  DISTANCE_SHORT_CODE_VALUE_OFFSET = new Int8Array([
    0,
    0,
    0,
    0,
    -1,
    1,
    -2,
    2,
    -3,
    3,
    -1,
    1,
    -2,
    2,
    -3,
    3
  ]);
  BLOCK_LENGTH_PREFIX = [
    { offset: 1, nbits: 2 },
    { offset: 5, nbits: 2 },
    { offset: 9, nbits: 2 },
    { offset: 13, nbits: 2 },
    { offset: 17, nbits: 3 },
    { offset: 25, nbits: 3 },
    { offset: 33, nbits: 3 },
    { offset: 41, nbits: 3 },
    { offset: 49, nbits: 4 },
    { offset: 65, nbits: 4 },
    { offset: 81, nbits: 4 },
    { offset: 97, nbits: 4 },
    { offset: 113, nbits: 5 },
    { offset: 145, nbits: 5 },
    { offset: 177, nbits: 5 },
    { offset: 209, nbits: 5 },
    { offset: 241, nbits: 6 },
    { offset: 305, nbits: 6 },
    { offset: 369, nbits: 7 },
    { offset: 497, nbits: 8 },
    { offset: 753, nbits: 9 },
    { offset: 1265, nbits: 10 },
    { offset: 2289, nbits: 11 },
    { offset: 4337, nbits: 12 },
    { offset: 8433, nbits: 13 },
    { offset: 16625, nbits: 24 }
  ];
  INSERT_LENGTH_PREFIX = [
    { offset: 0, nbits: 0 },
    { offset: 1, nbits: 0 },
    { offset: 2, nbits: 0 },
    { offset: 3, nbits: 0 },
    { offset: 4, nbits: 0 },
    { offset: 5, nbits: 0 },
    { offset: 6, nbits: 1 },
    { offset: 8, nbits: 1 },
    { offset: 10, nbits: 2 },
    { offset: 14, nbits: 2 },
    { offset: 18, nbits: 3 },
    { offset: 26, nbits: 3 },
    { offset: 34, nbits: 4 },
    { offset: 50, nbits: 4 },
    { offset: 66, nbits: 5 },
    { offset: 98, nbits: 5 },
    { offset: 130, nbits: 6 },
    { offset: 194, nbits: 7 },
    { offset: 322, nbits: 8 },
    { offset: 578, nbits: 9 },
    { offset: 1090, nbits: 10 },
    { offset: 2114, nbits: 12 },
    { offset: 6210, nbits: 14 },
    { offset: 22594, nbits: 24 }
  ];
  COPY_LENGTH_PREFIX = [
    { offset: 2, nbits: 0 },
    { offset: 3, nbits: 0 },
    { offset: 4, nbits: 0 },
    { offset: 5, nbits: 0 },
    { offset: 6, nbits: 0 },
    { offset: 7, nbits: 0 },
    { offset: 8, nbits: 0 },
    { offset: 9, nbits: 0 },
    { offset: 10, nbits: 1 },
    { offset: 12, nbits: 1 },
    { offset: 14, nbits: 2 },
    { offset: 18, nbits: 2 },
    { offset: 22, nbits: 3 },
    { offset: 30, nbits: 3 },
    { offset: 38, nbits: 4 },
    { offset: 54, nbits: 4 },
    { offset: 70, nbits: 5 },
    { offset: 102, nbits: 5 },
    { offset: 134, nbits: 6 },
    { offset: 198, nbits: 7 },
    { offset: 326, nbits: 8 },
    { offset: 582, nbits: 9 },
    { offset: 1094, nbits: 10 },
    { offset: 2118, nbits: 24 }
  ];
  INSERT_RANGE_LUT = [0, 0, 8, 8, 0, 16, 8, 16, 16];
  COPY_RANGE_LUT = [0, 8, 0, 8, 16, 0, 16, 8, 16];
  __testing = {
    getNextKey,
    replicateValue,
    nextTableBitSize,
    buildHuffmanTable,
    readBlockLength,
    readHuffmanCodeLengths,
    BitReader,
    HuffmanCode: {},
    CODE_LENGTH_CODES
  };
});

// reference/text-shaper/src/aat/state-machine.ts
var CLASS_END_OF_TEXT = 0;
var CLASS_OUT_OF_BOUNDS = 1;
function getGlyphClass(classTable, glyphId) {
  if (glyphId < 0 || glyphId >= classTable.classArray.length) {
    return CLASS_OUT_OF_BOUNDS;
  }
  return classTable.classArray[glyphId] ?? CLASS_OUT_OF_BOUNDS;
}
function processRearrangement(subtable, infos) {
  const { stateTable } = subtable;
  let state = 0;
  let markFirst = 0;
  let markLast = 0;
  for (let i = 0;i <= infos.length; i++) {
    const isEnd = i >= infos.length;
    const glyphClass = isEnd ? CLASS_END_OF_TEXT : getGlyphClass(stateTable.classTable, infos[i]?.glyphId);
    const stateRow = stateTable.stateArray[state];
    if (!stateRow)
      break;
    const entry = stateRow[glyphClass];
    if (!entry)
      break;
    const flags = entry.flags;
    if (flags & 32768) {
      markFirst = i;
    }
    if (flags & 8192) {
      markLast = i;
    }
    const verb = flags & 15;
    if (verb !== 0 && markFirst <= markLast && markLast < infos.length) {
      rearrangeGlyphs(infos, markFirst, markLast, verb);
    }
    if (!(flags & 16384)) {}
    state = entry.newState;
  }
}
function rearrangeGlyphs(infos, first, last, verb) {
  if (first >= last || first >= infos.length || last >= infos.length)
    return;
  const a = infos[first];
  const b = infos[first + 1];
  const c = infos[last - 1];
  const d = infos[last];
  if (!a || !d)
    return;
  switch (verb) {
    case 1:
      if (b) {
        infos[first] = b;
        infos[first + 1] = a;
      }
      break;
    case 2:
      if (c) {
        infos[last] = c;
        infos[last - 1] = d;
      }
      break;
    case 3:
      infos[first] = d;
      infos[last] = a;
      break;
    case 4:
      if (b && c) {
        const temp = infos.slice(first, first + 2);
        const [tempFirst, tempSecond] = temp;
        const thirdItem = infos[first + 2];
        if (tempFirst && tempSecond && thirdItem) {
          infos[first] = thirdItem;
          infos[first + 1] = tempFirst;
          infos[first + 2] = tempSecond;
        }
      }
      break;
    case 5:
      if (b && c) {
        const temp = infos.slice(first, first + 2);
        const [tempFirst, tempSecond] = temp;
        const thirdItem = infos[first + 2];
        if (tempFirst && tempSecond && thirdItem) {
          infos[first] = thirdItem;
          infos[first + 1] = tempSecond;
          infos[first + 2] = tempFirst;
        }
      }
      break;
    case 6:
      if (c && b) {
        const temp = infos.slice(last - 1, last + 1);
        const [tempFirst, tempSecond] = temp;
        const prevItem = infos[last - 2];
        if (tempFirst && tempSecond && prevItem) {
          infos[last] = prevItem;
          infos[last - 1] = tempSecond;
          infos[last - 2] = tempFirst;
        }
      }
      break;
    case 7:
      if (c && b) {
        const temp = infos.slice(last - 1, last + 1);
        const [tempFirst, tempSecond] = temp;
        const prevItem = infos[last - 2];
        if (tempFirst && tempSecond && prevItem) {
          infos[last] = prevItem;
          infos[last - 1] = tempFirst;
          infos[last - 2] = tempSecond;
        }
      }
      break;
    case 8:
      if (c) {
        const tempA = a;
        infos[first] = c;
        infos[last - 1] = d;
        infos[last] = tempA;
      }
      break;
    case 9:
      if (c) {
        const tempA = a;
        infos[first] = d;
        infos[last - 1] = c;
        infos[last] = tempA;
      }
      break;
    case 10:
      if (b && c) {
        const tempA = a;
        const tempB = b;
        const tempC = c;
        infos[first] = d;
        infos[first + 1] = tempC;
        infos[last - 1] = tempA;
        infos[last] = tempB;
      }
      break;
    case 11:
      if (b && c) {
        const tempA = a;
        const tempB = b;
        const tempC = c;
        infos[first] = d;
        infos[first + 1] = tempC;
        infos[last - 1] = tempB;
        infos[last] = tempA;
      }
      break;
    case 12:
      if (b && c) {
        const tempAB = [a, b];
        infos[first] = c;
        infos[first + 1] = d;
        infos[last - 1] = tempAB[0];
        infos[last] = tempAB[1];
      }
      break;
    case 13:
      if (b && c) {
        const tempAB = [a, b];
        infos[first] = c;
        infos[first + 1] = d;
        infos[last - 1] = tempAB[1];
        infos[last] = tempAB[0];
      }
      break;
    case 14:
      if (b && c) {
        const tempAB = [a, b];
        infos[first] = d;
        infos[first + 1] = c;
        infos[last - 1] = tempAB[0];
        infos[last] = tempAB[1];
      }
      break;
    case 15:
      if (b && c) {
        const tempAB = [a, b];
        infos[first] = d;
        infos[first + 1] = c;
        infos[last - 1] = tempAB[1];
        infos[last] = tempAB[0];
      }
      break;
  }
}
function processContextual(subtable, infos) {
  const { stateTable, substitutionTable } = subtable;
  let state = 0;
  let markIndex = -1;
  for (let i = 0;i <= infos.length; i++) {
    const isEnd = i >= infos.length;
    const glyphClass = isEnd ? CLASS_END_OF_TEXT : getGlyphClass(stateTable.classTable, infos[i]?.glyphId);
    const stateRow = stateTable.stateArray[state];
    if (!stateRow)
      break;
    const entry = stateRow[glyphClass];
    if (!entry)
      break;
    if (entry.flags & 32768) {
      markIndex = i;
    }
    if (entry.markIndex !== 65535 && markIndex >= 0 && markIndex < infos.length) {
      const substTable = substitutionTable[entry.markIndex];
      if (substTable) {
        const markedInfo = infos[markIndex];
        if (markedInfo) {
          const replacement = substTable.get(markedInfo.glyphId);
          if (replacement !== undefined) {
            markedInfo.glyphId = replacement;
          }
        }
      }
    }
    if (!isEnd && entry.currentIndex !== 65535) {
      const substTable = substitutionTable[entry.currentIndex];
      if (substTable) {
        const currentInfo = infos[i];
        if (currentInfo) {
          const replacement = substTable.get(currentInfo.glyphId);
          if (replacement !== undefined) {
            currentInfo.glyphId = replacement;
          }
        }
      }
    }
    if (!(entry.flags & 16384)) {}
    state = entry.newState;
  }
}
function processLigature(subtable, infos) {
  const { stateTable, ligatureActions, components, ligatures } = subtable;
  let state = 0;
  const stack = [];
  const result = [];
  const deleted = new Set;
  for (let i = 0;i <= infos.length; i++) {
    const isEnd = i >= infos.length;
    const glyphClass = isEnd ? CLASS_END_OF_TEXT : getGlyphClass(stateTable.classTable, infos[i]?.glyphId);
    const stateRow = stateTable.stateArray[state];
    if (!stateRow)
      break;
    const entry = stateRow[glyphClass];
    if (!entry)
      break;
    if (entry.flags & 32768) {
      stack.push(i);
    }
    if (entry.flags & 8192 && entry.ligActionIndex < ligatureActions.length) {
      let actionIndex = entry.ligActionIndex;
      let ligatureGlyph = 0;
      const componentIndices = [];
      while (actionIndex < ligatureActions.length) {
        const action = ligatureActions[actionIndex];
        if (action === undefined)
          break;
        const last = (action & 2147483648) !== 0;
        const store = (action & 1073741824) !== 0;
        const componentOffset = (action & 1073741823) << 2 >> 2;
        const stackIdx = stack.pop();
        if (stackIdx !== undefined && stackIdx < infos.length) {
          componentIndices.push(stackIdx);
          const info = infos[stackIdx];
          if (info) {
            const componentIdx = componentOffset;
            if (componentIdx >= 0 && componentIdx < components.length) {
              const component = components[componentIdx];
              if (component !== undefined) {
                ligatureGlyph = ligatureGlyph + component;
              }
            }
          }
        }
        if (store && ligatureGlyph < ligatures.length) {
          const firstIdx = componentIndices[componentIndices.length - 1];
          if (firstIdx !== undefined && firstIdx < infos.length) {
            const firstInfo = infos[firstIdx];
            const ligature = ligatures[ligatureGlyph];
            if (firstInfo && ligature !== undefined) {
              firstInfo.glyphId = ligature;
              for (let j = 0;j < componentIndices.length; j++) {
                if (j < componentIndices.length - 1) {
                  const idx = componentIndices[j];
                  deleted.add(idx);
                }
              }
            }
          }
          ligatureGlyph = 0;
        }
        if (last)
          break;
        actionIndex++;
      }
    }
    if (!(entry.flags & 16384)) {}
    state = entry.newState;
  }
  for (let i = 0;i < infos.length; i++) {
    if (!deleted.has(i)) {
      const info = infos[i];
      result.push(info);
    }
  }
  return result;
}
function processInsertion(subtable, infos) {
  const { stateTable, insertionGlyphs } = subtable;
  let state = 0;
  let markIndex = -1;
  const result = [];
  const insertions = new Map;
  for (let i = 0;i <= infos.length; i++) {
    const isEnd = i >= infos.length;
    const glyphClass = isEnd ? CLASS_END_OF_TEXT : getGlyphClass(stateTable.classTable, infos[i]?.glyphId);
    const stateRow = stateTable.stateArray[state];
    if (!stateRow)
      break;
    const entry = stateRow[glyphClass];
    if (!entry)
      break;
    if (entry.flags & 32768) {
      markIndex = i;
    }
    if (entry.markedInsertIndex !== 65535 && markIndex >= 0) {
      const count = entry.flags >> 5 & 31;
      const insertBefore = (entry.flags & 2048) !== 0;
      const glyphs = insertionGlyphs.slice(entry.markedInsertIndex, entry.markedInsertIndex + count);
      let ins = insertions.get(markIndex);
      if (!ins) {
        ins = { before: [], after: [] };
        insertions.set(markIndex, ins);
      }
      if (insertBefore) {
        ins.before.push(...glyphs);
      } else {
        ins.after.push(...glyphs);
      }
    }
    if (!isEnd && entry.currentInsertIndex !== 65535) {
      const count = entry.flags & 31;
      const insertBefore = (entry.flags & 32) !== 0;
      const glyphs = insertionGlyphs.slice(entry.currentInsertIndex, entry.currentInsertIndex + count);
      let ins = insertions.get(i);
      if (!ins) {
        ins = { before: [], after: [] };
        insertions.set(i, ins);
      }
      if (insertBefore) {
        ins.before.push(...glyphs);
      } else {
        ins.after.push(...glyphs);
      }
    }
    if (!(entry.flags & 16384)) {}
    state = entry.newState;
  }
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    const ins = insertions.get(i);
    if (ins) {
      for (let j = 0;j < ins.before.length; j++) {
        const glyph = ins.before[j];
        result.push({
          glyphId: glyph,
          cluster: info.cluster,
          mask: info.mask,
          codepoint: 0
        });
      }
    }
    result.push(info);
    if (ins) {
      for (let j = 0;j < ins.after.length; j++) {
        const glyph = ins.after[j];
        result.push({
          glyphId: glyph,
          cluster: info.cluster,
          mask: info.mask,
          codepoint: 0
        });
      }
    }
  }
  return result;
}
// reference/text-shaper/src/hinting/instructions/arithmetic.ts
function mulDiv(a, b, c) {
  if (c === 0)
    return (a ^ b) < 0 ? -2147483647 : 2147483647;
  let sign = 1;
  if (a < 0) {
    a = -a;
    sign = -sign;
  }
  if (b < 0) {
    b = -b;
    sign = -sign;
  }
  if (c < 0) {
    c = -c;
    sign = -sign;
  }
  const result = Math.floor((a * b + (c >> 1)) / c);
  return sign < 0 ? -result : result;
}
function ADD(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "ADD: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a + b;
}
function SUB(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "SUB: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a - b;
}
function DIV(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "DIV: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  if (b === 0) {
    ctx.error = "DIV: division by zero";
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = mulDiv(a, 64, b);
}
function MUL(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "MUL: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = mulDiv(a, b, 64);
}
function ABS(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "ABS: stack underflow";
    return;
  }
  ctx.stack[ctx.stackTop - 1] = val < 0 ? -val : val;
}
function NEG(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "NEG: stack underflow";
    return;
  }
  ctx.stack[ctx.stackTop - 1] = -val;
}
function FLOOR(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "FLOOR: stack underflow";
    return;
  }
  ctx.stack[ctx.stackTop - 1] = val & ~63;
}
function CEILING(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "CEILING: stack underflow";
    return;
  }
  ctx.stack[ctx.stackTop - 1] = val + 63 & ~63;
}
function MAX(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "MAX: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a > b ? a : b;
}
function MIN(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "MIN: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a < b ? a : b;
}
function LT(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "LT: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a < b ? 1 : 0;
}
function LTEQ(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "LTEQ: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a <= b ? 1 : 0;
}
function GT(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "GT: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a > b ? 1 : 0;
}
function GTEQ(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "GTEQ: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a >= b ? 1 : 0;
}
function EQ(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "EQ: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a === b ? 1 : 0;
}
function NEQ(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "NEQ: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a !== b ? 1 : 0;
}
function ODD(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "ODD: stack underflow";
    return;
  }
  const rounded = val + 32 & ~63;
  ctx.stack[ctx.stackTop - 1] = rounded & 64 ? 1 : 0;
}
function EVEN(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "EVEN: stack underflow";
    return;
  }
  const rounded = val + 32 & ~63;
  ctx.stack[ctx.stackTop - 1] = rounded & 64 ? 0 : 1;
}
function AND(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "AND: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a && b ? 1 : 0;
}
function OR(ctx) {
  const b = ctx.stack[--ctx.stackTop];
  const a = ctx.stack[--ctx.stackTop];
  if (a === undefined || b === undefined) {
    ctx.error = "OR: stack underflow";
    ctx.stackTop += 2;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = a || b ? 1 : 0;
}
function NOT(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  if (val === undefined) {
    ctx.error = "NOT: stack underflow";
    return;
  }
  ctx.stack[ctx.stackTop - 1] = val ? 0 : 1;
}

// reference/text-shaper/src/hinting/instructions/control-flow.ts
function IF(ctx) {
  const condition = ctx.stack[--ctx.stackTop];
  if (condition === undefined) {
    ctx.error = "IF: stack underflow";
    ctx.stackTop++;
    return;
  }
  if (condition) {
    return;
  }
  let depth = 1;
  while (ctx.IP < ctx.codeSize) {
    const opcode = ctx.code[ctx.IP++];
    if (opcode === undefined)
      break;
    switch (opcode) {
      case 88:
        depth++;
        break;
      case 27:
        if (depth === 1) {
          return;
        }
        break;
      case 89:
        depth--;
        if (depth === 0) {
          return;
        }
        break;
      case 64:
        ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);
        break;
      case 65:
        ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;
        break;
      default:
        if (opcode >= 176 && opcode <= 183) {
          ctx.IP += opcode - 176 + 1;
        } else if (opcode >= 184 && opcode <= 191) {
          ctx.IP += (opcode - 184 + 1) * 2;
        }
    }
  }
  ctx.error = "IF: missing EIF";
}
function ELSE(ctx) {
  let depth = 1;
  while (ctx.IP < ctx.codeSize) {
    const opcode = ctx.code[ctx.IP++];
    if (opcode === undefined)
      break;
    switch (opcode) {
      case 88:
        depth++;
        break;
      case 89:
        depth--;
        if (depth === 0) {
          return;
        }
        break;
      case 64:
        ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);
        break;
      case 65:
        ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;
        break;
      default:
        if (opcode >= 176 && opcode <= 183) {
          ctx.IP += opcode - 176 + 1;
        } else if (opcode >= 184 && opcode <= 191) {
          ctx.IP += (opcode - 184 + 1) * 2;
        }
    }
  }
  ctx.error = "ELSE: missing EIF";
}
function EIF(_ctx) {}
function JMPR(ctx) {
  const offset = ctx.stack[--ctx.stackTop];
  if (offset === undefined) {
    ctx.error = "JMPR: stack underflow";
    ctx.stackTop++;
    return;
  }
  ctx.IP += offset - 1;
}
function JROT(ctx) {
  const condition = ctx.stack[--ctx.stackTop];
  const offset = ctx.stack[--ctx.stackTop];
  if (condition === undefined || offset === undefined) {
    ctx.error = "JROT: stack underflow";
    ctx.stackTop += 2;
    return;
  }
  if (condition) {
    ctx.IP += offset - 1;
  }
}
function JROF(ctx) {
  const condition = ctx.stack[--ctx.stackTop];
  const offset = ctx.stack[--ctx.stackTop];
  if (condition === undefined || offset === undefined) {
    ctx.error = "JROF: stack underflow";
    ctx.stackTop += 2;
    return;
  }
  if (!condition) {
    ctx.IP += offset - 1;
  }
}
function FDEF(ctx) {
  const funcNum = ctx.stack[--ctx.stackTop];
  if (funcNum === undefined) {
    ctx.error = "FDEF: stack underflow";
    ctx.stackTop++;
    return;
  }
  if (funcNum < 0 || funcNum > 65535) {
    ctx.error = `FDEF: invalid function number ${funcNum}`;
    return;
  }
  let def = ctx.FDefs.find((entry) => entry.active && entry.id === funcNum);
  if (!def) {
    def = ctx.FDefs.find((entry) => !entry.active);
  }
  if (!def) {
    ctx.error = `FDEF: too many function definitions`;
    return;
  }
  def.id = funcNum;
  def.start = ctx.IP;
  def.active = true;
  def.range = ctx.currentRange;
  while (ctx.IP < ctx.codeSize) {
    const opcode = ctx.code[ctx.IP++];
    if (opcode === undefined)
      break;
    if (opcode === 45) {
      def.end = ctx.IP;
      return;
    }
    if (opcode === 64) {
      ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);
    } else if (opcode === 65) {
      ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;
    } else if (opcode >= 176 && opcode <= 183) {
      ctx.IP += opcode - 176 + 1;
    } else if (opcode >= 184 && opcode <= 191) {
      ctx.IP += (opcode - 184 + 1) * 2;
    }
  }
  ctx.error = "FDEF: missing ENDF";
}
function ENDF(ctx) {
  if (ctx.callStackTop <= 0) {
    ctx.error = "ENDF: not in function call";
    return;
  }
  const call = ctx.callStack[ctx.callStackTop - 1];
  if (!call) {
    ctx.error = "ENDF: missing call frame";
    return;
  }
  call.count--;
  if (call.count > 0) {
    ctx.IP = call.def.start;
  } else {
    ctx.callStackTop--;
    ctx.IP = call.callerIP;
    ctx.currentRange = call.callerRange;
    const range = ctx.codeRanges.get(ctx.currentRange);
    if (range) {
      ctx.code = range.code;
      ctx.codeSize = range.size;
    }
  }
}
function CALL(ctx) {
  const funcNum = ctx.stack[--ctx.stackTop];
  if (funcNum === undefined) {
    ctx.error = "CALL: stack underflow";
    ctx.stackTop++;
    return;
  }
  if (funcNum < 0 || funcNum > 65535) {
    ctx.error = `CALL: invalid function number ${funcNum}`;
    return;
  }
  const def = ctx.FDefs.find((entry) => entry.active && entry.id === funcNum);
  if (!def) {
    ctx.error = `CALL: function ${funcNum} not defined`;
    return;
  }
  if (ctx.callStackTop >= ctx.maxCallStack) {
    ctx.error = "CALL: call stack overflow";
    return;
  }
  const call = ctx.callStack[ctx.callStackTop++];
  if (!call) {
    ctx.error = "CALL: no call frame available";
    ctx.callStackTop--;
    return;
  }
  call.callerIP = ctx.IP;
  call.callerRange = ctx.currentRange;
  call.def = def;
  call.count = 1;
  ctx.currentRange = def.range;
  const range = ctx.codeRanges.get(ctx.currentRange);
  if (range) {
    ctx.code = range.code;
    ctx.codeSize = range.size;
  }
  ctx.IP = def.start;
}
function LOOPCALL(ctx) {
  const funcNum = ctx.stack[--ctx.stackTop];
  const count = ctx.stack[--ctx.stackTop];
  if (funcNum === undefined || count === undefined) {
    ctx.error = "LOOPCALL: stack underflow";
    ctx.stackTop += 2;
    return;
  }
  if (funcNum < 0 || funcNum > 65535) {
    ctx.error = `LOOPCALL: invalid function number ${funcNum}`;
    return;
  }
  const def = ctx.FDefs.find((entry) => entry.active && entry.id === funcNum);
  if (!def) {
    ctx.error = `LOOPCALL: function ${funcNum} not defined`;
    return;
  }
  if (count <= 0) {
    return;
  }
  if (ctx.callStackTop >= ctx.maxCallStack) {
    ctx.error = "LOOPCALL: call stack overflow";
    return;
  }
  const call = ctx.callStack[ctx.callStackTop++];
  if (!call) {
    ctx.error = "LOOPCALL: no call frame available";
    ctx.callStackTop--;
    return;
  }
  call.callerIP = ctx.IP;
  call.callerRange = ctx.currentRange;
  call.def = def;
  call.count = count;
  ctx.currentRange = def.range;
  const range = ctx.codeRanges.get(ctx.currentRange);
  if (range) {
    ctx.code = range.code;
    ctx.codeSize = range.size;
  }
  ctx.IP = def.start;
}
function IDEF(ctx) {
  const opcode = ctx.stack[--ctx.stackTop];
  if (opcode === undefined) {
    ctx.error = "IDEF: stack underflow";
    ctx.stackTop++;
    return;
  }
  if (opcode < 0 || opcode >= ctx.maxIDefs) {
    ctx.error = `IDEF: invalid opcode ${opcode}`;
    return;
  }
  const def = ctx.IDefs[opcode];
  if (!def) {
    ctx.error = `IDEF: no slot for opcode ${opcode}`;
    return;
  }
  def.opcode = opcode;
  def.start = ctx.IP;
  def.active = true;
  def.range = ctx.currentRange;
  while (ctx.IP < ctx.codeSize) {
    const op = ctx.code[ctx.IP++];
    if (op === undefined)
      break;
    if (op === 45) {
      def.end = ctx.IP;
      return;
    }
    if (op === 64) {
      ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);
    } else if (op === 65) {
      ctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;
    } else if (op >= 176 && op <= 183) {
      ctx.IP += op - 176 + 1;
    } else if (op >= 184 && op <= 191) {
      ctx.IP += (op - 184 + 1) * 2;
    }
  }
  ctx.error = "IDEF: missing ENDF";
}

// reference/text-shaper/src/hinting/types.ts
var RoundMode;
((RoundMode2) => {
  RoundMode2[RoundMode2["ToHalfGrid"] = 0] = "ToHalfGrid";
  RoundMode2[RoundMode2["ToGrid"] = 1] = "ToGrid";
  RoundMode2[RoundMode2["ToDoubleGrid"] = 2] = "ToDoubleGrid";
  RoundMode2[RoundMode2["DownToGrid"] = 3] = "DownToGrid";
  RoundMode2[RoundMode2["UpToGrid"] = 4] = "UpToGrid";
  RoundMode2[RoundMode2["Off"] = 5] = "Off";
  RoundMode2[RoundMode2["Super"] = 6] = "Super";
  RoundMode2[RoundMode2["Super45"] = 7] = "Super45";
})(RoundMode ||= {});
var TouchFlag;
((TouchFlag2) => {
  TouchFlag2[TouchFlag2["X"] = 16] = "X";
  TouchFlag2[TouchFlag2["Y"] = 32] = "Y";
  TouchFlag2[TouchFlag2["Both"] = 48] = "Both";
})(TouchFlag ||= {});
function createDefaultGraphicsState() {
  return {
    rp0: 0,
    rp1: 0,
    rp2: 0,
    dualVector: { x: 16384, y: 0 },
    projVector: { x: 16384, y: 0 },
    freeVector: { x: 16384, y: 0 },
    loop: 1,
    minimumDistance: 64,
    roundState: 1 /* ToGrid */,
    autoFlip: true,
    controlValueCutIn: 68,
    singleWidthCutIn: 0,
    singleWidthValue: 0,
    deltaBase: 9,
    deltaShift: 3,
    instructControl: 0,
    scanControl: 0,
    scanType: 0,
    gep0: 1,
    gep1: 1,
    gep2: 1,
    period: 64,
    phase: 0,
    threshold: 32
  };
}
var CodeRange;
((CodeRange2) => {
  CodeRange2[CodeRange2["None"] = 0] = "None";
  CodeRange2[CodeRange2["Font"] = 1] = "Font";
  CodeRange2[CodeRange2["CVT"] = 2] = "CVT";
  CodeRange2[CodeRange2["Glyph"] = 3] = "Glyph";
})(CodeRange ||= {});
function createGlyphZone(maxPoints, maxContours) {
  return {
    nPoints: 0,
    nContours: 0,
    org: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),
    cur: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),
    orus: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),
    tags: new Uint8Array(maxPoints),
    contours: new Uint16Array(maxContours)
  };
}
function createExecContext(maxStack = 256, maxStorage = 64, maxFDefs = 64, maxIDefs = 64, maxCallStack = 32, maxTwilightPoints = 16) {
  const defaultGS = createDefaultGraphicsState();
  return {
    GS: { ...defaultGS },
    defaultGS,
    zp0: createGlyphZone(0, 0),
    zp1: createGlyphZone(0, 0),
    zp2: createGlyphZone(0, 0),
    twilight: createGlyphZone(maxTwilightPoints, 1),
    pts: createGlyphZone(0, 0),
    stack: new Int32Array(maxStack),
    stackTop: 0,
    IP: 0,
    code: new Uint8Array(0),
    codeSize: 0,
    currentRange: 0 /* None */,
    opcode: 0,
    numArgs: 0,
    cvt: new Int32Array(0),
    cvtSize: 0,
    storage: new Int32Array(maxStorage),
    storageSize: maxStorage,
    FDefs: new Array(maxFDefs).fill(null).map((_, i) => ({
      id: i,
      start: 0,
      end: 0,
      active: false,
      range: 0 /* None */
    })),
    maxFDefs,
    IDefs: new Array(maxIDefs).fill(null).map((_, i) => ({
      opcode: i,
      start: 0,
      end: 0,
      active: false,
      range: 0 /* None */
    })),
    maxIDefs,
    callStack: new Array(maxCallStack).fill(null).map(() => ({
      callerIP: 0,
      callerRange: 0 /* None */,
      def: { id: 0, start: 0, end: 0, active: false, range: 0 /* None */ },
      count: 0
    })),
    callStackTop: 0,
    maxCallStack,
    codeRanges: new Map,
    ppem: 12,
    pointSize: 12,
    scale: 1,
    scaleFix: 65536,
    lightMode: false,
    grayscale: true,
    renderMode: "gray",
    backwardCompatibility: 0,
    isComposite: false,
    error: null,
    instructionCount: 0,
    maxInstructions: 1e6
  };
}
var Opcode = {
  NPUSHB: 64,
  NPUSHW: 65,
  PUSHB_0: 176,
  PUSHB_1: 177,
  PUSHB_2: 178,
  PUSHB_3: 179,
  PUSHB_4: 180,
  PUSHB_5: 181,
  PUSHB_6: 182,
  PUSHB_7: 183,
  PUSHW_0: 184,
  PUSHW_1: 185,
  PUSHW_2: 186,
  PUSHW_3: 187,
  PUSHW_4: 188,
  PUSHW_5: 189,
  PUSHW_6: 190,
  PUSHW_7: 191,
  RS: 67,
  WS: 66,
  RCVT: 69,
  WCVTP: 68,
  WCVTF: 112,
  DUP: 32,
  POP: 33,
  CLEAR: 34,
  SWAP: 35,
  DEPTH: 36,
  CINDEX: 37,
  MINDEX: 38,
  ROLL: 138,
  ADD: 96,
  SUB: 97,
  DIV: 98,
  MUL: 99,
  ABS: 100,
  NEG: 101,
  FLOOR: 102,
  CEILING: 103,
  MAX: 139,
  MIN: 140,
  LT: 80,
  LTEQ: 81,
  GT: 82,
  GTEQ: 83,
  EQ: 84,
  NEQ: 85,
  ODD: 86,
  EVEN: 87,
  AND: 90,
  OR: 91,
  NOT: 92,
  IF: 88,
  ELSE: 27,
  EIF: 89,
  JMPR: 28,
  JROT: 120,
  JROF: 121,
  FDEF: 44,
  ENDF: 45,
  CALL: 43,
  LOOPCALL: 42,
  IDEF: 137,
  SVTCA_Y: 0,
  SVTCA_X: 1,
  SPVTCA_Y: 2,
  SPVTCA_X: 3,
  SFVTCA_Y: 4,
  SFVTCA_X: 5,
  SPVTL_0: 6,
  SPVTL_1: 7,
  SFVTL_0: 8,
  SFVTL_1: 9,
  SDPVTL_0: 134,
  SDPVTL_1: 135,
  SPVFS: 10,
  SFVFS: 11,
  GPV: 12,
  GFV: 13,
  SFVTPV: 14,
  ISECT: 15,
  SRP0: 16,
  SRP1: 17,
  SRP2: 18,
  SZP0: 19,
  SZP1: 20,
  SZP2: 21,
  SZPS: 22,
  SLOOP: 23,
  RTG: 24,
  RTHG: 25,
  SMD: 26,
  RDTG: 125,
  RUTG: 124,
  ROFF: 122,
  SROUND: 118,
  S45ROUND: 119,
  SCVTCI: 29,
  SSWCI: 30,
  SSW: 31,
  FLIPON: 77,
  FLIPOFF: 78,
  SANGW: 126,
  SDB: 94,
  SDS: 95,
  GC_0: 70,
  GC_1: 71,
  SCFS: 72,
  MD_0: 73,
  MD_1: 74,
  MPPEM: 75,
  MPS: 76,
  FLIPPT: 128,
  FLIPRGON: 129,
  FLIPRGOFF: 130,
  SHP_0: 50,
  SHP_1: 51,
  SHC_0: 52,
  SHC_1: 53,
  SHZ_0: 54,
  SHZ_1: 55,
  SHPIX: 56,
  IP: 57,
  MSIRP_0: 58,
  MSIRP_1: 59,
  ALIGNRP: 60,
  RTDG: 61,
  MIAP_0: 62,
  MIAP_1: 63,
  ALIGNPTS: 39,
  UTP: 41,
  MDAP_0: 46,
  MDAP_1: 47,
  IUP_Y: 48,
  IUP_X: 49,
  DELTAP1: 93,
  DELTAP2: 113,
  DELTAP3: 114,
  DELTAC1: 115,
  DELTAC2: 116,
  DELTAC3: 117,
  ROUND_0: 104,
  ROUND_1: 105,
  ROUND_2: 106,
  ROUND_3: 107,
  NROUND_0: 108,
  NROUND_1: 109,
  NROUND_2: 110,
  NROUND_3: 111,
  GETINFO: 136,
  INSTCTRL: 142,
  SCANCTRL: 133,
  SCANTYPE: 141,
  AA: 127,
  DEBUG: 79,
  MDRP_BASE: 192,
  MIRP_BASE: 224
};
var OpcodePops = {
  [Opcode.RS]: 1,
  [Opcode.WS]: 2,
  [Opcode.RCVT]: 1,
  [Opcode.WCVTP]: 2,
  [Opcode.WCVTF]: 2,
  [Opcode.DUP]: 1,
  [Opcode.POP]: 1,
  [Opcode.CLEAR]: 0,
  [Opcode.SWAP]: 2,
  [Opcode.DEPTH]: 0,
  [Opcode.CINDEX]: 1,
  [Opcode.MINDEX]: 1,
  [Opcode.ROLL]: 3,
  [Opcode.ADD]: 2,
  [Opcode.SUB]: 2,
  [Opcode.DIV]: 2,
  [Opcode.MUL]: 2,
  [Opcode.ABS]: 1,
  [Opcode.NEG]: 1,
  [Opcode.FLOOR]: 1,
  [Opcode.CEILING]: 1,
  [Opcode.MAX]: 2,
  [Opcode.MIN]: 2,
  [Opcode.LT]: 2,
  [Opcode.LTEQ]: 2,
  [Opcode.GT]: 2,
  [Opcode.GTEQ]: 2,
  [Opcode.EQ]: 2,
  [Opcode.NEQ]: 2,
  [Opcode.ODD]: 1,
  [Opcode.EVEN]: 1,
  [Opcode.AND]: 2,
  [Opcode.OR]: 2,
  [Opcode.NOT]: 1,
  [Opcode.IF]: 1,
  [Opcode.JMPR]: 1,
  [Opcode.JROT]: 2,
  [Opcode.JROF]: 2,
  [Opcode.CALL]: 1,
  [Opcode.LOOPCALL]: 2,
  [Opcode.SRP0]: 1,
  [Opcode.SRP1]: 1,
  [Opcode.SRP2]: 1,
  [Opcode.SZP0]: 1,
  [Opcode.SZP1]: 1,
  [Opcode.SZP2]: 1,
  [Opcode.SZPS]: 1,
  [Opcode.SLOOP]: 1,
  [Opcode.SMD]: 1,
  [Opcode.SCVTCI]: 1,
  [Opcode.SSWCI]: 1,
  [Opcode.SSW]: 1,
  [Opcode.SDB]: 1,
  [Opcode.SDS]: 1,
  [Opcode.SPVFS]: 2,
  [Opcode.SFVFS]: 2,
  [Opcode.SPVTL_0]: 2,
  [Opcode.SPVTL_1]: 2,
  [Opcode.SFVTL_0]: 2,
  [Opcode.SFVTL_1]: 2,
  [Opcode.SCFS]: 2,
  [Opcode.GC_0]: 1,
  [Opcode.GC_1]: 1,
  [Opcode.MD_0]: 2,
  [Opcode.MD_1]: 2,
  [Opcode.ISECT]: 5,
  [Opcode.ALIGNRP]: 0,
  [Opcode.IP]: 0,
  [Opcode.SHPIX]: 1,
  [Opcode.MSIRP_0]: 2,
  [Opcode.MSIRP_1]: 2,
  [Opcode.MIAP_0]: 2,
  [Opcode.MIAP_1]: 2,
  [Opcode.MDAP_0]: 1,
  [Opcode.MDAP_1]: 1,
  [Opcode.DELTAP1]: 1,
  [Opcode.DELTAP2]: 1,
  [Opcode.DELTAP3]: 1,
  [Opcode.DELTAC1]: 1,
  [Opcode.DELTAC2]: 1,
  [Opcode.DELTAC3]: 1,
  [Opcode.SROUND]: 1,
  [Opcode.S45ROUND]: 1,
  [Opcode.ROUND_0]: 1,
  [Opcode.ROUND_1]: 1,
  [Opcode.ROUND_2]: 1,
  [Opcode.ROUND_3]: 1,
  [Opcode.NROUND_0]: 1,
  [Opcode.NROUND_1]: 1,
  [Opcode.NROUND_2]: 1,
  [Opcode.NROUND_3]: 1,
  [Opcode.INSTCTRL]: 2,
  [Opcode.SCANCTRL]: 1,
  [Opcode.SCANTYPE]: 1,
  [Opcode.GETINFO]: 1,
  [Opcode.FLIPPT]: 0,
  [Opcode.FLIPRGON]: 2,
  [Opcode.FLIPRGOFF]: 2
};

// reference/text-shaper/src/hinting/rounding.ts
function roundToGrid(distance, compensation) {
  if (distance >= 0) {
    const val = distance + compensation + 32 & -64;
    return val < 0 ? 0 : val;
  } else {
    const val = -(-distance + compensation + 32 & -64);
    return val > 0 ? 0 : val;
  }
}
function roundToHalfGrid(distance, compensation) {
  if (distance >= 0) {
    const val = (distance + compensation & -64) + 32;
    return val < 0 ? 32 : val;
  } else {
    const val = -((-distance + compensation & -64) + 32);
    return val > 0 ? -32 : val;
  }
}
function roundToDoubleGrid(distance, compensation) {
  if (distance >= 0) {
    const val = distance + compensation + 16 & -32;
    return val < 0 ? 0 : val;
  } else {
    const val = -(-distance + compensation + 16 & -32);
    return val > 0 ? 0 : val;
  }
}
function roundDownToGrid(distance, compensation) {
  if (distance >= 0) {
    const val = distance + compensation & -64;
    return val < 0 ? 0 : val;
  } else {
    const val = -(-distance + compensation & -64);
    return val > 0 ? 0 : val;
  }
}
function roundUpToGrid(distance, compensation) {
  if (distance >= 0) {
    const val = distance + compensation + 63 & -64;
    return val < 0 ? 0 : val;
  } else {
    const val = -(-distance + compensation + 63 & -64);
    return val > 0 ? 0 : val;
  }
}
function roundOff(distance, _compensation) {
  return distance;
}
function roundSuper(distance, compensation, GS) {
  const { period, phase, threshold } = GS;
  if (distance >= 0) {
    const val = distance + threshold - phase + compensation & -period;
    return val + phase;
  } else {
    const val = -distance + threshold - phase + compensation & -period;
    return -(val + phase);
  }
}
function roundSuper45(distance, compensation, GS) {
  const { period, phase, threshold } = GS;
  const period45 = Math.round(period * 46 / 64);
  if (distance >= 0) {
    const val = distance + threshold - phase + compensation & -period45;
    return val + phase;
  } else {
    const val = -distance + threshold - phase + compensation & -period45;
    return -(val + phase);
  }
}
function round(distance, compensation, GS) {
  switch (GS.roundState) {
    case 1 /* ToGrid */:
      return roundToGrid(distance, compensation);
    case 0 /* ToHalfGrid */:
      return roundToHalfGrid(distance, compensation);
    case 2 /* ToDoubleGrid */:
      return roundToDoubleGrid(distance, compensation);
    case 3 /* DownToGrid */:
      return roundDownToGrid(distance, compensation);
    case 4 /* UpToGrid */:
      return roundUpToGrid(distance, compensation);
    case 5 /* Off */:
      return roundOff(distance, compensation);
    case 6 /* Super */:
      return roundSuper(distance, compensation, GS);
    case 7 /* Super45 */:
      return roundSuper45(distance, compensation, GS);
    default:
      return roundToGrid(distance, compensation);
  }
}
function parseSuperRound(selector, GS) {
  switch (selector >> 6 & 3) {
    case 0:
      GS.period = 32;
      break;
    case 1:
      GS.period = 64;
      break;
    case 2:
      GS.period = 128;
      break;
    default:
      GS.period = 64;
  }
  switch (selector >> 4 & 3) {
    case 0:
      GS.phase = 0;
      break;
    case 1:
      GS.phase = GS.period >> 2;
      break;
    case 2:
      GS.phase = GS.period >> 1;
      break;
    case 3:
      GS.phase = GS.period * 3 >> 2;
      break;
  }
  const thresholdBits = selector & 15;
  if (thresholdBits === 0) {
    GS.threshold = GS.period - 1;
  } else {
    GS.threshold = (thresholdBits - 4) * GS.period >> 3;
  }
}
function compensate(_distance, _GS) {
  return 0;
}

// reference/text-shaper/src/hinting/scale.ts
function mulFix(value, scaleFix) {
  if (value === 0 || scaleFix === 0)
    return 0;
  let sign = 1;
  let a = value;
  let b = scaleFix;
  if (a < 0) {
    a = -a;
    sign = -sign;
  }
  if (b < 0) {
    b = -b;
    sign = -sign;
  }
  const result = Math.floor((a * b + 32768) / 65536);
  return sign < 0 ? -result : result;
}
function divFix(value, divisor) {
  if (divisor === 0)
    return value < 0 ? -2147483647 : 2147483647;
  let sign = 1;
  let a = value;
  let b = divisor;
  if (a < 0) {
    a = -a;
    sign = -sign;
  }
  if (b < 0) {
    b = -b;
    sign = -sign;
  }
  const result = Math.floor((a * 65536 + (b >> 1)) / b);
  return sign < 0 ? -result : result;
}
function scaleFUnits(value, scaleFix) {
  return mulFix(value, scaleFix);
}

// reference/text-shaper/src/hinting/instructions/points.ts
function dotFix14(ax, ay, bx, by) {
  const c = ax * bx + ay * by;
  const rounded = c + 8192 + (c < 0 ? -1 : 0);
  return Math.floor(rounded / 16384);
}
function mulFix14(a, b) {
  const c = a * b;
  const rounded = c + 8192 + (c < 0 ? -1 : 0);
  return Math.floor(rounded / 16384);
}
function dotFix14Vectors(ax, ay, bx, by) {
  const c = ax * bx + ay * by;
  const rounded = c + 8192 + (c < 0 ? -1 : 0);
  return Math.floor(rounded / 16384);
}
function mulDiv2(a, b, c) {
  if (c === 0)
    return (a ^ b) < 0 ? -2147483647 : 2147483647;
  let sign = 1;
  if (a < 0) {
    a = -a;
    sign = -sign;
  }
  if (b < 0) {
    b = -b;
    sign = -sign;
  }
  if (c < 0) {
    c = -c;
    sign = -sign;
  }
  const result = Math.floor((a * b + (c >> 1)) / c);
  return sign < 0 ? -result : result;
}
function project(ctx, p) {
  return dotFix14(p.x, p.y, ctx.GS.projVector.x, ctx.GS.projVector.y);
}
function dualProject(ctx, p) {
  return dotFix14(p.x, p.y, ctx.GS.dualVector.x, ctx.GS.dualVector.y);
}
function movePoint(ctx, zone, pointIndex, distance) {
  const pt = zone.cur[pointIndex];
  const fv = ctx.GS.freeVector;
  const pv = ctx.GS.projVector;
  const dot = dotFix14Vectors(fv.x, fv.y, pv.x, pv.y);
  if (dot === 0) {
    return;
  }
  const dx = mulDiv2(distance, fv.x, dot);
  const dy = mulDiv2(distance, fv.y, dot);
  let moveX = dx;
  let moveY = dy;
  if (ctx.backwardCompatibility) {
    if (fv.x !== 0)
      moveX = 0;
    if (fv.y !== 0 && ctx.backwardCompatibility === 7)
      moveY = 0;
  }
  pt.x += moveX;
  pt.y += moveY;
  if (zone === ctx.twilight) {
    const orgPt = zone.org[pointIndex];
    orgPt.x += moveX;
    orgPt.y += moveY;
  }
}
function getCurrent(ctx, zone, pointIndex) {
  const pt = zone.cur[pointIndex];
  if (!pt)
    return 0;
  return project(ctx, pt);
}
function getOriginal(ctx, zone, pointIndex) {
  const pt = zone.org[pointIndex];
  if (!pt)
    return 0;
  return dualProject(ctx, pt);
}
function touchPoint(ctx, zone, pointIndex) {
  const fv = ctx.GS.freeVector;
  if (fv.y !== 0) {
    zone.tags[pointIndex] |= 32 /* Y */;
  }
  if (fv.x !== 0) {
    zone.tags[pointIndex] |= 16 /* X */;
  }
}
function MDAP(ctx, doRound) {
  const pointIndex = ctx.stack[--ctx.stackTop];
  const zone = ctx.zp0;
  if (pointIndex < 0 || pointIndex >= zone.nPoints) {
    ctx.error = `MDAP: invalid point ${pointIndex}`;
    return;
  }
  let distance = getCurrent(ctx, zone, pointIndex);
  if (doRound) {
    const comp = compensate(distance, ctx.GS);
    distance = round(distance, comp, ctx.GS) - distance;
  } else {
    distance = 0;
  }
  movePoint(ctx, zone, pointIndex, distance);
  touchPoint(ctx, zone, pointIndex);
  ctx.GS.rp0 = pointIndex;
  ctx.GS.rp1 = pointIndex;
}
function MIAP(ctx, doRound) {
  const cvtIndex = ctx.stack[--ctx.stackTop];
  const pointIndex = ctx.stack[--ctx.stackTop];
  const zone = ctx.zp0;
  if (pointIndex < 0 || pointIndex >= zone.nPoints) {
    ctx.error = `MIAP: invalid point ${pointIndex}`;
    return;
  }
  if (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {
    return;
  }
  let cvtDistance = ctx.cvt[cvtIndex];
  const currentPos = getCurrent(ctx, zone, pointIndex);
  if (doRound) {
    const diff = Math.abs(cvtDistance - currentPos);
    if (diff > ctx.GS.controlValueCutIn) {
      cvtDistance = currentPos;
    }
    const comp = compensate(cvtDistance, ctx.GS);
    cvtDistance = round(cvtDistance, comp, ctx.GS);
  }
  const distance = cvtDistance - currentPos;
  movePoint(ctx, zone, pointIndex, distance);
  touchPoint(ctx, zone, pointIndex);
  ctx.GS.rp0 = pointIndex;
  ctx.GS.rp1 = pointIndex;
}
function MDRP(ctx, flags) {
  const pointIndex = ctx.stack[--ctx.stackTop];
  const setRp0 = (flags & 16) !== 0;
  const keepMinDist = (flags & 8) !== 0;
  const doRound = (flags & 4) !== 0;
  const distanceType = flags & 3;
  let roundState = ctx.GS.roundState;
  if (distanceType === 1) {
    roundState = 1 /* ToGrid */;
  } else if (distanceType === 2) {
    roundState = 0 /* ToHalfGrid */;
  } else if (distanceType === 3) {
    roundState = 2 /* ToDoubleGrid */;
  }
  const zp0 = ctx.zp0;
  const zp1 = ctx.zp1;
  if (pointIndex < 0 || pointIndex >= zp1.nPoints) {
    ctx.error = `MDRP: invalid point ${pointIndex}`;
    return;
  }
  const rp0 = ctx.GS.rp0;
  if (rp0 < 0 || rp0 >= zp0.nPoints) {
    ctx.error = `MDRP: invalid rp0 ${rp0}`;
    return;
  }
  let orgDist = getOriginal(ctx, zp1, pointIndex) - getOriginal(ctx, zp0, rp0);
  if (ctx.GS.singleWidthCutIn > 0 && Math.abs(orgDist - ctx.GS.singleWidthValue) < ctx.GS.singleWidthCutIn) {
    orgDist = orgDist >= 0 ? ctx.GS.singleWidthValue : -ctx.GS.singleWidthValue;
  }
  const comp = compensate(orgDist, ctx.GS);
  let distance;
  if (doRound) {
    const savedRound = ctx.GS.roundState;
    ctx.GS.roundState = roundState;
    distance = round(orgDist, comp, ctx.GS);
    ctx.GS.roundState = savedRound;
  } else {
    distance = orgDist + comp;
  }
  if (keepMinDist) {
    if (orgDist >= 0) {
      if (distance < ctx.GS.minimumDistance) {
        distance = ctx.GS.minimumDistance;
      }
    } else {
      if (distance > -ctx.GS.minimumDistance) {
        distance = -ctx.GS.minimumDistance;
      }
    }
  }
  const currentDist = getCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);
  const move = distance - currentDist;
  movePoint(ctx, zp1, pointIndex, move);
  touchPoint(ctx, zp1, pointIndex);
  ctx.GS.rp1 = ctx.GS.rp0;
  ctx.GS.rp2 = pointIndex;
  if (setRp0) {
    ctx.GS.rp0 = pointIndex;
  }
}
function MIRP(ctx, flags) {
  const cvtIndex = ctx.stack[--ctx.stackTop];
  const pointIndex = ctx.stack[--ctx.stackTop];
  const setRp0 = (flags & 16) !== 0;
  const keepMinDist = (flags & 8) !== 0;
  const doRound = (flags & 4) !== 0;
  const distanceType = flags & 3;
  let roundState = ctx.GS.roundState;
  if (distanceType === 1) {
    roundState = 1 /* ToGrid */;
  } else if (distanceType === 2) {
    roundState = 0 /* ToHalfGrid */;
  } else if (distanceType === 3) {
    roundState = 2 /* ToDoubleGrid */;
  }
  const zp0 = ctx.zp0;
  const zp1 = ctx.zp1;
  if (pointIndex < 0 || pointIndex >= zp1.nPoints) {
    ctx.error = `MIRP: invalid point ${pointIndex}`;
    return;
  }
  if (cvtIndex < -1 || cvtIndex >= ctx.cvtSize) {
    return;
  }
  const rp0 = ctx.GS.rp0;
  if (rp0 < 0 || rp0 >= zp0.nPoints) {
    ctx.error = `MIRP: invalid rp0 ${rp0}`;
    return;
  }
  const orgDist = getOriginal(ctx, zp1, pointIndex) - getOriginal(ctx, zp0, rp0);
  let cvtDist = cvtIndex === -1 ? 0 : ctx.cvt[cvtIndex];
  if (ctx.GS.singleWidthCutIn > 0 && Math.abs(cvtDist - ctx.GS.singleWidthValue) < ctx.GS.singleWidthCutIn) {
    cvtDist = cvtDist >= 0 ? ctx.GS.singleWidthValue : -ctx.GS.singleWidthValue;
  }
  if (ctx.GS.gep1 === 0) {
    const orgRp0 = ctx.zp0.org[rp0];
    const dx = mulFix14(cvtDist, ctx.GS.freeVector.x);
    const dy = mulFix14(cvtDist, ctx.GS.freeVector.y);
    ctx.zp1.org[pointIndex].x = orgRp0.x + dx;
    ctx.zp1.org[pointIndex].y = orgRp0.y + dy;
    ctx.zp1.cur[pointIndex].x = ctx.zp1.org[pointIndex].x;
    ctx.zp1.cur[pointIndex].y = ctx.zp1.org[pointIndex].y;
  }
  if (ctx.GS.autoFlip) {
    if ((orgDist ^ cvtDist) < 0) {
      cvtDist = -cvtDist;
    }
  }
  let distance = cvtDist;
  const comp = compensate(cvtDist, ctx.GS);
  if (doRound) {
    if (ctx.GS.gep0 === ctx.GS.gep1) {
      const diff = Math.abs(cvtDist - orgDist);
      if (diff > ctx.GS.controlValueCutIn) {
        distance = orgDist;
      }
    }
    const savedRound = ctx.GS.roundState;
    ctx.GS.roundState = roundState;
    distance = round(distance, comp, ctx.GS);
    ctx.GS.roundState = savedRound;
  } else {
    distance = distance + comp;
  }
  if (keepMinDist) {
    if (orgDist >= 0) {
      if (distance < ctx.GS.minimumDistance) {
        distance = ctx.GS.minimumDistance;
      }
    } else {
      if (distance > -ctx.GS.minimumDistance) {
        distance = -ctx.GS.minimumDistance;
      }
    }
  }
  const currentDist = getCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);
  const move = distance - currentDist;
  movePoint(ctx, zp1, pointIndex, move);
  touchPoint(ctx, zp1, pointIndex);
  ctx.GS.rp1 = ctx.GS.rp0;
  ctx.GS.rp2 = pointIndex;
  if (setRp0) {
    ctx.GS.rp0 = pointIndex;
  }
}
function SHP(ctx, useRp1) {
  const refZone = useRp1 ? ctx.zp0 : ctx.zp1;
  const refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;
  if (refPoint < 0 || refPoint >= refZone.nPoints) {
    ctx.error = `SHP: invalid reference point ${refPoint}`;
    return;
  }
  const orgRef = project(ctx, refZone.org[refPoint]);
  const curRef = getCurrent(ctx, refZone, refPoint);
  const shift = curRef - orgRef;
  const zone = ctx.zp2;
  const count = ctx.GS.loop;
  ctx.GS.loop = 1;
  for (let i = 0;i < count; i++) {
    const pointIndex = ctx.stack[--ctx.stackTop];
    if (pointIndex < 0 || pointIndex >= zone.nPoints) {
      ctx.error = `SHP: invalid point ${pointIndex}`;
      return;
    }
    movePoint(ctx, zone, pointIndex, shift);
    touchPoint(ctx, zone, pointIndex);
  }
}
function SHC(ctx, useRp1) {
  const contourIndex = ctx.stack[--ctx.stackTop];
  const refZone = useRp1 ? ctx.zp0 : ctx.zp1;
  const refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;
  if (refPoint < 0 || refPoint >= refZone.nPoints) {
    ctx.error = `SHC: invalid reference point ${refPoint}`;
    return;
  }
  const zone = ctx.zp2;
  if (contourIndex < 0 || contourIndex >= zone.nContours) {
    ctx.error = `SHC: invalid contour ${contourIndex}`;
    return;
  }
  const orgRef = project(ctx, refZone.org[refPoint]);
  const curRef = getCurrent(ctx, refZone, refPoint);
  const shift = curRef - orgRef;
  const start = contourIndex === 0 ? 0 : zone.contours[contourIndex - 1] + 1;
  const end = zone.contours[contourIndex];
  for (let i = start;i <= end; i++) {
    if (zone === refZone && i === refPoint)
      continue;
    movePoint(ctx, zone, i, shift);
    touchPoint(ctx, zone, i);
  }
}
function SHZ(ctx, useRp1) {
  const zoneIndex = ctx.stack[--ctx.stackTop];
  const refZone = useRp1 ? ctx.zp0 : ctx.zp1;
  const refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;
  if (refPoint < 0 || refPoint >= refZone.nPoints) {
    ctx.error = `SHZ: invalid reference point ${refPoint}`;
    return;
  }
  const zone = zoneIndex === 0 ? ctx.twilight : ctx.pts;
  const orgRef = project(ctx, refZone.org[refPoint]);
  const curRef = getCurrent(ctx, refZone, refPoint);
  const shift = curRef - orgRef;
  for (let i = 0;i < zone.nPoints; i++) {
    if (zone === refZone && i === refPoint)
      continue;
    movePoint(ctx, zone, i, shift);
  }
}
function movePointFree(ctx, zone, pointIndex, dx, dy) {
  const fv = ctx.GS.freeVector;
  if (fv.x !== 0) {
    if (!ctx.backwardCompatibility) {
      zone.cur[pointIndex].x += dx;
    }
  }
  if (fv.y !== 0) {
    if (ctx.backwardCompatibility !== 7) {
      zone.cur[pointIndex].y += dy;
    }
  }
  if (zone === ctx.twilight) {
    const orgPt = zone.org[pointIndex];
    if (fv.x !== 0 && !ctx.backwardCompatibility)
      orgPt.x += dx;
    if (fv.y !== 0 && ctx.backwardCompatibility !== 7)
      orgPt.y += dy;
  }
}
function SHPIX(ctx) {
  const distance = ctx.stack[--ctx.stackTop];
  const zone = ctx.zp2;
  const count = ctx.GS.loop;
  ctx.GS.loop = 1;
  const inTwilight = ctx.GS.gep0 === 0 || ctx.GS.gep1 === 0 || ctx.GS.gep2 === 0;
  const dx = mulFix14(distance, ctx.GS.freeVector.x);
  const dy = mulFix14(distance, ctx.GS.freeVector.y);
  for (let i = 0;i < count; i++) {
    const pointIndex = ctx.stack[--ctx.stackTop];
    if (pointIndex < 0 || pointIndex >= zone.nPoints) {
      ctx.error = `SHPIX: invalid point ${pointIndex}`;
      return;
    }
    if (ctx.backwardCompatibility) {
      if (inTwilight || ctx.backwardCompatibility !== 7 && (ctx.isComposite && ctx.GS.freeVector.y !== 0 || zone.tags[pointIndex] & 32 /* Y */)) {
        movePointFree(ctx, zone, pointIndex, 0, dy);
        touchPoint(ctx, zone, pointIndex);
      }
    } else {
      movePointFree(ctx, zone, pointIndex, dx, dy);
      touchPoint(ctx, zone, pointIndex);
    }
  }
}
function IP(ctx) {
  const rp1 = ctx.GS.rp1;
  const rp2 = ctx.GS.rp2;
  if (rp1 < 0 || rp1 >= ctx.zp0.nPoints) {
    ctx.error = `IP: invalid rp1 ${rp1}`;
    return;
  }
  if (rp2 < 0 || rp2 >= ctx.zp1.nPoints) {
    ctx.error = `IP: invalid rp2 ${rp2}`;
    return;
  }
  const orgRange = getOriginal(ctx, ctx.zp1, rp2) - getOriginal(ctx, ctx.zp0, rp1);
  const curRange = getCurrent(ctx, ctx.zp1, rp2) - getCurrent(ctx, ctx.zp0, rp1);
  const orgBase = getOriginal(ctx, ctx.zp0, rp1);
  const curBase = getCurrent(ctx, ctx.zp0, rp1);
  const zone = ctx.zp2;
  const count = ctx.GS.loop;
  ctx.GS.loop = 1;
  for (let i = 0;i < count; i++) {
    const pointIndex = ctx.stack[--ctx.stackTop];
    if (pointIndex < 0 || pointIndex >= zone.nPoints) {
      ctx.error = `IP: invalid point ${pointIndex}`;
      return;
    }
    const orgDist = getOriginal(ctx, zone, pointIndex) - orgBase;
    const curDist = getCurrent(ctx, zone, pointIndex) - curBase;
    let newDist;
    if (orgDist !== 0) {
      if (orgRange !== 0) {
        newDist = mulDiv2(orgDist, curRange, orgRange);
      } else {
        newDist = orgDist;
      }
    } else {
      newDist = 0;
    }
    movePoint(ctx, zone, pointIndex, newDist - curDist);
    touchPoint(ctx, zone, pointIndex);
  }
}
function ALIGNRP(ctx) {
  const rp0 = ctx.GS.rp0;
  if (rp0 < 0 || rp0 >= ctx.zp0.nPoints) {
    ctx.error = `ALIGNRP: invalid rp0 ${rp0}`;
    return;
  }
  const refPos = getCurrent(ctx, ctx.zp0, rp0);
  const zone = ctx.zp1;
  const count = ctx.GS.loop;
  ctx.GS.loop = 1;
  for (let i = 0;i < count; i++) {
    const pointIndex = ctx.stack[--ctx.stackTop];
    if (pointIndex < 0 || pointIndex >= zone.nPoints) {
      ctx.error = `ALIGNRP: invalid point ${pointIndex}`;
      return;
    }
    const curPos = getCurrent(ctx, zone, pointIndex);
    const distance = refPos - curPos;
    movePoint(ctx, zone, pointIndex, distance);
    touchPoint(ctx, zone, pointIndex);
  }
}
function MSIRP(ctx, setRp0) {
  const distance = ctx.stack[--ctx.stackTop];
  const pointIndex = ctx.stack[--ctx.stackTop];
  const zp0 = ctx.zp0;
  const zp1 = ctx.zp1;
  if (pointIndex < 0 || pointIndex >= zp1.nPoints) {
    ctx.error = `MSIRP: invalid point ${pointIndex}`;
    return;
  }
  const rp0 = ctx.GS.rp0;
  if (rp0 < 0 || rp0 >= zp0.nPoints) {
    ctx.error = `MSIRP: invalid rp0 ${rp0}`;
    return;
  }
  const currentDist = getCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);
  const move = distance - currentDist;
  movePoint(ctx, zp1, pointIndex, move);
  touchPoint(ctx, zp1, pointIndex);
  ctx.GS.rp1 = ctx.GS.rp0;
  ctx.GS.rp2 = pointIndex;
  if (setRp0) {
    ctx.GS.rp0 = pointIndex;
  }
}
function ISECT(ctx) {
  const b1 = ctx.stack[--ctx.stackTop];
  const b0 = ctx.stack[--ctx.stackTop];
  const a1 = ctx.stack[--ctx.stackTop];
  const a0 = ctx.stack[--ctx.stackTop];
  const point = ctx.stack[--ctx.stackTop];
  const zone0 = ctx.zp0;
  const zone1 = ctx.zp1;
  const zone2 = ctx.zp2;
  if (a0 < 0 || a0 >= zone1.nPoints || a1 < 0 || a1 >= zone1.nPoints) {
    ctx.error = `ISECT: invalid line A points`;
    return;
  }
  if (b0 < 0 || b0 >= zone0.nPoints || b1 < 0 || b1 >= zone0.nPoints) {
    ctx.error = `ISECT: invalid line B points`;
    return;
  }
  if (point < 0 || point >= zone2.nPoints) {
    ctx.error = `ISECT: invalid point ${point}`;
    return;
  }
  const pa0 = zone1.cur[a0];
  const pa1 = zone1.cur[a1];
  const pb0 = zone0.cur[b0];
  const pb1 = zone0.cur[b1];
  const dbx = pb1.x - pb0.x;
  const dby = pb1.y - pb0.y;
  const dax = pa1.x - pa0.x;
  const day = pa1.y - pa0.y;
  const dx = pb0.x - pa0.x;
  const dy = pb0.y - pa0.y;
  const discriminant = mulDiv2(dax, -dby, 64) + mulDiv2(day, dbx, 64);
  const dotproduct = mulDiv2(dax, dbx, 64) + mulDiv2(day, dby, 64);
  const pt = zone2.cur[point];
  if (Math.abs(discriminant) * 19 > Math.abs(dotproduct) && discriminant !== 0) {
    const val = mulDiv2(dx, -dby, 64) + mulDiv2(dy, dbx, 64);
    const rx = mulDiv2(val, dax, discriminant);
    const ry = mulDiv2(val, day, discriminant);
    pt.x = pa0.x + rx;
    pt.y = pa0.y + ry;
  } else {
    pt.x = pa0.x + pa1.x + pb0.x + pb1.x >> 2;
    pt.y = pa0.y + pa1.y + pb0.y + pb1.y >> 2;
  }
  zone2.tags[point] |= 48 /* Both */;
}
function ALIGNPTS(ctx) {
  const p2 = ctx.stack[--ctx.stackTop];
  const p1 = ctx.stack[--ctx.stackTop];
  const zone1 = ctx.zp0;
  const zone2 = ctx.zp1;
  if (p1 < 0 || p1 >= zone1.nPoints) {
    ctx.error = `ALIGNPTS: invalid point ${p1}`;
    return;
  }
  if (p2 < 0 || p2 >= zone2.nPoints) {
    ctx.error = `ALIGNPTS: invalid point ${p2}`;
    return;
  }
  const pos1 = getCurrent(ctx, zone1, p1);
  const pos2 = getCurrent(ctx, zone2, p2);
  const mid = pos1 + pos2 >> 1;
  movePoint(ctx, zone1, p1, mid - pos1);
  movePoint(ctx, zone2, p2, mid - pos2);
  touchPoint(ctx, zone1, p1);
  touchPoint(ctx, zone2, p2);
}
function GC(ctx, useOriginal) {
  const pointIndex = ctx.stack[--ctx.stackTop];
  const zone = ctx.zp2;
  if (pointIndex < 0 || pointIndex >= zone.nPoints) {
    ctx.error = `GC: invalid point ${pointIndex}`;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  const coord = useOriginal ? dualProject(ctx, zone.org[pointIndex]) : getCurrent(ctx, zone, pointIndex);
  ctx.stack[ctx.stackTop++] = coord;
}
function SCFS(ctx) {
  const coord = ctx.stack[--ctx.stackTop];
  const pointIndex = ctx.stack[--ctx.stackTop];
  const zone = ctx.zp2;
  if (pointIndex < 0 || pointIndex >= zone.nPoints) {
    ctx.error = `SCFS: invalid point ${pointIndex}`;
    return;
  }
  const current = getCurrent(ctx, zone, pointIndex);
  movePoint(ctx, zone, pointIndex, coord - current);
  touchPoint(ctx, zone, pointIndex);
}
function MD(ctx, useOriginal) {
  const p2 = ctx.stack[--ctx.stackTop];
  const p1 = ctx.stack[--ctx.stackTop];
  const zone0 = ctx.zp0;
  const zone1 = ctx.zp1;
  if (p1 < 0 || p1 >= zone0.nPoints) {
    ctx.error = `MD: invalid point ${p1}`;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  if (p2 < 0 || p2 >= zone1.nPoints) {
    ctx.error = `MD: invalid point ${p2}`;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  let distance;
  if (useOriginal) {
    distance = getOriginal(ctx, zone1, p2) - getOriginal(ctx, zone0, p1);
  } else {
    distance = getCurrent(ctx, zone1, p2) - getCurrent(ctx, zone0, p1);
  }
  ctx.stack[ctx.stackTop++] = distance;
}
function MPPEM(ctx) {
  ctx.stack[ctx.stackTop++] = ctx.ppem;
}
function MPS(ctx) {
  ctx.stack[ctx.stackTop++] = ctx.pointSize;
}
function FLIPPT(ctx) {
  if (ctx.backwardCompatibility === 7)
    return;
  const zone = ctx.pts;
  const count = ctx.GS.loop;
  ctx.GS.loop = 1;
  for (let i = 0;i < count; i++) {
    const pointIndex = ctx.stack[--ctx.stackTop];
    if (pointIndex < 0 || pointIndex >= zone.nPoints) {
      ctx.error = `FLIPPT: invalid point ${pointIndex}`;
      return;
    }
    zone.tags[pointIndex] ^= 1;
  }
}
function FLIPRGON(ctx) {
  if (ctx.backwardCompatibility === 7)
    return;
  const endPoint = ctx.stack[--ctx.stackTop];
  const startPoint = ctx.stack[--ctx.stackTop];
  const zone = ctx.pts;
  if (startPoint < 0 || endPoint >= zone.nPoints || startPoint > endPoint) {
    ctx.error = `FLIPRGON: invalid range ${startPoint}-${endPoint}`;
    return;
  }
  for (let i = startPoint;i <= endPoint; i++) {
    zone.tags[i] |= 1;
  }
}
function FLIPRGOFF(ctx) {
  if (ctx.backwardCompatibility === 7)
    return;
  const endPoint = ctx.stack[--ctx.stackTop];
  const startPoint = ctx.stack[--ctx.stackTop];
  const zone = ctx.pts;
  if (startPoint < 0 || endPoint >= zone.nPoints || startPoint > endPoint) {
    ctx.error = `FLIPRGOFF: invalid range ${startPoint}-${endPoint}`;
    return;
  }
  for (let i = startPoint;i <= endPoint; i++) {
    zone.tags[i] &= ~1;
  }
}
function ROUND(ctx, _colorIndex) {
  const value = ctx.stack[--ctx.stackTop];
  const comp = compensate(value, ctx.GS);
  ctx.stack[ctx.stackTop++] = round(value, comp, ctx.GS);
}
function NROUND(ctx, _colorIndex) {
  const value = ctx.stack[--ctx.stackTop];
  const comp = compensate(value, ctx.GS);
  ctx.stack[ctx.stackTop++] = value + comp;
}

// reference/text-shaper/src/hinting/instructions/delta.ts
function DELTAP1(ctx) {
  deltaPoint(ctx, 0);
}
function DELTAP2(ctx) {
  deltaPoint(ctx, 16);
}
function DELTAP3(ctx) {
  deltaPoint(ctx, 32);
}
function deltaPoint(ctx, rangeOffset) {
  const count = ctx.stack[--ctx.stackTop];
  if (count < 0) {
    ctx.error = `DELTAP: invalid count ${count}`;
    return;
  }
  const zone = ctx.zp0;
  for (let i = 0;i < count; i++) {
    const pointIndex = ctx.stack[--ctx.stackTop];
    const argByte = ctx.stack[--ctx.stackTop];
    if (pointIndex < 0 || pointIndex >= zone.nPoints) {
      ctx.error = `DELTAP: invalid point ${pointIndex}`;
      return;
    }
    const ppemDelta = (argByte >> 4 & 15) + ctx.GS.deltaBase + rangeOffset;
    const magnitude = argByte & 15;
    if (ppemDelta !== ctx.ppem) {
      continue;
    }
    const deltaStep = 1 << 6 - ctx.GS.deltaShift;
    let deltaValue = magnitude - 8;
    if (deltaValue >= 0)
      deltaValue += 1;
    const delta = deltaValue * deltaStep;
    if (ctx.backwardCompatibility) {
      if (ctx.backwardCompatibility === 7)
        continue;
      if (!(ctx.isComposite && ctx.GS.freeVector.y !== 0 || zone.tags[pointIndex] & 32 /* Y */)) {
        continue;
      }
    }
    movePoint(ctx, zone, pointIndex, delta);
    touchPoint(ctx, zone, pointIndex);
  }
}
function DELTAC1(ctx) {
  deltaCVT(ctx, 0);
}
function DELTAC2(ctx) {
  deltaCVT(ctx, 16);
}
function DELTAC3(ctx) {
  deltaCVT(ctx, 32);
}
function deltaCVT(ctx, rangeOffset) {
  const count = ctx.stack[--ctx.stackTop];
  if (count < 0) {
    ctx.error = `DELTAC: invalid count ${count}`;
    return;
  }
  for (let i = 0;i < count; i++) {
    const cvtIndex = ctx.stack[--ctx.stackTop];
    const argByte = ctx.stack[--ctx.stackTop];
    if (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {
      ctx.error = `DELTAC: invalid CVT index ${cvtIndex}`;
      return;
    }
    const ppemDelta = (argByte >> 4 & 15) + ctx.GS.deltaBase + rangeOffset;
    const magnitude = argByte & 15;
    if (ppemDelta !== ctx.ppem) {
      continue;
    }
    const deltaStep = 1 << 6 - ctx.GS.deltaShift;
    let deltaValue = magnitude - 8;
    if (deltaValue >= 0)
      deltaValue += 1;
    const delta = deltaValue * deltaStep;
    ctx.cvt[cvtIndex] += delta;
  }
}

// reference/text-shaper/src/hinting/instructions/graphics-state.ts
function SVTCA(ctx, axis) {
  if (axis === 0) {
    ctx.GS.projVector = { x: 0, y: 16384 };
    ctx.GS.freeVector = { x: 0, y: 16384 };
    ctx.GS.dualVector = { x: 0, y: 16384 };
  } else {
    ctx.GS.projVector = { x: 16384, y: 0 };
    ctx.GS.freeVector = { x: 16384, y: 0 };
    ctx.GS.dualVector = { x: 16384, y: 0 };
  }
}
function SPVTCA(ctx, axis) {
  if (axis === 0) {
    ctx.GS.projVector = { x: 0, y: 16384 };
    ctx.GS.dualVector = { x: 0, y: 16384 };
  } else {
    ctx.GS.projVector = { x: 16384, y: 0 };
    ctx.GS.dualVector = { x: 16384, y: 0 };
  }
}
function SFVTCA(ctx, axis) {
  if (axis === 0) {
    ctx.GS.freeVector = { x: 0, y: 16384 };
  } else {
    ctx.GS.freeVector = { x: 16384, y: 0 };
  }
}
function vectorFromPoints(ctx, p1, p2, zone1, zone2, useOriginal) {
  const z1 = zone1 === 0 ? ctx.twilight : ctx.pts;
  const z2 = zone2 === 0 ? ctx.twilight : ctx.pts;
  const pt1 = useOriginal ? z1.org[p1] : z1.cur[p1];
  const pt2 = useOriginal ? z2.org[p2] : z2.cur[p2];
  if (!pt1 || !pt2) {
    return { vec: { x: 16384, y: 0 }, isZero: true };
  }
  const dx = pt1.x - pt2.x;
  const dy = pt1.y - pt2.y;
  if (dx === 0 && dy === 0) {
    return { vec: { x: 16384, y: 0 }, isZero: true };
  }
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len === 0) {
    return { vec: { x: 16384, y: 0 }, isZero: true };
  }
  return {
    vec: {
      x: Math.round(dx / len * 16384),
      y: Math.round(dy / len * 16384)
    },
    isZero: false
  };
}
function SPVTL(ctx, perpendicular) {
  const p2 = ctx.stack[--ctx.stackTop];
  const p1 = ctx.stack[--ctx.stackTop];
  const { vec: proj, isZero } = vectorFromPoints(ctx, p2, p1, ctx.GS.gep1, ctx.GS.gep2, false);
  if (perpendicular && !isZero) {
    const tempProj = proj.x;
    proj.x = -proj.y;
    proj.y = tempProj;
  }
  ctx.GS.projVector = proj;
  ctx.GS.dualVector = { ...proj };
}
function SFVTL(ctx, perpendicular) {
  const p2 = ctx.stack[--ctx.stackTop];
  const p1 = ctx.stack[--ctx.stackTop];
  const { vec, isZero } = vectorFromPoints(ctx, p2, p1, ctx.GS.gep1, ctx.GS.gep2, false);
  if (perpendicular && !isZero) {
    const temp = vec.x;
    vec.x = -vec.y;
    vec.y = temp;
  }
  ctx.GS.freeVector = vec;
}
function SDPVTL(ctx, perpendicular) {
  const p2 = ctx.stack[--ctx.stackTop];
  const p1 = ctx.stack[--ctx.stackTop];
  const dual = vectorFromPoints(ctx, p2, p1, ctx.GS.gep1, ctx.GS.gep2, true);
  const proj = vectorFromPoints(ctx, p2, p1, ctx.GS.gep1, ctx.GS.gep2, false);
  if (perpendicular && !dual.isZero) {
    const temp = dual.vec.x;
    dual.vec.x = -dual.vec.y;
    dual.vec.y = temp;
  }
  if (perpendicular && !proj.isZero) {
    const temp = proj.vec.x;
    proj.vec.x = -proj.vec.y;
    proj.vec.y = temp;
  }
  ctx.GS.dualVector = dual.vec;
  ctx.GS.projVector = proj.vec;
}
function SPVFS(ctx) {
  const y = ctx.stack[--ctx.stackTop];
  const x = ctx.stack[--ctx.stackTop];
  const len = Math.sqrt(x * x + y * y);
  if (len === 0) {
    ctx.GS.projVector = { x: 16384, y: 0 };
  } else {
    ctx.GS.projVector = {
      x: Math.round(x / len * 16384),
      y: Math.round(y / len * 16384)
    };
  }
  ctx.GS.dualVector = { ...ctx.GS.projVector };
}
function SFVFS(ctx) {
  const y = ctx.stack[--ctx.stackTop];
  const x = ctx.stack[--ctx.stackTop];
  const len = Math.sqrt(x * x + y * y);
  if (len === 0) {
    ctx.GS.freeVector = { x: 16384, y: 0 };
  } else {
    ctx.GS.freeVector = {
      x: Math.round(x / len * 16384),
      y: Math.round(y / len * 16384)
    };
  }
}
function GPV(ctx) {
  ctx.stack[ctx.stackTop++] = ctx.GS.projVector.x;
  ctx.stack[ctx.stackTop++] = ctx.GS.projVector.y;
}
function GFV(ctx) {
  ctx.stack[ctx.stackTop++] = ctx.GS.freeVector.x;
  ctx.stack[ctx.stackTop++] = ctx.GS.freeVector.y;
}
function SFVTPV(ctx) {
  ctx.GS.freeVector = { ...ctx.GS.projVector };
}
function SRP0(ctx) {
  ctx.GS.rp0 = ctx.stack[--ctx.stackTop];
}
function SRP1(ctx) {
  ctx.GS.rp1 = ctx.stack[--ctx.stackTop];
}
function SRP2(ctx) {
  ctx.GS.rp2 = ctx.stack[--ctx.stackTop];
}
function SZP0(ctx) {
  const zone = ctx.stack[--ctx.stackTop];
  if (zone !== 0 && zone !== 1) {
    ctx.error = `SZP0: invalid zone ${zone}`;
    return;
  }
  ctx.GS.gep0 = zone;
  ctx.zp0 = zone === 0 ? ctx.twilight : ctx.pts;
}
function SZP1(ctx) {
  const zone = ctx.stack[--ctx.stackTop];
  if (zone !== 0 && zone !== 1) {
    ctx.error = `SZP1: invalid zone ${zone}`;
    return;
  }
  ctx.GS.gep1 = zone;
  ctx.zp1 = zone === 0 ? ctx.twilight : ctx.pts;
}
function SZP2(ctx) {
  const zone = ctx.stack[--ctx.stackTop];
  if (zone !== 0 && zone !== 1) {
    ctx.error = `SZP2: invalid zone ${zone}`;
    return;
  }
  ctx.GS.gep2 = zone;
  ctx.zp2 = zone === 0 ? ctx.twilight : ctx.pts;
}
function SZPS(ctx) {
  const zone = ctx.stack[--ctx.stackTop];
  if (zone !== 0 && zone !== 1) {
    ctx.error = `SZPS: invalid zone ${zone}`;
    return;
  }
  ctx.GS.gep0 = zone;
  ctx.GS.gep1 = zone;
  ctx.GS.gep2 = zone;
  const z = zone === 0 ? ctx.twilight : ctx.pts;
  ctx.zp0 = z;
  ctx.zp1 = z;
  ctx.zp2 = z;
}
function SLOOP(ctx) {
  const count = ctx.stack[--ctx.stackTop];
  if (count <= 0) {
    ctx.GS.loop = 0;
    return;
  }
  ctx.GS.loop = count;
}
function SMD(ctx) {
  ctx.GS.minimumDistance = ctx.stack[--ctx.stackTop];
}
function SCVTCI(ctx) {
  ctx.GS.controlValueCutIn = ctx.stack[--ctx.stackTop];
}
function SSWCI(ctx) {
  ctx.GS.singleWidthCutIn = ctx.stack[--ctx.stackTop];
}
function SSW(ctx) {
  const value = ctx.stack[--ctx.stackTop];
  ctx.GS.singleWidthValue = scaleFUnits(value, ctx.scaleFix);
}
function SDB(ctx) {
  ctx.GS.deltaBase = ctx.stack[--ctx.stackTop];
}
function SDS(ctx) {
  ctx.GS.deltaShift = ctx.stack[--ctx.stackTop];
}
function RTG(ctx) {
  ctx.GS.roundState = 1 /* ToGrid */;
}
function RTHG(ctx) {
  ctx.GS.roundState = 0 /* ToHalfGrid */;
}
function RTDG(ctx) {
  ctx.GS.roundState = 2 /* ToDoubleGrid */;
}
function RDTG(ctx) {
  ctx.GS.roundState = 3 /* DownToGrid */;
}
function RUTG(ctx) {
  ctx.GS.roundState = 4 /* UpToGrid */;
}
function ROFF(ctx) {
  ctx.GS.roundState = 5 /* Off */;
}
function SROUND(ctx) {
  const selector = ctx.stack[--ctx.stackTop];
  parseSuperRound(selector, ctx.GS);
  ctx.GS.roundState = 6 /* Super */;
}
function S45ROUND(ctx) {
  const selector = ctx.stack[--ctx.stackTop];
  parseSuperRound(selector, ctx.GS);
  ctx.GS.roundState = 7 /* Super45 */;
}
function FLIPON(ctx) {
  ctx.GS.autoFlip = true;
}
function FLIPOFF(ctx) {
  ctx.GS.autoFlip = false;
}
function SCANCTRL(ctx) {
  ctx.GS.scanControl = ctx.stack[--ctx.stackTop];
}
function SCANTYPE(ctx) {
  ctx.GS.scanType = ctx.stack[--ctx.stackTop];
}
function INSTCTRL(ctx) {
  const selector = ctx.stack[--ctx.stackTop];
  const value = ctx.stack[--ctx.stackTop];
  if (selector === 1 || selector === 2 || selector === 3 && ctx.currentRange === 2 /* CVT */) {
    const flag = 1 << selector - 1;
    if (value) {
      ctx.GS.instructControl |= flag;
    } else {
      ctx.GS.instructControl &= ~flag;
    }
  }
  if (selector === 3 && ctx.currentRange === 3 /* Glyph */ && ctx.lightMode) {
    ctx.backwardCompatibility = value & 4 ^ 4;
  }
}
function GETINFO(ctx) {
  const selector = ctx.stack[--ctx.stackTop];
  let result = 0;
  const mode = ctx.renderMode;
  const isMono = mode === "mono";
  const isLcd = mode === "lcd";
  const isLcdV = mode === "lcd_v";
  const grayscale = ctx.grayscale;
  const subpixelHinting = ctx.lightMode;
  if (selector & 1) {
    result |= 40;
  }
  if (selector & 32 && grayscale) {
    result |= 1 << 12;
  }
  if (subpixelHinting && !isMono) {
    if (selector & 64) {
      result |= 1 << 13;
    }
    if (selector & 256 && isLcdV) {
      result |= 1 << 15;
    }
    if (selector & 1024) {
      result |= 1 << 17;
    }
    if (selector & 2048 && !isMono) {
      result |= 1 << 18;
    }
    if (selector & 4096 && !isLcd && !isLcdV) {
      result |= 1 << 19;
    }
  }
  ctx.stack[ctx.stackTop++] = result;
}
function RS(ctx) {
  const index = ctx.stack[--ctx.stackTop];
  if (index < 0 || index >= ctx.storageSize) {
    ctx.error = `RS: invalid index ${index}`;
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = ctx.storage[index];
}
function WS(ctx) {
  const value = ctx.stack[--ctx.stackTop];
  const index = ctx.stack[--ctx.stackTop];
  if (index < 0 || index >= ctx.storageSize) {
    ctx.error = `WS: invalid index ${index}`;
    return;
  }
  ctx.storage[index] = value;
}
function RCVT(ctx) {
  const index = ctx.stack[--ctx.stackTop];
  if (index < 0 || index >= ctx.cvtSize) {
    ctx.stack[ctx.stackTop++] = 0;
    return;
  }
  ctx.stack[ctx.stackTop++] = ctx.cvt[index];
}
function WCVTP(ctx) {
  const value = ctx.stack[--ctx.stackTop];
  const index = ctx.stack[--ctx.stackTop];
  if (index < 0 || index >= ctx.cvtSize) {
    return;
  }
  ctx.cvt[index] = value;
}
function WCVTF(ctx) {
  const value = ctx.stack[--ctx.stackTop];
  const index = ctx.stack[--ctx.stackTop];
  if (index < 0 || index >= ctx.cvtSize) {
    return;
  }
  ctx.cvt[index] = scaleFUnits(value, ctx.scaleFix);
}
function UTP(ctx) {
  const pointIndex = ctx.stack[--ctx.stackTop];
  const zone = ctx.zp0;
  if (pointIndex < 0 || pointIndex >= zone.nPoints) {
    ctx.error = `UTP: invalid point ${pointIndex}`;
    return;
  }
  const fv = ctx.GS.freeVector;
  if (fv.y !== 0) {
    zone.tags[pointIndex] &= ~32 /* Y */;
  }
  if (fv.x !== 0) {
    zone.tags[pointIndex] &= ~16 /* X */;
  }
}

// reference/text-shaper/src/hinting/instructions/interpolate.ts
function IUP_X(ctx) {
  if (ctx.backwardCompatibility) {
    if (ctx.backwardCompatibility === 7)
      return;
    ctx.backwardCompatibility |= 2;
  }
  interpolateUntouched(ctx, 16 /* X */, true);
}
function IUP_Y(ctx) {
  if (ctx.backwardCompatibility) {
    if (ctx.backwardCompatibility === 7)
      return;
    ctx.backwardCompatibility |= 1;
  }
  interpolateUntouched(ctx, 32 /* Y */, false);
}
function interpolateUntouched(ctx, touchFlag, isX) {
  const zone = ctx.pts;
  const nPoints = zone.nPoints;
  const nContours = zone.nContours;
  if (nPoints === 0 || nContours === 0)
    return;
  let contourStart = 0;
  for (let c = 0;c < nContours; c++) {
    const contourEnd = zone.contours[c];
    let firstTouched = -1;
    for (let i2 = contourStart;i2 <= contourEnd; i2++) {
      if (zone.tags[i2] & touchFlag) {
        firstTouched = i2;
        break;
      }
    }
    if (firstTouched < 0) {
      contourStart = contourEnd + 1;
      continue;
    }
    let prevTouched = firstTouched;
    let i = firstTouched + 1;
    let wrapped = false;
    while (true) {
      if (i > contourEnd) {
        if (wrapped)
          break;
        i = contourStart;
        wrapped = true;
      }
      if (i === firstTouched && wrapped) {
        if (prevTouched !== firstTouched) {
          interpolateRange(zone, prevTouched, firstTouched, contourStart, contourEnd, isX);
        } else {
          shiftContour(zone, contourStart, contourEnd, firstTouched, isX);
        }
        break;
      }
      if (zone.tags[i] & touchFlag) {
        if (prevTouched !== i) {
          interpolateRange(zone, prevTouched, i, contourStart, contourEnd, isX);
        }
        prevTouched = i;
      }
      i++;
    }
    contourStart = contourEnd + 1;
  }
}
function shiftContour(zone, start, end, touched, isX) {
  const orgTouched = isX ? zone.org[touched]?.x : zone.org[touched]?.y;
  const curTouched = isX ? zone.cur[touched]?.x : zone.cur[touched]?.y;
  const delta = curTouched - orgTouched;
  if (delta === 0)
    return;
  for (let i = start;i <= end; i++) {
    if (i === touched)
      continue;
    if (isX) {
      zone.cur[i].x += delta;
    } else {
      zone.cur[i].y += delta;
    }
  }
}
function interpolateRange(zone, p1, p2, contourStart, contourEnd, isX) {
  let ref1 = p1;
  let ref2 = p2;
  let orus1 = isX ? zone.orus[ref1]?.x : zone.orus[ref1]?.y;
  let orus2 = isX ? zone.orus[ref2]?.x : zone.orus[ref2]?.y;
  if (orus1 > orus2) {
    const tmpO = orus1;
    orus1 = orus2;
    orus2 = tmpO;
    const tmpR = ref1;
    ref1 = ref2;
    ref2 = tmpR;
  }
  const org1 = isX ? zone.org[ref1]?.x : zone.org[ref1]?.y;
  const org2 = isX ? zone.org[ref2]?.x : zone.org[ref2]?.y;
  const cur1 = isX ? zone.cur[ref1]?.x : zone.cur[ref1]?.y;
  const cur2 = isX ? zone.cur[ref2]?.x : zone.cur[ref2]?.y;
  const delta1 = cur1 - org1;
  const delta2 = cur2 - org2;
  const useTrivial = cur1 === cur2 || orus1 === orus2;
  const scale = useTrivial ? 0 : divFix(cur2 - cur1, orus2 - orus1);
  let i = p1 + 1;
  if (i > contourEnd)
    i = contourStart;
  while (i !== p2) {
    let org = isX ? zone.org[i]?.x : zone.org[i]?.y;
    let newPos;
    if (org <= org1) {
      newPos = org + delta1;
    } else if (org >= org2) {
      newPos = org + delta2;
    } else if (useTrivial) {
      newPos = cur1;
    } else {
      const orus = isX ? zone.orus[i]?.x : zone.orus[i]?.y;
      newPos = cur1 + mulFix(orus - orus1, scale);
    }
    if (isX) {
      zone.cur[i].x = newPos;
    } else {
      zone.cur[i].y = newPos;
    }
    i++;
    if (i > contourEnd)
      i = contourStart;
  }
}

// reference/text-shaper/src/hinting/instructions/stack.ts
function DUP(ctx) {
  const val = ctx.stack[ctx.stackTop - 1];
  ctx.stack[ctx.stackTop++] = val;
}
function POP(ctx) {
  ctx.stackTop--;
}
function CLEAR(ctx) {
  ctx.stackTop = 0;
}
function SWAP(ctx) {
  const a = ctx.stack[ctx.stackTop - 1];
  const b = ctx.stack[ctx.stackTop - 2];
  ctx.stack[ctx.stackTop - 1] = b;
  ctx.stack[ctx.stackTop - 2] = a;
}
function DEPTH(ctx) {
  const depth = ctx.stackTop;
  ctx.stack[ctx.stackTop++] = depth;
}
function CINDEX(ctx) {
  const index = ctx.stack[--ctx.stackTop];
  if (index <= 0 || index > ctx.stackTop) {
    ctx.error = `CINDEX: invalid index ${index}`;
    return;
  }
  const val = ctx.stack[ctx.stackTop - index];
  ctx.stack[ctx.stackTop++] = val;
}
function MINDEX(ctx) {
  const index = ctx.stack[--ctx.stackTop];
  if (index <= 0 || index > ctx.stackTop) {
    ctx.error = `MINDEX: invalid index ${index}`;
    return;
  }
  const val = ctx.stack[ctx.stackTop - index];
  for (let i = ctx.stackTop - index;i < ctx.stackTop - 1; i++) {
    ctx.stack[i] = ctx.stack[i + 1];
  }
  ctx.stack[ctx.stackTop - 1] = val;
}
function ROLL(ctx) {
  const top = ctx.stack[ctx.stackTop - 1];
  const second = ctx.stack[ctx.stackTop - 2];
  const third = ctx.stack[ctx.stackTop - 3];
  ctx.stack[ctx.stackTop - 3] = second;
  ctx.stack[ctx.stackTop - 2] = top;
  ctx.stack[ctx.stackTop - 1] = third;
}
function PUSHB(ctx, count) {
  for (let i = 0;i < count; i++) {
    ctx.stack[ctx.stackTop++] = ctx.code[ctx.IP++];
  }
}
function PUSHW(ctx, count) {
  for (let i = 0;i < count; i++) {
    const hi = ctx.code[ctx.IP++];
    const lo = ctx.code[ctx.IP++];
    let val = hi << 8 | lo;
    if (val >= 32768)
      val -= 65536;
    ctx.stack[ctx.stackTop++] = val;
  }
}
function NPUSHB(ctx) {
  const n = ctx.code[ctx.IP++];
  PUSHB(ctx, n);
}
function NPUSHW(ctx) {
  const n = ctx.code[ctx.IP++];
  PUSHW(ctx, n);
}

// reference/text-shaper/src/hinting/interpreter.ts
function execute(ctx) {
  while (ctx.IP < ctx.codeSize && ctx.error === null) {
    if (++ctx.instructionCount > ctx.maxInstructions) {
      ctx.error = "Instruction limit exceeded (possible infinite loop)";
      return;
    }
    const opcode = ctx.code[ctx.IP++];
    ctx.opcode = opcode;
    executeOpcode(ctx, opcode);
  }
}
function executeOpcode(ctx, opcode) {
  if (opcode >= 176 && opcode <= 183) {
    PUSHB(ctx, opcode - 176 + 1);
    return;
  }
  if (opcode >= 184 && opcode <= 191) {
    PUSHW(ctx, opcode - 184 + 1);
    return;
  }
  if (opcode >= 192 && opcode <= 223) {
    MDRP(ctx, opcode & 31);
    return;
  }
  if (opcode >= 224 && opcode <= 255) {
    MIRP(ctx, opcode & 31);
    return;
  }
  switch (opcode) {
    case Opcode.SVTCA_Y:
      SVTCA(ctx, 0);
      break;
    case Opcode.SVTCA_X:
      SVTCA(ctx, 1);
      break;
    case Opcode.SPVTCA_Y:
      SPVTCA(ctx, 0);
      break;
    case Opcode.SPVTCA_X:
      SPVTCA(ctx, 1);
      break;
    case Opcode.SFVTCA_Y:
      SFVTCA(ctx, 0);
      break;
    case Opcode.SFVTCA_X:
      SFVTCA(ctx, 1);
      break;
    case Opcode.SPVTL_0:
      SPVTL(ctx, false);
      break;
    case Opcode.SPVTL_1:
      SPVTL(ctx, true);
      break;
    case Opcode.SFVTL_0:
      SFVTL(ctx, false);
      break;
    case Opcode.SFVTL_1:
      SFVTL(ctx, true);
      break;
    case Opcode.SDPVTL_0:
      SDPVTL(ctx, false);
      break;
    case Opcode.SDPVTL_1:
      SDPVTL(ctx, true);
      break;
    case Opcode.SPVFS:
      SPVFS(ctx);
      break;
    case Opcode.SFVFS:
      SFVFS(ctx);
      break;
    case Opcode.GPV:
      GPV(ctx);
      break;
    case Opcode.GFV:
      GFV(ctx);
      break;
    case Opcode.SFVTPV:
      SFVTPV(ctx);
      break;
    case Opcode.ISECT:
      ISECT(ctx);
      break;
    case Opcode.SRP0:
      SRP0(ctx);
      break;
    case Opcode.SRP1:
      SRP1(ctx);
      break;
    case Opcode.SRP2:
      SRP2(ctx);
      break;
    case Opcode.SZP0:
      SZP0(ctx);
      break;
    case Opcode.SZP1:
      SZP1(ctx);
      break;
    case Opcode.SZP2:
      SZP2(ctx);
      break;
    case Opcode.SZPS:
      SZPS(ctx);
      break;
    case Opcode.SLOOP:
      SLOOP(ctx);
      break;
    case Opcode.RTG:
      RTG(ctx);
      break;
    case Opcode.RTHG:
      RTHG(ctx);
      break;
    case Opcode.SMD:
      SMD(ctx);
      break;
    case Opcode.ELSE:
      ELSE(ctx);
      break;
    case Opcode.JMPR:
      JMPR(ctx);
      break;
    case Opcode.SCVTCI:
      SCVTCI(ctx);
      break;
    case Opcode.SSWCI:
      SSWCI(ctx);
      break;
    case Opcode.SSW:
      SSW(ctx);
      break;
    case Opcode.DUP:
      DUP(ctx);
      break;
    case Opcode.POP:
      POP(ctx);
      break;
    case Opcode.CLEAR:
      CLEAR(ctx);
      break;
    case Opcode.SWAP:
      SWAP(ctx);
      break;
    case Opcode.DEPTH:
      DEPTH(ctx);
      break;
    case Opcode.CINDEX:
      CINDEX(ctx);
      break;
    case Opcode.MINDEX:
      MINDEX(ctx);
      break;
    case Opcode.ROLL:
      ROLL(ctx);
      break;
    case Opcode.FDEF:
      FDEF(ctx);
      break;
    case Opcode.ENDF:
      ENDF(ctx);
      break;
    case Opcode.CALL:
      CALL(ctx);
      break;
    case Opcode.LOOPCALL:
      LOOPCALL(ctx);
      break;
    case Opcode.MDAP_0:
      MDAP(ctx, false);
      break;
    case Opcode.MDAP_1:
      MDAP(ctx, true);
      break;
    case Opcode.IUP_Y:
      IUP_Y(ctx);
      break;
    case Opcode.IUP_X:
      IUP_X(ctx);
      break;
    case Opcode.SHP_0:
      SHP(ctx, false);
      break;
    case Opcode.SHP_1:
      SHP(ctx, true);
      break;
    case Opcode.SHC_0:
      SHC(ctx, false);
      break;
    case Opcode.SHC_1:
      SHC(ctx, true);
      break;
    case Opcode.SHZ_0:
      SHZ(ctx, false);
      break;
    case Opcode.SHZ_1:
      SHZ(ctx, true);
      break;
    case Opcode.SHPIX:
      SHPIX(ctx);
      break;
    case Opcode.IP:
      IP(ctx);
      break;
    case Opcode.MSIRP_0:
      MSIRP(ctx, false);
      break;
    case Opcode.MSIRP_1:
      MSIRP(ctx, true);
      break;
    case Opcode.ALIGNRP:
      ALIGNRP(ctx);
      break;
    case Opcode.ALIGNPTS:
      ALIGNPTS(ctx);
      break;
    case Opcode.UTP:
      UTP(ctx);
      break;
    case Opcode.RTDG:
      RTDG(ctx);
      break;
    case Opcode.MIAP_0:
      MIAP(ctx, false);
      break;
    case Opcode.MIAP_1:
      MIAP(ctx, true);
      break;
    case Opcode.NPUSHB:
      NPUSHB(ctx);
      break;
    case Opcode.NPUSHW:
      NPUSHW(ctx);
      break;
    case Opcode.WS:
      WS(ctx);
      break;
    case Opcode.RS:
      RS(ctx);
      break;
    case Opcode.WCVTP:
      WCVTP(ctx);
      break;
    case Opcode.RCVT:
      RCVT(ctx);
      break;
    case Opcode.GC_0:
      GC(ctx, false);
      break;
    case Opcode.GC_1:
      GC(ctx, true);
      break;
    case Opcode.SCFS:
      SCFS(ctx);
      break;
    case Opcode.MD_0:
      MD(ctx, true);
      break;
    case Opcode.MD_1:
      MD(ctx, false);
      break;
    case Opcode.MPPEM:
      MPPEM(ctx);
      break;
    case Opcode.MPS:
      MPS(ctx);
      break;
    case Opcode.FLIPON:
      FLIPON(ctx);
      break;
    case Opcode.FLIPOFF:
      FLIPOFF(ctx);
      break;
    case Opcode.DEBUG:
      break;
    case Opcode.LT:
      LT(ctx);
      break;
    case Opcode.LTEQ:
      LTEQ(ctx);
      break;
    case Opcode.GT:
      GT(ctx);
      break;
    case Opcode.GTEQ:
      GTEQ(ctx);
      break;
    case Opcode.EQ:
      EQ(ctx);
      break;
    case Opcode.NEQ:
      NEQ(ctx);
      break;
    case Opcode.ODD:
      ODD(ctx);
      break;
    case Opcode.EVEN:
      EVEN(ctx);
      break;
    case Opcode.IF:
      IF(ctx);
      break;
    case Opcode.EIF:
      EIF(ctx);
      break;
    case Opcode.AND:
      AND(ctx);
      break;
    case Opcode.OR:
      OR(ctx);
      break;
    case Opcode.NOT:
      NOT(ctx);
      break;
    case Opcode.DELTAP1:
      DELTAP1(ctx);
      break;
    case Opcode.SDB:
      SDB(ctx);
      break;
    case Opcode.SDS:
      SDS(ctx);
      break;
    case Opcode.ADD:
      ADD(ctx);
      break;
    case Opcode.SUB:
      SUB(ctx);
      break;
    case Opcode.DIV:
      DIV(ctx);
      break;
    case Opcode.MUL:
      MUL(ctx);
      break;
    case Opcode.ABS:
      ABS(ctx);
      break;
    case Opcode.NEG:
      NEG(ctx);
      break;
    case Opcode.FLOOR:
      FLOOR(ctx);
      break;
    case Opcode.CEILING:
      CEILING(ctx);
      break;
    case Opcode.ROUND_0:
      ROUND(ctx, 0);
      break;
    case Opcode.ROUND_1:
      ROUND(ctx, 1);
      break;
    case Opcode.ROUND_2:
      ROUND(ctx, 2);
      break;
    case Opcode.ROUND_3:
      ROUND(ctx, 3);
      break;
    case Opcode.NROUND_0:
      NROUND(ctx, 0);
      break;
    case Opcode.NROUND_1:
      NROUND(ctx, 1);
      break;
    case Opcode.NROUND_2:
      NROUND(ctx, 2);
      break;
    case Opcode.NROUND_3:
      NROUND(ctx, 3);
      break;
    case Opcode.WCVTF:
      WCVTF(ctx);
      break;
    case Opcode.DELTAP2:
      DELTAP2(ctx);
      break;
    case Opcode.DELTAP3:
      DELTAP3(ctx);
      break;
    case Opcode.DELTAC1:
      DELTAC1(ctx);
      break;
    case Opcode.DELTAC2:
      DELTAC2(ctx);
      break;
    case Opcode.DELTAC3:
      DELTAC3(ctx);
      break;
    case Opcode.SROUND:
      SROUND(ctx);
      break;
    case Opcode.S45ROUND:
      S45ROUND(ctx);
      break;
    case Opcode.JROT:
      JROT(ctx);
      break;
    case Opcode.JROF:
      JROF(ctx);
      break;
    case Opcode.ROFF:
      ROFF(ctx);
      break;
    case Opcode.RUTG:
      RUTG(ctx);
      break;
    case Opcode.RDTG:
      RDTG(ctx);
      break;
    case Opcode.SANGW:
      ctx.stackTop--;
      break;
    case Opcode.AA:
      ctx.stackTop--;
      break;
    case Opcode.FLIPPT:
      FLIPPT(ctx);
      break;
    case Opcode.FLIPRGON:
      FLIPRGON(ctx);
      break;
    case Opcode.FLIPRGOFF:
      FLIPRGOFF(ctx);
      break;
    case Opcode.SCANCTRL:
      SCANCTRL(ctx);
      break;
    case Opcode.SCANTYPE:
      SCANTYPE(ctx);
      break;
    case Opcode.MAX:
      MAX(ctx);
      break;
    case Opcode.MIN:
      MIN(ctx);
      break;
    case Opcode.GETINFO:
      GETINFO(ctx);
      break;
    case Opcode.IDEF:
      IDEF(ctx);
      break;
    case Opcode.INSTCTRL:
      INSTCTRL(ctx);
      break;
    default:
      if (opcode < ctx.maxIDefs && ctx.IDefs[opcode]?.active) {
        const def = ctx.IDefs[opcode];
        if (ctx.callStackTop >= ctx.maxCallStack) {
          ctx.error = "IDEF call: call stack overflow";
          return;
        }
        const call = ctx.callStack[ctx.callStackTop++];
        call.callerIP = ctx.IP;
        call.callerRange = ctx.currentRange;
        call.def = {
          id: opcode,
          start: def.start,
          end: def.end,
          active: true,
          range: def.range
        };
        call.count = 1;
        ctx.currentRange = def.range;
        const range = ctx.codeRanges.get(ctx.currentRange);
        if (range) {
          ctx.code = range.code;
          ctx.codeSize = range.size;
        }
        ctx.IP = def.start;
      } else {
        ctx.error = `Unknown opcode 0x${opcode.toString(16)}`;
      }
  }
}
function setCodeRange(ctx, range, code) {
  ctx.codeRanges.set(range, { code, size: code.length });
}
function runProgram(ctx, range) {
  const codeRange = ctx.codeRanges.get(range);
  if (!codeRange) {
    return;
  }
  ctx.stackTop = 0;
  ctx.callStackTop = 0;
  ctx.currentRange = range;
  ctx.code = codeRange.code;
  ctx.codeSize = codeRange.size;
  ctx.IP = 0;
  ctx.instructionCount = 0;
  execute(ctx);
}
function runFontProgram(ctx) {
  ctx.backwardCompatibility = 0;
  ctx.twilight.nPoints = ctx.twilight.org.length;
  for (let i = 0;i < ctx.twilight.nPoints; i++) {
    ctx.twilight.org[i].x = 0;
    ctx.twilight.org[i].y = 0;
    ctx.twilight.cur[i].x = 0;
    ctx.twilight.cur[i].y = 0;
    ctx.twilight.tags[i] = 0;
  }
  ctx.zp0 = ctx.twilight;
  ctx.zp1 = ctx.twilight;
  ctx.zp2 = ctx.twilight;
  ctx.GS.gep0 = 0;
  ctx.GS.gep1 = 0;
  ctx.GS.gep2 = 0;
  runProgram(ctx, 1 /* Font */);
}
function runCVTProgram(ctx) {
  ctx.GS = { ...ctx.defaultGS };
  ctx.backwardCompatibility = 0;
  ctx.twilight.nPoints = ctx.twilight.org.length;
  for (let i = 0;i < ctx.twilight.nPoints; i++) {
    ctx.twilight.org[i].x = 0;
    ctx.twilight.org[i].y = 0;
    ctx.twilight.cur[i].x = 0;
    ctx.twilight.cur[i].y = 0;
    ctx.twilight.tags[i] = 0;
  }
  ctx.zp0 = ctx.twilight;
  ctx.zp1 = ctx.twilight;
  ctx.zp2 = ctx.twilight;
  ctx.GS.gep0 = 0;
  ctx.GS.gep1 = 0;
  ctx.GS.gep2 = 0;
  runProgram(ctx, 2 /* CVT */);
  ctx.defaultGS = { ...ctx.GS };
  ctx.defaultGS.projVector = { x: 16384, y: 0 };
  ctx.defaultGS.freeVector = { x: 16384, y: 0 };
  ctx.defaultGS.dualVector = { x: 16384, y: 0 };
  ctx.defaultGS.rp0 = 0;
  ctx.defaultGS.rp1 = 0;
  ctx.defaultGS.rp2 = 0;
  ctx.defaultGS.loop = 1;
  ctx.defaultGS.gep0 = 1;
  ctx.defaultGS.gep1 = 1;
  ctx.defaultGS.gep2 = 1;
}
function runGlyphProgram(ctx, instructions) {
  ctx.GS = { ...ctx.defaultGS };
  ctx.GS.rp0 = 0;
  ctx.GS.rp1 = 0;
  ctx.GS.rp2 = 0;
  ctx.GS.loop = 1;
  ctx.zp0 = ctx.pts;
  ctx.zp1 = ctx.pts;
  ctx.zp2 = ctx.pts;
  ctx.GS.gep0 = 1;
  ctx.GS.gep1 = 1;
  ctx.GS.gep2 = 1;
  setCodeRange(ctx, 3 /* Glyph */, instructions);
  runProgram(ctx, 3 /* Glyph */);
}
// reference/text-shaper/src/hinting/programs.ts
function createHintingEngine(unitsPerEM, maxStack = 256, maxStorage = 64, maxFDefs = 64, maxTwilightPoints = 16, cvtValues) {
  const ctx = createExecContext(maxStack, maxStorage, maxFDefs, maxFDefs, 32, maxTwilightPoints);
  let cvtOriginal;
  if (cvtValues) {
    cvtOriginal = new Int32Array(cvtValues);
    ctx.cvt = new Int32Array(cvtValues);
    ctx.cvtSize = cvtValues.length;
  }
  ctx.twilight.nPoints = maxTwilightPoints;
  ctx.zp0 = ctx.twilight;
  ctx.zp1 = ctx.twilight;
  ctx.zp2 = ctx.twilight;
  return {
    ctx,
    unitsPerEM,
    cvtOriginal,
    fpgmExecuted: false,
    currentPpem: 0
  };
}
function loadFontProgram(engine, fpgm) {
  setCodeRange(engine.ctx, 1 /* Font */, fpgm);
}
function loadCVTProgram(engine, prep) {
  setCodeRange(engine.ctx, 2 /* CVT */, prep);
}
function executeFontProgram(engine) {
  if (engine.fpgmExecuted)
    return null;
  engine.ctx.error = null;
  runFontProgram(engine.ctx);
  engine.fpgmExecuted = true;
  return engine.ctx.error;
}
function setSize(engine, ppem, pointSize) {
  if (!engine.fpgmExecuted) {
    const fpgmError = executeFontProgram(engine);
    if (fpgmError)
      return fpgmError;
  }
  if (engine.currentPpem === ppem)
    return null;
  engine.ctx.scale = ppem * 64 / engine.unitsPerEM;
  engine.ctx.scaleFix = Math.round(engine.ctx.scale * 65536);
  engine.ctx.ppem = ppem;
  engine.ctx.pointSize = pointSize * 64;
  engine.ctx.grayscale = engine.ctx.renderMode !== "mono" && !engine.ctx.lightMode;
  scaleCVT(engine.ctx, engine.cvtOriginal);
  engine.ctx.error = null;
  runCVTProgram(engine.ctx);
  engine.currentPpem = ppem;
  engine.cvtBase = new Int32Array(engine.ctx.cvt);
  return engine.ctx.error;
}
function scaleCVT(ctx, original) {
  if (!original) {
    for (let i = 0;i < ctx.cvtSize; i++) {
      ctx.cvt[i] = scaleFUnits(ctx.cvt[i], ctx.scaleFix);
    }
    return;
  }
  for (let i = 0;i < ctx.cvtSize; i++) {
    ctx.cvt[i] = scaleFUnits(original[i], ctx.scaleFix);
  }
}
function hintGlyph(engine, outline) {
  const ctx = engine.ctx;
  const nPoints = outline.xCoords.length;
  const nContours = outline.contourEnds.length;
  const totalPoints = nPoints + 4;
  const zone = createGlyphZone(totalPoints, nContours);
  zone.nPoints = totalPoints;
  zone.nContours = nContours;
  for (let i = 0;i < nPoints; i++) {
    const x = scaleFUnits(outline.xCoords[i], ctx.scaleFix);
    const y = scaleFUnits(outline.yCoords[i], ctx.scaleFix);
    zone.org[i].x = x;
    zone.org[i].y = y;
    zone.cur[i].x = x;
    zone.cur[i].y = y;
    zone.orus[i].x = outline.xCoords[i];
    zone.orus[i].y = outline.yCoords[i];
    zone.tags[i] = outline.flags[i];
  }
  let xMin = Infinity;
  for (let i = 0;i < nPoints; i++) {
    if (outline.xCoords[i] < xMin)
      xMin = outline.xCoords[i];
  }
  if (!Number.isFinite(xMin))
    xMin = 0;
  const lsb = outline.lsb ?? 0;
  const advW = outline.advanceWidth ?? 0;
  const pp0x = scaleFUnits(xMin - lsb, ctx.scaleFix);
  zone.org[nPoints].x = pp0x;
  zone.org[nPoints].y = 0;
  zone.cur[nPoints].x = pp0x;
  zone.cur[nPoints].y = 0;
  zone.orus[nPoints].x = xMin - lsb;
  zone.orus[nPoints].y = 0;
  zone.tags[nPoints] = 0;
  const pp1x = scaleFUnits(xMin - lsb + advW, ctx.scaleFix);
  zone.org[nPoints + 1].x = pp1x;
  zone.org[nPoints + 1].y = 0;
  zone.cur[nPoints + 1].x = pp1x;
  zone.cur[nPoints + 1].y = 0;
  zone.orus[nPoints + 1].x = xMin - lsb + advW;
  zone.orus[nPoints + 1].y = 0;
  zone.tags[nPoints + 1] = 0;
  for (let i = nPoints + 2;i < totalPoints; i++) {
    zone.org[i].x = 0;
    zone.org[i].y = 0;
    zone.cur[i].x = 0;
    zone.cur[i].y = 0;
    zone.orus[i].x = 0;
    zone.orus[i].y = 0;
    zone.tags[i] = 0;
  }
  zone.cur[nPoints].x = roundToGrid(zone.cur[nPoints].x, 0);
  zone.cur[nPoints + 1].x = roundToGrid(zone.cur[nPoints + 1].x, 0);
  zone.cur[nPoints + 2].y = roundToGrid(zone.cur[nPoints + 2].y, 0);
  zone.cur[nPoints + 3].y = roundToGrid(zone.cur[nPoints + 3].y, 0);
  for (let i = 0;i < nContours; i++) {
    zone.contours[i] = outline.contourEnds[i];
  }
  ctx.pts = zone;
  ctx.zp0 = zone;
  ctx.zp1 = zone;
  ctx.zp2 = zone;
  ctx.twilight.nPoints = ctx.twilight.org.length;
  for (let i = 0;i < ctx.twilight.nPoints; i++) {
    ctx.twilight.org[i].x = 0;
    ctx.twilight.org[i].y = 0;
    ctx.twilight.cur[i].x = 0;
    ctx.twilight.cur[i].y = 0;
    ctx.twilight.tags[i] = 0;
  }
  ctx.isComposite = outline.isComposite ?? false;
  ctx.backwardCompatibility = ctx.lightMode ? 4 : 0;
  if (engine.cvtBase) {
    ctx.cvt.set(engine.cvtBase);
  }
  ctx.error = null;
  if ((ctx.GS.instructControl & 1) !== 0) {} else if (outline.instructions.length > 0) {
    runGlyphProgram(ctx, outline.instructions);
  }
  const xCoords = new Array(nPoints);
  const yCoords = new Array(nPoints);
  for (let i = 0;i < nPoints; i++) {
    xCoords[i] = zone.cur[i]?.x;
    yCoords[i] = zone.cur[i]?.y;
  }
  return {
    xCoords,
    yCoords,
    flags: outline.flags,
    contourEnds: outline.contourEnds,
    error: ctx.error
  };
}
function hintedToPixels(coords) {
  return coords.map((c) => c / 64);
}
// reference/text-shaper/src/types.ts
var Direction;
((Direction2) => {
  Direction2[Direction2["Invalid"] = 0] = "Invalid";
  Direction2[Direction2["LTR"] = 4] = "LTR";
  Direction2[Direction2["RTL"] = 5] = "RTL";
  Direction2[Direction2["TTB"] = 6] = "TTB";
  Direction2[Direction2["BTT"] = 7] = "BTT";
})(Direction ||= {});
var ClusterLevel;
((ClusterLevel2) => {
  ClusterLevel2[ClusterLevel2["MonotoneGraphemes"] = 0] = "MonotoneGraphemes";
  ClusterLevel2[ClusterLevel2["MonotoneCharacters"] = 1] = "MonotoneCharacters";
  ClusterLevel2[ClusterLevel2["Characters"] = 2] = "Characters";
})(ClusterLevel ||= {});
var BufferFlags;
((BufferFlags2) => {
  BufferFlags2[BufferFlags2["Default"] = 0] = "Default";
  BufferFlags2[BufferFlags2["BeginningOfText"] = 1] = "BeginningOfText";
  BufferFlags2[BufferFlags2["EndOfText"] = 2] = "EndOfText";
  BufferFlags2[BufferFlags2["PreserveDefaultIgnorables"] = 4] = "PreserveDefaultIgnorables";
  BufferFlags2[BufferFlags2["RemoveDefaultIgnorables"] = 8] = "RemoveDefaultIgnorables";
  BufferFlags2[BufferFlags2["DoNotInsertDottedCircle"] = 16] = "DoNotInsertDottedCircle";
})(BufferFlags ||= {});
var GlyphClass;
((GlyphClass2) => {
  GlyphClass2[GlyphClass2["Base"] = 1] = "Base";
  GlyphClass2[GlyphClass2["Ligature"] = 2] = "Ligature";
  GlyphClass2[GlyphClass2["Mark"] = 3] = "Mark";
  GlyphClass2[GlyphClass2["Component"] = 4] = "Component";
})(GlyphClass ||= {});
function tag(str) {
  if (str.length !== 4) {
    throw new Error(`Tag must be exactly 4 characters: "${str}"`);
  }
  return str.charCodeAt(0) << 24 | str.charCodeAt(1) << 16 | str.charCodeAt(2) << 8 | str.charCodeAt(3);
}
function tagToString(t) {
  return String.fromCharCode(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255);
}
var Tags = {
  head: tag("head"),
  hhea: tag("hhea"),
  hmtx: tag("hmtx"),
  maxp: tag("maxp"),
  cmap: tag("cmap"),
  loca: tag("loca"),
  glyf: tag("glyf"),
  name: tag("name"),
  OS2: tag("OS/2"),
  post: tag("post"),
  GDEF: tag("GDEF"),
  GSUB: tag("GSUB"),
  GPOS: tag("GPOS"),
  BASE: tag("BASE"),
  JSTF: tag("JSTF"),
  MATH: tag("MATH"),
  CFF: tag("CFF "),
  CFF2: tag("CFF2"),
  fvar: tag("fvar"),
  gvar: tag("gvar"),
  avar: tag("avar"),
  HVAR: tag("HVAR"),
  VVAR: tag("VVAR"),
  MVAR: tag("MVAR"),
  morx: tag("morx"),
  kerx: tag("kerx"),
  kern: tag("kern"),
  trak: tag("trak"),
  feat: tag("feat"),
  COLR: tag("COLR"),
  CPAL: tag("CPAL"),
  SVG: tag("SVG "),
  sbix: tag("sbix"),
  CBDT: tag("CBDT"),
  CBLC: tag("CBLC"),
  STAT: tag("STAT"),
  vhea: tag("vhea"),
  vmtx: tag("vmtx"),
  VORG: tag("VORG"),
  fpgm: tag("fpgm"),
  prep: tag("prep"),
  cvt: tag("cvt "),
  gasp: tag("gasp")
};
var FeatureTags = {
  ccmp: tag("ccmp"),
  locl: tag("locl"),
  rlig: tag("rlig"),
  liga: tag("liga"),
  clig: tag("clig"),
  calt: tag("calt"),
  rclt: tag("rclt"),
  dlig: tag("dlig"),
  smcp: tag("smcp"),
  c2sc: tag("c2sc"),
  isol: tag("isol"),
  init: tag("init"),
  medi: tag("medi"),
  fina: tag("fina"),
  kern: tag("kern"),
  mark: tag("mark"),
  mkmk: tag("mkmk"),
  curs: tag("curs"),
  dist: tag("dist")
};

// reference/text-shaper/src/buffer/glyph-buffer.ts
class GlyphBuffer {
  direction = 4 /* LTR */;
  script = "Zyyy";
  language = null;
  infos = [];
  positions = [];
  _deleted = null;
  _deletedCount = 0;
  _infoPool = [];
  _posPool = [];
  _capacity = 0;
  static withCapacity(capacity) {
    const buffer = new GlyphBuffer;
    buffer._capacity = capacity;
    return buffer;
  }
  get length() {
    return this.infos.length;
  }
  reset() {
    this.infos.length = 0;
    this.positions.length = 0;
    this._deleted = null;
    this._deletedCount = 0;
  }
  initFromCodepoints(codepoints, clusters, getGlyphId) {
    const len = codepoints.length;
    const poolLen = this._infoPool.length;
    if (poolLen < len) {
      const needed = len - poolLen;
      for (let i = 0;i < needed; i++) {
        this._infoPool.push({ glyphId: 0, cluster: 0, mask: 0, codepoint: 0 });
        this._posPool.push({
          xAdvance: 0,
          yAdvance: 0,
          xOffset: 0,
          yOffset: 0
        });
      }
    }
    this.infos.length = len;
    this.positions.length = len;
    for (let i = 0;i < len; i++) {
      const codepoint = codepoints[i];
      const info = this._infoPool[i];
      info.glyphId = getGlyphId(codepoint);
      info.cluster = clusters[i];
      info.mask = 4294967295;
      info.codepoint = codepoint;
      this.infos[i] = info;
      const pos = this._posPool[i];
      pos.xAdvance = 0;
      pos.yAdvance = 0;
      pos.xOffset = 0;
      pos.yOffset = 0;
      this.positions[i] = pos;
    }
    this._deleted = null;
    this._deletedCount = 0;
  }
  initFromCodepointsWithFont(codepoints, clusters, font) {
    const len = codepoints.length;
    const poolLen = this._infoPool.length;
    if (poolLen < len) {
      const needed = len - poolLen;
      for (let i = 0;i < needed; i++) {
        this._infoPool.push({ glyphId: 0, cluster: 0, mask: 0, codepoint: 0 });
        this._posPool.push({
          xAdvance: 0,
          yAdvance: 0,
          xOffset: 0,
          yOffset: 0
        });
      }
    }
    this.infos.length = len;
    this.positions.length = len;
    for (let i = 0;i < len; i++) {
      const codepoint = codepoints[i];
      const info = this._infoPool[i];
      info.glyphId = font.glyphId(codepoint);
      info.cluster = clusters[i];
      info.mask = 4294967295;
      info.codepoint = codepoint;
      this.infos[i] = info;
      const pos = this._posPool[i];
      pos.xAdvance = 0;
      pos.yAdvance = 0;
      pos.xOffset = 0;
      pos.yOffset = 0;
      this.positions[i] = pos;
    }
    this._deleted = null;
    this._deletedCount = 0;
  }
  initFromInfos(infos) {
    this.infos = infos;
    const len = infos.length;
    const positions = new Array(len);
    for (let i = 0;i < len; i++) {
      positions[i] = { xAdvance: 0, yAdvance: 0, xOffset: 0, yOffset: 0 };
    }
    this.positions = positions;
  }
  setAdvance(index, xAdvance, yAdvance = 0) {
    const pos = this.positions[index];
    if (pos) {
      pos.xAdvance = xAdvance;
      pos.yAdvance = yAdvance;
    }
  }
  addOffset(index, xOffset, yOffset) {
    const pos = this.positions[index];
    if (pos) {
      pos.xOffset += xOffset;
      pos.yOffset += yOffset;
    }
  }
  replaceGlyph(index, glyphId) {
    const info = this.infos[index];
    if (info) {
      info.glyphId = glyphId;
    }
  }
  insertGlyph(index, info, position) {
    this.infos.splice(index, 0, info);
    this.positions.splice(index, 0, position);
    if (this._deleted) {
      const newDeleted = new Uint8Array(this.infos.length);
      for (let i = 0;i < index; i++) {
        newDeleted[i] = this._deleted[i];
      }
      newDeleted[index] = 0;
      for (let i = index;i < this._deleted.length; i++) {
        newDeleted[i + 1] = this._deleted[i];
      }
      this._deleted = newDeleted;
    }
  }
  removeRange(start, end) {
    const count = end - start;
    this.infos.splice(start, count);
    this.positions.splice(start, count);
    if (this._deleted && this._deleted.length > this.infos.length) {
      this._deleted = this._deleted.slice(0, this.infos.length);
    }
  }
  markDeleted(index) {
    if (!this._deleted) {
      this._deleted = new Uint8Array(this.infos.length);
    }
    if (!this._deleted[index]) {
      this._deleted[index] = 1;
      this._deletedCount++;
    }
  }
  isDeleted(index) {
    return this._deleted ? this._deleted[index] === 1 : false;
  }
  hasPendingDeletions() {
    return this._deletedCount > 0;
  }
  compact() {
    if (this._deletedCount === 0 || !this._deleted)
      return;
    let writeIdx = 0;
    for (let readIdx = 0;readIdx < this.infos.length; readIdx++) {
      if (!this._deleted[readIdx]) {
        if (writeIdx !== readIdx) {
          this.infos[writeIdx] = this.infos[readIdx];
          this.positions[writeIdx] = this.positions[readIdx];
        }
        writeIdx++;
      }
    }
    this.infos.length = writeIdx;
    this.positions.length = writeIdx;
    this._deleted = null;
    this._deletedCount = 0;
  }
  mergeClusters(start, end) {
    if (start >= end || start < 0 || end >= this.infos.length)
      return;
    const cluster = this.infos[start]?.cluster;
    for (let i = start + 1;i <= end; i++) {
      const info = this.infos[i];
      if (info) {
        info.cluster = cluster;
      }
    }
  }
  reverse() {
    this.infos.reverse();
    this.positions.reverse();
  }
  reverseRange(start, end) {
    let i = start;
    let j = end - 1;
    while (i < j) {
      const tmpInfo = this.infos[i];
      const tmpInfoJ = this.infos[j];
      if (!tmpInfo || !tmpInfoJ)
        break;
      this.infos[i] = tmpInfoJ;
      this.infos[j] = tmpInfo;
      const tmpPos = this.positions[i];
      const tmpPosJ = this.positions[j];
      if (!tmpPos || !tmpPosJ)
        break;
      this.positions[i] = tmpPosJ;
      this.positions[j] = tmpPos;
      i++;
      j--;
    }
  }
  getTotalAdvance() {
    let x = 0;
    let y = 0;
    const positions = this.positions;
    for (let i = 0;i < positions.length; i++) {
      const pos = positions[i];
      x += pos.xAdvance;
      y += pos.yAdvance;
    }
    return { x, y };
  }
  serialize() {
    const parts = [];
    const infos = this.infos;
    const positions = this.positions;
    for (let i = 0;i < infos.length; i++) {
      const info = infos[i];
      const pos = positions[i];
      if (!pos)
        continue;
      let str = `${info.glyphId}`;
      if (i === 0 || info.cluster !== infos[i - 1]?.cluster) {
        str += `=${info.cluster}`;
      }
      if (pos.xOffset !== 0 || pos.yOffset !== 0) {
        str += `@${pos.xOffset},${pos.yOffset}`;
      }
      if (pos.xAdvance !== 0) {
        str += `+${pos.xAdvance}`;
      }
      parts.push(str);
    }
    return `[${parts.join("|")}]`;
  }
  glyphIds() {
    return this.infos.map((info) => info.glyphId);
  }
  clusters() {
    return this.infos.map((info) => info.cluster);
  }
  *[Symbol.iterator]() {
    const infos = this.infos;
    const positions = this.positions;
    for (let i = 0;i < infos.length; i++) {
      const info = infos[i];
      const position = positions[i];
      if (!position)
        continue;
      yield { info, position };
    }
  }
}
// reference/text-shaper/src/buffer/unicode-buffer.ts
class UnicodeBuffer {
  _direction = 4 /* LTR */;
  _script = "Zyyy";
  _language = null;
  _clusterLevel = 0 /* MonotoneGraphemes */;
  _flags = 0 /* Default */;
  codepoints = [];
  clusters = [];
  preContext = [];
  postContext = [];
  addStr(text, startCluster = 0) {
    const len = text.length;
    if (len === 0)
      return this;
    const baseLen = this.codepoints.length;
    if (baseLen > 0) {
      return this._addStrAppend(text, startCluster);
    }
    const codepoints = new Array(len);
    const clusters = new Array(len);
    let cluster = startCluster;
    let writeIdx = 0;
    for (let i = 0;i < len; i++) {
      const code = text.charCodeAt(i);
      if (code >= 55296 && code <= 56319 && i + 1 < len) {
        const low = text.charCodeAt(i + 1);
        if (low >= 56320 && low <= 57343) {
          codepoints[writeIdx] = (code - 55296 << 10) + (low - 56320) + 65536;
          clusters[writeIdx] = cluster;
          writeIdx++;
          cluster++;
          i++;
          continue;
        }
      }
      codepoints[writeIdx] = code;
      clusters[writeIdx] = cluster;
      writeIdx++;
      cluster++;
    }
    if (writeIdx < len) {
      codepoints.length = writeIdx;
      clusters.length = writeIdx;
    }
    this.codepoints = codepoints;
    this.clusters = clusters;
    return this;
  }
  _addStrAppend(text, startCluster) {
    let cluster = startCluster;
    const len = text.length;
    for (let i = 0;i < len; i++) {
      const code = text.charCodeAt(i);
      if (code >= 55296 && code <= 56319 && i + 1 < len) {
        const low = text.charCodeAt(i + 1);
        if (low >= 56320 && low <= 57343) {
          this.codepoints.push((code - 55296 << 10) + (low - 56320) + 65536);
          this.clusters.push(cluster);
          cluster++;
          i++;
          continue;
        }
      }
      this.codepoints.push(code);
      this.clusters.push(cluster);
      cluster++;
    }
    return this;
  }
  addCodepoints(codepoints, startCluster = 0) {
    let cluster = startCluster;
    for (let i = 0;i < codepoints.length; i++) {
      const cp = codepoints[i];
      this.codepoints.push(cp);
      this.clusters.push(cluster);
      cluster++;
    }
    return this;
  }
  addCodepoint(codepoint, cluster) {
    this.codepoints.push(codepoint);
    this.clusters.push(cluster ?? this.codepoints.length - 1);
    return this;
  }
  setDirection(direction) {
    this._direction = direction;
    return this;
  }
  setScript(script) {
    this._script = script;
    return this;
  }
  setLanguage(language) {
    this._language = language;
    return this;
  }
  setClusterLevel(level) {
    this._clusterLevel = level;
    return this;
  }
  setFlags(flags) {
    this._flags = flags;
    return this;
  }
  setPreContext(text) {
    this.preContext = [];
    const len = text.length;
    for (let i = 0;i < len; i++) {
      const code = text.charCodeAt(i);
      if (code >= 55296 && code <= 56319 && i + 1 < len) {
        const low = text.charCodeAt(i + 1);
        if (low >= 56320 && low <= 57343) {
          this.preContext.push((code - 55296 << 10) + (low - 56320) + 65536);
          i++;
          continue;
        }
      }
      this.preContext.push(code);
    }
    return this;
  }
  setPostContext(text) {
    this.postContext = [];
    const len = text.length;
    for (let i = 0;i < len; i++) {
      const code = text.charCodeAt(i);
      if (code >= 55296 && code <= 56319 && i + 1 < len) {
        const low = text.charCodeAt(i + 1);
        if (low >= 56320 && low <= 57343) {
          this.postContext.push((code - 55296 << 10) + (low - 56320) + 65536);
          i++;
          continue;
        }
      }
      this.postContext.push(code);
    }
    return this;
  }
  clear() {
    this.codepoints.length = 0;
    this.clusters.length = 0;
    this.preContext.length = 0;
    this.postContext.length = 0;
    return this;
  }
  get length() {
    return this.codepoints.length;
  }
  get direction() {
    return this._direction;
  }
  get script() {
    return this._script;
  }
  get language() {
    return this._language;
  }
  get clusterLevel() {
    return this._clusterLevel;
  }
  get flags() {
    return this._flags;
  }
  toGlyphInfos() {
    return this.codepoints.map((codepoint, i) => ({
      glyphId: 0,
      cluster: this.clusters[i] ?? 0,
      mask: 0,
      codepoint
    }));
  }
}
// reference/text-shaper/src/font/tables/gvar.ts
var EMBEDDED_PEAK_TUPLE = 32768;
var INTERMEDIATE_REGION = 16384;
var PRIVATE_POINT_NUMBERS = 8192;
var TUPLE_INDEX_MASK = 4095;
function parseGvar(reader, _numGlyphs) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const axisCount = reader.uint16();
  const sharedTupleCount = reader.uint16();
  const sharedTuplesOffset = reader.offset32();
  const glyphCount = reader.uint16();
  const flags = reader.uint16();
  const glyphVariationDataArrayOffset = reader.offset32();
  const offsetSize = flags & 1 ? 4 : 2;
  const offsets = [];
  for (let i = 0;i <= glyphCount; i++) {
    const offset = offsetSize === 4 ? reader.uint32() : reader.uint16() * 2;
    offsets.push(offset);
  }
  const sharedTuples = [];
  if (sharedTupleCount > 0) {
    const tupleReader = reader.sliceFrom(sharedTuplesOffset);
    for (let i = 0;i < sharedTupleCount; i++) {
      const tuple = [];
      for (let a = 0;a < axisCount; a++) {
        tuple.push(tupleReader.f2dot14());
      }
      sharedTuples.push(tuple);
    }
  }
  const glyphVariationData = [];
  for (let g = 0;g < glyphCount; g++) {
    const startOffset = offsets[g];
    const endOffset = offsets[g + 1];
    if (startOffset === undefined || endOffset === undefined) {
      glyphVariationData.push({ tupleVariationHeaders: [] });
      continue;
    }
    const dataStart = glyphVariationDataArrayOffset + startOffset;
    const dataEnd = glyphVariationDataArrayOffset + endOffset;
    if (dataStart === dataEnd) {
      glyphVariationData.push({ tupleVariationHeaders: [] });
      continue;
    }
    const dataReader = reader.sliceFrom(dataStart);
    const variationData = parseGlyphVariationData(dataReader, dataEnd - dataStart, axisCount, sharedTuples);
    glyphVariationData.push(variationData);
  }
  return {
    majorVersion,
    minorVersion,
    axisCount,
    sharedTupleCount,
    sharedTuples,
    glyphVariationData
  };
}
function parseGlyphVariationData(reader, dataLength, axisCount, sharedTuples) {
  if (dataLength === 0) {
    return { tupleVariationHeaders: [] };
  }
  const startOffset = reader.offset;
  const tupleVariationCount = reader.uint16();
  const dataOffset = reader.offset16();
  const tupleCount = tupleVariationCount & 4095;
  const hasSharedPointNumbers = (tupleVariationCount & 32768) !== 0;
  const headerData = [];
  for (let i = 0;i < tupleCount; i++) {
    const variationDataSize = reader.uint16();
    const tupleIndex = reader.uint16();
    let peakTuple = null;
    let intermediateStartTuple = null;
    let intermediateEndTuple = null;
    if (tupleIndex & EMBEDDED_PEAK_TUPLE) {
      peakTuple = [];
      for (let a = 0;a < axisCount; a++) {
        peakTuple.push(reader.f2dot14());
      }
    } else {
      const sharedIndex = tupleIndex & TUPLE_INDEX_MASK;
      peakTuple = sharedTuples[sharedIndex] || null;
    }
    if (tupleIndex & INTERMEDIATE_REGION) {
      intermediateStartTuple = [];
      intermediateEndTuple = [];
      for (let a = 0;a < axisCount; a++) {
        intermediateStartTuple.push(reader.f2dot14());
      }
      for (let a = 0;a < axisCount; a++) {
        intermediateEndTuple.push(reader.f2dot14());
      }
    }
    headerData.push({
      variationDataSize,
      tupleIndex,
      peakTuple,
      intermediateStartTuple,
      intermediateEndTuple
    });
  }
  const dataReader = reader.sliceFrom(startOffset + dataOffset);
  let sharedPoints = null;
  if (hasSharedPointNumbers) {
    sharedPoints = parsePackedPoints(dataReader);
  }
  const headers = [];
  for (let i = 0;i < headerData.length; i++) {
    const hd = headerData[i];
    const hasPrivatePoints = (hd.tupleIndex & PRIVATE_POINT_NUMBERS) !== 0;
    let pointNumbers;
    if (hasPrivatePoints) {
      pointNumbers = parsePackedPoints(dataReader);
    } else {
      pointNumbers = sharedPoints;
    }
    const numPoints = pointNumbers ? pointNumbers.length : 0;
    const xDeltas = numPoints > 0 ? parsePackedDeltas(dataReader, numPoints) : [];
    const yDeltas = numPoints > 0 ? parsePackedDeltas(dataReader, numPoints) : [];
    const deltas = [];
    for (let p = 0;p < xDeltas.length; p++) {
      const xDelta = xDeltas[p];
      const yDelta = yDeltas[p];
      deltas.push({
        x: xDelta ?? 0,
        y: yDelta ?? 0
      });
    }
    headers.push({
      variationDataSize: hd.variationDataSize,
      tupleIndex: hd.tupleIndex,
      peakTuple: hd.peakTuple,
      intermediateStartTuple: hd.intermediateStartTuple,
      intermediateEndTuple: hd.intermediateEndTuple,
      serializedData: new Uint8Array(0),
      pointNumbers,
      deltas
    });
  }
  return { tupleVariationHeaders: headers };
}
function parsePackedPoints(reader) {
  const count = reader.uint8();
  const totalPoints = count === 0 ? 0 : count & 128 ? (count & 127) << 8 | reader.uint8() : count;
  if (totalPoints === 0) {
    return [];
  }
  const points = [];
  let pointIdx = 0;
  while (points.length < totalPoints) {
    const runHeader = reader.uint8();
    const runCount = (runHeader & 127) + 1;
    const pointsAreWords = (runHeader & 128) !== 0;
    for (let i = 0;i < runCount && points.length < totalPoints; i++) {
      const delta = pointsAreWords ? reader.uint16() : reader.uint8();
      pointIdx += delta;
      points.push(pointIdx);
    }
  }
  return points;
}
function parsePackedDeltas(reader, count) {
  const deltas = [];
  while (deltas.length < count) {
    const runHeader = reader.uint8();
    const runCount = (runHeader & 63) + 1;
    const deltasAreZero = (runHeader & 128) !== 0;
    const deltasAreWords = (runHeader & 64) !== 0;
    for (let i = 0;i < runCount && deltas.length < count; i++) {
      if (deltasAreZero) {
        deltas.push(0);
      } else if (deltasAreWords) {
        deltas.push(reader.int16());
      } else {
        deltas.push(reader.int8());
      }
    }
  }
  return deltas;
}
function calculateTupleScalar(peakTuple, axisCoords, intermediateStart, intermediateEnd) {
  let scalar = 1;
  for (let i = 0;i < peakTuple.length; i++) {
    const peak = peakTuple[i];
    const coord = axisCoords[i] ?? 0;
    if (peak === 0 || coord === 0) {
      if (peak !== 0)
        scalar = 0;
      continue;
    }
    if (intermediateStart && intermediateEnd) {
      const start = intermediateStart[i];
      const end = intermediateEnd[i];
      if (start === undefined || end === undefined)
        continue;
      if (coord < start || coord > end) {
        scalar = 0;
        break;
      }
      if (coord < peak) {
        scalar *= (coord - start) / (peak - start);
      } else if (coord > peak) {
        scalar *= (end - coord) / (end - peak);
      }
    } else {
      if (peak > 0 && coord < 0 || peak < 0 && coord > 0) {
        scalar = 0;
        break;
      }
      if (Math.abs(coord) < Math.abs(peak)) {
        scalar *= coord / peak;
      }
    }
  }
  return scalar;
}
function getGlyphDelta(gvar, glyphId, pointIndex, axisCoords) {
  const glyphData = gvar.glyphVariationData[glyphId];
  if (!glyphData)
    return { x: 0, y: 0 };
  let totalX = 0;
  let totalY = 0;
  for (let i = 0;i < glyphData.tupleVariationHeaders.length; i++) {
    const header = glyphData.tupleVariationHeaders[i];
    if (!header.peakTuple)
      continue;
    const scalar = calculateTupleScalar(header.peakTuple, axisCoords, header.intermediateStartTuple, header.intermediateEndTuple);
    if (scalar === 0)
      continue;
    if (header.pointNumbers !== null) {
      const pointIdx = header.pointNumbers.indexOf(pointIndex);
      if (pointIdx < 0)
        continue;
      const delta = header.deltas[pointIdx];
      if (delta) {
        totalX += delta.x * scalar;
        totalY += delta.y * scalar;
      }
    } else {
      const delta = header.deltas[pointIndex];
      if (delta) {
        totalX += delta.x * scalar;
        totalY += delta.y * scalar;
      }
    }
  }
  return { x: Math.round(totalX), y: Math.round(totalY) };
}

// reference/text-shaper/src/font/tables/loca.ts
function parseLoca(reader, numGlyphs, indexToLocFormat) {
  const isShort = indexToLocFormat === 0;
  const offsets = [];
  const count = numGlyphs + 1;
  if (isShort) {
    for (let i = 0;i < count; i++) {
      offsets.push(reader.uint16() * 2);
    }
  } else {
    for (let i = 0;i < count; i++) {
      offsets.push(reader.uint32());
    }
  }
  return { offsets, isShort };
}
function getGlyphLocation(loca, glyphId) {
  if (glyphId < 0 || glyphId >= loca.offsets.length - 1) {
    return null;
  }
  const offset = loca.offsets[glyphId];
  const nextOffset = loca.offsets[glyphId + 1];
  if (offset === undefined || nextOffset === undefined) {
    return null;
  }
  const length = nextOffset - offset;
  if (length === 0) {
    return null;
  }
  return { offset, length };
}
function hasGlyphOutline(loca, glyphId) {
  return getGlyphLocation(loca, glyphId) !== null;
}

// reference/text-shaper/src/font/tables/glyf.ts
var PointFlag = {
  OnCurve: 1,
  XShortVector: 2,
  YShortVector: 4,
  Repeat: 8,
  XIsSameOrPositive: 16,
  YIsSameOrPositive: 32,
  OverlapSimple: 64
};
var CompositeFlag = {
  Arg1And2AreWords: 1,
  ArgsAreXYValues: 2,
  RoundXYToGrid: 4,
  WeHaveAScale: 8,
  MoreComponents: 32,
  WeHaveAnXAndYScale: 64,
  WeHaveATwoByTwo: 128,
  WeHaveInstructions: 256,
  UseMyMetrics: 512,
  OverlapCompound: 1024,
  ScaledComponentOffset: 2048,
  UnscaledComponentOffset: 4096
};
function parseGlyf(reader) {
  return { reader };
}
function parseGlyph(glyf, loca, glyphId) {
  const location = getGlyphLocation(loca, glyphId);
  if (!location) {
    return { type: "empty" };
  }
  const reader = glyf.reader.slice(location.offset, location.length);
  return parseGlyphData(reader);
}
function parseGlyphData(reader) {
  const numberOfContours = reader.int16();
  const xMin = reader.int16();
  const yMin = reader.int16();
  const xMax = reader.int16();
  const yMax = reader.int16();
  if (numberOfContours >= 0) {
    return parseSimpleGlyph(reader, numberOfContours, xMin, yMin, xMax, yMax);
  } else {
    return parseCompositeGlyph(reader, numberOfContours, xMin, yMin, xMax, yMax);
  }
}
function parseSimpleGlyph(reader, numberOfContours, xMin, yMin, xMax, yMax) {
  if (numberOfContours === 0) {
    return {
      type: "simple",
      numberOfContours,
      xMin,
      yMin,
      xMax,
      yMax,
      contours: [],
      instructions: new Uint8Array(0)
    };
  }
  const endPtsOfContours = [];
  for (let i = 0;i < numberOfContours; i++) {
    endPtsOfContours.push(reader.uint16());
  }
  const lastEndPt = endPtsOfContours[numberOfContours - 1];
  if (lastEndPt === undefined) {
    return {
      type: "simple",
      numberOfContours,
      xMin,
      yMin,
      xMax,
      yMax,
      contours: [],
      instructions: new Uint8Array(0)
    };
  }
  const numPoints = lastEndPt + 1;
  const instructionLength = reader.uint16();
  const instructions = reader.bytes(instructionLength);
  const flags = [];
  while (flags.length < numPoints) {
    const flag = reader.uint8();
    flags.push(flag);
    if (flag & PointFlag.Repeat) {
      const repeatCount = reader.uint8();
      for (let i = 0;i < repeatCount; i++) {
        flags.push(flag);
      }
    }
  }
  const xCoordinates = [];
  let x = 0;
  for (let i = 0;i < flags.length; i++) {
    const flag = flags[i];
    if (flag & PointFlag.XShortVector) {
      const dx = reader.uint8();
      x += flag & PointFlag.XIsSameOrPositive ? dx : -dx;
    } else if (!(flag & PointFlag.XIsSameOrPositive)) {
      x += reader.int16();
    }
    xCoordinates.push(x);
  }
  const yCoordinates = [];
  let y = 0;
  for (let i = 0;i < flags.length; i++) {
    const flag = flags[i];
    if (flag & PointFlag.YShortVector) {
      const dy = reader.uint8();
      y += flag & PointFlag.YIsSameOrPositive ? dy : -dy;
    } else if (!(flag & PointFlag.YIsSameOrPositive)) {
      y += reader.int16();
    }
    yCoordinates.push(y);
  }
  const contours = [];
  let pointIndex = 0;
  for (let i = 0;i < endPtsOfContours.length; i++) {
    const endPt = endPtsOfContours[i];
    const contour = [];
    while (pointIndex <= endPt) {
      const xCoord = xCoordinates[pointIndex];
      const yCoord = yCoordinates[pointIndex];
      const flag = flags[pointIndex];
      if (xCoord === undefined || yCoord === undefined || flag === undefined) {
        break;
      }
      contour.push({
        x: xCoord,
        y: yCoord,
        onCurve: (flag & PointFlag.OnCurve) !== 0
      });
      pointIndex++;
    }
    contours.push(contour);
  }
  return {
    type: "simple",
    numberOfContours,
    xMin,
    yMin,
    xMax,
    yMax,
    contours,
    instructions
  };
}
function parseCompositeGlyph(reader, numberOfContours, xMin, yMin, xMax, yMax) {
  const components = [];
  let flags;
  do {
    flags = reader.uint16();
    const glyphIndex = reader.uint16();
    let arg1;
    let arg2;
    if (flags & CompositeFlag.Arg1And2AreWords) {
      if (flags & CompositeFlag.ArgsAreXYValues) {
        arg1 = reader.int16();
        arg2 = reader.int16();
      } else {
        arg1 = reader.uint16();
        arg2 = reader.uint16();
      }
    } else {
      if (flags & CompositeFlag.ArgsAreXYValues) {
        arg1 = reader.int8();
        arg2 = reader.int8();
      } else {
        arg1 = reader.uint8();
        arg2 = reader.uint8();
      }
    }
    let a = 1, b = 0, c = 0, d = 1;
    if (flags & CompositeFlag.WeHaveAScale) {
      a = d = reader.f2dot14();
    } else if (flags & CompositeFlag.WeHaveAnXAndYScale) {
      a = reader.f2dot14();
      d = reader.f2dot14();
    } else if (flags & CompositeFlag.WeHaveATwoByTwo) {
      a = reader.f2dot14();
      b = reader.f2dot14();
      c = reader.f2dot14();
      d = reader.f2dot14();
    }
    components.push({
      glyphId: glyphIndex,
      flags,
      arg1,
      arg2,
      transform: [a, b, c, d]
    });
  } while (flags & CompositeFlag.MoreComponents);
  let instructions = new Uint8Array(0);
  if (flags & CompositeFlag.WeHaveInstructions) {
    const instructionLength = reader.uint16();
    instructions = reader.bytes(instructionLength);
  }
  return {
    type: "composite",
    numberOfContours,
    xMin,
    yMin,
    xMax,
    yMax,
    components,
    instructions
  };
}
function shouldScaleComponentOffset(flags, a, b, c, d) {
  if (flags & CompositeFlag.UnscaledComponentOffset)
    return false;
  if (flags & CompositeFlag.ScaledComponentOffset)
    return true;
  return a !== 1 || b !== 0 || c !== 0 || d !== 1;
}
function flattenContoursPoints(contours) {
  const points = [];
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    for (let j = 0;j < contour.length; j++) {
      points.push(contour[j]);
    }
  }
  return points;
}
function transformContour(contour, a, b, c, d, dx, dy) {
  const transformed = new Array(contour.length);
  for (let i = 0;i < contour.length; i++) {
    const point = contour[i];
    const x = Math.round(a * point.x + c * point.y + dx);
    const y = Math.round(b * point.x + d * point.y + dy);
    const transformedPoint = { x, y, onCurve: point.onCurve };
    if (point.cubic)
      transformedPoint.cubic = true;
    transformed[i] = transformedPoint;
  }
  return transformed;
}
function appendComponentContours(result, parentPoints, component, componentContours) {
  const [a, b, c, d] = component.transform;
  const hasXY = (component.flags & CompositeFlag.ArgsAreXYValues) !== 0;
  const componentPoints = flattenContoursPoints(componentContours);
  let dx = 0;
  let dy = 0;
  if (hasXY) {
    dx = component.arg1;
    dy = component.arg2;
    if (shouldScaleComponentOffset(component.flags, a, b, c, d)) {
      const scaledX = a * dx + c * dy;
      const scaledY = b * dx + d * dy;
      dx = scaledX;
      dy = scaledY;
    }
    if (component.flags & CompositeFlag.RoundXYToGrid) {
      dx = Math.round(dx);
      dy = Math.round(dy);
    }
  } else {
    const parentIndex = component.arg1;
    const compIndex = component.arg2;
    if (parentIndex >= 0 && parentIndex < parentPoints.length && compIndex >= 0 && compIndex < componentPoints.length) {
      const parentPoint = parentPoints[parentIndex];
      const compPoint = componentPoints[compIndex];
      const compX = a * compPoint.x + c * compPoint.y;
      const compY = b * compPoint.x + d * compPoint.y;
      dx = parentPoint.x - compX;
      dy = parentPoint.y - compY;
    }
  }
  for (let i = 0;i < componentContours.length; i++) {
    const contour = componentContours[i];
    const transformedContour = transformContour(contour, a, b, c, d, dx, dy);
    result.push(transformedContour);
    for (let j = 0;j < transformedContour.length; j++) {
      parentPoints.push(transformedContour[j]);
    }
  }
}
function flattenCompositeGlyph(glyf, loca, glyph, depth = 0) {
  if (depth > 32) {
    return [];
  }
  const result = [];
  const parentPoints = [];
  for (let i = 0;i < glyph.components.length; i++) {
    const component = glyph.components[i];
    const componentGlyph = parseGlyph(glyf, loca, component.glyphId);
    let componentContours;
    if (componentGlyph.type === "simple") {
      componentContours = componentGlyph.contours;
    } else if (componentGlyph.type === "composite") {
      componentContours = flattenCompositeGlyph(glyf, loca, componentGlyph, depth + 1);
    } else {
      continue;
    }
    appendComponentContours(result, parentPoints, component, componentContours);
  }
  return result;
}
var compositeCache = new WeakMap;
var COMPOSITE_CACHE_SIZE = 256;
function getCompositeCache(glyf) {
  let cache = compositeCache.get(glyf);
  if (!cache) {
    cache = new Map;
    compositeCache.set(glyf, cache);
  }
  return cache;
}
function getGlyphContours(glyf, loca, glyphId) {
  const glyph = parseGlyph(glyf, loca, glyphId);
  if (glyph.type === "empty") {
    return [];
  } else if (glyph.type === "simple") {
    return glyph.contours;
  } else {
    const cache = getCompositeCache(glyf);
    const cached = cache.get(glyphId);
    if (cached)
      return cached;
    const result = flattenCompositeGlyph(glyf, loca, glyph);
    if (cache.size >= COMPOSITE_CACHE_SIZE) {
      const firstKey = cache.keys().next().value;
      if (firstKey !== undefined)
        cache.delete(firstKey);
    }
    cache.set(glyphId, result);
    return result;
  }
}
function getGlyphContoursAndBounds(glyf, loca, glyphId) {
  const glyph = parseGlyph(glyf, loca, glyphId);
  if (glyph.type === "empty") {
    return { contours: [], bounds: null };
  }
  const bounds = {
    xMin: glyph.xMin,
    yMin: glyph.yMin,
    xMax: glyph.xMax,
    yMax: glyph.yMax
  };
  if (glyph.type === "simple") {
    return { contours: glyph.contours, bounds };
  }
  const cache = getCompositeCache(glyf);
  let contours = cache.get(glyphId);
  if (!contours) {
    contours = flattenCompositeGlyph(glyf, loca, glyph);
    if (cache.size >= COMPOSITE_CACHE_SIZE) {
      const firstKey = cache.keys().next().value;
      if (firstKey !== undefined)
        cache.delete(firstKey);
    }
    cache.set(glyphId, contours);
  }
  if (contours.length === 0) {
    return { contours, bounds: null };
  }
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    for (let j = 0;j < contour.length; j++) {
      const point = contour[j];
      xMin = Math.min(xMin, point.x);
      yMin = Math.min(yMin, point.y);
      xMax = Math.max(xMax, point.x);
      yMax = Math.max(yMax, point.y);
    }
  }
  const compositeBounds = xMin === Infinity ? null : { xMin, yMin, xMax, yMax };
  return { contours, bounds: compositeBounds };
}
function getGlyphBounds(glyf, loca, glyphId) {
  const glyph = parseGlyph(glyf, loca, glyphId);
  if (glyph.type === "empty") {
    return null;
  }
  return {
    xMin: glyph.xMin,
    yMin: glyph.yMin,
    xMax: glyph.xMax,
    yMax: glyph.yMax
  };
}
function getGlyphDeltas(gvar, glyphId, numPoints, axisCoords) {
  const glyphData = gvar.glyphVariationData[glyphId];
  if (!glyphData) {
    return Array(numPoints).fill({ x: 0, y: 0 });
  }
  const deltas = Array(numPoints).fill(null).map(() => ({ x: 0, y: 0 }));
  for (let i = 0;i < glyphData.tupleVariationHeaders.length; i++) {
    const header = glyphData.tupleVariationHeaders[i];
    if (!header.peakTuple)
      continue;
    const scalar = calculateTupleScalar(header.peakTuple, axisCoords, header.intermediateStartTuple, header.intermediateEndTuple);
    if (scalar === 0)
      continue;
    if (header.pointNumbers !== null) {
      for (let j = 0;j < header.pointNumbers.length; j++) {
        const pointIndex = header.pointNumbers[j];
        const delta = deltas[pointIndex];
        const headerDelta = header.deltas[j];
        if (pointIndex < numPoints && delta && headerDelta) {
          delta.x += headerDelta.x * scalar;
          delta.y += headerDelta.y * scalar;
        }
      }
    } else {
      for (let j = 0;j < Math.min(header.deltas.length, numPoints); j++) {
        const delta = deltas[j];
        const headerDelta = header.deltas[j];
        if (delta && headerDelta) {
          delta.x += headerDelta.x * scalar;
          delta.y += headerDelta.y * scalar;
        }
      }
    }
  }
  for (let i = 0;i < deltas.length; i++) {
    const d = deltas[i];
    d.x = Math.round(d.x);
    d.y = Math.round(d.y);
  }
  return deltas;
}
function applyVariationDeltas(contours, deltas) {
  const result = [];
  let pointIndex = 0;
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    const newContour = [];
    for (let j = 0;j < contour.length; j++) {
      const point = contour[j];
      const delta = deltas[pointIndex] ?? { x: 0, y: 0 };
      newContour.push({
        x: point.x + delta.x,
        y: point.y + delta.y,
        onCurve: point.onCurve
      });
      pointIndex++;
    }
    result.push(newContour);
  }
  return result;
}
function getGlyphContoursWithVariation(glyf, loca, gvar, glyphId, axisCoords) {
  const glyph = parseGlyph(glyf, loca, glyphId);
  if (glyph.type === "empty") {
    return [];
  }
  let contours;
  if (glyph.type === "simple") {
    contours = glyph.contours;
  } else {
    contours = flattenCompositeGlyphWithVariation(glyf, loca, gvar, glyph, axisCoords);
  }
  if (gvar && axisCoords && axisCoords.length > 0) {
    let numPoints = 0;
    for (let i = 0;i < contours.length; i++) {
      const c = contours[i];
      numPoints += c.length;
    }
    numPoints += 4;
    const deltas = getGlyphDeltas(gvar, glyphId, numPoints, axisCoords);
    contours = applyVariationDeltas(contours, deltas);
  }
  return contours;
}
function flattenCompositeGlyphWithVariation(glyf, loca, gvar, glyph, axisCoords, depth = 0) {
  if (depth > 32) {
    return [];
  }
  const result = [];
  const parentPoints = [];
  for (let i = 0;i < glyph.components.length; i++) {
    const component = glyph.components[i];
    const componentGlyph = parseGlyph(glyf, loca, component.glyphId);
    let componentContours;
    if (componentGlyph.type === "simple") {
      componentContours = componentGlyph.contours;
      if (gvar && axisCoords && axisCoords.length > 0) {
        let numPoints = 0;
        for (let j = 0;j < componentContours.length; j++) {
          const c = componentContours[j];
          numPoints += c.length;
        }
        numPoints += 4;
        const deltas = getGlyphDeltas(gvar, component.glyphId, numPoints, axisCoords);
        componentContours = applyVariationDeltas(componentContours, deltas);
      }
    } else if (componentGlyph.type === "composite") {
      componentContours = flattenCompositeGlyphWithVariation(glyf, loca, gvar, componentGlyph, axisCoords, depth + 1);
    } else {
      continue;
    }
    appendComponentContours(result, parentPoints, component, componentContours);
  }
  return result;
}

// reference/text-shaper/src/render/outline-transform.ts
function identity2D() {
  return [1, 0, 0, 1, 0, 0];
}
function identity3x3() {
  return [
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]
  ];
}
function translate2D(tx, ty) {
  return [1, 0, 0, 1, tx, ty];
}
function scale2D(sx, sy) {
  return [sx, 0, 0, sy, 0, 0];
}
function rotate2D(angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [cos, sin, -sin, cos, 0, 0];
}
function shear2D(shearX, shearY) {
  return [1, shearY, shearX, 1, 0, 0];
}
function multiply2D(a, b) {
  return [
    a[0] * b[0] + a[2] * b[1],
    a[1] * b[0] + a[3] * b[1],
    a[0] * b[2] + a[2] * b[3],
    a[1] * b[2] + a[3] * b[3],
    a[0] * b[4] + a[2] * b[5] + a[4],
    a[1] * b[4] + a[3] * b[5] + a[5]
  ];
}
function multiply3x3(a, b) {
  const result = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0]
  ];
  for (let i = 0;i < 3; i++) {
    for (let j = 0;j < 3; j++) {
      result[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
    }
  }
  return result;
}
function transformPoint2D(x, y, m) {
  return {
    x: m[0] * x + m[2] * y + m[4],
    y: m[1] * x + m[3] * y + m[5]
  };
}
function transformPoint3x3(x, y, m) {
  const w = m[2][0] * x + m[2][1] * y + m[2][2];
  const minW = 0.01;
  if (w < minW) {
    const clampedW = minW;
    return {
      x: (m[0][0] * x + m[0][1] * y + m[0][2]) / clampedW,
      y: (m[1][0] * x + m[1][1] * y + m[1][2]) / clampedW
    };
  }
  return {
    x: (m[0][0] * x + m[0][1] * y + m[0][2]) / w,
    y: (m[1][0] * x + m[1][1] * y + m[1][2]) / w
  };
}
function rotateOutline90(path, offsetX = 0, offsetY = 0) {
  const commands = path.commands.map((cmd) => {
    switch (cmd.type) {
      case "M":
      case "L":
        return {
          type: cmd.type,
          x: -cmd.y + offsetX,
          y: cmd.x + offsetY
        };
      case "Q":
        return {
          type: "Q",
          x1: -cmd.y1 + offsetX,
          y1: cmd.x1 + offsetY,
          x: -cmd.y + offsetX,
          y: cmd.x + offsetY
        };
      case "C":
        return {
          type: "C",
          x1: -cmd.y1 + offsetX,
          y1: cmd.x1 + offsetY,
          x2: -cmd.y2 + offsetX,
          y2: cmd.x2 + offsetY,
          x: -cmd.y + offsetX,
          y: cmd.x + offsetY
        };
      case "Z":
        return { type: "Z" };
      default:
        return cmd;
    }
  });
  let bounds = null;
  if (path.bounds) {
    const b = path.bounds;
    bounds = {
      xMin: -b.yMax + offsetX,
      yMin: b.xMin + offsetY,
      xMax: -b.yMin + offsetX,
      yMax: b.xMax + offsetY
    };
    if (bounds.xMin > bounds.xMax) {
      [bounds.xMin, bounds.xMax] = [bounds.xMax, bounds.xMin];
    }
    if (bounds.yMin > bounds.yMax) {
      [bounds.yMin, bounds.yMax] = [bounds.yMax, bounds.yMin];
    }
  }
  return { commands, bounds, flags: path.flags };
}
function scaleOutlinePow2(path, scaleOrdX, scaleOrdY) {
  const scaleX = scaleOrdX >= 0 ? 1 << scaleOrdX : 1 / (1 << -scaleOrdX);
  const scaleY = scaleOrdY >= 0 ? 1 << scaleOrdY : 1 / (1 << -scaleOrdY);
  const commands = path.commands.map((cmd) => {
    switch (cmd.type) {
      case "M":
      case "L":
        return {
          type: cmd.type,
          x: cmd.x * scaleX,
          y: cmd.y * scaleY
        };
      case "Q":
        return {
          type: "Q",
          x1: cmd.x1 * scaleX,
          y1: cmd.y1 * scaleY,
          x: cmd.x * scaleX,
          y: cmd.y * scaleY
        };
      case "C":
        return {
          type: "C",
          x1: cmd.x1 * scaleX,
          y1: cmd.y1 * scaleY,
          x2: cmd.x2 * scaleX,
          y2: cmd.y2 * scaleY,
          x: cmd.x * scaleX,
          y: cmd.y * scaleY
        };
      case "Z":
        return { type: "Z" };
      default:
        return cmd;
    }
  });
  let bounds = null;
  if (path.bounds) {
    bounds = {
      xMin: path.bounds.xMin * scaleX,
      yMin: path.bounds.yMin * scaleY,
      xMax: path.bounds.xMax * scaleX,
      yMax: path.bounds.yMax * scaleY
    };
  }
  return { commands, bounds, flags: path.flags };
}
function transformOutline2D(path, m) {
  const commands = path.commands.map((cmd) => {
    switch (cmd.type) {
      case "M":
      case "L": {
        const p = transformPoint2D(cmd.x, cmd.y, m);
        return { type: cmd.type, x: p.x, y: p.y };
      }
      case "Q": {
        const p1 = transformPoint2D(cmd.x1, cmd.y1, m);
        const p = transformPoint2D(cmd.x, cmd.y, m);
        return { type: "Q", x1: p1.x, y1: p1.y, x: p.x, y: p.y };
      }
      case "C": {
        const cp1 = transformPoint2D(cmd.x1, cmd.y1, m);
        const cp2 = transformPoint2D(cmd.x2, cmd.y2, m);
        const p = transformPoint2D(cmd.x, cmd.y, m);
        return {
          type: "C",
          x1: cp1.x,
          y1: cp1.y,
          x2: cp2.x,
          y2: cp2.y,
          x: p.x,
          y: p.y
        };
      }
      case "Z":
        return { type: "Z" };
      default:
        return cmd;
    }
  });
  let bounds = null;
  if (path.bounds) {
    const b = path.bounds;
    const corners = [
      transformPoint2D(b.xMin, b.yMin, m),
      transformPoint2D(b.xMax, b.yMin, m),
      transformPoint2D(b.xMin, b.yMax, m),
      transformPoint2D(b.xMax, b.yMax, m)
    ];
    bounds = {
      xMin: Math.min(...corners.map((c) => c.x)),
      yMin: Math.min(...corners.map((c) => c.y)),
      xMax: Math.max(...corners.map((c) => c.x)),
      yMax: Math.max(...corners.map((c) => c.y))
    };
  }
  return { commands, bounds, flags: path.flags };
}
function transformOutline3D(path, m) {
  const commands = path.commands.map((cmd) => {
    switch (cmd.type) {
      case "M":
      case "L": {
        const p = transformPoint3x3(cmd.x, cmd.y, m);
        return { type: cmd.type, x: p.x, y: p.y };
      }
      case "Q": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1, m);
        const p = transformPoint3x3(cmd.x, cmd.y, m);
        return { type: "Q", x1: p1.x, y1: p1.y, x: p.x, y: p.y };
      }
      case "C": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1, m);
        const p2 = transformPoint3x3(cmd.x2, cmd.y2, m);
        const p = transformPoint3x3(cmd.x, cmd.y, m);
        return {
          type: "C",
          x1: p1.x,
          y1: p1.y,
          x2: p2.x,
          y2: p2.y,
          x: p.x,
          y: p.y
        };
      }
      case "Z":
        return { type: "Z" };
      default:
        return cmd;
    }
  });
  let bounds = null;
  if (path.bounds) {
    const b = path.bounds;
    const corners = [
      transformPoint3x3(b.xMin, b.yMin, m),
      transformPoint3x3(b.xMax, b.yMin, m),
      transformPoint3x3(b.xMin, b.yMax, m),
      transformPoint3x3(b.xMax, b.yMax, m)
    ];
    bounds = {
      xMin: Math.min(...corners.map((c) => c.x)),
      yMin: Math.min(...corners.map((c) => c.y)),
      xMax: Math.max(...corners.map((c) => c.x)),
      yMax: Math.max(...corners.map((c) => c.y))
    };
  }
  return { commands, bounds, flags: path.flags };
}
function computeControlBox(path) {
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
      case "L":
        xMin = Math.min(xMin, cmd.x);
        yMin = Math.min(yMin, cmd.y);
        xMax = Math.max(xMax, cmd.x);
        yMax = Math.max(yMax, cmd.y);
        break;
      case "Q":
        xMin = Math.min(xMin, cmd.x1, cmd.x);
        yMin = Math.min(yMin, cmd.y1, cmd.y);
        xMax = Math.max(xMax, cmd.x1, cmd.x);
        yMax = Math.max(yMax, cmd.y1, cmd.y);
        break;
      case "C":
        xMin = Math.min(xMin, cmd.x1, cmd.x2, cmd.x);
        yMin = Math.min(yMin, cmd.y1, cmd.y2, cmd.y);
        xMax = Math.max(xMax, cmd.x1, cmd.x2, cmd.x);
        yMax = Math.max(yMax, cmd.y1, cmd.y2, cmd.y);
        break;
    }
  }
  if (!Number.isFinite(xMin)) {
    return { xMin: 0, yMin: 0, xMax: 0, yMax: 0 };
  }
  return { xMin, yMin, xMax, yMax };
}
function quadraticExtrema(p0, p1, p2) {
  const denom = p0 - 2 * p1 + p2;
  if (Math.abs(denom) < 0.0000000001)
    return [];
  const t = (p0 - p1) / denom;
  if (t > 0 && t < 1)
    return [t];
  return [];
}
function cubicExtrema(p0, p1, p2, p3) {
  const a = -p0 + 3 * p1 - 3 * p2 + p3;
  const b = 2 * (p0 - 2 * p1 + p2);
  const c = -p0 + p1;
  const result = [];
  if (Math.abs(a) < 0.0000000001) {
    if (Math.abs(b) > 0.0000000001) {
      const t = -c / b;
      if (t > 0 && t < 1)
        result.push(t);
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (disc >= 0) {
      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b + sqrtDisc) / (2 * a);
      const t2 = (-b - sqrtDisc) / (2 * a);
      if (t1 > 0 && t1 < 1)
        result.push(t1);
      if (t2 > 0 && t2 < 1)
        result.push(t2);
    }
  }
  return result;
}
function evalQuadratic(p0, p1, p2, t) {
  const ti = 1 - t;
  return ti * ti * p0 + 2 * ti * t * p1 + t * t * p2;
}
function evalCubic(p0, p1, p2, p3, t) {
  const ti = 1 - t;
  return ti * ti * ti * p0 + 3 * ti * ti * t * p1 + 3 * ti * t * t * p2 + t * t * t * p3;
}
function computeTightBounds(path) {
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  let curX = 0;
  let curY = 0;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        curX = cmd.x;
        curY = cmd.y;
        xMin = Math.min(xMin, curX);
        yMin = Math.min(yMin, curY);
        xMax = Math.max(xMax, curX);
        yMax = Math.max(yMax, curY);
        break;
      case "L":
        curX = cmd.x;
        curY = cmd.y;
        xMin = Math.min(xMin, curX);
        yMin = Math.min(yMin, curY);
        xMax = Math.max(xMax, curX);
        yMax = Math.max(yMax, curY);
        break;
      case "Q": {
        xMin = Math.min(xMin, cmd.x);
        yMin = Math.min(yMin, cmd.y);
        xMax = Math.max(xMax, cmd.x);
        yMax = Math.max(yMax, cmd.y);
        const xExtrema = quadraticExtrema(curX, cmd.x1, cmd.x);
        for (let j = 0;j < xExtrema.length; j++) {
          const t = xExtrema[j];
          const x = evalQuadratic(curX, cmd.x1, cmd.x, t);
          xMin = Math.min(xMin, x);
          xMax = Math.max(xMax, x);
        }
        const yExtrema = quadraticExtrema(curY, cmd.y1, cmd.y);
        for (let j = 0;j < yExtrema.length; j++) {
          const t = yExtrema[j];
          const y = evalQuadratic(curY, cmd.y1, cmd.y, t);
          yMin = Math.min(yMin, y);
          yMax = Math.max(yMax, y);
        }
        curX = cmd.x;
        curY = cmd.y;
        break;
      }
      case "C": {
        xMin = Math.min(xMin, cmd.x);
        yMin = Math.min(yMin, cmd.y);
        xMax = Math.max(xMax, cmd.x);
        yMax = Math.max(yMax, cmd.y);
        const xExtrema = cubicExtrema(curX, cmd.x1, cmd.x2, cmd.x);
        for (let j = 0;j < xExtrema.length; j++) {
          const t = xExtrema[j];
          const x = evalCubic(curX, cmd.x1, cmd.x2, cmd.x, t);
          xMin = Math.min(xMin, x);
          xMax = Math.max(xMax, x);
        }
        const yExtrema = cubicExtrema(curY, cmd.y1, cmd.y2, cmd.y);
        for (let j = 0;j < yExtrema.length; j++) {
          const t = yExtrema[j];
          const y = evalCubic(curY, cmd.y1, cmd.y2, cmd.y, t);
          yMin = Math.min(yMin, y);
          yMax = Math.max(yMax, y);
        }
        curX = cmd.x;
        curY = cmd.y;
        break;
      }
    }
  }
  if (!Number.isFinite(xMin)) {
    return { xMin: 0, yMin: 0, xMax: 0, yMax: 0 };
  }
  return { xMin, yMin, xMax, yMax };
}
function updateMinTransformedX(path, m, currentMinX) {
  let minX = currentMinX;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
      case "L": {
        const p = transformPoint3x3(cmd.x, cmd.y, m);
        minX = Math.min(minX, p.x);
        break;
      }
      case "Q": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1, m);
        const p = transformPoint3x3(cmd.x, cmd.y, m);
        minX = Math.min(minX, p1.x, p.x);
        break;
      }
      case "C": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1, m);
        const p2 = transformPoint3x3(cmd.x2, cmd.y2, m);
        const p = transformPoint3x3(cmd.x, cmd.y, m);
        minX = Math.min(minX, p1.x, p2.x, p.x);
        break;
      }
    }
  }
  return minX;
}
function translateOutline(path, dx, dy) {
  return transformOutline2D(path, translate2D(dx, dy));
}
function scaleOutline(path, sx, sy = sx) {
  return transformOutline2D(path, scale2D(sx, sy));
}
function rotateOutline(path, angle) {
  return transformOutline2D(path, rotate2D(angle));
}
function italicizeOutline(path, angle) {
  const shearX = Math.tan(angle * Math.PI / 180);
  return transformOutline2D(path, shear2D(shearX, 0));
}
function perspectiveMatrix(vanishingPointX, vanishingPointY, strength) {
  return [
    [1, 0, -vanishingPointX * strength],
    [0, 1, -vanishingPointY * strength],
    [0, 0, 1]
  ];
}
function combinePaths(paths) {
  const commands = [];
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  for (let i = 0;i < paths.length; i++) {
    const path = paths[i];
    commands.push(...path.commands);
    if (path.bounds) {
      xMin = Math.min(xMin, path.bounds.xMin);
      yMin = Math.min(yMin, path.bounds.yMin);
      xMax = Math.max(xMax, path.bounds.xMax);
      yMax = Math.max(yMax, path.bounds.yMax);
    }
  }
  const bounds = Number.isFinite(xMin) ? { xMin, yMin, xMax, yMax } : null;
  return { commands, bounds };
}
function clonePath(path) {
  return {
    commands: path.commands.map((cmd) => ({ ...cmd })),
    bounds: path.bounds ? { ...path.bounds } : null,
    flags: path.flags
  };
}

// reference/text-shaper/src/render/path.ts
function contourToPath(contour) {
  if (contour.length === 0)
    return [];
  for (let i = 0;i < contour.length; i++) {
    const p = contour[i];
    if (!p.onCurve) {
      return p.cubic ? contourToPathCubic(contour) : contourToPathQuadratic(contour);
    }
  }
  return contourToPathQuadratic(contour);
}
function contourToPathCubic(contour) {
  if (contour.length === 0)
    return [];
  const commands = [];
  let i = 0;
  const first = contour[0];
  if (!first)
    return [];
  commands.push({ type: "M", x: first.x, y: first.y });
  i = 1;
  while (i < contour.length) {
    const point = contour[i];
    if (!point)
      break;
    if (point.onCurve) {
      commands.push({ type: "L", x: point.x, y: point.y });
      i++;
    } else if (point.cubic) {
      const cp1 = point;
      const cp2 = contour[i + 1];
      const end = contour[i + 2];
      if (!cp2 || !end) {
        i++;
        continue;
      }
      commands.push({
        type: "C",
        x1: cp1.x,
        y1: cp1.y,
        x2: cp2.x,
        y2: cp2.y,
        x: end.x,
        y: end.y
      });
      i += 3;
    } else {
      const cp = point;
      const next = contour[i + 1];
      if (!next) {
        i++;
        continue;
      }
      let endPoint;
      if (next.onCurve) {
        endPoint = next;
        i += 2;
      } else {
        endPoint = {
          x: (cp.x + next.x) / 2,
          y: (cp.y + next.y) / 2,
          onCurve: true
        };
        i++;
      }
      commands.push({
        type: "Q",
        x1: cp.x,
        y1: cp.y,
        x: endPoint.x,
        y: endPoint.y
      });
    }
  }
  commands.push({ type: "Z" });
  return commands;
}
function contourToPathQuadratic(contour) {
  if (contour.length === 0)
    return [];
  const commands = [];
  let startIndex = 0;
  for (let i2 = 0;i2 < contour.length; i2++) {
    const point = contour[i2];
    if (point.onCurve) {
      startIndex = i2;
      break;
    }
  }
  const allOffCurve = contour.every((p) => !p.onCurve);
  let startPoint;
  if (allOffCurve) {
    const first = contour[0];
    const last = contour[contour.length - 1];
    if (!first || !last)
      return [];
    startPoint = {
      x: (first.x + last.x) / 2,
      y: (first.y + last.y) / 2,
      onCurve: true
    };
    startIndex = 0;
  } else {
    const point = contour[startIndex];
    if (!point)
      return [];
    startPoint = point;
  }
  commands.push({ type: "M", x: startPoint.x, y: startPoint.y });
  const n = contour.length;
  let i = allOffCurve ? 0 : startIndex + 1;
  if (i >= n)
    i = 0;
  let current = startPoint;
  let iterations = 0;
  while (iterations < n) {
    const point = contour[i];
    if (!point)
      break;
    if (point.onCurve) {
      commands.push({ type: "L", x: point.x, y: point.y });
      current = point;
    } else {
      const nextIndex = i + 1 < n ? i + 1 : 0;
      const nextPoint = contour[nextIndex];
      if (!nextPoint)
        break;
      let endPoint;
      if (nextPoint.onCurve) {
        endPoint = nextPoint;
        i = nextIndex;
        iterations++;
      } else {
        endPoint = {
          x: (point.x + nextPoint.x) / 2,
          y: (point.y + nextPoint.y) / 2,
          onCurve: true
        };
      }
      commands.push({
        type: "Q",
        x1: point.x,
        y1: point.y,
        x: endPoint.x,
        y: endPoint.y
      });
      current = endPoint;
    }
    i++;
    if (i >= n)
      i = 0;
    iterations++;
    if (current.x === startPoint.x && current.y === startPoint.y) {
      break;
    }
  }
  commands.push({ type: "Z" });
  return commands;
}
var pathCache = new WeakMap;
function getGlyphPath(font, glyphId) {
  let fontCache = pathCache.get(font);
  if (fontCache) {
    const cached = fontCache.get(glyphId);
    if (cached !== undefined)
      return cached;
  }
  const result = font.getGlyphContoursAndBounds(glyphId);
  if (!result) {
    if (!fontCache) {
      fontCache = new Map;
      pathCache.set(font, fontCache);
    }
    fontCache.set(glyphId, null);
    return null;
  }
  const commands = [];
  for (let i = 0;i < result.contours.length; i++) {
    const contour = result.contours[i];
    commands.push(...contourToPath(contour));
  }
  const path = { commands, bounds: result.bounds };
  if (!fontCache) {
    fontCache = new Map;
    pathCache.set(font, fontCache);
  }
  fontCache.set(glyphId, path);
  return path;
}
var SVG_SCALE = 10;
var svgCache = new WeakMap;
function pathToSVG(path, options) {
  const scale = options?.scale ?? 1;
  const flipY = options?.flipY ?? true;
  if (scale === 1 && flipY) {
    const cached = svgCache.get(path);
    if (cached)
      return cached;
  }
  const s = scale * SVG_SCALE;
  const ys = flipY ? -s : s;
  let result = "";
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    if (i > 0)
      result += " ";
    switch (cmd.type) {
      case "M":
        result += "M " + Math.round(cmd.x * s) + " " + Math.round(cmd.y * ys);
        break;
      case "L":
        result += "L " + Math.round(cmd.x * s) + " " + Math.round(cmd.y * ys);
        break;
      case "Q":
        result += "Q " + Math.round(cmd.x1 * s) + " " + Math.round(cmd.y1 * ys) + " " + Math.round(cmd.x * s) + " " + Math.round(cmd.y * ys);
        break;
      case "C":
        result += "C " + Math.round(cmd.x1 * s) + " " + Math.round(cmd.y1 * ys) + " " + Math.round(cmd.x2 * s) + " " + Math.round(cmd.y2 * ys) + " " + Math.round(cmd.x * s) + " " + Math.round(cmd.y * ys);
        break;
      case "Z":
        result += "Z";
        break;
    }
  }
  if (scale === 1 && flipY) {
    svgCache.set(path, result);
  }
  return result;
}
function pathToCanvas(ctx, path, options) {
  const scale = options?.scale ?? 1;
  const flipY = options?.flipY ?? true;
  const offsetX = options?.offsetX ?? 0;
  const offsetY = options?.offsetY ?? 0;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        ctx.moveTo(cmd.x * scale + offsetX, (flipY ? -cmd.y : cmd.y) * scale + offsetY);
        break;
      case "L":
        ctx.lineTo(cmd.x * scale + offsetX, (flipY ? -cmd.y : cmd.y) * scale + offsetY);
        break;
      case "Q":
        ctx.quadraticCurveTo(cmd.x1 * scale + offsetX, (flipY ? -cmd.y1 : cmd.y1) * scale + offsetY, cmd.x * scale + offsetX, (flipY ? -cmd.y : cmd.y) * scale + offsetY);
        break;
      case "C":
        ctx.bezierCurveTo(cmd.x1 * scale + offsetX, (flipY ? -cmd.y1 : cmd.y1) * scale + offsetY, cmd.x2 * scale + offsetX, (flipY ? -cmd.y2 : cmd.y2) * scale + offsetY, cmd.x * scale + offsetX, (flipY ? -cmd.y : cmd.y) * scale + offsetY);
        break;
      case "Z":
        ctx.closePath();
        break;
    }
  }
}
function glyphToSVG(font, glyphId, options) {
  const path = getGlyphPath(font, glyphId);
  if (!path)
    return null;
  const fontSize = options?.fontSize ?? 100;
  const fill = options?.fill ?? "currentColor";
  const stroke = options?.stroke;
  const strokeWidth = options?.strokeWidth ?? 1;
  const scale = fontSize / font.unitsPerEm;
  const bounds = path.bounds;
  if (!bounds)
    return null;
  const strokePadding = stroke ? strokeWidth / 2 : 0;
  const width = Math.ceil((bounds.xMax - bounds.xMin) * scale + strokePadding * 2);
  const height = Math.ceil((bounds.yMax - bounds.yMin) * scale + strokePadding * 2);
  const vbX = Math.round((bounds.xMin - strokePadding) * SVG_SCALE);
  const vbY = Math.round((-bounds.yMax - strokePadding) * SVG_SCALE);
  const vbW = Math.round((bounds.xMax - bounds.xMin + strokePadding * 2) * SVG_SCALE);
  const vbH = Math.round((bounds.yMax - bounds.yMin + strokePadding * 2) * SVG_SCALE);
  const viewBox = `${vbX} ${vbY} ${vbW} ${vbH}`;
  const pathData = pathToSVG(path, { flipY: true, scale: 1 });
  const strokeAttr = stroke ? ` stroke="${stroke}" stroke-width="${strokeWidth * SVG_SCALE}"` : "";
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${viewBox}">
  <path d="${pathData}" fill="${fill}"${strokeAttr}/>
</svg>`;
}
function renderShapedText(ctx, font, glyphs, options) {
  const fontSize = options?.fontSize ?? 16;
  const startX = options?.x ?? 0;
  const startY = options?.y ?? 0;
  const fill = options?.fill ?? "black";
  const stroke = options?.stroke;
  const strokeWidth = options?.strokeWidth ?? 1;
  const matrix = options?.matrix;
  const matrix3D = options?.matrix3D;
  const scale = fontSize / font.unitsPerEm;
  ctx.fillStyle = fill;
  if (stroke) {
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokeWidth * scale;
    if (options?.lineCap)
      ctx.lineCap = options.lineCap;
    if (options?.lineJoin)
      ctx.lineJoin = options.lineJoin;
  }
  let x = startX;
  let y = startY;
  for (let i = 0;i < glyphs.length; i++) {
    const glyph = glyphs[i];
    const path = getGlyphPath(font, glyph.glyphId);
    if (path) {
      ctx.beginPath();
      if (matrix3D) {
        const posX = x + glyph.xOffset * scale;
        const posY = y - glyph.yOffset * scale;
        const combined = [
          [
            matrix3D[0][0] * scale,
            matrix3D[0][1] * scale,
            matrix3D[0][0] * posX + matrix3D[0][1] * posY + matrix3D[0][2]
          ],
          [
            matrix3D[1][0] * scale,
            matrix3D[1][1] * scale,
            matrix3D[1][0] * posX + matrix3D[1][1] * posY + matrix3D[1][2]
          ],
          [
            matrix3D[2][0] * scale,
            matrix3D[2][1] * scale,
            matrix3D[2][0] * posX + matrix3D[2][1] * posY + matrix3D[2][2]
          ]
        ];
        pathToCanvasWithMatrix3D(ctx, path, combined);
      } else if (matrix) {
        const posX = x + glyph.xOffset * scale;
        const posY = y - glyph.yOffset * scale;
        const combined = [
          matrix[0] * scale,
          matrix[1] * scale,
          matrix[2] * scale,
          matrix[3] * scale,
          matrix[0] * posX + matrix[2] * posY + matrix[4],
          matrix[1] * posX + matrix[3] * posY + matrix[5]
        ];
        pathToCanvasWithMatrix(ctx, path, combined);
      } else {
        pathToCanvas(ctx, path, {
          scale,
          flipY: true,
          offsetX: x + glyph.xOffset * scale,
          offsetY: y - glyph.yOffset * scale
        });
      }
      if (fill !== "none")
        ctx.fill();
      if (stroke)
        ctx.stroke();
    }
    x += glyph.xAdvance * scale;
    y += glyph.yAdvance * scale;
  }
}
function shapedTextToSVG(font, glyphs, options) {
  const fontSize = options?.fontSize ?? 100;
  const fill = options?.fill ?? "currentColor";
  const stroke = options?.stroke;
  const strokeWidth = options?.strokeWidth ?? 1;
  const matrix = options?.matrix;
  const matrix3D = options?.matrix3D;
  const useNativeTransform = options?.useNativeTransform ?? false;
  const scale = fontSize / font.unitsPerEm;
  let pathsStr = "";
  let x = 0;
  let y = 0;
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0;i < glyphs.length; i++) {
    const glyph = glyphs[i];
    const path = getGlyphPath(font, glyph.glyphId);
    if (path?.bounds) {
      const offsetX = x + glyph.xOffset * scale;
      const offsetY = y - glyph.yOffset * scale;
      let pathStr;
      if (matrix3D && !useNativeTransform) {
        const combined = [
          [
            matrix3D[0][0] * scale,
            matrix3D[0][1] * scale,
            matrix3D[0][0] * offsetX + matrix3D[0][1] * offsetY + matrix3D[0][2]
          ],
          [
            matrix3D[1][0] * scale,
            matrix3D[1][1] * scale,
            matrix3D[1][0] * offsetX + matrix3D[1][1] * offsetY + matrix3D[1][2]
          ],
          [
            matrix3D[2][0] * scale,
            matrix3D[2][1] * scale,
            matrix3D[2][0] * offsetX + matrix3D[2][1] * offsetY + matrix3D[2][2]
          ]
        ];
        pathStr = pathToSVGWithMatrix3D(path, combined);
        const b = path.bounds;
        const corners = [
          transformPoint3x3(b.xMin * scale + offsetX, -b.yMax * scale + offsetY, matrix3D),
          transformPoint3x3(b.xMax * scale + offsetX, -b.yMax * scale + offsetY, matrix3D),
          transformPoint3x3(b.xMin * scale + offsetX, -b.yMin * scale + offsetY, matrix3D),
          transformPoint3x3(b.xMax * scale + offsetX, -b.yMin * scale + offsetY, matrix3D)
        ];
        for (let j = 0;j < corners.length; j++) {
          const c = corners[j];
          minX = Math.min(minX, c.x);
          maxX = Math.max(maxX, c.x);
          minY = Math.min(minY, c.y);
          maxY = Math.max(maxY, c.y);
        }
      } else if (matrix && !useNativeTransform) {
        const combined = [
          matrix[0] * scale,
          matrix[1] * scale,
          matrix[2] * scale,
          matrix[3] * scale,
          matrix[0] * offsetX + matrix[2] * offsetY + matrix[4],
          matrix[1] * offsetX + matrix[3] * offsetY + matrix[5]
        ];
        pathStr = pathToSVGWithMatrix(path, combined);
        const b = path.bounds;
        const corners = [
          transformPoint2D(b.xMin * scale + offsetX, -b.yMax * scale + offsetY, matrix),
          transformPoint2D(b.xMax * scale + offsetX, -b.yMax * scale + offsetY, matrix),
          transformPoint2D(b.xMin * scale + offsetX, -b.yMin * scale + offsetY, matrix),
          transformPoint2D(b.xMax * scale + offsetX, -b.yMin * scale + offsetY, matrix)
        ];
        for (let j = 0;j < corners.length; j++) {
          const c = corners[j];
          minX = Math.min(minX, c.x);
          maxX = Math.max(maxX, c.x);
          minY = Math.min(minY, c.y);
          maxY = Math.max(maxY, c.y);
        }
      } else {
        pathStr = pathToSVGDirect(path, scale, offsetX, offsetY);
        const b = path.bounds;
        minX = Math.min(minX, offsetX + b.xMin * scale);
        maxX = Math.max(maxX, offsetX + b.xMax * scale);
        minY = Math.min(minY, offsetY - b.yMax * scale);
        maxY = Math.max(maxY, offsetY - b.yMin * scale);
      }
      if (pathsStr)
        pathsStr += " ";
      pathsStr += pathStr;
    }
    x += glyph.xAdvance * scale;
    y += glyph.yAdvance * scale;
  }
  if (!pathsStr) {
    return '<svg xmlns="http://www.w3.org/2000/svg"></svg>';
  }
  const strokePadding = stroke ? strokeWidth / 2 : 0;
  const width = Math.ceil(maxX - minX + strokePadding * 2);
  const height = Math.ceil(maxY - minY + strokePadding * 2);
  const vbX = Math.floor((minX - strokePadding) * SVG_SCALE);
  const vbY = Math.floor((minY - strokePadding) * SVG_SCALE);
  const vbW = Math.ceil(width * SVG_SCALE);
  const vbH = Math.ceil(height * SVG_SCALE);
  const viewBox = `${vbX} ${vbY} ${vbW} ${vbH}`;
  const strokeAttr = stroke ? ` stroke="${stroke}" stroke-width="${strokeWidth * SVG_SCALE}"${options?.lineCap ? ` stroke-linecap="${options.lineCap}"` : ""}${options?.lineJoin ? ` stroke-linejoin="${options.lineJoin}"` : ""}` : "";
  const transformAttr = useNativeTransform && matrix ? ` transform="${matrixToSVGTransform(matrix)}"` : "";
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${viewBox}">
  <path d="${pathsStr}" fill="${fill}"${strokeAttr}${transformAttr}/>
</svg>`;
}
function glyphBufferToShapedGlyphs(buffer) {
  const result = [];
  for (let i = 0;i < buffer.infos.length; i++) {
    const info = buffer.infos[i];
    const pos = buffer.positions[i];
    if (!pos)
      continue;
    result.push({
      glyphId: info.glyphId,
      xOffset: pos.xOffset,
      yOffset: pos.yOffset,
      xAdvance: pos.xAdvance,
      yAdvance: pos.yAdvance
    });
  }
  return result;
}
function getGlyphPathWithVariation(font, glyphId, axisCoords) {
  const contours = font.getGlyphContoursWithVariation(glyphId, axisCoords);
  if (!contours)
    return null;
  const commands = [];
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    commands.push(...contourToPath(contour));
  }
  const bounds = font.getGlyphBounds(glyphId);
  return { commands, bounds };
}
function renderShapedTextWithVariation(ctx, font, glyphs, axisCoords, options) {
  const fontSize = options?.fontSize ?? 16;
  const startX = options?.x ?? 0;
  const startY = options?.y ?? 0;
  const fill = options?.fill ?? "black";
  const stroke = options?.stroke;
  const strokeWidth = options?.strokeWidth ?? 1;
  const scale = fontSize / font.unitsPerEm;
  ctx.fillStyle = fill;
  if (stroke) {
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokeWidth * scale;
    if (options?.lineCap)
      ctx.lineCap = options.lineCap;
    if (options?.lineJoin)
      ctx.lineJoin = options.lineJoin;
  }
  let x = startX;
  let y = startY;
  for (let i = 0;i < glyphs.length; i++) {
    const glyph = glyphs[i];
    const path = getGlyphPathWithVariation(font, glyph.glyphId, axisCoords);
    if (path) {
      ctx.beginPath();
      pathToCanvas(ctx, path, {
        scale,
        flipY: true,
        offsetX: x + glyph.xOffset * scale,
        offsetY: y - glyph.yOffset * scale
      });
      if (fill !== "none")
        ctx.fill();
      if (stroke)
        ctx.stroke();
    }
    x += glyph.xAdvance * scale;
    y += glyph.yAdvance * scale;
  }
}
function shapedTextToSVGWithVariation(font, glyphs, axisCoords, options) {
  const fontSize = options?.fontSize ?? 100;
  const fill = options?.fill ?? "currentColor";
  const stroke = options?.stroke;
  const strokeWidth = options?.strokeWidth ?? 1;
  const scale = fontSize / font.unitsPerEm;
  let pathsStr = "";
  let x = 0;
  let y = 0;
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0;i < glyphs.length; i++) {
    const glyph = glyphs[i];
    const path = getGlyphPathWithVariation(font, glyph.glyphId, axisCoords);
    if (path?.bounds) {
      const offsetX = x + glyph.xOffset * scale;
      const offsetY = y - glyph.yOffset * scale;
      const pathStr = pathToSVGDirect(path, scale, offsetX, offsetY);
      if (pathsStr)
        pathsStr += " ";
      pathsStr += pathStr;
      const b = path.bounds;
      minX = Math.min(minX, offsetX + b.xMin * scale);
      maxX = Math.max(maxX, offsetX + b.xMax * scale);
      minY = Math.min(minY, offsetY - b.yMax * scale);
      maxY = Math.max(maxY, offsetY - b.yMin * scale);
    }
    x += glyph.xAdvance * scale;
    y += glyph.yAdvance * scale;
  }
  if (!pathsStr) {
    return '<svg xmlns="http://www.w3.org/2000/svg"></svg>';
  }
  const strokePadding = stroke ? strokeWidth / 2 : 0;
  const width = Math.ceil(maxX - minX + strokePadding * 2);
  const height = Math.ceil(maxY - minY + strokePadding * 2);
  const vbX = Math.floor((minX - strokePadding) * SVG_SCALE);
  const vbY = Math.floor((minY - strokePadding) * SVG_SCALE);
  const vbW = Math.ceil(width * SVG_SCALE);
  const vbH = Math.ceil(height * SVG_SCALE);
  const viewBox = `${vbX} ${vbY} ${vbW} ${vbH}`;
  const strokeAttr = stroke ? ` stroke="${stroke}" stroke-width="${strokeWidth * SVG_SCALE}"${options?.lineCap ? ` stroke-linecap="${options.lineCap}"` : ""}${options?.lineJoin ? ` stroke-linejoin="${options.lineJoin}"` : ""}` : "";
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${viewBox}">
  <path d="${pathsStr}" fill="${fill}"${strokeAttr}/>
</svg>`;
}
function getTextWidth(glyphs, font, fontSize) {
  const scale = fontSize / font.unitsPerEm;
  let width = 0;
  for (let i = 0;i < glyphs.length; i++) {
    const glyph = glyphs[i];
    width += glyph.xAdvance;
  }
  return width * scale;
}
function createPath2D(path, options) {
  const p = new Path2D;
  pathToCanvas(p, path, options);
  return p;
}
function pathToCanvasWithMatrix(ctx, path, matrix, options) {
  const flipY = options?.flipY ?? true;
  const ySign = flipY ? -1 : 1;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M": {
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        ctx.moveTo(p.x, p.y);
        break;
      }
      case "L": {
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        ctx.lineTo(p.x, p.y);
        break;
      }
      case "Q": {
        const p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        ctx.quadraticCurveTo(p1.x, p1.y, p.x, p.y);
        break;
      }
      case "C": {
        const p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);
        const p2 = transformPoint2D(cmd.x2, cmd.y2 * ySign, matrix);
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p.x, p.y);
        break;
      }
      case "Z":
        ctx.closePath();
        break;
    }
  }
}
function pathToSVGWithMatrix(path, matrix, options) {
  const flipY = options?.flipY ?? true;
  const ySign = flipY ? -1 : 1;
  let result = "";
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    if (i > 0)
      result += " ";
    switch (cmd.type) {
      case "M": {
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        result += "M " + p.x + " " + p.y;
        break;
      }
      case "L": {
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        result += "L " + p.x + " " + p.y;
        break;
      }
      case "Q": {
        const p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        result += "Q " + p1.x + " " + p1.y + " " + p.x + " " + p.y;
        break;
      }
      case "C": {
        const p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);
        const p2 = transformPoint2D(cmd.x2, cmd.y2 * ySign, matrix);
        const p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);
        result += "C " + p1.x + " " + p1.y + " " + p2.x + " " + p2.y + " " + p.x + " " + p.y;
        break;
      }
      case "Z":
        result += "Z";
        break;
    }
  }
  return result;
}
function pathToCanvasWithMatrix3D(ctx, path, matrix, options) {
  const flipY = options?.flipY ?? true;
  const ySign = flipY ? -1 : 1;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M": {
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        ctx.moveTo(p.x, p.y);
        break;
      }
      case "L": {
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        ctx.lineTo(p.x, p.y);
        break;
      }
      case "Q": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        ctx.quadraticCurveTo(p1.x, p1.y, p.x, p.y);
        break;
      }
      case "C": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);
        const p2 = transformPoint3x3(cmd.x2, cmd.y2 * ySign, matrix);
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p.x, p.y);
        break;
      }
      case "Z":
        ctx.closePath();
        break;
    }
  }
}
function pathToSVGWithMatrix3D(path, matrix, options) {
  const flipY = options?.flipY ?? true;
  const ySign = flipY ? -1 : 1;
  let result = "";
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    if (i > 0)
      result += " ";
    switch (cmd.type) {
      case "M": {
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        result += "M " + p.x + " " + p.y;
        break;
      }
      case "L": {
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        result += "L " + p.x + " " + p.y;
        break;
      }
      case "Q": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        result += "Q " + p1.x + " " + p1.y + " " + p.x + " " + p.y;
        break;
      }
      case "C": {
        const p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);
        const p2 = transformPoint3x3(cmd.x2, cmd.y2 * ySign, matrix);
        const p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);
        result += "C " + p1.x + " " + p1.y + " " + p2.x + " " + p2.y + " " + p.x + " " + p.y;
        break;
      }
      case "Z":
        result += "Z";
        break;
    }
  }
  return result;
}
function applyMatrixToContext(ctx, matrix) {
  ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
}
function matrixToSVGTransform(matrix) {
  return `matrix(${matrix[0]} ${matrix[1]} ${matrix[2]} ${matrix[3]} ${matrix[4]} ${matrix[5]})`;
}
function pathToSVGDirect(path, scale, offsetX, offsetY) {
  let result = "";
  const s = scale * SVG_SCALE;
  const ns = -scale * SVG_SCALE;
  const ox = offsetX * SVG_SCALE;
  const oy = offsetY * SVG_SCALE;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    if (i > 0)
      result += " ";
    switch (cmd.type) {
      case "M":
        result += "M " + Math.round(cmd.x * s + ox) + " " + Math.round(cmd.y * ns + oy);
        break;
      case "L":
        result += "L " + Math.round(cmd.x * s + ox) + " " + Math.round(cmd.y * ns + oy);
        break;
      case "Q":
        result += "Q " + Math.round(cmd.x1 * s + ox) + " " + Math.round(cmd.y1 * ns + oy) + " " + Math.round(cmd.x * s + ox) + " " + Math.round(cmd.y * ns + oy);
        break;
      case "C":
        result += "C " + Math.round(cmd.x1 * s + ox) + " " + Math.round(cmd.y1 * ns + oy) + " " + Math.round(cmd.x2 * s + ox) + " " + Math.round(cmd.y2 * ns + oy) + " " + Math.round(cmd.x * s + ox) + " " + Math.round(cmd.y * ns + oy);
        break;
      case "Z":
        result += "Z";
        break;
    }
  }
  return result;
}

// reference/text-shaper/src/raster/fixed-point.ts
var PIXEL_BITS = 8;
var ONE_PIXEL = 1 << PIXEL_BITS;
var PIXEL_MASK = ONE_PIXEL - 1;
var F26DOT6_SHIFT = 6;
var F26DOT6_ONE = 1 << F26DOT6_SHIFT;
var F16DOT16_SHIFT = 16;
var F16DOT16_ONE = 1 << F16DOT16_SHIFT;
function floatToF26Dot6(x) {
  return Math.round(x * F26DOT6_ONE);
}
function f26Dot6ToFloat(x) {
  return x / F26DOT6_ONE;
}
function floatToPixel(x, scale) {
  return Math.round(x * scale * ONE_PIXEL);
}
function truncPixel(x) {
  return x >> PIXEL_BITS;
}
function fracPixel(x) {
  return x & PIXEL_MASK;
}
function roundPixel(x) {
  return x + (ONE_PIXEL >> 1) >> PIXEL_BITS;
}
function floorPixel(x) {
  return x & ~PIXEL_MASK;
}
function ceilPixel(x) {
  return x + PIXEL_MASK & ~PIXEL_MASK;
}
function upscale(x) {
  return x << PIXEL_BITS - F26DOT6_SHIFT;
}
function downscale(x) {
  return x >> PIXEL_BITS - F26DOT6_SHIFT;
}
function mulDiv3(a, b, c) {
  if (c === 0)
    return 0;
  const absA = a < 0 ? -a : a;
  const absB = b < 0 ? -b : b;
  if (absA < 8388607 && absB < 8388607) {
    return Math.trunc(a * b / c);
  }
  return Number(BigInt(a) * BigInt(b) / BigInt(c));
}
function mulFix2(a, b) {
  return mulDiv3(a, b, F16DOT16_ONE);
}
function divFix2(a, b) {
  if (b === 0)
    return 0;
  return mulDiv3(a, F16DOT16_ONE, b);
}
function hypot(x, y) {
  x = abs(x);
  y = abs(y);
  return x > y ? x + (3 * y >> 3) : y + (3 * x >> 3);
}
function vectorLength(dx, dy) {
  return hypot(dx, dy);
}
function normalizeVector(dx, dy) {
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len === 0)
    return { x: F16DOT16_ONE, y: 0 };
  return {
    x: Math.round(dx / len * F16DOT16_ONE),
    y: Math.round(dy / len * F16DOT16_ONE)
  };
}
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
function abs(x) {
  return x < 0 ? -x : x;
}
function sign(x) {
  return x < 0 ? -1 : x > 0 ? 1 : 0;
}

// reference/text-shaper/src/raster/cell.ts
var DEFAULT_POOL_SIZE = 16384;
var CELL_MAX_X = 2147483647;

class PoolOverflowError extends Error {
  constructor() {
    super("Cell pool overflow");
    this.name = "PoolOverflowError";
  }
}

class CellBuffer {
  pool;
  poolSize;
  freeIndex;
  ycells;
  bandMinY = 0;
  bandMaxY = 0;
  minY = Infinity;
  maxY = -Infinity;
  minX = Infinity;
  maxX = -Infinity;
  currentX = 0;
  currentY = 0;
  currentCellIndex = -1;
  clipMinX = -Infinity;
  clipMinY = -Infinity;
  clipMaxX = Infinity;
  clipMaxY = Infinity;
  nullCellIndex;
  bandSet = false;
  constructor(poolSize = DEFAULT_POOL_SIZE) {
    this.poolSize = poolSize;
    this.nullCellIndex = poolSize - 1;
    this.pool = new Array(poolSize);
    for (let i = 0;i < poolSize; i++) {
      this.pool[i] = { x: 0, area: 0, cover: 0, next: -1 };
    }
    this.pool[this.nullCellIndex].x = CELL_MAX_X;
    this.pool[this.nullCellIndex].next = -1;
    this.ycells = [];
    this.freeIndex = 0;
    this.bandMinY = -1e4;
    this.bandMaxY = 1e4;
  }
  setClip(minX, minY, maxX, maxY) {
    this.clipMinX = minX;
    this.clipMinY = minY;
    this.clipMaxX = maxX;
    this.clipMaxY = maxY;
  }
  setBandBounds(minY, maxY) {
    this.bandMinY = minY;
    this.bandMaxY = maxY;
    this.bandSet = true;
    const height = maxY - minY;
    if (this.ycells.length < height) {
      this.ycells = new Array(height);
    }
    for (let i = 0;i < height; i++) {
      this.ycells[i] = this.nullCellIndex;
    }
    this.freeIndex = 0;
  }
  reset() {
    this.freeIndex = 0;
    this.pool[this.nullCellIndex].x = CELL_MAX_X;
    this.pool[this.nullCellIndex].area = 0;
    this.pool[this.nullCellIndex].cover = 0;
    this.pool[this.nullCellIndex].next = -1;
    if (this.bandSet) {
      for (let i = 0;i < this.ycells.length; i++) {
        this.ycells[i] = this.nullCellIndex;
      }
    } else {
      this.ycells = [];
      this.bandMinY = -1e5;
      this.bandMaxY = 1e5;
    }
    this.minY = Infinity;
    this.maxY = -Infinity;
    this.minX = Infinity;
    this.maxX = -Infinity;
    this.currentCellIndex = -1;
  }
  setCurrentCell(x, y) {
    const px = truncPixel(x);
    const py = truncPixel(y);
    if (this.currentCellIndex >= 0 && this.currentX === px && this.currentY === py) {
      return;
    }
    if (py < this.clipMinY || py >= this.clipMaxY || px < this.clipMinX || px >= this.clipMaxX || this.bandSet && (py < this.bandMinY || py >= this.bandMaxY)) {
      this.currentCellIndex = this.nullCellIndex;
      this.currentX = px;
      this.currentY = py;
      return;
    }
    this.currentX = px;
    this.currentY = py;
    this.currentCellIndex = this.findOrCreateCell(px, py);
    this.minY = Math.min(this.minY, py);
    this.maxY = Math.max(this.maxY, py);
    this.minX = Math.min(this.minX, px);
    this.maxX = Math.max(this.maxX, px);
  }
  findOrCreateCell(x, y) {
    if (!this.bandSet) {
      this.ensureYCellsCapacity(y);
    }
    const rowIndex = y - this.bandMinY;
    if (rowIndex < 0 || rowIndex >= this.ycells.length) {
      return this.nullCellIndex;
    }
    let prevIndex = -1;
    let cellIndex = this.ycells[rowIndex];
    while (cellIndex !== this.nullCellIndex) {
      const cell = this.pool[cellIndex];
      if (cell.x === x) {
        return cellIndex;
      }
      if (cell.x > x) {
        break;
      }
      prevIndex = cellIndex;
      cellIndex = cell.next;
    }
    if (this.freeIndex >= this.nullCellIndex) {
      throw new PoolOverflowError;
    }
    const newIndex = this.freeIndex++;
    const newCell = this.pool[newIndex];
    newCell.x = x;
    newCell.area = 0;
    newCell.cover = 0;
    newCell.next = cellIndex;
    if (prevIndex === -1) {
      this.ycells[rowIndex] = newIndex;
    } else {
      this.pool[prevIndex].next = newIndex;
    }
    return newIndex;
  }
  ensureYCellsCapacity(y) {
    if (this.ycells.length === 0) {
      this.bandMinY = Math.min(y, 0);
      this.bandMaxY = Math.max(y + 1, 256);
      const height = this.bandMaxY - this.bandMinY;
      this.ycells = new Array(height);
      for (let i = 0;i < height; i++) {
        this.ycells[i] = this.nullCellIndex;
      }
      return;
    }
    if (y < this.bandMinY) {
      const expand = this.bandMinY - y;
      const newYcells = new Array(this.ycells.length + expand);
      for (let i = 0;i < expand; i++) {
        newYcells[i] = this.nullCellIndex;
      }
      for (let i = 0;i < this.ycells.length; i++) {
        newYcells[expand + i] = this.ycells[i];
      }
      this.ycells = newYcells;
      this.bandMinY = y;
    } else if (y >= this.bandMaxY) {
      const newMaxY = y + 1;
      const oldLen = this.ycells.length;
      const newLen = newMaxY - this.bandMinY;
      if (newLen > oldLen) {
        const newYcells = new Array(newLen);
        for (let i = 0;i < oldLen; i++) {
          newYcells[i] = this.ycells[i];
        }
        for (let i = oldLen;i < newLen; i++) {
          newYcells[i] = this.nullCellIndex;
        }
        this.ycells = newYcells;
      }
      this.bandMaxY = newMaxY;
    }
  }
  addArea(area, cover) {
    if (this.currentCellIndex >= 0) {
      const cell = this.pool[this.currentCellIndex];
      cell.area += area;
      cell.cover += cover;
    }
  }
  getArea() {
    if (this.currentCellIndex >= 0) {
      return this.pool[this.currentCellIndex]?.area;
    }
    return 0;
  }
  getCover() {
    if (this.currentCellIndex >= 0) {
      return this.pool[this.currentCellIndex]?.cover;
    }
    return 0;
  }
  getCellsForRow(y) {
    const rowIndex = y - this.bandMinY;
    if (rowIndex < 0 || rowIndex >= this.ycells.length) {
      return [];
    }
    const cells = [];
    let cellIndex = this.ycells[rowIndex];
    while (cellIndex !== this.nullCellIndex) {
      cells.push(this.pool[cellIndex]);
      cellIndex = this.pool[cellIndex].next;
    }
    return cells;
  }
  *iterateCells() {
    for (let i = 0;i < this.ycells.length; i++) {
      const y = this.bandMinY + i;
      let cellIndex = this.ycells[i];
      if (cellIndex === this.nullCellIndex)
        continue;
      const cells = [];
      while (cellIndex !== this.nullCellIndex) {
        cells.push(this.pool[cellIndex]);
        cellIndex = this.pool[cellIndex].next;
      }
      if (cells.length > 0) {
        yield { y, cells };
      }
    }
  }
  *iterateScanlines() {
    for (let i = 0;i < this.ycells.length; i++) {
      const cellIndex = this.ycells[i];
      if (cellIndex !== this.nullCellIndex) {
        yield { y: this.bandMinY + i, firstCellIndex: cellIndex };
      }
    }
  }
  getPool() {
    return this.pool;
  }
  getNullIndex() {
    return this.nullCellIndex;
  }
  getYCells() {
    return this.ycells;
  }
  getBandMinY() {
    return this.bandMinY;
  }
  *iterateRowCells(y) {
    const rowIndex = y - this.bandMinY;
    if (rowIndex < 0 || rowIndex >= this.ycells.length)
      return;
    let cellIndex = this.ycells[rowIndex];
    while (cellIndex !== this.nullCellIndex) {
      yield this.pool[cellIndex];
      cellIndex = this.pool[cellIndex].next;
    }
  }
  getCellCount() {
    return this.freeIndex;
  }
  isNearCapacity() {
    return this.freeIndex > this.poolSize * 0.9;
  }
}

// reference/text-shaper/src/raster/gray-raster.ts
init_types();
var MAX_BAND_DEPTH = 32;
var MAX_GRAY_SPANS = 16;

class GrayRaster {
  cells;
  x = 0;
  y = 0;
  minX = 0;
  minY = 0;
  maxX = 0;
  maxY = 0;
  constructor() {
    this.cells = new CellBuffer;
  }
  setClip(minX, minY, maxX, maxY) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
    this.cells.setClip(minX, minY, maxX, maxY);
  }
  setBandBounds(minY, maxY) {
    this.cells.setBandBounds(minY, maxY);
  }
  reset() {
    this.cells.reset();
    this.x = 0;
    this.y = 0;
  }
  moveTo(x, y) {
    this.x = x;
    this.y = y;
    this.cells.setCurrentCell(x, y);
  }
  lineTo(toX, toY) {
    this.renderLine(toX, toY);
    this.x = toX;
    this.y = toY;
  }
  renderLine(toX, toY) {
    let ey1 = truncPixel(this.y);
    const ey2 = truncPixel(toY);
    if (ey1 >= this.maxY && ey2 >= this.maxY || ey1 < this.minY && ey2 < this.minY) {
      return;
    }
    const fy1 = fracPixel(this.y);
    const fy2 = fracPixel(toY);
    if (ey1 === ey2) {
      this.renderScanline(ey1, this.x, fy1, toX, fy2);
      return;
    }
    const dx = toX - this.x;
    const dy = toY - this.y;
    if (dx === 0) {
      const _ex = truncPixel(this.x);
      const twoFx = fracPixel(this.x) * 2;
      let first2;
      let incr2;
      if (dy > 0) {
        first2 = ONE_PIXEL;
        incr2 = 1;
      } else {
        first2 = 0;
        incr2 = -1;
      }
      let delta2 = first2 - fy1;
      this.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);
      this.cells.addArea(delta2 * twoFx, delta2);
      ey1 += incr2;
      this.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);
      delta2 = first2 + first2 - ONE_PIXEL;
      while (ey1 !== ey2) {
        this.cells.addArea(delta2 * twoFx, delta2);
        ey1 += incr2;
        this.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);
      }
      delta2 = fy2 - ONE_PIXEL + first2;
      this.cells.addArea(delta2 * twoFx, delta2);
      return;
    }
    let x = this.x;
    let incr;
    let first;
    let p;
    const absDy = abs(dy);
    if (dy > 0) {
      first = ONE_PIXEL;
      incr = 1;
      p = (ONE_PIXEL - fy1) * dx;
    } else {
      first = 0;
      incr = -1;
      p = fy1 * dx;
    }
    let delta = Math.trunc(p / absDy);
    let mod = p % absDy;
    if (mod < 0) {
      delta--;
      mod += absDy;
    }
    let x2 = x + delta;
    this.renderScanline(ey1, x, fy1, x2, first);
    x = x2;
    ey1 += incr;
    this.cells.setCurrentCell(x, ey1 << PIXEL_BITS);
    if (ey1 !== ey2) {
      p = ONE_PIXEL * dx;
      let lift = Math.trunc(p / absDy);
      let rem = p % absDy;
      if (rem < 0) {
        lift--;
        rem += absDy;
      }
      while (ey1 !== ey2) {
        delta = lift;
        mod += rem;
        if (mod >= absDy) {
          mod -= absDy;
          delta++;
        }
        x2 = x + delta;
        this.renderScanline(ey1, x, ONE_PIXEL - first, x2, first);
        x = x2;
        ey1 += incr;
        this.cells.setCurrentCell(x, ey1 << PIXEL_BITS);
      }
    }
    this.renderScanline(ey1, x, ONE_PIXEL - first, toX, fy2);
  }
  renderScanline(ey, x1, y1, x2, y2) {
    const ex1 = truncPixel(x1);
    const ex2 = truncPixel(x2);
    if (y1 === y2) {
      this.cells.setCurrentCell(x2, ey << PIXEL_BITS);
      return;
    }
    const fx1 = fracPixel(x1);
    const fx2 = fracPixel(x2);
    if (ex1 === ex2) {
      const delta2 = y2 - y1;
      this.cells.setCurrentCell(x1, ey << PIXEL_BITS);
      this.cells.addArea(delta2 * (fx1 + fx2), delta2);
      return;
    }
    const dx = x2 - x1;
    const dy = y2 - y1;
    const absDx = abs(dx);
    let first;
    let incr;
    let p;
    if (dx > 0) {
      first = ONE_PIXEL;
      incr = 1;
      p = (ONE_PIXEL - fx1) * dy;
    } else {
      first = 0;
      incr = -1;
      p = fx1 * dy;
    }
    let delta = Math.trunc(p / absDx);
    let mod = p % absDx;
    if (mod < 0) {
      delta--;
      mod += absDx;
    }
    this.cells.setCurrentCell(x1, ey << PIXEL_BITS);
    this.cells.addArea(delta * (fx1 + first), delta);
    let y = y1 + delta;
    let ex = ex1 + incr;
    this.cells.setCurrentCell(ex << PIXEL_BITS, ey << PIXEL_BITS);
    if (ex !== ex2) {
      p = ONE_PIXEL * dy;
      let lift = Math.trunc(p / absDx);
      let rem = p % absDx;
      if (rem < 0) {
        lift--;
        rem += absDx;
      }
      while (ex !== ex2) {
        delta = lift;
        mod += rem;
        if (mod >= absDx) {
          mod -= absDx;
          delta++;
        }
        this.cells.addArea(delta * ONE_PIXEL, delta);
        y += delta;
        ex += incr;
        this.cells.setCurrentCell(ex << PIXEL_BITS, ey << PIXEL_BITS);
      }
    }
    delta = y2 - y;
    this.cells.addArea(delta * (fx2 + ONE_PIXEL - first), delta);
  }
  mulDiv(a, b, c) {
    if (c === 0)
      return 0;
    return Math.trunc(a * b / c);
  }
  conicTo(cx, cy, toX, toY) {
    this.subdivConic(this.x, this.y, cx, cy, toX, toY, 0);
    this.x = toX;
    this.y = toY;
  }
  subdivConic(x1, y1, cx, cy, x3, y3, level) {
    if (level > 16) {
      this.renderLine(x3, y3);
      this.x = x3;
      this.y = y3;
      return;
    }
    let dx = abs(x1 + x3 - 2 * cx);
    let dy = abs(y1 + y3 - 2 * cy);
    if (dx < dy)
      dx = dy;
    if (dx <= ONE_PIXEL >> 2) {
      this.renderLine(x3, y3);
      this.x = x3;
      this.y = y3;
      return;
    }
    const x12 = x1 + cx >> 1;
    const y12 = y1 + cy >> 1;
    const x23 = cx + x3 >> 1;
    const y23 = cy + y3 >> 1;
    const x123 = x12 + x23 >> 1;
    const y123 = y12 + y23 >> 1;
    this.subdivConic(x1, y1, x12, y12, x123, y123, level + 1);
    this.subdivConic(x123, y123, x23, y23, x3, y3, level + 1);
  }
  cubicTo(cx1, cy1, cx2, cy2, x, y) {
    this.subdivCubic(this.x, this.y, cx1, cy1, cx2, cy2, x, y, 0);
    this.x = x;
    this.y = y;
  }
  subdivCubic(x1, y1, cx1, cy1, cx2, cy2, x4, y4, level) {
    if (level > 16) {
      this.renderLine(x4, y4);
      this.x = x4;
      this.y = y4;
      return;
    }
    if (abs(2 * x4 - 3 * cx2 + x1) > ONE_PIXEL >> 1 || abs(2 * y4 - 3 * cy2 + y1) > ONE_PIXEL >> 1 || abs(x4 - 3 * cx1 + 2 * x1) > ONE_PIXEL >> 1 || abs(y4 - 3 * cy1 + 2 * y1) > ONE_PIXEL >> 1) {
      const x12 = x1 + cx1 >> 1;
      const y12 = y1 + cy1 >> 1;
      const x23 = cx1 + cx2 >> 1;
      const y23 = cy1 + cy2 >> 1;
      const x34 = cx2 + x4 >> 1;
      const y34 = cy2 + y4 >> 1;
      const x123 = x12 + x23 >> 1;
      const y123 = y12 + y23 >> 1;
      const x234 = x23 + x34 >> 1;
      const y234 = y23 + y34 >> 1;
      const x1234 = x123 + x234 >> 1;
      const y1234 = y123 + y234 >> 1;
      this.subdivCubic(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);
      this.subdivCubic(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);
      return;
    }
    this.renderLine(x4, y4);
    this.x = x4;
    this.y = y4;
  }
  sweep(bitmap, fillRule = 0 /* NonZero */) {
    const pitch = bitmap.pitch;
    const origin = pitch < 0 ? (bitmap.rows - 1) * -pitch : 0;
    const bitmapWidth = bitmap.width;
    const bitmapRows = bitmap.rows;
    const pool = this.cells.getPool();
    const nullIndex = this.cells.getNullIndex();
    const ycells = this.cells.getYCells();
    const bandMinY = this.cells.getBandMinY();
    const ycellsLen = ycells.length;
    for (let i = 0;i < ycellsLen; i++) {
      const firstCellIndex = ycells[i];
      if (firstCellIndex === nullIndex)
        continue;
      const y = bandMinY + i;
      if (y < 0 || y >= bitmapRows)
        continue;
      let cover = 0;
      let x = 0;
      const row = pitch < 0 ? origin - y * -pitch : y * pitch;
      let cellIndex = firstCellIndex;
      while (cellIndex !== nullIndex) {
        const cell = pool[cellIndex];
        if (cell.x > x && cover !== 0) {
          const gray2 = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
          if (gray2 > 0) {
            const start = x < 0 ? 0 : x;
            const end = cell.x > bitmapWidth ? bitmapWidth : cell.x;
            this.fillSpan(bitmap, row, start, end, gray2);
          }
        }
        cover += cell.cover * (ONE_PIXEL * 2);
        const area = cover - cell.area;
        const gray = this.applyFillRule(area >> PIXEL_BITS + 1, fillRule);
        if (gray > 0 && cell.x >= 0 && cell.x < bitmapWidth) {
          this.setPixel(bitmap, row, cell.x, gray);
        }
        x = cell.x + 1;
        cellIndex = cell.next;
      }
      if (x < bitmapWidth && cover !== 0) {
        const gray = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
        if (gray > 0) {
          this.fillSpan(bitmap, row, x, bitmapWidth, gray);
        }
      }
    }
  }
  applyFillRule(value, fillRule) {
    let v = value;
    if (v < 0)
      v = -v;
    if (fillRule === 1 /* EvenOdd */) {
      v &= 511;
      if (v > 256)
        v = 512 - v;
    }
    return v > 255 ? 255 : v;
  }
  fillSpan(bitmap, row, start, end, gray) {
    if (bitmap.pixelMode === 1 /* Gray */) {
      bitmap.buffer.fill(gray, row + start, row + end);
    } else if (bitmap.pixelMode === 0 /* Mono */) {
      if (gray >= 128) {
        for (let x = start;x < end; x++) {
          const byteIdx = row + (x >> 3);
          const bitIdx = 7 - (x & 7);
          bitmap.buffer[byteIdx] |= 1 << bitIdx;
        }
      }
    } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
      for (let x = start;x < end; x++) {
        const idx = row + x * 3;
        bitmap.buffer[idx] = gray;
        bitmap.buffer[idx + 1] = gray;
        bitmap.buffer[idx + 2] = gray;
      }
    } else if (bitmap.pixelMode === 4 /* RGBA */) {
      for (let x = start;x < end; x++) {
        const idx = row + x * 4;
        bitmap.buffer[idx] = 0;
        bitmap.buffer[idx + 1] = 0;
        bitmap.buffer[idx + 2] = 0;
        bitmap.buffer[idx + 3] = gray;
      }
    }
  }
  setPixel(bitmap, row, x, gray) {
    if (bitmap.pixelMode === 1 /* Gray */) {
      bitmap.buffer[row + x] = gray;
    } else if (bitmap.pixelMode === 0 /* Mono */) {
      if (gray >= 128) {
        const byteIdx = row + (x >> 3);
        const bitIdx = 7 - (x & 7);
        bitmap.buffer[byteIdx] |= 1 << bitIdx;
      }
    } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
      const idx = row + x * 3;
      bitmap.buffer[idx] = gray;
      bitmap.buffer[idx + 1] = gray;
      bitmap.buffer[idx + 2] = gray;
    } else if (bitmap.pixelMode === 4 /* RGBA */) {
      const idx = row + x * 4;
      bitmap.buffer[idx] = 0;
      bitmap.buffer[idx + 1] = 0;
      bitmap.buffer[idx + 2] = 0;
      bitmap.buffer[idx + 3] = gray;
    }
  }
  sweepSpans(callback, fillRule = 0 /* NonZero */, userData) {
    const ycells = this.cells.getYCells();
    const pool = this.cells.getPool();
    const nullIndex = this.cells.getNullIndex();
    const bandMinY = this.cells.getBandMinY();
    for (let i = 0;i < ycells.length; i++) {
      let cellIndex = ycells[i];
      if (cellIndex === nullIndex)
        continue;
      const y = bandMinY + i;
      const spans = [];
      let cover = 0;
      let spanStart = -1;
      while (cellIndex !== nullIndex) {
        const cell = pool[cellIndex];
        if (cover !== 0 && cell.x > spanStart + 1) {
          const gray2 = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
          if (gray2 > 0) {
            spans.push({
              x: spanStart + 1,
              len: cell.x - spanStart - 1,
              coverage: gray2
            });
          }
        }
        cover += cell.cover * (ONE_PIXEL * 2);
        const area = cover - cell.area;
        const gray = this.applyFillRule(area >> PIXEL_BITS + 1, fillRule);
        if (gray > 0) {
          spans.push({ x: cell.x, len: 1, coverage: gray });
        }
        spanStart = cell.x;
        cellIndex = cell.next;
      }
      if (spans.length > 0) {
        callback(y, spans, userData);
      }
    }
  }
  sweepDirect(callback, fillRule = 0 /* NonZero */, minX = 0, maxX = Infinity, userData) {
    const spanBuffer = [];
    const ycells = this.cells.getYCells();
    const pool = this.cells.getPool();
    const nullIndex = this.cells.getNullIndex();
    const bandMinY = this.cells.getBandMinY();
    for (let i = 0;i < ycells.length; i++) {
      let cellIndex = ycells[i];
      if (cellIndex === nullIndex)
        continue;
      const y = bandMinY + i;
      let cover = 0;
      let x = minX;
      while (cellIndex !== nullIndex) {
        const cell = pool[cellIndex];
        if (cover !== 0 && cell.x > x) {
          const gray2 = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
          if (gray2 > 0) {
            spanBuffer.push({ x, len: cell.x - x, coverage: gray2 });
            if (spanBuffer.length >= MAX_GRAY_SPANS) {
              callback(y, spanBuffer.splice(0, spanBuffer.length), userData);
            }
          }
        }
        cover += cell.cover * (ONE_PIXEL * 2);
        const area = cover - cell.area;
        const gray = this.applyFillRule(area >> PIXEL_BITS + 1, fillRule);
        if (gray > 0 && cell.x >= minX && cell.x < maxX) {
          spanBuffer.push({ x: cell.x, len: 1, coverage: gray });
          if (spanBuffer.length >= MAX_GRAY_SPANS) {
            callback(y, spanBuffer.splice(0, spanBuffer.length), userData);
          }
        }
        x = cell.x + 1;
        cellIndex = cell.next;
      }
      if (cover !== 0 && x < maxX) {
        const gray = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
        if (gray > 0) {
          spanBuffer.push({
            x,
            len: Math.min(maxX, this.maxX + 1) - x,
            coverage: gray
          });
        }
      }
      if (spanBuffer.length > 0) {
        callback(y, spanBuffer.splice(0, spanBuffer.length), userData);
      }
    }
  }
  renderWithBands(bitmap, decomposeFn, bounds, fillRule = 0 /* NonZero */) {
    const poolSize = 2048;
    const height = bounds.maxY - bounds.minY;
    let bandHeight = Math.max(1, Math.floor(poolSize / 8));
    if (height <= bandHeight) {
      bandHeight = height;
    }
    const xMin = bounds.minX ?? 0;
    const xMax = bounds.maxX ?? bitmap.width;
    const bandStack = [];
    for (let y = bounds.minY;y < bounds.maxY; y += bandHeight) {
      bandStack.push({
        minY: y,
        maxY: Math.min(y + bandHeight, bounds.maxY),
        minX: xMin,
        maxX: xMax,
        depth: 0
      });
    }
    while (bandStack.length > 0) {
      const band = bandStack.pop();
      if (!band)
        break;
      if (this.renderBandWithXClip(bitmap, decomposeFn, band.minY, band.maxY, band.minX, band.maxX, fillRule)) {
        continue;
      }
      const bandDepth = band.depth;
      if (bandDepth >= MAX_BAND_DEPTH) {
        console.warn(`Rasterizer: band overflow at (${band.minX},${band.minY}), depth limit reached`);
        continue;
      }
      const childDepth = bandDepth + 1;
      const midX = band.minX + band.maxX >> 1;
      if (midX > band.minX) {
        bandStack.push({
          minY: band.minY,
          maxY: band.maxY,
          minX: midX,
          maxX: band.maxX,
          depth: childDepth
        });
        bandStack.push({
          minY: band.minY,
          maxY: band.maxY,
          minX: band.minX,
          maxX: midX,
          depth: childDepth
        });
        continue;
      }
      const midY = band.minY + band.maxY >> 1;
      if (midY > band.minY) {
        bandStack.push({
          minY: midY,
          maxY: band.maxY,
          minX: band.minX,
          maxX: band.maxX,
          depth: childDepth
        });
        bandStack.push({
          minY: band.minY,
          maxY: midY,
          minX: band.minX,
          maxX: band.maxX,
          depth: childDepth
        });
        continue;
      }
      console.warn(`Rasterizer: band overflow at (${band.minX},${band.minY}), cannot bisect further`);
    }
  }
  renderBandWithXClip(bitmap, decomposeFn, minY, maxY, minX, maxX, fillRule) {
    this.setClip(minX, minY, maxX, maxY);
    this.cells.setBandBounds(minY, maxY);
    this.cells.reset();
    this.minY = minY;
    this.maxY = maxY;
    try {
      decomposeFn();
      this.sweepBandWithXClip(bitmap, minY, maxY, minX, maxX, fillRule);
      return true;
    } catch (e) {
      if (e instanceof PoolOverflowError) {
        return false;
      }
      throw e;
    }
  }
  sweepBandWithXClip(bitmap, minY, maxY, minX, maxX, fillRule) {
    const pitch = bitmap.pitch;
    const origin = pitch < 0 ? (bitmap.rows - 1) * -pitch : 0;
    const ycells = this.cells.getYCells();
    const pool = this.cells.getPool();
    const nullIndex = this.cells.getNullIndex();
    const bandMinY = this.cells.getBandMinY();
    for (let y = minY;y < maxY; y++) {
      if (y < 0 || y >= bitmap.rows)
        continue;
      const rowIndex = y - bandMinY;
      if (rowIndex < 0 || rowIndex >= ycells.length)
        continue;
      let cellIndex = ycells[rowIndex];
      if (cellIndex === nullIndex)
        continue;
      let cover = 0;
      let x = minX;
      const row = pitch < 0 ? origin - y * -pitch : y * pitch;
      while (cellIndex !== nullIndex) {
        const cell = pool[cellIndex];
        if (cell.x < minX) {
          cover += cell.cover * (ONE_PIXEL * 2);
          cellIndex = cell.next;
          continue;
        }
        if (cell.x >= maxX) {
          if (cover !== 0 && x < maxX) {
            const gray2 = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
            if (gray2 > 0) {
              this.fillSpan(bitmap, row, Math.max(0, x), Math.min(bitmap.width, maxX), gray2);
            }
          }
          break;
        }
        if (cell.x > x && cover !== 0) {
          const gray2 = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
          if (gray2 > 0) {
            const start = Math.max(0, x);
            const end = Math.min(bitmap.width, cell.x);
            this.fillSpan(bitmap, row, start, end, gray2);
          }
        }
        cover += cell.cover * (ONE_PIXEL * 2);
        const area = cover - cell.area;
        const gray = this.applyFillRule(area >> PIXEL_BITS + 1, fillRule);
        if (gray > 0 && cell.x >= 0 && cell.x < bitmap.width) {
          this.setPixel(bitmap, row, cell.x, gray);
        }
        x = cell.x + 1;
        cellIndex = cell.next;
      }
      if (x < maxX && x < bitmap.width && cover !== 0) {
        const gray = this.applyFillRule(cover >> PIXEL_BITS + 1, fillRule);
        if (gray > 0) {
          this.fillSpan(bitmap, row, x, Math.min(bitmap.width, maxX), gray);
        }
      }
    }
  }
}

// reference/text-shaper/src/raster/outline-decompose.ts
init_types();
var OutlineError;
((OutlineError2) => {
  OutlineError2[OutlineError2["Ok"] = 0] = "Ok";
  OutlineError2[OutlineError2["InvalidOutline"] = 1] = "InvalidOutline";
  OutlineError2[OutlineError2["InvalidArgument"] = 2] = "InvalidArgument";
  OutlineError2[OutlineError2["EmptyOutline"] = 3] = "EmptyOutline";
})(OutlineError ||= {});
function validateOutline(path, allowEmpty = true) {
  if (!path) {
    return {
      error: 1 /* InvalidOutline */,
      message: "Path is null or undefined"
    };
  }
  if (!path.commands) {
    return {
      error: 1 /* InvalidOutline */,
      message: "Path commands array is missing"
    };
  }
  if (path.commands.length === 0) {
    if (allowEmpty) {
      return { error: 3 /* EmptyOutline */ };
    }
    return { error: 1 /* InvalidOutline */, message: "Path is empty" };
  }
  let hasMove = false;
  let inContour = false;
  let contourCount = 0;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        if (inContour) {}
        hasMove = true;
        inContour = true;
        contourCount++;
        if (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Invalid coordinates at command ${i}: (${cmd.x}, ${cmd.y})`
          };
        }
        break;
      case "L":
        if (!hasMove) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Line command at ${i} without preceding moveTo`
          };
        }
        if (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Invalid coordinates at command ${i}`
          };
        }
        break;
      case "Q":
        if (!hasMove) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Quadratic curve at ${i} without preceding moveTo`
          };
        }
        if (!Number.isFinite(cmd.x1) || !Number.isFinite(cmd.y1) || !Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Invalid coordinates at command ${i}`
          };
        }
        break;
      case "C":
        if (!hasMove) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Cubic curve at ${i} without preceding moveTo`
          };
        }
        if (!Number.isFinite(cmd.x1) || !Number.isFinite(cmd.y1) || !Number.isFinite(cmd.x2) || !Number.isFinite(cmd.y2) || !Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) {
          return {
            error: 1 /* InvalidOutline */,
            message: `Invalid coordinates at command ${i}`
          };
        }
        break;
      case "Z":
        inContour = false;
        break;
      default:
        return {
          error: 1 /* InvalidOutline */,
          message: `Unknown command type at ${i}: ${cmd.type}`
        };
    }
  }
  if (contourCount === 0 && !allowEmpty) {
    return { error: 3 /* EmptyOutline */, message: "No contours in path" };
  }
  return { error: 0 /* Ok */ };
}
function decomposePath(raster, path, scale, offsetX = 0, offsetY = 0, flipY = true) {
  let startX = 0;
  let startY = 0;
  let inContour = false;
  const scaleX = scale * ONE_PIXEL;
  const scaleY = (flipY ? -scale : scale) * ONE_PIXEL;
  const offX = offsetX * ONE_PIXEL;
  const offY = offsetY * ONE_PIXEL;
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M": {
        if (inContour) {
          raster.lineTo(startX, startY);
        }
        const x = Math.round(cmd.x * scaleX + offX);
        const y = Math.round(cmd.y * scaleY + offY);
        raster.moveTo(x, y);
        startX = x;
        startY = y;
        inContour = true;
        break;
      }
      case "L": {
        const x = Math.round(cmd.x * scaleX + offX);
        const y = Math.round(cmd.y * scaleY + offY);
        raster.lineTo(x, y);
        break;
      }
      case "Q": {
        const cx = Math.round(cmd.x1 * scaleX + offX);
        const cy = Math.round(cmd.y1 * scaleY + offY);
        const x = Math.round(cmd.x * scaleX + offX);
        const y = Math.round(cmd.y * scaleY + offY);
        raster.conicTo(cx, cy, x, y);
        break;
      }
      case "C": {
        const cx1 = Math.round(cmd.x1 * scaleX + offX);
        const cy1 = Math.round(cmd.y1 * scaleY + offY);
        const cx2 = Math.round(cmd.x2 * scaleX + offX);
        const cy2 = Math.round(cmd.y2 * scaleY + offY);
        const x = Math.round(cmd.x * scaleX + offX);
        const y = Math.round(cmd.y * scaleY + offY);
        raster.cubicTo(cx1, cy1, cx2, cy2, x, y);
        break;
      }
      case "Z": {
        if (inContour) {
          raster.lineTo(startX, startY);
          inContour = false;
        }
        break;
      }
    }
  }
  if (inContour) {
    raster.lineTo(startX, startY);
  }
}
function mulFix3(value, scaleFix) {
  if (value === 0 || scaleFix === 0)
    return 0;
  let sign2 = 1;
  let a = value;
  let b = scaleFix;
  if (a < 0) {
    a = -a;
    sign2 = -sign2;
  }
  if (b < 0) {
    b = -b;
    sign2 = -sign2;
  }
  const result = Math.floor((a * b + 32768) / 65536);
  return sign2 < 0 ? -result : result;
}
function getPathBounds(path, scale, flipY = true, roundToGrid2 = false) {
  if (roundToGrid2) {
    const scale26Fix = Math.round(scale * 64 * 65536);
    let minX26 = Infinity;
    let minY26 = Infinity;
    let maxX26 = -Infinity;
    let maxY26 = -Infinity;
    const update = (x, y) => {
      const rx = mulFix3(x, scale26Fix);
      const ry = mulFix3(y, scale26Fix);
      if (rx < minX26)
        minX26 = rx;
      if (rx > maxX26)
        maxX26 = rx;
      if (ry < minY26)
        minY26 = ry;
      if (ry > maxY26)
        maxY26 = ry;
    };
    for (const cmd of path.commands) {
      switch (cmd.type) {
        case "M":
        case "L":
          update(cmd.x, cmd.y);
          break;
        case "Q":
          update(cmd.x1, cmd.y1);
          update(cmd.x, cmd.y);
          break;
        case "C":
          update(cmd.x1, cmd.y1);
          update(cmd.x2, cmd.y2);
          update(cmd.x, cmd.y);
          break;
        default:
          break;
      }
    }
    if (!Number.isFinite(minX26) || !Number.isFinite(minY26))
      return null;
    if (flipY) {
      const flippedMinY = -maxY26;
      const flippedMaxY = -minY26;
      return {
        minX: Math.floor(minX26 / 64),
        minY: Math.floor(flippedMinY / 64),
        maxX: Math.floor((maxX26 + 63) / 64),
        maxY: Math.floor((flippedMaxY + 63) / 64)
      };
    }
    return {
      minX: Math.floor(minX26 / 64),
      minY: Math.floor(minY26 / 64),
      maxX: Math.floor((maxX26 + 63) / 64),
      maxY: Math.floor((maxY26 + 63) / 64)
    };
  }
  if (!path.bounds)
    return null;
  const b = path.bounds;
  if (flipY) {
    return {
      minX: Math.floor(b.xMin * scale),
      minY: Math.floor(-b.yMax * scale),
      maxX: Math.ceil(b.xMax * scale),
      maxY: Math.ceil(-b.yMin * scale)
    };
  } else {
    return {
      minX: Math.floor(b.xMin * scale),
      minY: Math.floor(b.yMin * scale),
      maxX: Math.ceil(b.xMax * scale),
      maxY: Math.ceil(b.yMax * scale)
    };
  }
}
function getFillRuleFromFlags(path, defaultRule = 0 /* NonZero */) {
  if (!path?.flags)
    return defaultRule;
  return (path.flags & 1 /* EvenOddFill */) !== 0 ? 1 /* EvenOdd */ : 0 /* NonZero */;
}

// reference/text-shaper/src/raster/rasterize.ts
init_types();

// reference/text-shaper/src/raster/bitmap-utils.ts
init_types();
function emboldenBitmap(bitmap, xStrength, yStrength) {
  if (xStrength === 0 && yStrength === 0) {
    return copyBitmap(bitmap);
  }
  const result = createBitmap(bitmap.width, bitmap.rows, bitmap.pixelMode);
  if (bitmap.pixelMode === 1 /* Gray */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        let maxVal = 0;
        for (let dy = -Math.floor(yStrength);dy <= Math.ceil(yStrength); dy++) {
          for (let dx = -Math.floor(xStrength);dx <= Math.ceil(xStrength); dx++) {
            const sx = x + dx;
            const sy = y + dy;
            if (sx >= 0 && sx < bitmap.width && sy >= 0 && sy < bitmap.rows) {
              const val = bitmap.buffer[sy * bitmap.pitch + sx] ?? 0;
              maxVal = Math.max(maxVal, val);
            }
          }
        }
        result.buffer[y * result.pitch + x] = maxVal;
      }
    }
  } else if (bitmap.pixelMode === 0 /* Mono */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        let hasSet = false;
        for (let dy = -Math.floor(yStrength);dy <= Math.ceil(yStrength); dy++) {
          for (let dx = -Math.floor(xStrength);dx <= Math.ceil(xStrength); dx++) {
            const sx = x + dx;
            const sy = y + dy;
            if (sx >= 0 && sx < bitmap.width && sy >= 0 && sy < bitmap.rows) {
              const byteIdx = sy * bitmap.pitch + (sx >> 3);
              const bitIdx = 7 - (sx & 7);
              const bit = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1;
              if (bit) {
                hasSet = true;
                break;
              }
            }
          }
          if (hasSet)
            break;
        }
        if (hasSet) {
          const dstByteIdx = y * result.pitch + (x >> 3);
          const dstBitIdx = 7 - (x & 7);
          result.buffer[dstByteIdx] |= 1 << dstBitIdx;
        }
      }
    }
  } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        let maxR = 0, maxG = 0, maxB = 0;
        for (let dy = -Math.floor(yStrength);dy <= Math.ceil(yStrength); dy++) {
          for (let dx = -Math.floor(xStrength);dx <= Math.ceil(xStrength); dx++) {
            const sx = x + dx;
            const sy = y + dy;
            if (sx >= 0 && sx < bitmap.width && sy >= 0 && sy < bitmap.rows) {
              const idx = sy * bitmap.pitch + sx * 3;
              maxR = Math.max(maxR, bitmap.buffer[idx] ?? 0);
              maxG = Math.max(maxG, bitmap.buffer[idx + 1] ?? 0);
              maxB = Math.max(maxB, bitmap.buffer[idx + 2] ?? 0);
            }
          }
        }
        const dstIdx = y * result.pitch + x * 3;
        result.buffer[dstIdx] = maxR;
        result.buffer[dstIdx + 1] = maxG;
        result.buffer[dstIdx + 2] = maxB;
      }
    }
  }
  return result;
}
function convertBitmap(bitmap, targetMode) {
  if (bitmap.pixelMode === targetMode) {
    return bitmap;
  }
  const result = createBitmap(bitmap.width, bitmap.rows, targetMode);
  if (bitmap.pixelMode === 1 /* Gray */ && targetMode === 0 /* Mono */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const gray = bitmap.buffer[y * bitmap.pitch + x] ?? 0;
        if (gray >= 128) {
          const byteIdx = y * result.pitch + (x >> 3);
          const bitIdx = 7 - (x & 7);
          result.buffer[byteIdx] |= 1 << bitIdx;
        }
      }
    }
  } else if (bitmap.pixelMode === 0 /* Mono */ && targetMode === 1 /* Gray */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const byteIdx = y * bitmap.pitch + (x >> 3);
        const bitIdx = 7 - (x & 7);
        const bit = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1;
        result.buffer[y * result.pitch + x] = bit ? 255 : 0;
      }
    }
  } else if (bitmap.pixelMode === 1 /* Gray */ && targetMode === 2 /* LCD */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const gray = bitmap.buffer[y * bitmap.pitch + x] ?? 0;
        const dstIdx = y * result.pitch + x * 3;
        result.buffer[dstIdx] = gray;
        result.buffer[dstIdx + 1] = gray;
        result.buffer[dstIdx + 2] = gray;
      }
    }
  } else if (bitmap.pixelMode === 0 /* Mono */ && targetMode === 2 /* LCD */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const byteIdx = y * bitmap.pitch + (x >> 3);
        const bitIdx = 7 - (x & 7);
        const bit = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1;
        const val = bit ? 255 : 0;
        const dstIdx = y * result.pitch + x * 3;
        result.buffer[dstIdx] = val;
        result.buffer[dstIdx + 1] = val;
        result.buffer[dstIdx + 2] = val;
      }
    }
  } else if (bitmap.pixelMode === 1 /* Gray */ && targetMode === 3 /* LCD_V */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const gray = bitmap.buffer[y * bitmap.pitch + x] ?? 0;
        const dstIdx = y * result.pitch + x * 3;
        result.buffer[dstIdx] = gray;
        result.buffer[dstIdx + 1] = gray;
        result.buffer[dstIdx + 2] = gray;
      }
    }
  } else if (bitmap.pixelMode === 2 /* LCD */ && targetMode === 1 /* Gray */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const srcIdx = y * bitmap.pitch + x * 3;
        const r = bitmap.buffer[srcIdx] ?? 0;
        const g = bitmap.buffer[srcIdx + 1] ?? 0;
        const b = bitmap.buffer[srcIdx + 2] ?? 0;
        result.buffer[y * result.pitch + x] = Math.floor((r + g + b) / 3);
      }
    }
  }
  return result;
}
function blendBitmap(dst, src, x, y, opacity) {
  if (dst.pixelMode !== 1 /* Gray */ || src.pixelMode !== 1 /* Gray */) {
    return;
  }
  opacity = Math.max(0, Math.min(1, opacity));
  const startX = Math.max(0, -x);
  const startY = Math.max(0, -y);
  const endX = Math.min(src.width, dst.width - x);
  const endY = Math.min(src.rows, dst.rows - y);
  for (let sy = startY;sy < endY; sy++) {
    for (let sx = startX;sx < endX; sx++) {
      const dx = x + sx;
      const dy = y + sy;
      if (dx >= 0 && dx < dst.width && dy >= 0 && dy < dst.rows) {
        const srcVal = src.buffer[sy * src.pitch + sx] ?? 0;
        const dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;
        const blended = dstVal + srcVal * opacity;
        dst.buffer[dy * dst.pitch + dx] = Math.min(255, Math.floor(blended));
      }
    }
  }
}
function copyBitmap(bitmap) {
  return {
    buffer: new Uint8Array(bitmap.buffer),
    width: bitmap.width,
    rows: bitmap.rows,
    pitch: bitmap.pitch,
    pixelMode: bitmap.pixelMode,
    numGrays: bitmap.numGrays
  };
}
function resizeBitmap(bitmap, newWidth, newHeight) {
  const result = createBitmap(newWidth, newHeight, bitmap.pixelMode);
  const xRatio = bitmap.width / newWidth;
  const yRatio = bitmap.rows / newHeight;
  if (bitmap.pixelMode === 1 /* Gray */) {
    for (let y = 0;y < newHeight; y++) {
      for (let x = 0;x < newWidth; x++) {
        const sx = Math.floor(x * xRatio);
        const sy = Math.floor(y * yRatio);
        result.buffer[y * result.pitch + x] = bitmap.buffer[sy * bitmap.pitch + sx] ?? 0;
      }
    }
  } else if (bitmap.pixelMode === 0 /* Mono */) {
    for (let y = 0;y < newHeight; y++) {
      for (let x = 0;x < newWidth; x++) {
        const sx = Math.floor(x * xRatio);
        const sy = Math.floor(y * yRatio);
        const srcByteIdx = sy * bitmap.pitch + (sx >> 3);
        const srcBitIdx = 7 - (sx & 7);
        const bit = (bitmap.buffer[srcByteIdx] ?? 0) >> srcBitIdx & 1;
        if (bit) {
          const dstByteIdx = y * result.pitch + (x >> 3);
          const dstBitIdx = 7 - (x & 7);
          result.buffer[dstByteIdx] |= 1 << dstBitIdx;
        }
      }
    }
  } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    for (let y = 0;y < newHeight; y++) {
      for (let x = 0;x < newWidth; x++) {
        const sx = Math.floor(x * xRatio);
        const sy = Math.floor(y * yRatio);
        const srcIdx = sy * bitmap.pitch + sx * 3;
        const dstIdx = y * result.pitch + x * 3;
        result.buffer[dstIdx] = bitmap.buffer[srcIdx] ?? 0;
        result.buffer[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;
        result.buffer[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;
      }
    }
  }
  return result;
}
function resizeBitmapBilinear(bitmap, newWidth, newHeight) {
  const result = createBitmap(newWidth, newHeight, bitmap.pixelMode);
  const xRatio = (bitmap.width - 1) / Math.max(1, newWidth - 1);
  const yRatio = (bitmap.rows - 1) / Math.max(1, newHeight - 1);
  if (bitmap.pixelMode === 1 /* Gray */) {
    for (let y = 0;y < newHeight; y++) {
      const srcY = y * yRatio;
      const y0 = Math.floor(srcY);
      const y1 = Math.min(y0 + 1, bitmap.rows - 1);
      const yFrac = srcY - y0;
      for (let x = 0;x < newWidth; x++) {
        const srcX = x * xRatio;
        const x0 = Math.floor(srcX);
        const x1 = Math.min(x0 + 1, bitmap.width - 1);
        const xFrac = srcX - x0;
        const p00 = bitmap.buffer[y0 * bitmap.pitch + x0] ?? 0;
        const p10 = bitmap.buffer[y0 * bitmap.pitch + x1] ?? 0;
        const p01 = bitmap.buffer[y1 * bitmap.pitch + x0] ?? 0;
        const p11 = bitmap.buffer[y1 * bitmap.pitch + x1] ?? 0;
        const top = p00 + (p10 - p00) * xFrac;
        const bottom = p01 + (p11 - p01) * xFrac;
        const value = top + (bottom - top) * yFrac;
        result.buffer[y * result.pitch + x] = Math.round(value);
      }
    }
  } else if (bitmap.pixelMode === 0 /* Mono */) {
    return resizeBitmap(bitmap, newWidth, newHeight);
  } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    for (let y = 0;y < newHeight; y++) {
      const srcY = y * yRatio;
      const y0 = Math.floor(srcY);
      const y1 = Math.min(y0 + 1, bitmap.rows - 1);
      const yFrac = srcY - y0;
      for (let x = 0;x < newWidth; x++) {
        const srcX = x * xRatio;
        const x0 = Math.floor(srcX);
        const x1 = Math.min(x0 + 1, bitmap.width - 1);
        const xFrac = srcX - x0;
        const idx00 = y0 * bitmap.pitch + x0 * 3;
        const idx10 = y0 * bitmap.pitch + x1 * 3;
        const idx01 = y1 * bitmap.pitch + x0 * 3;
        const idx11 = y1 * bitmap.pitch + x1 * 3;
        for (let c = 0;c < 3; c++) {
          const p00 = bitmap.buffer[idx00 + c] ?? 0;
          const p10 = bitmap.buffer[idx10 + c] ?? 0;
          const p01 = bitmap.buffer[idx01 + c] ?? 0;
          const p11 = bitmap.buffer[idx11 + c] ?? 0;
          const top = p00 + (p10 - p00) * xFrac;
          const bottom = p01 + (p11 - p01) * xFrac;
          const value = top + (bottom - top) * yFrac;
          result.buffer[y * result.pitch + x * 3 + c] = Math.round(value);
        }
      }
    }
  }
  return result;
}
function addBitmaps(dst, src, srcX = 0, srcY = 0) {
  if (dst.pixelMode !== 1 /* Gray */ || src.pixelMode !== 1 /* Gray */) {
    return;
  }
  const startX = Math.max(0, -srcX);
  const startY = Math.max(0, -srcY);
  const endX = Math.min(src.width, dst.width - srcX);
  const endY = Math.min(src.rows, dst.rows - srcY);
  for (let sy = startY;sy < endY; sy++) {
    const dy = srcY + sy;
    if (dy < 0 || dy >= dst.rows)
      continue;
    for (let sx = startX;sx < endX; sx++) {
      const dx = srcX + sx;
      if (dx < 0 || dx >= dst.width)
        continue;
      const srcVal = src.buffer[sy * src.pitch + sx] ?? 0;
      const dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;
      dst.buffer[dy * dst.pitch + dx] = Math.min(255, srcVal + dstVal);
    }
  }
}
function mulBitmaps(dst, src, srcX = 0, srcY = 0) {
  if (dst.pixelMode !== 1 /* Gray */ || src.pixelMode !== 1 /* Gray */) {
    return;
  }
  const startX = Math.max(0, -srcX);
  const startY = Math.max(0, -srcY);
  const endX = Math.min(src.width, dst.width - srcX);
  const endY = Math.min(src.rows, dst.rows - srcY);
  for (let sy = startY;sy < endY; sy++) {
    const dy = srcY + sy;
    if (dy < 0 || dy >= dst.rows)
      continue;
    for (let sx = startX;sx < endX; sx++) {
      const dx = srcX + sx;
      if (dx < 0 || dx >= dst.width)
        continue;
      const srcVal = src.buffer[sy * src.pitch + sx] ?? 0;
      const dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;
      dst.buffer[dy * dst.pitch + dx] = Math.floor((srcVal * dstVal + 127) / 255);
    }
  }
}
function subBitmaps(dst, src, srcX = 0, srcY = 0) {
  if (dst.pixelMode !== 1 /* Gray */ || src.pixelMode !== 1 /* Gray */) {
    return;
  }
  const startX = Math.max(0, -srcX);
  const startY = Math.max(0, -srcY);
  const endX = Math.min(src.width, dst.width - srcX);
  const endY = Math.min(src.rows, dst.rows - srcY);
  for (let sy = startY;sy < endY; sy++) {
    const dy = srcY + sy;
    if (dy < 0 || dy >= dst.rows)
      continue;
    for (let sx = startX;sx < endX; sx++) {
      const dx = srcX + sx;
      if (dx < 0 || dx >= dst.width)
        continue;
      const srcVal = src.buffer[sy * src.pitch + sx] ?? 0;
      const dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;
      dst.buffer[dy * dst.pitch + dx] = Math.max(0, dstVal - srcVal);
    }
  }
}
function compositeBitmaps(dst, src, srcX = 0, srcY = 0) {
  if (dst.pixelMode !== 1 /* Gray */ || src.pixelMode !== 1 /* Gray */) {
    return;
  }
  const startX = Math.max(0, -srcX);
  const startY = Math.max(0, -srcY);
  const endX = Math.min(src.width, dst.width - srcX);
  const endY = Math.min(src.rows, dst.rows - srcY);
  for (let sy = startY;sy < endY; sy++) {
    const dy = srcY + sy;
    if (dy < 0 || dy >= dst.rows)
      continue;
    for (let sx = startX;sx < endX; sx++) {
      const dx = srcX + sx;
      if (dx < 0 || dx >= dst.width)
        continue;
      const srcVal = src.buffer[sy * src.pitch + sx] ?? 0;
      const dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;
      const result = srcVal + Math.floor((dstVal * (255 - srcVal) + 127) / 255);
      dst.buffer[dy * dst.pitch + dx] = Math.min(255, result);
    }
  }
}
function shiftBitmap(bitmap, shiftX, shiftY) {
  const result = createBitmap(bitmap.width, bitmap.rows, bitmap.pixelMode);
  if (bitmap.pixelMode === 1 /* Gray */) {
    for (let y = 0;y < bitmap.rows; y++) {
      const sy = y - shiftY;
      if (sy < 0 || sy >= bitmap.rows)
        continue;
      for (let x = 0;x < bitmap.width; x++) {
        const sx = x - shiftX;
        if (sx < 0 || sx >= bitmap.width)
          continue;
        result.buffer[y * result.pitch + x] = bitmap.buffer[sy * bitmap.pitch + sx] ?? 0;
      }
    }
  } else if (bitmap.pixelMode === 0 /* Mono */) {
    for (let y = 0;y < bitmap.rows; y++) {
      const sy = y - shiftY;
      if (sy < 0 || sy >= bitmap.rows)
        continue;
      for (let x = 0;x < bitmap.width; x++) {
        const sx = x - shiftX;
        if (sx < 0 || sx >= bitmap.width)
          continue;
        const srcByteIdx = sy * bitmap.pitch + (sx >> 3);
        const srcBitIdx = 7 - (sx & 7);
        const bit = (bitmap.buffer[srcByteIdx] ?? 0) >> srcBitIdx & 1;
        if (bit) {
          const dstByteIdx = y * result.pitch + (x >> 3);
          const dstBitIdx = 7 - (x & 7);
          result.buffer[dstByteIdx] |= 1 << dstBitIdx;
        }
      }
    }
  } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    for (let y = 0;y < bitmap.rows; y++) {
      const sy = y - shiftY;
      if (sy < 0 || sy >= bitmap.rows)
        continue;
      for (let x = 0;x < bitmap.width; x++) {
        const sx = x - shiftX;
        if (sx < 0 || sx >= bitmap.width)
          continue;
        const srcIdx = sy * bitmap.pitch + sx * 3;
        const dstIdx = y * result.pitch + x * 3;
        result.buffer[dstIdx] = bitmap.buffer[srcIdx] ?? 0;
        result.buffer[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;
        result.buffer[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;
      }
    }
  }
  return result;
}
function fixOutline(outlineBitmap, glyphBitmap, glyphX = 0, glyphY = 0, threshold = 128) {
  if (outlineBitmap.pixelMode !== 1 /* Gray */ || glyphBitmap.pixelMode !== 1 /* Gray */) {
    return;
  }
  const startX = Math.max(0, -glyphX);
  const startY = Math.max(0, -glyphY);
  const endX = Math.min(glyphBitmap.width, outlineBitmap.width - glyphX);
  const endY = Math.min(glyphBitmap.rows, outlineBitmap.rows - glyphY);
  for (let gy = startY;gy < endY; gy++) {
    const oy = glyphY + gy;
    if (oy < 0 || oy >= outlineBitmap.rows)
      continue;
    for (let gx = startX;gx < endX; gx++) {
      const ox = glyphX + gx;
      if (ox < 0 || ox >= outlineBitmap.width)
        continue;
      const glyphVal = glyphBitmap.buffer[gy * glyphBitmap.pitch + gx] ?? 0;
      if (glyphVal >= threshold) {
        outlineBitmap.buffer[oy * outlineBitmap.pitch + ox] = 0;
      }
    }
  }
}
function maxBitmaps(dst, src, srcX = 0, srcY = 0) {
  if (dst.pixelMode !== 1 /* Gray */ || src.pixelMode !== 1 /* Gray */) {
    return;
  }
  const startX = Math.max(0, -srcX);
  const startY = Math.max(0, -srcY);
  const endX = Math.min(src.width, dst.width - srcX);
  const endY = Math.min(src.rows, dst.rows - srcY);
  for (let sy = startY;sy < endY; sy++) {
    const dy = srcY + sy;
    if (dy < 0 || dy >= dst.rows)
      continue;
    for (let sx = startX;sx < endX; sx++) {
      const dx = srcX + sx;
      if (dx < 0 || dx >= dst.width)
        continue;
      const srcVal = src.buffer[sy * src.pitch + sx] ?? 0;
      const dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;
      dst.buffer[dy * dst.pitch + dx] = Math.max(srcVal, dstVal);
    }
  }
}
function padBitmap(bitmap, padLeft, padTop, padRight, padBottom) {
  const newWidth = bitmap.width + padLeft + padRight;
  const newHeight = bitmap.rows + padTop + padBottom;
  const result = createBitmap(newWidth, newHeight, bitmap.pixelMode);
  if (bitmap.pixelMode === 1 /* Gray */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        result.buffer[(y + padTop) * result.pitch + (x + padLeft)] = bitmap.buffer[y * bitmap.pitch + x] ?? 0;
      }
    }
  } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    for (let y = 0;y < bitmap.rows; y++) {
      for (let x = 0;x < bitmap.width; x++) {
        const srcIdx = y * bitmap.pitch + x * 3;
        const dstIdx = (y + padTop) * result.pitch + (x + padLeft) * 3;
        result.buffer[dstIdx] = bitmap.buffer[srcIdx] ?? 0;
        result.buffer[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;
        result.buffer[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;
      }
    }
  }
  return result;
}
function expandToFit(dst, src, srcX, srcY) {
  const dstLeft = 0;
  const dstTop = 0;
  const dstRight = dst.width;
  const dstBottom = dst.rows;
  const srcLeft = srcX;
  const srcTop = srcY;
  const srcRight = srcX + src.width;
  const srcBottom = srcY + src.rows;
  const left = Math.min(dstLeft, srcLeft);
  const top = Math.min(dstTop, srcTop);
  const right = Math.max(dstRight, srcRight);
  const bottom = Math.max(dstBottom, srcBottom);
  const newWidth = right - left;
  const newHeight = bottom - top;
  const expanded = createBitmap(newWidth, newHeight, dst.pixelMode);
  const dstOffsetX = dstLeft - left;
  const dstOffsetY = dstTop - top;
  const srcOffsetX = srcLeft - left;
  const srcOffsetY = srcTop - top;
  if (dst.pixelMode === 1 /* Gray */) {
    for (let y = 0;y < dst.rows; y++) {
      for (let x = 0;x < dst.width; x++) {
        expanded.buffer[(y + dstOffsetY) * expanded.pitch + (x + dstOffsetX)] = dst.buffer[y * dst.pitch + x] ?? 0;
      }
    }
  }
  return { expanded, dstOffsetX, dstOffsetY, srcOffsetX, srcOffsetY };
}
function getRowOffset(bitmap, y) {
  const pitch = bitmap.pitch;
  const absPitch = Math.abs(pitch);
  const origin = pitch < 0 ? (bitmap.rows - 1) * absPitch : 0;
  return origin + y * pitch;
}
function getPixelChannel(bitmap, x, y, channel) {
  if (x < 0 || y < 0 || x >= bitmap.width || y >= bitmap.rows)
    return 0;
  const row = getRowOffset(bitmap, y);
  switch (bitmap.pixelMode) {
    case 1 /* Gray */:
      return bitmap.buffer[row + x] ?? 0;
    case 0 /* Mono */: {
      const byteIdx = row + (x >> 3);
      const bitIdx = 7 - (x & 7);
      const bit = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1;
      return bit ? 255 : 0;
    }
    case 2 /* LCD */:
    case 3 /* LCD_V */: {
      const idx = row + x * 3 + channel;
      return bitmap.buffer[idx] ?? 0;
    }
    case 4 /* RGBA */: {
      const idx = row + x * 4 + channel;
      return bitmap.buffer[idx] ?? 0;
    }
  }
}
function sampleBilinear(bitmap, x, y, channels, out) {
  const x0 = Math.floor(x);
  const y0 = Math.floor(y);
  const x1 = x0 + 1;
  const y1 = y0 + 1;
  const wx = x - x0;
  const wy = y - y0;
  const w00 = (1 - wx) * (1 - wy);
  const w10 = wx * (1 - wy);
  const w01 = (1 - wx) * wy;
  const w11 = wx * wy;
  for (let c = 0;c < channels; c++) {
    const p00 = getPixelChannel(bitmap, x0, y0, c);
    const p10 = getPixelChannel(bitmap, x1, y0, c);
    const p01 = getPixelChannel(bitmap, x0, y1, c);
    const p11 = getPixelChannel(bitmap, x1, y1, c);
    const value = p00 * w00 + p10 * w10 + p01 * w01 + p11 * w11;
    out[c] = Math.min(255, Math.max(0, Math.round(value)));
  }
}
function invert2D(matrix) {
  const [a, b, c, d, e, f] = matrix;
  const det = a * d - b * c;
  if (det === 0)
    return null;
  const invA = d / det;
  const invB = -b / det;
  const invC = -c / det;
  const invD = a / det;
  const invE = (c * f - d * e) / det;
  const invF = (b * e - a * f) / det;
  return { inv: [invA, invB, invC, invD, invE, invF], det };
}
function invert3x3(matrix) {
  const a = matrix[0][0];
  const b = matrix[0][1];
  const c = matrix[0][2];
  const d = matrix[1][0];
  const e = matrix[1][1];
  const f = matrix[1][2];
  const g = matrix[2][0];
  const h = matrix[2][1];
  const i = matrix[2][2];
  const a00 = e * i - f * h;
  const a01 = c * h - b * i;
  const a02 = b * f - c * e;
  const a10 = f * g - d * i;
  const a11 = a * i - c * g;
  const a12 = c * d - a * f;
  const a20 = d * h - e * g;
  const a21 = b * g - a * h;
  const a22 = a * e - b * d;
  const det = a * a00 + b * a10 + c * a20;
  if (det === 0)
    return null;
  const invDet = 1 / det;
  return [
    [a00 * invDet, a01 * invDet, a02 * invDet],
    [a10 * invDet, a11 * invDet, a12 * invDet],
    [a20 * invDet, a21 * invDet, a22 * invDet]
  ];
}
function transformPoint3x3Safe(x, y, matrix) {
  const w = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2];
  const minW = 0.000001;
  const safeW = Math.abs(w) < minW ? w < 0 ? -minW : minW : w;
  return {
    x: (matrix[0][0] * x + matrix[0][1] * y + matrix[0][2]) / safeW,
    y: (matrix[1][0] * x + matrix[1][1] * y + matrix[1][2]) / safeW
  };
}
function subtractBitmap(dst, src, srcX = 0, srcY = 0) {
  subBitmaps(dst, src, srcX, srcY);
}
function fixOutlineBitmap(outlineBitmap, glyphBitmap, glyphX = 0, glyphY = 0, threshold = 128) {
  fixOutline(outlineBitmap, glyphBitmap, glyphX, glyphY, threshold);
}
function measureRasterGlyph(bitmap, bearingX, bearingY) {
  let topRow = Infinity;
  let bottomRow = -Infinity;
  for (let y = 0;y < bitmap.rows; y++) {
    for (let x = 0;x < bitmap.width; x++) {
      let covered = false;
      switch (bitmap.pixelMode) {
        case 1 /* Gray */: {
          const row = getRowOffset(bitmap, y);
          covered = (bitmap.buffer[row + x] ?? 0) > 0;
          break;
        }
        case 0 /* Mono */: {
          const row = getRowOffset(bitmap, y);
          const byteIdx = row + (x >> 3);
          const bitIdx = 7 - (x & 7);
          const bit = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1;
          covered = bit === 1;
          break;
        }
        case 2 /* LCD */:
        case 3 /* LCD_V */: {
          const row = getRowOffset(bitmap, y);
          const idx = row + x * 3;
          covered = (bitmap.buffer[idx] ?? 0) > 0 || (bitmap.buffer[idx + 1] ?? 0) > 0 || (bitmap.buffer[idx + 2] ?? 0) > 0;
          break;
        }
        case 4 /* RGBA */: {
          const row = getRowOffset(bitmap, y);
          const idx = row + x * 4;
          covered = (bitmap.buffer[idx + 3] ?? 0) > 0;
          break;
        }
      }
      if (covered) {
        topRow = Math.min(topRow, y);
        bottomRow = Math.max(bottomRow, y);
      }
    }
  }
  if (!Number.isFinite(topRow) || !Number.isFinite(bottomRow)) {
    return { ascent: 0, descent: 0 };
  }
  const ascent = bearingY - topRow;
  const descent = bottomRow + 1 - bearingY;
  return { ascent, descent };
}
function expandRasterMetrics(metrics, options) {
  const blur = options.blur ?? 0;
  const be = options.be ?? 0;
  const border = options.border ?? 0;
  const shadowX = options.shadowX ?? 0;
  const shadowY = options.shadowY ?? 0;
  const basePad = Math.ceil(blur + be + border);
  const padLeft = basePad + Math.max(0, -shadowX);
  const padRight = basePad + Math.max(0, shadowX);
  const padTop = basePad + Math.max(0, -shadowY);
  const padBottom = basePad + Math.max(0, shadowY);
  return {
    width: metrics.width + padLeft + padRight,
    height: metrics.height + padTop + padBottom,
    bearingX: metrics.bearingX - padLeft,
    bearingY: metrics.bearingY + padTop,
    ascent: metrics.ascent + padTop,
    descent: metrics.descent + padBottom,
    padLeft,
    padRight,
    padTop,
    padBottom
  };
}
function emboldenBitmapWithBearing(bitmap, bearingX, bearingY, xStrength, yStrength) {
  const padX = Math.max(0, Math.ceil(xStrength));
  const padY = Math.max(0, Math.ceil(yStrength));
  const padded = padBitmap(bitmap, padX, padY, padX, padY);
  const emboldened = emboldenBitmap(padded, xStrength, yStrength);
  return {
    bitmap: emboldened,
    bearingX: bearingX - padX,
    bearingY: bearingY + padY
  };
}
function transformBitmap2D(bitmap, matrix, options = {}) {
  const bearingX = options.bearingX ?? 0;
  const bearingY = options.bearingY ?? 0;
  const offsetX = (options.offsetX26 ?? 0) / 64;
  const offsetY = (options.offsetY26 ?? 0) / 64;
  const [a, b, c, d, e, f] = matrix;
  const adjusted = [a, b, c, d, e + offsetX, f + offsetY];
  const left = bearingX;
  const top = bearingY;
  const right = left + bitmap.width;
  const bottom = top - bitmap.rows;
  const corners = [
    {
      x: adjusted[0] * left + adjusted[2] * top + adjusted[4],
      y: adjusted[1] * left + adjusted[3] * top + adjusted[5]
    },
    {
      x: adjusted[0] * right + adjusted[2] * top + adjusted[4],
      y: adjusted[1] * right + adjusted[3] * top + adjusted[5]
    },
    {
      x: adjusted[0] * left + adjusted[2] * bottom + adjusted[4],
      y: adjusted[1] * left + adjusted[3] * bottom + adjusted[5]
    },
    {
      x: adjusted[0] * right + adjusted[2] * bottom + adjusted[4],
      y: adjusted[1] * right + adjusted[3] * bottom + adjusted[5]
    }
  ];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (const p of corners) {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }
  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
    return {
      bitmap: createBitmap(1, 1, bitmap.pixelMode),
      bearingX: 0,
      bearingY: 0
    };
  }
  const outMinX = Math.floor(minX);
  const outMaxX = Math.ceil(maxX);
  const outMinY = Math.floor(minY);
  const outMaxY = Math.ceil(maxY);
  const outWidth = Math.max(1, outMaxX - outMinX);
  const outHeight = Math.max(1, outMaxY - outMinY);
  const result = createBitmap(outWidth, outHeight, bitmap.pixelMode);
  const inverse = invert2D(adjusted);
  if (!inverse) {
    return { bitmap: result, bearingX: outMinX, bearingY: outMaxY };
  }
  const inv = inverse.inv;
  const channels = bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */ ? 3 : bitmap.pixelMode === 4 /* RGBA */ ? 4 : 1;
  const sampleBuffer = new Array(channels).fill(0);
  for (let y = 0;y < outHeight; y++) {
    for (let x = 0;x < outWidth; x++) {
      const gx = outMinX + x + 0.5;
      const gy = outMaxY - y - 0.5;
      const sxg = inv[0] * gx + inv[2] * gy + inv[4];
      const syg = inv[1] * gx + inv[3] * gy + inv[5];
      const sx = sxg - bearingX - 0.5;
      const sy = bearingY - syg - 0.5;
      sampleBilinear(bitmap, sx, sy, channels, sampleBuffer);
      if (bitmap.pixelMode === 0 /* Mono */) {
        const val = sampleBuffer[0] ?? 0;
        if (val >= 128) {
          const byteIdx = y * result.pitch + (x >> 3);
          const bitIdx = 7 - (x & 7);
          result.buffer[byteIdx] |= 1 << bitIdx;
        }
      } else if (bitmap.pixelMode === 1 /* Gray */) {
        result.buffer[y * result.pitch + x] = sampleBuffer[0] ?? 0;
      } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
        const idx = y * result.pitch + x * 3;
        result.buffer[idx] = sampleBuffer[0] ?? 0;
        result.buffer[idx + 1] = sampleBuffer[1] ?? 0;
        result.buffer[idx + 2] = sampleBuffer[2] ?? 0;
      } else if (bitmap.pixelMode === 4 /* RGBA */) {
        const idx = y * result.pitch + x * 4;
        result.buffer[idx] = sampleBuffer[0] ?? 0;
        result.buffer[idx + 1] = sampleBuffer[1] ?? 0;
        result.buffer[idx + 2] = sampleBuffer[2] ?? 0;
        result.buffer[idx + 3] = sampleBuffer[3] ?? 0;
      }
    }
  }
  return { bitmap: result, bearingX: outMinX, bearingY: outMaxY };
}
function transformBitmap3D(bitmap, matrix, options = {}) {
  const bearingX = options.bearingX ?? 0;
  const bearingY = options.bearingY ?? 0;
  const offsetX = (options.offsetX26 ?? 0) / 64;
  const offsetY = (options.offsetY26 ?? 0) / 64;
  const adjusted = [
    [matrix[0][0], matrix[0][1], matrix[0][2] + offsetX],
    [matrix[1][0], matrix[1][1], matrix[1][2] + offsetY],
    [matrix[2][0], matrix[2][1], matrix[2][2]]
  ];
  const left = bearingX;
  const top = bearingY;
  const right = left + bitmap.width;
  const bottom = top - bitmap.rows;
  const corners = [
    transformPoint3x3Safe(left, top, adjusted),
    transformPoint3x3Safe(right, top, adjusted),
    transformPoint3x3Safe(left, bottom, adjusted),
    transformPoint3x3Safe(right, bottom, adjusted)
  ];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (const p of corners) {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }
  if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
    return {
      bitmap: createBitmap(1, 1, bitmap.pixelMode),
      bearingX: 0,
      bearingY: 0
    };
  }
  const outMinX = Math.floor(minX);
  const outMaxX = Math.ceil(maxX);
  const outMinY = Math.floor(minY);
  const outMaxY = Math.ceil(maxY);
  const outWidth = Math.max(1, outMaxX - outMinX);
  const outHeight = Math.max(1, outMaxY - outMinY);
  const result = createBitmap(outWidth, outHeight, bitmap.pixelMode);
  const inverse = invert3x3(adjusted);
  if (!inverse) {
    return { bitmap: result, bearingX: outMinX, bearingY: outMaxY };
  }
  const channels = bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */ ? 3 : bitmap.pixelMode === 4 /* RGBA */ ? 4 : 1;
  const sampleBuffer = new Array(channels).fill(0);
  for (let y = 0;y < outHeight; y++) {
    for (let x = 0;x < outWidth; x++) {
      const gx = outMinX + x + 0.5;
      const gy = outMaxY - y - 0.5;
      const src = transformPoint3x3Safe(gx, gy, inverse);
      const sx = src.x - bearingX - 0.5;
      const sy = bearingY - src.y - 0.5;
      sampleBilinear(bitmap, sx, sy, channels, sampleBuffer);
      if (bitmap.pixelMode === 0 /* Mono */) {
        const val = sampleBuffer[0] ?? 0;
        if (val >= 128) {
          const byteIdx = y * result.pitch + (x >> 3);
          const bitIdx = 7 - (x & 7);
          result.buffer[byteIdx] |= 1 << bitIdx;
        }
      } else if (bitmap.pixelMode === 1 /* Gray */) {
        result.buffer[y * result.pitch + x] = sampleBuffer[0] ?? 0;
      } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
        const idx = y * result.pitch + x * 3;
        result.buffer[idx] = sampleBuffer[0] ?? 0;
        result.buffer[idx + 1] = sampleBuffer[1] ?? 0;
        result.buffer[idx + 2] = sampleBuffer[2] ?? 0;
      } else if (bitmap.pixelMode === 4 /* RGBA */) {
        const idx = y * result.pitch + x * 4;
        result.buffer[idx] = sampleBuffer[0] ?? 0;
        result.buffer[idx + 1] = sampleBuffer[1] ?? 0;
        result.buffer[idx + 2] = sampleBuffer[2] ?? 0;
        result.buffer[idx + 3] = sampleBuffer[3] ?? 0;
      }
    }
  }
  return { bitmap: result, bearingX: outMinX, bearingY: outMaxY };
}
function shearBitmapX(bitmap, amount, options = {}) {
  return transformBitmap2D(bitmap, [1, 0, amount, 1, 0, 0], options);
}
function shearBitmapY(bitmap, amount, options = {}) {
  return transformBitmap2D(bitmap, [1, amount, 0, 1, 0, 0], options);
}

// reference/text-shaper/src/raster/size.ts
function resolveFontSize(font, fontSize, sizeMode) {
  if (sizeMode !== "height")
    return fontSize;
  if (!Number.isFinite(fontSize) || fontSize <= 0)
    return fontSize;
  const baseHeight = font.ascender - font.descender;
  const height = font.isCFF ? baseHeight : baseHeight + font.lineGap;
  if (!Number.isFinite(height) || height <= 0)
    return fontSize;
  return fontSize * font.unitsPerEm / height;
}
function resolveFontScale(font, fontSize, sizeMode) {
  const effectiveSize = resolveFontSize(font, fontSize, sizeMode);
  return effectiveSize / font.unitsPerEm;
}

// reference/text-shaper/src/raster/bbox.ts
function getExactBounds(path) {
  if (!path.commands || path.commands.length === 0) {
    return null;
  }
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  let currentX = 0;
  let currentY = 0;
  let hasPoints = false;
  const updateBounds = (x, y) => {
    xMin = Math.min(xMin, x);
    yMin = Math.min(yMin, y);
    xMax = Math.max(xMax, x);
    yMax = Math.max(yMax, y);
    hasPoints = true;
  };
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M": {
        currentX = cmd.x;
        currentY = cmd.y;
        updateBounds(currentX, currentY);
        break;
      }
      case "L": {
        currentX = cmd.x;
        currentY = cmd.y;
        updateBounds(currentX, currentY);
        break;
      }
      case "Q": {
        updateBounds(cmd.x, cmd.y);
        const xExtrema = getQuadraticExtrema(currentX, cmd.x1, cmd.x);
        for (let j = 0;j < xExtrema.length; j++) {
          const t = xExtrema[j];
          const x = evaluateQuadratic(currentX, cmd.x1, cmd.x, t);
          updateBounds(x, currentY);
        }
        const yExtrema = getQuadraticExtrema(currentY, cmd.y1, cmd.y);
        for (let j = 0;j < yExtrema.length; j++) {
          const t = yExtrema[j];
          const y = evaluateQuadratic(currentY, cmd.y1, cmd.y, t);
          updateBounds(currentX, y);
        }
        const allExtrema = new Set([...xExtrema, ...yExtrema]);
        const extremaArray = [...allExtrema];
        for (let j = 0;j < extremaArray.length; j++) {
          const t = extremaArray[j];
          const x = evaluateQuadratic(currentX, cmd.x1, cmd.x, t);
          const y = evaluateQuadratic(currentY, cmd.y1, cmd.y, t);
          updateBounds(x, y);
        }
        currentX = cmd.x;
        currentY = cmd.y;
        break;
      }
      case "C": {
        updateBounds(cmd.x, cmd.y);
        const xExtrema = getCubicExtrema(currentX, cmd.x1, cmd.x2, cmd.x);
        for (let j = 0;j < xExtrema.length; j++) {
          const t = xExtrema[j];
          const x = evaluateCubic(currentX, cmd.x1, cmd.x2, cmd.x, t);
          updateBounds(x, currentY);
        }
        const yExtrema = getCubicExtrema(currentY, cmd.y1, cmd.y2, cmd.y);
        for (let j = 0;j < yExtrema.length; j++) {
          const t = yExtrema[j];
          const y = evaluateCubic(currentY, cmd.y1, cmd.y2, cmd.y, t);
          updateBounds(currentX, y);
        }
        const allExtrema = new Set([...xExtrema, ...yExtrema]);
        const extremaArray = [...allExtrema];
        for (let j = 0;j < extremaArray.length; j++) {
          const t = extremaArray[j];
          const x = evaluateCubic(currentX, cmd.x1, cmd.x2, cmd.x, t);
          const y = evaluateCubic(currentY, cmd.y1, cmd.y2, cmd.y, t);
          updateBounds(x, y);
        }
        currentX = cmd.x;
        currentY = cmd.y;
        break;
      }
      case "Z": {
        break;
      }
    }
  }
  if (!hasPoints) {
    return null;
  }
  return { xMin, yMin, xMax, yMax };
}
function getQuadraticExtrema(p0, p1, p2) {
  const denominator = p0 - 2 * p1 + p2;
  if (Math.abs(denominator) < 0.0000000001) {
    return [];
  }
  const t = (p0 - p1) / denominator;
  if (t > 0 && t < 1) {
    return [t];
  }
  return [];
}
function getCubicExtrema(p0, p1, p2, p3) {
  const a = 3 * (p3 - 3 * p2 + 3 * p1 - p0);
  const b = 6 * (p2 - 2 * p1 + p0);
  const c = 3 * (p1 - p0);
  const extrema = [];
  if (Math.abs(a) < 0.0000000001) {
    if (Math.abs(b) < 0.0000000001) {
      return [];
    }
    const t = -c / b;
    if (t > 0 && t < 1) {
      extrema.push(t);
    }
    return extrema;
  }
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) {
    return [];
  }
  if (Math.abs(discriminant) < 0.0000000001) {
    const t = -b / (2 * a);
    if (t > 0 && t < 1) {
      extrema.push(t);
    }
    return extrema;
  }
  const sqrtD = Math.sqrt(discriminant);
  const t1 = (-b + sqrtD) / (2 * a);
  const t2 = (-b - sqrtD) / (2 * a);
  if (t1 > 0 && t1 < 1) {
    extrema.push(t1);
  }
  if (t2 > 0 && t2 < 1) {
    extrema.push(t2);
  }
  return extrema;
}
function evaluateQuadratic(p0, p1, p2, t) {
  const oneMinusT = 1 - t;
  return oneMinusT * oneMinusT * p0 + 2 * oneMinusT * t * p1 + t * t * p2;
}
function evaluateCubic(p0, p1, p2, p3, t) {
  const oneMinusT = 1 - t;
  const oneMinusT2 = oneMinusT * oneMinusT;
  const t2 = t * t;
  return oneMinusT2 * oneMinusT * p0 + 3 * oneMinusT2 * t * p1 + 3 * oneMinusT * t2 * p2 + t2 * t * p3;
}
// reference/text-shaper/src/raster/blur.ts
init_types();
function createGaussianKernel(radius) {
  if (radius <= 0) {
    return new Float32Array([1]);
  }
  const sigma = radius;
  const size = Math.ceil(radius * 2) * 2 + 1;
  const kernel = new Float32Array(size);
  const center = Math.floor(size / 2);
  let sum = 0;
  for (let i = 0;i < size; i++) {
    const x = i - center;
    const weight = Math.exp(-(x * x) / (2 * sigma * sigma));
    kernel[i] = weight;
    sum += weight;
  }
  for (let i = 0;i < size; i++) {
    kernel[i] /= sum;
  }
  return kernel;
}
function convolveHorizontal(src, dst, width, height, srcPitch, dstPitch, kernel, channels) {
  const radius = Math.floor(kernel.length / 2);
  for (let y = 0;y < height; y++) {
    for (let x = 0;x < width; x++) {
      for (let c = 0;c < channels; c++) {
        let sum = 0;
        for (let k = 0;k < kernel.length; k++) {
          const sx = x + k - radius;
          const clampedX = Math.max(0, Math.min(width - 1, sx));
          const srcIdx = y * srcPitch + clampedX * channels + c;
          sum += (src[srcIdx] ?? 0) * kernel[k];
        }
        const dstIdx = y * dstPitch + x * channels + c;
        dst[dstIdx] = Math.min(255, Math.max(0, Math.round(sum)));
      }
    }
  }
}
function convolveVertical(src, dst, width, height, srcPitch, dstPitch, kernel, channels) {
  const radius = Math.floor(kernel.length / 2);
  for (let y = 0;y < height; y++) {
    for (let x = 0;x < width; x++) {
      for (let c = 0;c < channels; c++) {
        let sum = 0;
        for (let k = 0;k < kernel.length; k++) {
          const sy = y + k - radius;
          const clampedY = Math.max(0, Math.min(height - 1, sy));
          const srcIdx = clampedY * srcPitch + x * channels + c;
          sum += (src[srcIdx] ?? 0) * kernel[k];
        }
        const dstIdx = y * dstPitch + x * channels + c;
        dst[dstIdx] = Math.min(255, Math.max(0, Math.round(sum)));
      }
    }
  }
}
function gaussianBlur(bitmap, radius) {
  if (bitmap.pixelMode === 0 /* Mono */) {
    const converted = convertBitmap(bitmap, 1 /* Gray */);
    return gaussianBlur(converted, radius);
  }
  if (radius <= 0) {
    return bitmap;
  }
  const kernel = createGaussianKernel(radius);
  let channels = 1;
  if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    channels = 3;
  } else if (bitmap.pixelMode === 4 /* RGBA */) {
    channels = 4;
  }
  const temp = new Uint8Array(bitmap.buffer.length);
  convolveHorizontal(bitmap.buffer, temp, bitmap.width, bitmap.rows, bitmap.pitch, bitmap.pitch, kernel, channels);
  convolveVertical(temp, bitmap.buffer, bitmap.width, bitmap.rows, bitmap.pitch, bitmap.pitch, kernel, channels);
  return bitmap;
}
function boxBlur(bitmap, radius) {
  if (bitmap.pixelMode === 0 /* Mono */) {
    const converted = convertBitmap(bitmap, 1 /* Gray */);
    return boxBlur(converted, radius);
  }
  if (radius <= 0) {
    return bitmap;
  }
  let channels = 1;
  if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
    channels = 3;
  } else if (bitmap.pixelMode === 4 /* RGBA */) {
    channels = 4;
  }
  const iRadius = Math.floor(radius);
  const _kernelSize = iRadius * 2 + 1;
  const temp = new Uint8Array(bitmap.buffer.length);
  for (let y = 0;y < bitmap.rows; y++) {
    for (let c = 0;c < channels; c++) {
      let sum = 0;
      let count = 0;
      for (let x = -iRadius;x <= iRadius; x++) {
        if (x >= 0 && x < bitmap.width) {
          const idx = y * bitmap.pitch + x * channels + c;
          sum += bitmap.buffer[idx] ?? 0;
          count++;
        }
      }
      const dstIdx0 = y * bitmap.pitch + 0 * channels + c;
      temp[dstIdx0] = Math.round(sum / count);
      for (let x = 1;x < bitmap.width; x++) {
        const leftX = x - iRadius - 1;
        if (leftX >= 0) {
          const leftIdx = y * bitmap.pitch + leftX * channels + c;
          sum -= bitmap.buffer[leftIdx] ?? 0;
          count--;
        }
        const rightX = x + iRadius;
        if (rightX < bitmap.width) {
          const rightIdx = y * bitmap.pitch + rightX * channels + c;
          sum += bitmap.buffer[rightIdx] ?? 0;
          count++;
        }
        const dstIdx = y * bitmap.pitch + x * channels + c;
        temp[dstIdx] = Math.round(sum / count);
      }
    }
  }
  for (let x = 0;x < bitmap.width; x++) {
    for (let c = 0;c < channels; c++) {
      let sum = 0;
      let count = 0;
      for (let y = -iRadius;y <= iRadius; y++) {
        if (y >= 0 && y < bitmap.rows) {
          const idx = y * bitmap.pitch + x * channels + c;
          sum += temp[idx] ?? 0;
          count++;
        }
      }
      const dstIdx0 = 0 * bitmap.pitch + x * channels + c;
      bitmap.buffer[dstIdx0] = Math.round(sum / count);
      for (let y = 1;y < bitmap.rows; y++) {
        const topY = y - iRadius - 1;
        if (topY >= 0) {
          const topIdx = topY * bitmap.pitch + x * channels + c;
          sum -= temp[topIdx] ?? 0;
          count--;
        }
        const bottomY = y + iRadius;
        if (bottomY < bitmap.rows) {
          const bottomIdx = bottomY * bitmap.pitch + x * channels + c;
          sum += temp[bottomIdx] ?? 0;
          count++;
        }
        const dstIdx = y * bitmap.pitch + x * channels + c;
        bitmap.buffer[dstIdx] = Math.round(sum / count);
      }
    }
  }
  return bitmap;
}
function blurBitmap(bitmap, radius, type = "gaussian") {
  if (type === "box") {
    return boxBlur(bitmap, radius);
  } else {
    return gaussianBlur(bitmap, radius);
  }
}
// reference/text-shaper/src/raster/gradient.ts
init_types();
function lerpColor(color1, color2, t) {
  return [
    Math.round(color1[0] + (color2[0] - color1[0]) * t),
    Math.round(color1[1] + (color2[1] - color1[1]) * t),
    Math.round(color1[2] + (color2[2] - color1[2]) * t),
    Math.round(color1[3] + (color2[3] - color1[3]) * t)
  ];
}
function interpolateGradient(gradient, x, y) {
  if (gradient.stops.length === 0) {
    return [0, 0, 0, 0];
  }
  if (gradient.stops.length === 1) {
    return gradient.stops[0].color;
  }
  let t;
  if (gradient.type === "linear") {
    const dx = gradient.x1 - gradient.x0;
    const dy = gradient.y1 - gradient.y0;
    const lengthSq = dx * dx + dy * dy;
    if (lengthSq === 0) {
      return gradient.stops[0].color;
    }
    const px = x - gradient.x0;
    const py = y - gradient.y0;
    t = (px * dx + py * dy) / lengthSq;
  } else {
    const dx = x - gradient.cx;
    const dy = y - gradient.cy;
    const distance = Math.sqrt(dx * dx + dy * dy);
    t = gradient.radius > 0 ? distance / gradient.radius : 0;
  }
  t = Math.max(0, Math.min(1, t));
  const sortedStops = [...gradient.stops].sort((a, b) => a.offset - b.offset);
  if (t <= sortedStops[0].offset) {
    return sortedStops[0].color;
  }
  if (t >= sortedStops[sortedStops.length - 1].offset) {
    return sortedStops[sortedStops.length - 1].color;
  }
  for (let i = 0;i < sortedStops.length - 1; i++) {
    const stop1 = sortedStops[i];
    const stop2 = sortedStops[i + 1];
    if (t >= stop1.offset && t <= stop2.offset) {
      const range = stop2.offset - stop1.offset;
      if (range === 0) {
        return stop2.color;
      }
      const localT = (t - stop1.offset) / range;
      return lerpColor(stop1.color, stop2.color, localT);
    }
  }
  return sortedStops[sortedStops.length - 1].color;
}
function createGradientBitmap(width, height, gradient) {
  const bitmap = createBitmap(width, height, 4 /* RGBA */);
  for (let y = 0;y < height; y++) {
    for (let x = 0;x < width; x++) {
      const color = interpolateGradient(gradient, x, y);
      const idx = (y * width + x) * 4;
      bitmap.buffer[idx] = color[0];
      bitmap.buffer[idx + 1] = color[1];
      bitmap.buffer[idx + 2] = color[2];
      bitmap.buffer[idx + 3] = color[3];
    }
  }
  return bitmap;
}
function rasterizePathWithGradient(path, gradient, options) {
  const { width, height } = options;
  const coverageBitmap = rasterizePath(path, {
    ...options,
    pixelMode: 1 /* Gray */,
    flipY: options.flipY ?? false
  });
  const resultBitmap = createBitmap(width, height, 4 /* RGBA */);
  for (let y = 0;y < height; y++) {
    for (let x = 0;x < width; x++) {
      const coverage = coverageBitmap.buffer[y * coverageBitmap.pitch + x] ?? 0;
      if (coverage > 0) {
        const color = interpolateGradient(gradient, x, y);
        const idx = (y * width + x) * 4;
        const alpha = color[3] * coverage / 255;
        resultBitmap.buffer[idx] = color[0];
        resultBitmap.buffer[idx + 1] = color[1];
        resultBitmap.buffer[idx + 2] = color[2];
        resultBitmap.buffer[idx + 3] = Math.round(alpha);
      }
    }
  }
  return resultBitmap;
}
// reference/text-shaper/src/raster/sdf.ts
init_types();
function renderSdf(path, options) {
  const {
    width,
    height,
    scale,
    offsetX = 0,
    offsetY = 0,
    flipY = false,
    spread = 8
  } = options;
  const bitmap = createBitmap(width, height, 1 /* Gray */);
  const edges = extractEdges(path, scale, offsetX, offsetY, flipY);
  if (edges.length === 0) {
    bitmap.buffer.fill(0);
    return bitmap;
  }
  for (let y = 0;y < height; y++) {
    for (let x = 0;x < width; x++) {
      const px = x + 0.5;
      const py = y + 0.5;
      let minDist = Infinity;
      for (let k = 0;k < edges.length; k++) {
        const edge = edges[k];
        const dist = distanceToEdge(px, py, edge);
        minDist = Math.min(minDist, dist);
      }
      const inside = isPointInside(px, py, edges);
      const signedDist = inside ? minDist : -minDist;
      const normalized = 128 + signedDist / spread * 127;
      const clamped = Math.max(0, Math.min(255, Math.round(normalized)));
      bitmap.buffer[y * bitmap.pitch + x] = clamped;
    }
  }
  return bitmap;
}
function extractEdges(path, scale, offsetX, offsetY, flipY) {
  const edges = [];
  let currentPoint = null;
  let firstPoint = null;
  const transform = (x, y) => ({
    x: x * scale + offsetX,
    y: flipY ? -(y * scale) + offsetY : y * scale + offsetY
  });
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        currentPoint = transform(cmd.x, cmd.y);
        firstPoint = currentPoint;
        break;
      case "L":
        if (currentPoint) {
          const p1 = transform(cmd.x, cmd.y);
          edges.push({ type: "line", p0: currentPoint, p1 });
          currentPoint = p1;
        }
        break;
      case "Q":
        if (currentPoint) {
          const p1 = transform(cmd.x1, cmd.y1);
          const p2 = transform(cmd.x, cmd.y);
          edges.push({ type: "quadratic", p0: currentPoint, p1, p2 });
          currentPoint = p2;
        }
        break;
      case "C":
        if (currentPoint) {
          const p1 = transform(cmd.x1, cmd.y1);
          const p2 = transform(cmd.x2, cmd.y2);
          const p3 = transform(cmd.x, cmd.y);
          edges.push({ type: "cubic", p0: currentPoint, p1, p2, p3 });
          currentPoint = p3;
        }
        break;
      case "Z":
        if (currentPoint && firstPoint) {
          if (Math.abs(currentPoint.x - firstPoint.x) > 0.001 || Math.abs(currentPoint.y - firstPoint.y) > 0.001) {
            edges.push({ type: "line", p0: currentPoint, p1: firstPoint });
          }
          currentPoint = firstPoint;
        }
        break;
    }
  }
  return edges;
}
function distanceToEdge(px, py, edge) {
  switch (edge.type) {
    case "line":
      return distanceToLine(px, py, edge.p0, edge.p1);
    case "quadratic":
      return distanceToQuadratic(px, py, edge.p0, edge.p1, edge.p2);
    case "cubic":
      return distanceToCubic(px, py, edge.p0, edge.p1, edge.p2, edge.p3);
  }
}
function distanceToLine(px, py, p0, p1) {
  const dx = p1.x - p0.x;
  const dy = p1.y - p0.y;
  const lenSq = dx * dx + dy * dy;
  if (lenSq < 0.0001) {
    const dpx = px - p0.x;
    const dpy = py - p0.y;
    return Math.sqrt(dpx * dpx + dpy * dpy);
  }
  let t = ((px - p0.x) * dx + (py - p0.y) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  const closestX = p0.x + t * dx;
  const closestY = p0.y + t * dy;
  const distX = px - closestX;
  const distY = py - closestY;
  return Math.sqrt(distX * distX + distY * distY);
}
function distanceToQuadratic(px, py, p0, p1, p2) {
  let minDist = Infinity;
  const samples = 32;
  for (let i = 0;i <= samples; i++) {
    const t = i / samples;
    const ti = 1 - t;
    const x = ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x;
    const y = ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y;
    const dx = px - x;
    const dy = py - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    minDist = Math.min(minDist, dist);
  }
  return minDist;
}
function distanceToCubic(px, py, p0, p1, p2, p3) {
  let minDist = Infinity;
  const samples = 32;
  for (let i = 0;i <= samples; i++) {
    const t = i / samples;
    const ti = 1 - t;
    const x = ti * ti * ti * p0.x + 3 * ti * ti * t * p1.x + 3 * ti * t * t * p2.x + t * t * t * p3.x;
    const y = ti * ti * ti * p0.y + 3 * ti * ti * t * p1.y + 3 * ti * t * t * p2.y + t * t * t * p3.y;
    const dx = px - x;
    const dy = py - y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    minDist = Math.min(minDist, dist);
  }
  return minDist;
}
function isPointInside(px, py, edges) {
  let crossings = 0;
  for (let i = 0;i < edges.length; i++) {
    const edge = edges[i];
    const points = flattenEdge(edge);
    for (let j = 0;j < points.length - 1; j++) {
      const p0 = points[j];
      const p1 = points[j + 1];
      if (!p0 || !p1)
        continue;
      if (p0.y > py !== p1.y > py) {
        const slope = (p1.x - p0.x) / (p1.y - p0.y);
        const x = p0.x + slope * (py - p0.y);
        if (px < x) {
          crossings++;
        }
      }
    }
  }
  return (crossings & 1) === 1;
}
function flattenEdge(edge) {
  switch (edge.type) {
    case "line":
      return [edge.p0, edge.p1];
    case "quadratic": {
      const points = [edge.p0];
      const samples = 16;
      for (let i = 1;i <= samples; i++) {
        const t = i / samples;
        const ti = 1 - t;
        points.push({
          x: ti * ti * edge.p0.x + 2 * ti * t * edge.p1.x + t * t * edge.p2.x,
          y: ti * ti * edge.p0.y + 2 * ti * t * edge.p1.y + t * t * edge.p2.y
        });
      }
      return points;
    }
    case "cubic": {
      const points = [edge.p0];
      const samples = 16;
      for (let i = 1;i <= samples; i++) {
        const t = i / samples;
        const ti = 1 - t;
        points.push({
          x: ti * ti * ti * edge.p0.x + 3 * ti * ti * t * edge.p1.x + 3 * ti * t * t * edge.p2.x + t * t * t * edge.p3.x,
          y: ti * ti * ti * edge.p0.y + 3 * ti * ti * t * edge.p1.y + 3 * ti * t * t * edge.p2.y + t * t * t * edge.p3.y
        });
      }
      return points;
    }
  }
}
// reference/text-shaper/src/raster/stroker.ts
function normalize(v) {
  const len = Math.sqrt(v.x * v.x + v.y * v.y);
  if (len === 0)
    return { x: 0, y: 0 };
  return { x: v.x / len, y: v.y / len };
}
function perp(v) {
  return { x: -v.y, y: v.x };
}
function angleBetween(v1, v2) {
  const dot = v1.x * v2.x + v1.y * v2.y;
  const cross = v1.x * v2.y - v1.y * v2.x;
  return Math.atan2(cross, dot);
}
function addRoundCap(commands, center, direction, radius, clockwise) {
  const perpDir = perp(direction);
  const start = {
    x: center.x + perpDir.x * radius * (clockwise ? 1 : -1),
    y: center.y + perpDir.y * radius * (clockwise ? 1 : -1)
  };
  const end = {
    x: center.x - perpDir.x * radius * (clockwise ? 1 : -1),
    y: center.y - perpDir.y * radius * (clockwise ? 1 : -1)
  };
  const mid = {
    x: center.x + direction.x * radius,
    y: center.y + direction.y * radius
  };
  const ctrl1 = {
    x: start.x + direction.x * radius * 0.5523,
    y: start.y + direction.y * radius * 0.5523
  };
  const ctrl2 = {
    x: end.x + direction.x * radius * 0.5523,
    y: end.y + direction.y * radius * 0.5523
  };
  commands.push({ type: "Q", x1: ctrl1.x, y1: ctrl1.y, x: mid.x, y: mid.y });
  commands.push({ type: "Q", x1: ctrl2.x, y1: ctrl2.y, x: end.x, y: end.y });
}
function addSquareCap(commands, center, direction, radius) {
  const perpDir = perp(direction);
  const extended = {
    x: center.x + direction.x * radius,
    y: center.y + direction.y * radius
  };
  const corner1 = {
    x: extended.x + perpDir.x * radius,
    y: extended.y + perpDir.y * radius
  };
  const corner2 = {
    x: extended.x - perpDir.x * radius,
    y: extended.y - perpDir.y * radius
  };
  commands.push({ type: "L", x: corner1.x, y: corner1.y });
  commands.push({ type: "L", x: corner2.x, y: corner2.y });
}
function addJoin(commands, point, prevDir, nextDir, radius, lineJoin, miterLimit, outer) {
  const angle = angleBetween(prevDir, nextDir);
  const isConvex = outer ? angle < 0 : angle > 0;
  if (Math.abs(angle) < 0.01) {
    return;
  }
  const prevPerp = perp(prevDir);
  const nextPerp = perp(nextDir);
  const sign2 = outer ? 1 : -1;
  const _prevOffset = {
    x: point.x + prevPerp.x * radius * sign2,
    y: point.y + prevPerp.y * radius * sign2
  };
  const nextOffset = {
    x: point.x + nextPerp.x * radius * sign2,
    y: point.y + nextPerp.y * radius * sign2
  };
  if (!isConvex) {
    commands.push({ type: "L", x: nextOffset.x, y: nextOffset.y });
    return;
  }
  switch (lineJoin) {
    case "round": {
      const arcAngle = Math.abs(angle);
      const numSegments = Math.max(2, Math.ceil(arcAngle / (Math.PI / 4)));
      for (let i = 1;i <= numSegments; i++) {
        const t = i / numSegments;
        const currentAngle = Math.atan2(prevPerp.y, prevPerp.x) + angle * t * sign2;
        const px = point.x + Math.cos(currentAngle) * radius * sign2;
        const py = point.y + Math.sin(currentAngle) * radius * sign2;
        commands.push({ type: "L", x: px, y: py });
      }
      break;
    }
    case "miter": {
      const miterLength = 1 / Math.sin(Math.abs(angle) / 2);
      if (miterLength <= miterLimit) {
        const halfAngle = angle / 2;
        const miterDir = normalize({
          x: prevDir.x + nextDir.x,
          y: prevDir.y + nextDir.y
        });
        const miterDist = radius / Math.cos(halfAngle);
        const miterPoint = {
          x: point.x + miterDir.x * miterDist * sign2,
          y: point.y + miterDir.y * miterDist * sign2
        };
        commands.push({ type: "L", x: miterPoint.x, y: miterPoint.y });
        commands.push({ type: "L", x: nextOffset.x, y: nextOffset.y });
      } else {
        commands.push({ type: "L", x: nextOffset.x, y: nextOffset.y });
      }
      break;
    }
    default:
      commands.push({ type: "L", x: nextOffset.x, y: nextOffset.y });
      break;
  }
}
function strokeContour(points, options) {
  if (points.length < 2)
    return [];
  const { width, lineJoin, miterLimit } = options;
  const radius = width / 2;
  const commands = [];
  const n = points.length;
  const directions = [];
  for (let i = 0;i < n; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % n];
    if (!p1 || !p2)
      continue;
    directions.push(normalize({ x: p2.x - p1.x, y: p2.y - p1.y }));
  }
  const firstDir = directions[0];
  const firstPoint = points[0];
  if (!firstDir || !firstPoint)
    return [];
  const firstPerp = perp(firstDir);
  commands.push({
    type: "M",
    x: firstPoint.x + firstPerp.x * radius,
    y: firstPoint.y + firstPerp.y * radius
  });
  for (let i = 0;i < n; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % n];
    const dir = directions[i];
    const nextDir = directions[(i + 1) % n];
    if (!p1 || !p2 || !dir || !nextDir)
      continue;
    const perpDir = perp(dir);
    commands.push({
      type: "L",
      x: p2.x + perpDir.x * radius,
      y: p2.y + perpDir.y * radius
    });
    addJoin(commands, p2, dir, nextDir, radius, lineJoin, miterLimit, true);
  }
  commands.push({ type: "Z" });
  const lastIdx = n - 1;
  const lastDir = directions[lastIdx];
  const lastPoint = points[0];
  if (!lastDir || !lastPoint)
    return commands;
  const lastPerp = perp(firstDir);
  commands.push({
    type: "M",
    x: firstPoint.x - lastPerp.x * radius,
    y: firstPoint.y - lastPerp.y * radius
  });
  for (let i = 0;i < n; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % n];
    const dir = directions[i];
    const nextDir = directions[(i + 1) % n];
    if (!p1 || !p2 || !dir || !nextDir)
      continue;
    const perpDir = perp(dir);
    commands.push({
      type: "L",
      x: p2.x - perpDir.x * radius,
      y: p2.y - perpDir.y * radius
    });
    addJoin(commands, p2, dir, nextDir, radius, lineJoin, miterLimit, false);
  }
  commands.push({ type: "Z" });
  return commands;
}
function strokeOpenPath(points, options) {
  if (points.length < 2)
    return [];
  const { width, lineCap, lineJoin, miterLimit } = options;
  const radius = width / 2;
  const commands = [];
  const n = points.length;
  const directions = [];
  for (let i = 0;i < n - 1; i++) {
    const p1 = points[i];
    const p2 = points[i + 1];
    if (!p1 || !p2)
      continue;
    directions.push(normalize({ x: p2.x - p1.x, y: p2.y - p1.y }));
  }
  const firstPoint = points[0];
  const lastPoint = points[n - 1];
  const firstDir = directions[0];
  const lastDir = directions[directions.length - 1];
  if (!firstPoint || !lastPoint || !firstDir || !lastDir)
    return [];
  const firstPerp = perp(firstDir);
  commands.push({
    type: "M",
    x: firstPoint.x + firstPerp.x * radius,
    y: firstPoint.y + firstPerp.y * radius
  });
  for (let i = 0;i < n - 1; i++) {
    const p2 = points[i + 1];
    const dir = directions[i];
    const nextDir = directions[i + 1];
    if (!p2 || !dir)
      continue;
    const perpDir = perp(dir);
    commands.push({
      type: "L",
      x: p2.x + perpDir.x * radius,
      y: p2.y + perpDir.y * radius
    });
    if (nextDir) {
      addJoin(commands, p2, dir, nextDir, radius, lineJoin, miterLimit, true);
    }
  }
  const _negLastDir = { x: -lastDir.x, y: -lastDir.y };
  switch (lineCap) {
    case "round":
      addRoundCap(commands, lastPoint, lastDir, radius, true);
      break;
    case "square":
      addSquareCap(commands, lastPoint, lastDir, radius);
      break;
    default: {
      const lastPerp = perp(lastDir);
      commands.push({
        type: "L",
        x: lastPoint.x - lastPerp.x * radius,
        y: lastPoint.y - lastPerp.y * radius
      });
      break;
    }
  }
  for (let i = n - 2;i >= 0; i--) {
    const p1 = points[i];
    const dir = directions[i];
    const prevDir = directions[i - 1];
    if (!p1 || !dir)
      continue;
    const perpDir = perp(dir);
    commands.push({
      type: "L",
      x: p1.x - perpDir.x * radius,
      y: p1.y - perpDir.y * radius
    });
    if (prevDir) {
      addJoin(commands, p1, { x: -dir.x, y: -dir.y }, { x: -prevDir.x, y: -prevDir.y }, radius, lineJoin, miterLimit, true);
    }
  }
  const negFirstDir = { x: -firstDir.x, y: -firstDir.y };
  switch (lineCap) {
    case "round":
      addRoundCap(commands, firstPoint, negFirstDir, radius, true);
      break;
    case "square":
      addSquareCap(commands, firstPoint, negFirstDir, radius);
      break;
    default:
      break;
  }
  commands.push({ type: "Z" });
  return commands;
}
function extractContours(path) {
  const contours = [];
  let currentContour = [];
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        if (currentContour.length > 0) {
          contours.push({ points: currentContour, closed: false });
        }
        currentContour = [{ x: cmd.x, y: cmd.y }];
        break;
      case "L":
        currentContour.push({ x: cmd.x, y: cmd.y });
        break;
      case "Q": {
        const last = currentContour[currentContour.length - 1];
        if (last) {
          const steps = 8;
          for (let j = 1;j <= steps; j++) {
            const t = j / steps;
            const ti = 1 - t;
            const x = ti * ti * last.x + 2 * ti * t * cmd.x1 + t * t * cmd.x;
            const y = ti * ti * last.y + 2 * ti * t * cmd.y1 + t * t * cmd.y;
            currentContour.push({ x, y });
          }
        }
        break;
      }
      case "C": {
        const last = currentContour[currentContour.length - 1];
        if (last) {
          const steps = 12;
          for (let j = 1;j <= steps; j++) {
            const t = j / steps;
            const ti = 1 - t;
            const x = ti * ti * ti * last.x + 3 * ti * ti * t * cmd.x1 + 3 * ti * t * t * cmd.x2 + t * t * t * cmd.x;
            const y = ti * ti * ti * last.y + 3 * ti * ti * t * cmd.y1 + 3 * ti * t * t * cmd.y2 + t * t * t * cmd.y;
            currentContour.push({ x, y });
          }
        }
        break;
      }
      case "Z":
        if (currentContour.length > 0) {
          contours.push({ points: currentContour, closed: true });
          currentContour = [];
        }
        break;
    }
  }
  if (currentContour.length > 0) {
    contours.push({ points: currentContour, closed: false });
  }
  return contours;
}
function strokePath(path, options) {
  const opts = {
    width: options.width,
    lineCap: options.lineCap ?? "butt",
    lineJoin: options.lineJoin ?? "miter",
    miterLimit: options.miterLimit ?? 4
  };
  const contours = extractContours(path);
  const commands = [];
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    if (contour.points.length < 2)
      continue;
    const contourCommands = contour.closed ? strokeContour(contour.points, opts) : strokeOpenPath(contour.points, opts);
    commands.push(...contourCommands);
  }
  let bounds = path.bounds;
  if (bounds) {
    const padding = opts.width / 2;
    bounds = {
      xMin: bounds.xMin - padding,
      yMin: bounds.yMin - padding,
      xMax: bounds.xMax + padding,
      yMax: bounds.yMax + padding
    };
  }
  return { commands, bounds };
}
// reference/text-shaper/src/raster/asymmetric-stroke.ts
function computeAsymmetricOffset(dx, dy, xBorder, yBorder) {
  const px = -dy * yBorder;
  const py = dx * xBorder;
  const len = Math.sqrt(px * px + py * py);
  if (len < 0.0000000001) {
    return { x: 0, y: 0, len: 0 };
  }
  return {
    x: px / len,
    y: py / len,
    len
  };
}
function flattenQuadratic(p0, p1, p2, eps, result) {
  const dx = p2.x - p0.x;
  const dy = p2.y - p0.y;
  const d = Math.abs((p1.x - p0.x) * dy - (p1.y - p0.y) * dx) / Math.sqrt(dx * dx + dy * dy + 0.0000000001);
  if (d <= eps) {
    result.push(p2);
    return;
  }
  const p01 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
  const p12 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
  const p012 = { x: (p01.x + p12.x) / 2, y: (p01.y + p12.y) / 2 };
  flattenQuadratic(p0, p01, p012, eps, result);
  flattenQuadratic(p012, p12, p2, eps, result);
}
function flattenCubic(p0, p1, p2, p3, eps, result) {
  const dx = p3.x - p0.x;
  const dy = p3.y - p0.y;
  const lenSq = dx * dx + dy * dy + 0.0000000001;
  const d1 = Math.abs((p1.x - p0.x) * dy - (p1.y - p0.y) * dx) / Math.sqrt(lenSq);
  const d2 = Math.abs((p2.x - p0.x) * dy - (p2.y - p0.y) * dx) / Math.sqrt(lenSq);
  if (d1 <= eps && d2 <= eps) {
    result.push(p3);
    return;
  }
  const p01 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
  const p12 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
  const p23 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };
  const p012 = { x: (p01.x + p12.x) / 2, y: (p01.y + p12.y) / 2 };
  const p123 = { x: (p12.x + p23.x) / 2, y: (p12.y + p23.y) / 2 };
  const p0123 = { x: (p012.x + p123.x) / 2, y: (p012.y + p123.y) / 2 };
  flattenCubic(p0, p01, p012, p0123, eps, result);
  flattenCubic(p0123, p123, p23, p3, eps, result);
}
function pathToContours(path, eps) {
  const contours = [];
  let current = [];
  let curPoint = { x: 0, y: 0 };
  let startPoint = { x: 0, y: 0 };
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        if (current.length > 1) {
          contours.push({ points: current, closed: false });
        }
        curPoint = { x: cmd.x, y: cmd.y };
        startPoint = curPoint;
        current = [curPoint];
        break;
      case "L":
        curPoint = { x: cmd.x, y: cmd.y };
        current.push(curPoint);
        break;
      case "Q":
        flattenQuadratic(curPoint, { x: cmd.x1, y: cmd.y1 }, { x: cmd.x, y: cmd.y }, eps, current);
        curPoint = { x: cmd.x, y: cmd.y };
        break;
      case "C":
        flattenCubic(curPoint, { x: cmd.x1, y: cmd.y1 }, { x: cmd.x2, y: cmd.y2 }, { x: cmd.x, y: cmd.y }, eps, current);
        curPoint = { x: cmd.x, y: cmd.y };
        break;
      case "Z":
        if (current.length > 1) {
          const first = current[0];
          const last = current[current.length - 1];
          if (first && last) {
            const dx = last.x - first.x;
            const dy = last.y - first.y;
            if (dx * dx + dy * dy > eps * eps) {
              current.push({ ...first });
            }
          }
          contours.push({ points: current, closed: true });
        }
        current = [];
        curPoint = startPoint;
        break;
    }
  }
  if (current.length > 1) {
    contours.push({ points: current, closed: false });
  }
  return contours;
}
function contourSignedArea(points) {
  if (points.length < 3)
    return 0;
  let end = points.length;
  const first = points[0];
  const last = points[end - 1];
  if (first && last) {
    const dx = last.x - first.x;
    const dy = last.y - first.y;
    if (dx * dx + dy * dy < 1)
      end -= 1;
  }
  if (end < 3)
    return 0;
  let area = 0;
  for (let i = 0;i < end; i++) {
    const p0 = points[i];
    const p1 = points[(i + 1) % end];
    if (!p0 || !p1)
      continue;
    area += p0.x * p1.y - p1.x * p0.y;
  }
  return area;
}
function addRoundJoin(result, center, normal0, normal1, xBorder, yBorder, outer) {
  const dot = normal0.x * normal1.x + normal0.y * normal1.y;
  const cross = normal0.x * normal1.y - normal0.y * normal1.x;
  const angle = Math.atan2(cross, dot);
  const numSegments = Math.max(2, Math.ceil(Math.abs(angle) / (Math.PI / 8)));
  const sign2 = outer ? 1 : -1;
  const startAngle = Math.atan2(normal0.y, normal0.x);
  for (let i = 1;i <= numSegments; i++) {
    const t = i / numSegments;
    const currentAngle = startAngle + angle * t;
    const nx = Math.cos(currentAngle);
    const ny = Math.sin(currentAngle);
    result.push({
      x: center.x + nx * xBorder * sign2,
      y: center.y + ny * yBorder * sign2
    });
  }
}
function addMiterJoin(result, center, normal0, normal1, xBorder, yBorder, miterLimit, outer) {
  const sign2 = outer ? 1 : -1;
  const dot = normal0.x * normal1.x + normal0.y * normal1.y;
  const sinHalfAngle = Math.sqrt((1 - dot) / 2);
  if (sinHalfAngle < 0.0000000001) {
    return false;
  }
  const miterLength = 1 / sinHalfAngle;
  if (miterLength > miterLimit) {
    return false;
  }
  const mx = normal0.x + normal1.x;
  const my = normal0.y + normal1.y;
  const mlen = Math.sqrt(mx * mx + my * my);
  if (mlen < 0.0000000001) {
    return false;
  }
  const miterDist = miterLength * Math.sqrt(xBorder * xBorder + yBorder * yBorder) / 2;
  result.push({
    x: center.x + mx / mlen * miterDist * sign2,
    y: center.y + my / mlen * miterDist * sign2
  });
  return true;
}
function strokeClosedContour(points, xBorder, yBorder, lineJoin, miterLimit, outwardIsLeft) {
  const n = points.length;
  if (n < 3) {
    return { outer: [], inner: [] };
  }
  const lastIdx = n - 1;
  const first = points[0];
  const last = points[lastIdx];
  let effectiveN = n;
  if (first && last) {
    const dx = last.x - first.x;
    const dy = last.y - first.y;
    if (dx * dx + dy * dy < 1) {
      effectiveN = n - 1;
    }
  }
  if (effectiveN < 3) {
    return { outer: [], inner: [] };
  }
  const normalFlip = outwardIsLeft ? 1 : -1;
  const normals = [];
  for (let i = 0;i < effectiveN; i++) {
    const p0 = points[i];
    const p1 = points[(i + 1) % effectiveN];
    if (!p0 || !p1)
      continue;
    const dx = p1.x - p0.x;
    const dy = p1.y - p0.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len < 0.0000000001) {
      normals.push({ x: 0, y: 0, len: 0 });
    } else {
      const nrm = computeAsymmetricOffset(dx / len, dy / len, xBorder, yBorder);
      if (normalFlip < 0) {
        nrm.x = -nrm.x;
        nrm.y = -nrm.y;
      }
      normals.push(nrm);
    }
  }
  const outer = [];
  const inner = [];
  for (let i = 0;i < effectiveN; i++) {
    const pt = points[i];
    const prevNormal = normals[(i - 1 + effectiveN) % effectiveN];
    const nextNormal = normals[i];
    if (!pt || !prevNormal || !nextNormal)
      continue;
    if (prevNormal.len < 0.0000000001 || nextNormal.len < 0.0000000001) {
      outer.push({
        x: pt.x + (nextNormal.len > 0 ? nextNormal.x * xBorder : 0),
        y: pt.y + (nextNormal.len > 0 ? nextNormal.y * yBorder : 0)
      });
      continue;
    }
    const offsetPt = {
      x: pt.x + nextNormal.x * xBorder,
      y: pt.y + nextNormal.y * yBorder
    };
    const cross = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
    const isConvex = cross > 0;
    if (Math.abs(cross) < 0.01) {
      outer.push(offsetPt);
    } else if (isConvex) {
      switch (lineJoin) {
        case "round":
          addRoundJoin(outer, pt, prevNormal, nextNormal, xBorder, yBorder, true);
          break;
        case "miter":
          if (!addMiterJoin(outer, pt, prevNormal, nextNormal, xBorder, yBorder, miterLimit, true)) {
            outer.push(offsetPt);
          }
          break;
        default:
          outer.push(offsetPt);
          break;
      }
    } else {
      outer.push(offsetPt);
    }
  }
  for (let i = 0;i < effectiveN; i++) {
    const pt = points[i];
    const prevNormal = normals[(i - 1 + effectiveN) % effectiveN];
    const nextNormal = normals[i];
    if (!pt || !prevNormal || !nextNormal)
      continue;
    if (prevNormal.len < 0.0000000001 || nextNormal.len < 0.0000000001) {
      inner.push({
        x: pt.x - (nextNormal.len > 0 ? nextNormal.x * xBorder : 0),
        y: pt.y - (nextNormal.len > 0 ? nextNormal.y * yBorder : 0)
      });
      continue;
    }
    const offsetPt = {
      x: pt.x - nextNormal.x * xBorder,
      y: pt.y - nextNormal.y * yBorder
    };
    const cross = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
    const isConvex = cross < 0;
    if (Math.abs(cross) < 0.01) {
      inner.push(offsetPt);
    } else if (isConvex) {
      switch (lineJoin) {
        case "round":
          addRoundJoin(inner, pt, prevNormal, nextNormal, xBorder, yBorder, false);
          break;
        case "miter":
          if (!addMiterJoin(inner, pt, prevNormal, nextNormal, xBorder, yBorder, miterLimit, false)) {
            inner.push(offsetPt);
          }
          break;
        default:
          inner.push(offsetPt);
          break;
      }
    } else {
      inner.push(offsetPt);
    }
  }
  return { outer, inner };
}
function pointsToPath(points, closed) {
  if (points.length === 0)
    return [];
  const commands = [];
  const first = points[0];
  if (!first)
    return [];
  commands.push({ type: "M", x: first.x, y: first.y });
  for (let i = 1;i < points.length; i++) {
    const pt = points[i];
    if (!pt)
      continue;
    commands.push({ type: "L", x: pt.x, y: pt.y });
  }
  if (closed) {
    commands.push({ type: "Z" });
  }
  return commands;
}
function strokeAsymmetric(path, options) {
  const {
    xBorder,
    yBorder,
    eps = 1,
    lineJoin = "round",
    miterLimit = 4
  } = options;
  if (xBorder <= 0 && yBorder <= 0) {
    return {
      outer: { commands: [], bounds: null },
      inner: { commands: [], bounds: null }
    };
  }
  const contours = pathToContours(path, eps);
  const outerCommands = [];
  const innerCommands = [];
  const areas = [];
  let outerSign = 1;
  let maxAbs = 0;
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    const area = contourSignedArea(contour.points);
    areas[i] = area;
    const abs2 = Math.abs(area);
    if (abs2 > maxAbs) {
      maxAbs = abs2;
      outerSign = area >= 0 ? 1 : -1;
    }
  }
  if (maxAbs === 0)
    outerSign = 1;
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    if (!contour.closed) {
      const firstPoint = contour.points[0];
      if (firstPoint)
        contour.points.push(firstPoint);
      contour.closed = true;
    }
    const area = areas[i] ?? 0;
    const contourSign = area >= 0 ? 1 : -1;
    const interiorIsLeft = contourSign > 0;
    const isOuter = contourSign === outerSign;
    const outwardIsLeft = isOuter ? !interiorIsLeft : interiorIsLeft;
    const { outer, inner } = strokeClosedContour(contour.points, xBorder, yBorder, lineJoin, miterLimit, outwardIsLeft);
    inner.reverse();
    outerCommands.push(...pointsToPath(outer, true));
    innerCommands.push(...pointsToPath(inner, true));
  }
  let outerBounds = null;
  let innerBounds = null;
  if (path.bounds) {
    outerBounds = {
      xMin: path.bounds.xMin - xBorder,
      yMin: path.bounds.yMin - yBorder,
      xMax: path.bounds.xMax + xBorder,
      yMax: path.bounds.yMax + yBorder
    };
    innerBounds = {
      xMin: path.bounds.xMin + xBorder,
      yMin: path.bounds.yMin + yBorder,
      xMax: path.bounds.xMax - xBorder,
      yMax: path.bounds.yMax - yBorder
    };
  }
  return {
    outer: { commands: outerCommands, bounds: outerBounds, flags: path.flags },
    inner: { commands: innerCommands, bounds: innerBounds, flags: path.flags }
  };
}
function strokeAsymmetricCombined(path, options) {
  const { outer, inner } = strokeAsymmetric(path, options);
  const commands = [...outer.commands, ...inner.commands];
  const bounds = outer.bounds;
  return { commands, bounds, flags: path.flags };
}
function strokeUniform(path, border, options) {
  return strokeAsymmetric(path, {
    xBorder: border,
    yBorder: border,
    ...options
  });
}

// reference/text-shaper/src/raster/synth.ts
function computeBounds(commands) {
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  for (let i = 0;i < commands.length; i++) {
    const cmd = commands[i];
    switch (cmd.type) {
      case "M":
      case "L":
        xMin = Math.min(xMin, cmd.x);
        xMax = Math.max(xMax, cmd.x);
        yMin = Math.min(yMin, cmd.y);
        yMax = Math.max(yMax, cmd.y);
        break;
      case "Q":
        xMin = Math.min(xMin, cmd.x, cmd.x1);
        xMax = Math.max(xMax, cmd.x, cmd.x1);
        yMin = Math.min(yMin, cmd.y, cmd.y1);
        yMax = Math.max(yMax, cmd.y, cmd.y1);
        break;
      case "C":
        xMin = Math.min(xMin, cmd.x, cmd.x1, cmd.x2);
        xMax = Math.max(xMax, cmd.x, cmd.x1, cmd.x2);
        yMin = Math.min(yMin, cmd.y, cmd.y1, cmd.y2);
        yMax = Math.max(yMax, cmd.y, cmd.y1, cmd.y2);
        break;
      case "Z":
        break;
    }
  }
  if (!Number.isFinite(xMin))
    return null;
  return { xMin, yMin, xMax, yMax };
}
function obliquePath(path, slant) {
  const commands = [];
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
      case "L":
        commands.push({
          type: cmd.type,
          x: cmd.x + cmd.y * slant,
          y: cmd.y
        });
        break;
      case "Q":
        commands.push({
          type: "Q",
          x1: cmd.x1 + cmd.y1 * slant,
          y1: cmd.y1,
          x: cmd.x + cmd.y * slant,
          y: cmd.y
        });
        break;
      case "C":
        commands.push({
          type: "C",
          x1: cmd.x1 + cmd.y1 * slant,
          y1: cmd.y1,
          x2: cmd.x2 + cmd.y2 * slant,
          y2: cmd.y2,
          x: cmd.x + cmd.y * slant,
          y: cmd.y
        });
        break;
      case "Z":
        commands.push({ type: "Z" });
        break;
    }
  }
  const bounds = computeBounds(commands);
  return { commands, bounds, flags: path.flags };
}
function condensePath(path, factor) {
  const commands = [];
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
      case "L":
        commands.push({
          type: cmd.type,
          x: cmd.x * factor,
          y: cmd.y
        });
        break;
      case "Q":
        commands.push({
          type: "Q",
          x1: cmd.x1 * factor,
          y1: cmd.y1,
          x: cmd.x * factor,
          y: cmd.y
        });
        break;
      case "C":
        commands.push({
          type: "C",
          x1: cmd.x1 * factor,
          y1: cmd.y1,
          x2: cmd.x2 * factor,
          y2: cmd.y2,
          x: cmd.x * factor,
          y: cmd.y
        });
        break;
      case "Z":
        commands.push({ type: "Z" });
        break;
    }
  }
  let bounds = path.bounds;
  if (bounds) {
    bounds = {
      xMin: bounds.xMin * factor,
      yMin: bounds.yMin,
      xMax: bounds.xMax * factor,
      yMax: bounds.yMax
    };
  }
  return { commands, bounds, flags: path.flags };
}
function emboldenPath(path, strength) {
  if (strength === 0) {
    return { ...path, commands: [...path.commands] };
  }
  if (strength > 0) {
    const { outer } = strokeAsymmetric(path, {
      xBorder: strength,
      yBorder: strength,
      eps: 0.25,
      lineJoin: "round"
    });
    return {
      commands: outer.commands,
      bounds: outer.bounds ?? computeBounds(outer.commands),
      flags: path.flags
    };
  }
  const contours = extractContours2(path);
  const commands = [];
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    if (contour.length < 3)
      continue;
    const offsetContour = offsetPolygon(contour, strength);
    if (offsetContour.length > 0) {
      commands.push({
        type: "M",
        x: offsetContour[0].x,
        y: offsetContour[0].y
      });
      for (let j = 1;j < offsetContour.length; j++) {
        commands.push({
          type: "L",
          x: offsetContour[j].x,
          y: offsetContour[j].y
        });
      }
      commands.push({ type: "Z" });
    }
  }
  let bounds = null;
  if (commands.length > 0) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (let i = 0;i < commands.length; i++) {
      const cmd = commands[i];
      if (cmd.type === "M" || cmd.type === "L") {
        minX = Math.min(minX, cmd.x);
        minY = Math.min(minY, cmd.y);
        maxX = Math.max(maxX, cmd.x);
        maxY = Math.max(maxY, cmd.y);
      }
    }
    if (Number.isFinite(minX)) {
      bounds = { xMin: minX, yMin: minY, xMax: maxX, yMax: maxY };
    }
  }
  return { commands, bounds, flags: path.flags };
}
function extractContours2(path) {
  const contours = [];
  let currentContour = [];
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        if (currentContour.length > 0) {
          contours.push(currentContour);
        }
        currentContour = [{ x: cmd.x, y: cmd.y }];
        break;
      case "L":
        currentContour.push({ x: cmd.x, y: cmd.y });
        break;
      case "Q": {
        const last = currentContour[currentContour.length - 1];
        if (last) {
          const steps = 8;
          for (let j = 1;j <= steps; j++) {
            const t = j / steps;
            const ti = 1 - t;
            const x = ti * ti * last.x + 2 * ti * t * cmd.x1 + t * t * cmd.x;
            const y = ti * ti * last.y + 2 * ti * t * cmd.y1 + t * t * cmd.y;
            currentContour.push({ x, y });
          }
        }
        break;
      }
      case "C": {
        const last = currentContour[currentContour.length - 1];
        if (last) {
          const steps = 12;
          for (let j = 1;j <= steps; j++) {
            const t = j / steps;
            const ti = 1 - t;
            const x = ti * ti * ti * last.x + 3 * ti * ti * t * cmd.x1 + 3 * ti * t * t * cmd.x2 + t * t * t * cmd.x;
            const y = ti * ti * ti * last.y + 3 * ti * ti * t * cmd.y1 + 3 * ti * t * t * cmd.y2 + t * t * t * cmd.y;
            currentContour.push({ x, y });
          }
        }
        break;
      }
      case "Z":
        if (currentContour.length > 0) {
          contours.push(currentContour);
          currentContour = [];
        }
        break;
    }
  }
  if (currentContour.length > 0) {
    contours.push(currentContour);
  }
  return contours;
}
function offsetPolygon(points, offset) {
  const n = points.length;
  if (n < 3)
    return points;
  let area = 0;
  for (let i = 0;i < n; i++) {
    const j = (i + 1) % n;
    const p1 = points[i];
    const p2 = points[j];
    if (p1 && p2) {
      area += (p2.x - p1.x) * (p2.y + p1.y);
    }
  }
  const sign2 = area < 0 ? -1 : 1;
  const actualOffset = offset * sign2;
  const result = [];
  for (let i = 0;i < n; i++) {
    const prev = points[(i - 1 + n) % n];
    const curr = points[i];
    const next = points[(i + 1) % n];
    if (!prev || !curr || !next)
      continue;
    const edge1 = { x: curr.x - prev.x, y: curr.y - prev.y };
    const edge2 = { x: next.x - curr.x, y: next.y - curr.y };
    const len1 = Math.sqrt(edge1.x * edge1.x + edge1.y * edge1.y);
    const len2 = Math.sqrt(edge2.x * edge2.x + edge2.y * edge2.y);
    if (len1 === 0 || len2 === 0) {
      result.push(curr);
      continue;
    }
    edge1.x /= len1;
    edge1.y /= len1;
    edge2.x /= len2;
    edge2.y /= len2;
    const normal1 = { x: -edge1.y, y: edge1.x };
    const normal2 = { x: -edge2.y, y: edge2.x };
    let normalX = (normal1.x + normal2.x) / 2;
    let normalY = (normal1.y + normal2.y) / 2;
    const normalLen = Math.sqrt(normalX * normalX + normalY * normalY);
    if (normalLen > 0.001) {
      normalX /= normalLen;
      normalY /= normalLen;
      const dot = normal1.x * normal2.x + normal1.y * normal2.y;
      const scale = dot > -0.999 ? 1 / Math.sqrt((1 + dot) / 2) : 1;
      const limitedScale = Math.min(scale, 3);
      result.push({
        x: curr.x + normalX * actualOffset * limitedScale,
        y: curr.y + normalY * actualOffset * limitedScale
      });
    } else {
      result.push(curr);
    }
  }
  return result;
}

// reference/text-shaper/src/raster/rasterize.ts
init_types();
var hintingEngineCache = new WeakMap;
var sharedRaster = null;
function getSharedRaster() {
  if (!sharedRaster)
    sharedRaster = new GrayRaster;
  return sharedRaster;
}
var sharedBuffer = null;
var sharedBufferSize = 0;
function getSharedBuffer(size) {
  if (size <= sharedBufferSize && sharedBuffer) {
    sharedBuffer.fill(0, 0, size);
    return sharedBuffer;
  }
  const allocSize = Math.max(size, 4096);
  sharedBuffer = new Uint8Array(allocSize);
  sharedBufferSize = allocSize;
  return sharedBuffer;
}
function createBitmapShared(width, height, pixelMode) {
  const bytesPerPixel = pixelMode === 4 /* RGBA */ ? 4 : pixelMode === 2 /* LCD */ || pixelMode === 3 /* LCD_V */ ? 3 : pixelMode === 0 /* Mono */ ? 0.125 : 1;
  const pitch = pixelMode === 0 /* Mono */ ? Math.ceil(width / 8) : Math.ceil(width * bytesPerPixel);
  const size = pitch * height;
  const buffer = getSharedBuffer(size);
  return {
    width,
    rows: height,
    pitch,
    buffer: buffer.subarray(0, size),
    pixelMode,
    numGrays: pixelMode === 0 /* Mono */ ? 2 : 256
  };
}
var hintedGlyphCache = new WeakMap;
function shouldScaleComponentOffset2(flags) {
  if (flags & CompositeFlag.UnscaledComponentOffset)
    return false;
  if (flags & CompositeFlag.ScaledComponentOffset)
    return true;
  return false;
}
function roundOffsetToGrid(value26) {
  return Math.round(value26 / 64) * 64;
}
function buildGlyphPoints26(font, glyphId, scale, depth = 0, options) {
  if (depth > 32)
    return null;
  const glyph = font.getGlyph(glyphId);
  if (!glyph || glyph.type === "empty")
    return null;
  const roundCompositeOffsets = options?.roundCompositeOffsets ?? true;
  if (glyph.type === "simple") {
    const xCoords2 = [];
    const yCoords2 = [];
    const flags2 = [];
    const contourEnds2 = [];
    let pointIndex2 = 0;
    for (const contour of glyph.contours) {
      for (const point of contour) {
        xCoords2.push(Math.round(point.x * scale));
        yCoords2.push(Math.round(point.y * scale));
        flags2.push(point.onCurve ? 1 : 0);
        pointIndex2++;
      }
      contourEnds2.push(pointIndex2 - 1);
    }
    return {
      xCoords: xCoords2,
      yCoords: yCoords2,
      flags: new Uint8Array(flags2),
      contourEnds: contourEnds2
    };
  }
  const xCoords = [];
  const yCoords = [];
  const flags = [];
  const contourEnds = [];
  const parentPoints = [];
  let pointIndex = 0;
  for (const component of glyph.components) {
    const comp = buildGlyphPoints26(font, component.glyphId, scale, depth + 1, {
      roundCompositeOffsets
    });
    if (!comp || comp.xCoords.length === 0)
      continue;
    const [a, b, c, d] = component.transform;
    const hasXY = (component.flags & CompositeFlag.ArgsAreXYValues) !== 0;
    const tx = new Array(comp.xCoords.length);
    const ty = new Array(comp.yCoords.length);
    for (let i = 0;i < comp.xCoords.length; i++) {
      const cx = comp.xCoords[i];
      const cy = comp.yCoords[i];
      tx[i] = Math.round(a * cx + c * cy);
      ty[i] = Math.round(b * cx + d * cy);
    }
    let dx26 = 0;
    let dy26 = 0;
    if (hasXY) {
      const rawDx = component.arg1;
      const rawDy = component.arg2;
      if (shouldScaleComponentOffset2(component.flags)) {
        const dx = Math.round(rawDx * scale);
        const dy = Math.round(rawDy * scale);
        dx26 = Math.round(a * dx + c * dy);
        dy26 = Math.round(b * dx + d * dy);
      } else {
        dx26 = Math.round(rawDx * scale);
        dy26 = Math.round(rawDy * scale);
      }
      if (roundCompositeOffsets && component.flags & CompositeFlag.RoundXYToGrid) {
        dx26 = roundOffsetToGrid(dx26);
        dy26 = roundOffsetToGrid(dy26);
      }
    } else {
      const parentIndex = component.arg1;
      const compIndex = component.arg2;
      if (parentIndex >= 0 && parentIndex < parentPoints.length && compIndex >= 0 && compIndex < tx.length) {
        const parentPoint = parentPoints[parentIndex];
        dx26 = parentPoint.x - tx[compIndex];
        dy26 = parentPoint.y - ty[compIndex];
      }
    }
    for (let i = 0;i < tx.length; i++) {
      const x = tx[i] + dx26;
      const y = ty[i] + dy26;
      xCoords.push(x);
      yCoords.push(y);
      flags.push(comp.flags[i] ?? 0);
      parentPoints.push({ x, y });
    }
    for (let i = 0;i < comp.contourEnds.length; i++) {
      contourEnds.push(pointIndex + comp.contourEnds[i]);
    }
    pointIndex += tx.length;
  }
  if (xCoords.length === 0)
    return null;
  return {
    xCoords,
    yCoords,
    flags: new Uint8Array(flags),
    contourEnds
  };
}
function hintCompositeGlyph(engine, font, glyph, ppem, depth) {
  if (glyph.type !== "composite")
    return null;
  if (depth > 16)
    return null;
  const xCoords = [];
  const yCoords = [];
  const flags = [];
  const contourEnds = [];
  const parentPoints = [];
  let pointIndex = 0;
  for (let i = 0;i < glyph.components.length; i++) {
    const component = glyph.components[i];
    const hinted = getCachedHintedGlyph(engine, font, component.glyphId, ppem, depth + 1);
    if (!hinted || hinted.xCoords.length === 0)
      continue;
    const [a, b, c, d] = component.transform;
    const hasXY = (component.flags & CompositeFlag.ArgsAreXYValues) !== 0;
    let dx26 = 0;
    let dy26 = 0;
    if (hasXY) {
      let dx = component.arg1;
      let dy = component.arg2;
      if (shouldScaleComponentOffset2(component.flags)) {
        const scaledX = a * dx + c * dy;
        const scaledY = b * dx + d * dy;
        dx = scaledX;
        dy = scaledY;
      }
      dx26 = scaleFUnits(dx, engine.ctx.scaleFix);
      dy26 = scaleFUnits(dy, engine.ctx.scaleFix);
      if (component.flags & CompositeFlag.RoundXYToGrid) {
        dx26 = roundOffsetToGrid(dx26);
        dy26 = roundOffsetToGrid(dy26);
      }
    } else {
      const parentIndex = component.arg1;
      const compIndex = component.arg2;
      if (parentIndex >= 0 && parentIndex < parentPoints.length && compIndex >= 0 && compIndex < hinted.xCoords.length) {
        const parentPoint = parentPoints[parentIndex];
        const compX = a * hinted.xCoords[compIndex] + c * hinted.yCoords[compIndex];
        const compY = b * hinted.xCoords[compIndex] + d * hinted.yCoords[compIndex];
        dx26 = Math.round(parentPoint.x - compX);
        dy26 = Math.round(parentPoint.y - compY);
      }
    }
    for (let j = 0;j < hinted.xCoords.length; j++) {
      const hx = hinted.xCoords[j];
      const hy = hinted.yCoords[j];
      const x = Math.round(a * hx + c * hy + dx26);
      const y = Math.round(b * hx + d * hy + dy26);
      xCoords.push(x);
      yCoords.push(y);
      flags.push(hinted.flags[j] ?? 0);
      parentPoints.push({ x, y });
    }
    for (let j = 0;j < hinted.contourEnds.length; j++) {
      contourEnds.push(pointIndex + hinted.contourEnds[j]);
    }
    pointIndex += hinted.xCoords.length;
  }
  if (xCoords.length === 0)
    return null;
  return {
    xCoords,
    yCoords,
    flags: new Uint8Array(flags),
    contourEnds,
    error: null
  };
}
function getCachedHintedGlyph(engine, font, glyphId, ppem, pointSize, depth = 0) {
  const pointKey = Math.round(pointSize * 64);
  const key = `${glyphId}:${ppem}:${pointKey}:${engine.ctx.lightMode ? "light" : "full"}`;
  let cache = hintedGlyphCache.get(font);
  if (!cache) {
    cache = new Map;
    hintedGlyphCache.set(font, cache);
  }
  const cached = cache.get(key);
  if (cached !== undefined)
    return cached;
  const glyph = font.getGlyph(glyphId);
  if (!glyph || glyph.type === "empty") {
    cache.set(key, null);
    return null;
  }
  const error = setSize(engine, ppem, pointSize);
  if (error) {
    cache.set(key, null);
    return null;
  }
  if (glyph.type === "composite" && glyph.instructions.length === 0) {
    const compositeHinted = hintCompositeGlyph(engine, font, glyph, ppem, depth);
    if (compositeHinted && compositeHinted.xCoords.length > 0) {
      cache.set(key, compositeHinted);
      return compositeHinted;
    }
  }
  const outline = glyphToOutline(font, glyphId, engine.ctx.scale);
  if (!outline) {
    cache.set(key, null);
    return null;
  }
  const hinted = hintGlyph(engine, outline);
  if (hinted.error || hinted.xCoords.length === 0) {
    cache.set(key, null);
    return null;
  }
  cache.set(key, hinted);
  return hinted;
}
function getHintingEngine(font) {
  if (!font.isTrueType || !font.hasHinting)
    return null;
  let engine = hintingEngineCache.get(font);
  if (engine)
    return engine;
  const cvt = font.cvtTable;
  const cvtValues = cvt ? new Int32Array(cvt.values) : undefined;
  const maxp = font.maxp;
  engine = createHintingEngine(font.unitsPerEm, "maxStackElements" in maxp ? maxp.maxStackElements : 256, "maxStorage" in maxp ? maxp.maxStorage : 64, "maxFunctionDefs" in maxp ? maxp.maxFunctionDefs : 64, "maxTwilightPoints" in maxp ? maxp.maxTwilightPoints : 16, cvtValues);
  const fpgm = font.fpgm;
  if (fpgm)
    loadFontProgram(engine, fpgm.instructions);
  const prep = font.prep;
  if (prep)
    loadCVTProgram(engine, prep.instructions);
  hintingEngineCache.set(font, engine);
  return engine;
}
function glyphToOutline(font, glyphId, scale) {
  const glyph = font.getGlyph(glyphId);
  if (!glyph || glyph.type === "empty")
    return null;
  const xCoords = [];
  const yCoords = [];
  const flags = [];
  const contourEnds = [];
  const advanceWidth = font.advanceWidth(glyphId);
  const lsb = font.leftSideBearing(glyphId);
  if (glyph.type === "composite" && glyph.instructions.length > 0 && scale) {
    const points26 = buildGlyphPoints26(font, glyphId, scale);
    if (!points26 || points26.xCoords.length === 0)
      return null;
    const invScale = 1 / scale;
    for (let i = 0;i < points26.xCoords.length; i++) {
      xCoords.push(points26.xCoords[i] * invScale);
      yCoords.push(points26.yCoords[i] * invScale);
      flags.push(points26.flags[i] ?? 0);
    }
    for (let i = 0;i < points26.contourEnds.length; i++) {
      contourEnds.push(points26.contourEnds[i]);
    }
  } else {
    const contours = glyph.type === "simple" ? glyph.contours : font.getGlyphContours(glyphId);
    if (!contours || contours.length === 0)
      return null;
    let pointIndex = 0;
    for (let i = 0;i < contours.length; i++) {
      const contour = contours[i];
      for (let j = 0;j < contour.length; j++) {
        const point = contour[j];
        xCoords.push(point.x);
        yCoords.push(point.y);
        flags.push(point.onCurve ? 1 : 0);
        pointIndex++;
      }
      contourEnds.push(pointIndex - 1);
    }
  }
  return {
    xCoords,
    yCoords,
    flags: new Uint8Array(flags),
    contourEnds,
    instructions: glyph.instructions,
    lsb,
    advanceWidth,
    isComposite: glyph.type === "composite"
  };
}
function decomposeHintedGlyph(raster, hinted, offsetX, offsetY) {
  const { xCoords, yCoords, flags, contourEnds } = hinted;
  let contourIdx = 0;
  let contourStart = 0;
  for (let i = 0;i < xCoords.length; i++) {
    const contourEnd = contourEnds[contourIdx];
    const isEnd = i === contourEnd;
    const x = (xCoords[i] << 2 | 0) + (offsetX << 8);
    const y = (-yCoords[i] << 2 | 0) + (offsetY << 8);
    const onCurve = (flags[i] & 1) !== 0;
    if (i === contourStart) {
      raster.moveTo(x, y);
    } else if (onCurve) {
      raster.lineTo(x, y);
    } else {
      const nextIdx = isEnd ? contourStart : i + 1;
      const nx = (xCoords[nextIdx] << 2 | 0) + (offsetX << 8);
      const ny = (-yCoords[nextIdx] << 2 | 0) + (offsetY << 8);
      const nextOn = (flags[nextIdx] & 1) !== 0;
      if (nextOn) {
        raster.conicTo(x, y, nx, ny);
        if (!isEnd) {
          i++;
          if (i === contourEnd) {
            const sx = (xCoords[contourStart] << 2 | 0) + (offsetX << 8);
            const sy = (-yCoords[contourStart] << 2 | 0) + (offsetY << 8);
            raster.lineTo(sx, sy);
            contourIdx++;
            contourStart = i + 1;
          }
        }
      } else {
        raster.conicTo(x, y, x + nx >> 1, y + ny >> 1);
      }
    }
    if (isEnd && i === contourEnd) {
      const sx = (xCoords[contourStart] << 2 | 0) + (offsetX << 8);
      const sy = (-yCoords[contourStart] << 2 | 0) + (offsetY << 8);
      if (onCurve && i !== contourStart) {
        raster.lineTo(sx, sy);
      } else if (!onCurve) {
        const startOn = (flags[contourStart] & 1) !== 0;
        if (startOn) {}
      }
      contourIdx++;
      contourStart = i + 1;
    }
  }
}
var BAND_PROCESSING_THRESHOLD = 256;
function rasterizePath(path, options) {
  const {
    width,
    height,
    scale,
    offsetX = 0,
    offsetY = 0,
    pixelMode = 1 /* Gray */,
    fillRule = 0 /* NonZero */,
    flipY = true
  } = options;
  const bitmap = createBitmap(width, height, pixelMode);
  const raster = getSharedRaster();
  raster.setClip(0, 0, width, height);
  if (height > BAND_PROCESSING_THRESHOLD) {
    const decomposeFn = () => decomposePath(raster, path, scale, offsetX, offsetY, flipY);
    raster.renderWithBands(bitmap, decomposeFn, { minY: 0, maxY: height }, fillRule);
  } else {
    raster.setBandBounds(0, height);
    raster.reset();
    decomposePath(raster, path, scale, offsetX, offsetY, flipY);
    raster.sweep(bitmap, fillRule);
  }
  return bitmap;
}
function rasterizeGlyph(font, glyphId, fontSize, options) {
  const padding = options?.padding ?? 0;
  const pixelMode = options?.pixelMode ?? 1 /* Gray */;
  const useHinting = options?.hinting ?? false;
  const sizeMode = options?.sizeMode;
  const effectiveSize = resolveFontSize(font, fontSize, sizeMode);
  if (useHinting && font.hasHinting) {
    const pointSize = sizeMode === "height" ? fontSize : effectiveSize;
    const result = rasterizeHintedGlyph(font, glyphId, effectiveSize, padding, pixelMode, pointSize);
    if (result)
      return result;
  }
  if (font.isTrueType) {
    const scale26 = effectiveSize * 64 / font.unitsPerEm;
    const points26 = buildGlyphPoints26(font, glyphId, scale26, 0, {
      roundCompositeOffsets: false
    });
    if (points26) {
      const raster = rasterizeTrueTypePoints26(points26, padding, pixelMode);
      if (raster)
        return raster;
    }
  }
  const path = getGlyphPath(font, glyphId);
  if (!path)
    return null;
  const scale = effectiveSize / font.unitsPerEm;
  const bounds = getPathBounds(path, scale, true, true);
  if (!bounds) {
    return {
      bitmap: createBitmap(1, 1, pixelMode),
      bearingX: 0,
      bearingY: 0
    };
  }
  const width = bounds.maxX - bounds.minX + padding * 2;
  const height = bounds.maxY - bounds.minY + padding * 2;
  if (width <= 0 || height <= 0) {
    return {
      bitmap: createBitmap(1, 1, pixelMode),
      bearingX: 0,
      bearingY: 0
    };
  }
  const offsetX = -bounds.minX + padding;
  const offsetY = -bounds.minY + padding;
  const bitmap = rasterizePath(path, {
    width,
    height,
    scale,
    offsetX,
    offsetY,
    pixelMode,
    flipY: true
  });
  return {
    bitmap,
    bearingX: bounds.minX - padding,
    bearingY: -(bounds.minY - padding)
  };
}
function rasterizeGlyphWithTransform(font, glyphId, fontSize, matrix, options) {
  const raster = rasterizeGlyph(font, glyphId, fontSize, options);
  if (!raster)
    return null;
  const transformOptions = {
    bearingX: raster.bearingX,
    bearingY: raster.bearingY,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  };
  if (Array.isArray(matrix[0])) {
    const result2 = transformBitmap3D(raster.bitmap, matrix, transformOptions);
    return result2;
  }
  const result = transformBitmap2D(raster.bitmap, matrix, transformOptions);
  return result;
}
function rasterizeHintedGlyph(font, glyphId, fontSize, padding, pixelMode, pointSize = fontSize) {
  const engine = getHintingEngine(font);
  if (!engine)
    return null;
  const ppem = Math.round(fontSize);
  engine.ctx.lightMode = pixelMode === 1 /* Gray */;
  engine.ctx.renderMode = pixelMode === 0 /* Mono */ ? "mono" : pixelMode === 2 /* LCD */ ? "lcd" : pixelMode === 3 /* LCD_V */ ? "lcd_v" : "gray";
  engine.ctx.grayscale = engine.ctx.renderMode !== "mono" && !engine.ctx.lightMode;
  const hinted = getCachedHintedGlyph(engine, font, glyphId, ppem, pointSize);
  if (!hinted)
    return null;
  const hintedForRaster = hinted;
  const xCoords = hintedForRaster.xCoords;
  const yCoords = hintedForRaster.yCoords;
  let minX26 = xCoords[0];
  let minY26 = yCoords[0];
  let maxX26 = xCoords[0];
  let maxY26 = yCoords[0];
  for (let i = 1;i < xCoords.length; i++) {
    const x = xCoords[i];
    const y = yCoords[i];
    if (x < minX26)
      minX26 = x;
    if (x > maxX26)
      maxX26 = x;
    if (y < minY26)
      minY26 = y;
    if (y > maxY26)
      maxY26 = y;
  }
  if (!Number.isFinite(minX26)) {
    return { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };
  }
  const glyphBounds = font.getGlyphBounds(glyphId);
  if (glyphBounds) {
    const scale = fontSize / font.unitsPerEm;
    const unhintedWidth = (glyphBounds.xMax - glyphBounds.xMin) * scale;
    const unhintedHeight = (glyphBounds.yMax - glyphBounds.yMin) * scale;
    const maxWidth = Math.max(unhintedWidth * 8, fontSize * 8, unhintedWidth + 64);
    const maxHeight = Math.max(unhintedHeight * 8, fontSize * 8, unhintedHeight + 64);
    const hintedWidth = (maxX26 - minX26) / 64;
    const hintedHeight = (maxY26 - minY26) / 64;
    if (hintedWidth > maxWidth || hintedHeight > maxHeight) {
      return null;
    }
  }
  const bMinX = Math.floor(minX26 / 64);
  const bMinY = Math.floor(minY26 / 64);
  const bMaxX = Math.floor((maxX26 + 63) / 64);
  const bMaxY = Math.floor((maxY26 + 63) / 64);
  const width = bMaxX - bMinX + padding * 2;
  const height = bMaxY - bMinY + padding * 2;
  if (width <= 0 || height <= 0) {
    return { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };
  }
  const tempBitmap = createBitmapShared(width, height, pixelMode);
  const raster = getSharedRaster();
  raster.setClip(0, 0, width, height);
  raster.setBandBounds(0, height);
  raster.reset();
  const offsetX = -bMinX + padding;
  const offsetY = bMaxY + padding;
  const decomposeFn = () => decomposeHintedGlyph(raster, hintedForRaster, offsetX, offsetY);
  try {
    decomposeFn();
    raster.sweep(tempBitmap, 0 /* NonZero */);
  } catch (e) {
    if (e instanceof PoolOverflowError) {
      raster.reset();
      raster.renderWithBands(tempBitmap, decomposeFn, { minY: 0, maxY: height, minX: 0, maxX: width }, 0 /* NonZero */);
    } else {
      throw e;
    }
  }
  const bitmap = createBitmap(width, height, pixelMode);
  bitmap.buffer.set(tempBitmap.buffer);
  return {
    bitmap,
    bearingX: bMinX - padding,
    bearingY: bMaxY + padding
  };
}
function rasterizeTrueTypePoints26(points, padding, pixelMode) {
  const xCoords = points.xCoords;
  const yCoords = points.yCoords;
  if (xCoords.length === 0)
    return null;
  let minX26 = xCoords[0];
  let minY26 = yCoords[0];
  let maxX26 = xCoords[0];
  let maxY26 = yCoords[0];
  for (let i = 1;i < xCoords.length; i++) {
    const x = xCoords[i];
    const y = yCoords[i];
    if (x < minX26)
      minX26 = x;
    if (x > maxX26)
      maxX26 = x;
    if (y < minY26)
      minY26 = y;
    if (y > maxY26)
      maxY26 = y;
  }
  if (!Number.isFinite(minX26)) {
    return { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };
  }
  const bMinX = Math.floor(minX26 / 64);
  const bMinY = Math.floor(minY26 / 64);
  const bMaxX = Math.floor((maxX26 + 63) / 64);
  const bMaxY = Math.floor((maxY26 + 63) / 64);
  const width = bMaxX - bMinX + padding * 2;
  const height = bMaxY - bMinY + padding * 2;
  if (width <= 0 || height <= 0) {
    return { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };
  }
  const tempBitmap = createBitmapShared(width, height, pixelMode);
  const raster = getSharedRaster();
  raster.setClip(0, 0, width, height);
  raster.setBandBounds(0, height);
  raster.reset();
  const offsetX = -bMinX + padding;
  const offsetY = bMaxY + padding;
  const hinted = {
    xCoords: points.xCoords,
    yCoords: points.yCoords,
    flags: points.flags,
    contourEnds: points.contourEnds,
    error: null
  };
  const decomposeFn = () => decomposeHintedGlyph(raster, hinted, offsetX, offsetY);
  try {
    decomposeFn();
    raster.sweep(tempBitmap, 0 /* NonZero */);
  } catch (e) {
    if (e instanceof PoolOverflowError) {
      raster.reset();
      raster.renderWithBands(tempBitmap, decomposeFn, { minY: 0, maxY: height, minX: 0, maxX: width }, 0 /* NonZero */);
    } else {
      throw e;
    }
  }
  const bitmap = createBitmap(width, height, pixelMode);
  bitmap.buffer.set(tempBitmap.buffer);
  return {
    bitmap,
    bearingX: bMinX - padding,
    bearingY: bMaxY + padding
  };
}
function rasterizeText(font, text, fontSize, options) {
  const scale = resolveFontScale(font, fontSize, options?.sizeMode);
  const padding = options?.padding ?? 0;
  const pixelMode = options?.pixelMode ?? 1 /* Gray */;
  const glyphs = [];
  let totalAdvance = 0;
  let maxAscent = 0;
  let maxDescent = 0;
  const textArray = [...text];
  for (let i = 0;i < textArray.length; i++) {
    const char = textArray[i];
    const codepoint = char.codePointAt(0);
    if (codepoint === undefined)
      continue;
    const glyphId = font.glyphId(codepoint);
    if (glyphId === undefined)
      continue;
    const advance = font.advanceWidth(glyphId) * scale;
    const path = getGlyphPath(font, glyphId);
    if (path?.bounds) {
      maxAscent = Math.max(maxAscent, -path.bounds.yMin * scale);
      maxDescent = Math.max(maxDescent, path.bounds.yMax * scale);
    }
    glyphs.push({ glyphId, advance });
    totalAdvance += advance;
  }
  if (glyphs.length === 0)
    return null;
  const width = Math.ceil(totalAdvance) + padding * 2;
  const height = Math.ceil(maxAscent + maxDescent) + padding * 2;
  const bitmap = createBitmap(width, height, pixelMode);
  const raster = getSharedRaster();
  raster.setClip(0, 0, width, height);
  raster.setBandBounds(0, height);
  let x = padding;
  const baseline = maxDescent + padding;
  for (let i = 0;i < glyphs.length; i++) {
    const glyph = glyphs[i];
    const path = getGlyphPath(font, glyph.glyphId);
    if (path) {
      raster.reset();
      decomposePath(raster, path, scale, x, baseline, true);
      raster.sweep(bitmap);
    }
    x += glyph.advance;
  }
  return bitmap;
}
function bitmapToRGBA(bitmap) {
  const isLCD = bitmap.pixelMode === 2 /* LCD */;
  const isLCDV = bitmap.pixelMode === 3 /* LCD_V */;
  const rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);
  const pitch = bitmap.pitch;
  const absPitch = Math.abs(pitch);
  const origin = pitch < 0 ? (bitmap.rows - 1) * absPitch : 0;
  for (let y = 0;y < bitmap.rows; y++) {
    const srcRow = origin + y * pitch;
    for (let x = 0;x < bitmap.width; x++) {
      const dstIdx = (y * bitmap.width + x) * 4;
      if (bitmap.pixelMode === 1 /* Gray */) {
        const srcIdx = srcRow + x;
        const alpha = bitmap.buffer[srcIdx] ?? 0;
        rgba[dstIdx] = 255 - alpha;
        rgba[dstIdx + 1] = 255 - alpha;
        rgba[dstIdx + 2] = 255 - alpha;
        rgba[dstIdx + 3] = 255;
      } else if (bitmap.pixelMode === 0 /* Mono */) {
        const byteIdx = srcRow + (x >> 3);
        const bitIdx = 7 - (x & 7);
        const alpha = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1 ? 255 : 0;
        rgba[dstIdx] = 255 - alpha;
        rgba[dstIdx + 1] = 255 - alpha;
        rgba[dstIdx + 2] = 255 - alpha;
        rgba[dstIdx + 3] = 255;
      } else if (isLCD || isLCDV) {
        const srcIdx = srcRow + x * 3;
        const r = bitmap.buffer[srcIdx] ?? 0;
        const g = bitmap.buffer[srcIdx + 1] ?? 0;
        const b = bitmap.buffer[srcIdx + 2] ?? 0;
        rgba[dstIdx] = 255 - r;
        rgba[dstIdx + 1] = 255 - g;
        rgba[dstIdx + 2] = 255 - b;
        rgba[dstIdx + 3] = 255;
      } else if (bitmap.pixelMode === 4 /* RGBA */) {
        const srcIdx = srcRow + x * 4;
        rgba[dstIdx] = bitmap.buffer[srcIdx] ?? 0;
        rgba[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;
        rgba[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;
        rgba[dstIdx + 3] = bitmap.buffer[srcIdx + 3] ?? 0;
      } else {
        const srcIdx = srcRow + x;
        const alpha = bitmap.buffer[srcIdx] ?? 0;
        rgba[dstIdx] = 255 - alpha;
        rgba[dstIdx + 1] = 255 - alpha;
        rgba[dstIdx + 2] = 255 - alpha;
        rgba[dstIdx + 3] = 255;
      }
    }
  }
  return rgba;
}
function bitmapToGray(bitmap) {
  if (bitmap.pixelMode === 1 /* Gray */ && bitmap.pitch === bitmap.width) {
    return bitmap.buffer;
  }
  const gray = new Uint8Array(bitmap.width * bitmap.rows);
  const pitch = bitmap.pitch;
  const absPitch = Math.abs(pitch);
  const origin = pitch < 0 ? (bitmap.rows - 1) * absPitch : 0;
  for (let y = 0;y < bitmap.rows; y++) {
    const srcRow = origin + y * pitch;
    for (let x = 0;x < bitmap.width; x++) {
      const dstIdx = y * bitmap.width + x;
      if (bitmap.pixelMode === 1 /* Gray */) {
        gray[dstIdx] = bitmap.buffer[srcRow + x] ?? 0;
      } else if (bitmap.pixelMode === 0 /* Mono */) {
        const byteIdx = srcRow + (x >> 3);
        const bitIdx = 7 - (x & 7);
        gray[dstIdx] = (bitmap.buffer[byteIdx] ?? 0) >> bitIdx & 1 ? 255 : 0;
      } else if (bitmap.pixelMode === 2 /* LCD */ || bitmap.pixelMode === 3 /* LCD_V */) {
        const srcIdx = srcRow + x * 3;
        const r = bitmap.buffer[srcIdx] ?? 0;
        const g = bitmap.buffer[srcIdx + 1] ?? 0;
        const b = bitmap.buffer[srcIdx + 2] ?? 0;
        gray[dstIdx] = Math.round((r + g + b) / 3);
      } else if (bitmap.pixelMode === 4 /* RGBA */) {
        const srcIdx = srcRow + x * 4;
        gray[dstIdx] = bitmap.buffer[srcIdx + 3] ?? 0;
      }
    }
  }
  return gray;
}

// reference/text-shaper/src/raster/atlas.ts
init_types();
function buildAtlas(font, glyphIds, options) {
  const {
    fontSize,
    sizeMode,
    padding = 1,
    maxWidth = 2048,
    maxHeight = 2048,
    pixelMode = 1 /* Gray */
  } = options;
  const glyphData = [];
  const scale = resolveFontScale(font, fontSize, sizeMode);
  for (let i = 0;i < glyphIds.length; i++) {
    const glyphId = glyphIds[i];
    const result = rasterizeGlyph(font, glyphId, fontSize, {
      padding: 0,
      pixelMode,
      sizeMode
    });
    if (!result)
      continue;
    const advance = font.advanceWidth(glyphId) * scale;
    glyphData.push({
      glyphId,
      bitmap: result.bitmap,
      bearingX: result.bearingX,
      bearingY: result.bearingY,
      advance
    });
  }
  glyphData.sort((a, b) => b.bitmap.rows - a.bitmap.rows);
  const {
    width: atlasWidth,
    height: atlasHeight,
    placements
  } = packGlyphs(glyphData.map((g) => ({
    width: g.bitmap.width + padding * 2,
    height: g.bitmap.rows + padding * 2
  })), maxWidth, maxHeight);
  const atlas = createBitmap(atlasWidth, atlasHeight, pixelMode);
  const glyphMetrics = new Map;
  for (let i = 0;i < glyphData.length; i++) {
    const glyph = glyphData[i];
    const placement = placements[i];
    if (!placement.placed)
      continue;
    copyBitmap2(glyph.bitmap, atlas, placement.x + padding, placement.y + padding);
    glyphMetrics.set(glyph.glyphId, {
      glyphId: glyph.glyphId,
      atlasX: placement.x + padding,
      atlasY: placement.y + padding,
      width: glyph.bitmap.width,
      height: glyph.bitmap.rows,
      bearingX: glyph.bearingX,
      bearingY: glyph.bearingY,
      advance: glyph.advance
    });
  }
  return {
    bitmap: atlas,
    glyphs: glyphMetrics,
    fontSize
  };
}
function buildAsciiAtlas(font, options) {
  const glyphIds = [];
  for (let codepoint = 32;codepoint <= 126; codepoint++) {
    const glyphId = font.glyphId(codepoint);
    if (glyphId !== undefined && glyphId !== 0) {
      glyphIds.push(glyphId);
    }
  }
  return buildAtlas(font, glyphIds, options);
}
function buildStringAtlas(font, text, options) {
  const glyphIdSet = new Set;
  const textArray = [...text];
  for (let i = 0;i < textArray.length; i++) {
    const char = textArray[i];
    const codepoint = char.codePointAt(0);
    if (codepoint === undefined)
      continue;
    const glyphId = font.glyphId(codepoint);
    if (glyphId !== undefined && glyphId !== 0) {
      glyphIdSet.add(glyphId);
    }
  }
  return buildAtlas(font, [...glyphIdSet], options);
}
function packGlyphs(sizes, maxWidth, maxHeight) {
  const shelves = [];
  const placements = [];
  let atlasWidth = 0;
  let atlasHeight = 0;
  for (let i = 0;i < sizes.length; i++) {
    const size = sizes[i];
    let placed = false;
    let bestShelf = -1;
    let bestY = maxHeight;
    for (let j = 0;j < shelves.length; j++) {
      const shelf = shelves[j];
      if (shelf.width + size.width <= maxWidth && size.height <= shelf.height) {
        if (shelf.y < bestY) {
          bestShelf = j;
          bestY = shelf.y;
        }
      }
    }
    if (bestShelf >= 0) {
      const shelf = shelves[bestShelf];
      placements.push({
        x: shelf.width,
        y: shelf.y,
        placed: true
      });
      shelf.width += size.width;
      atlasWidth = Math.max(atlasWidth, shelf.width);
      placed = true;
    } else {
      const newY = atlasHeight;
      if (newY + size.height <= maxHeight && size.width <= maxWidth) {
        shelves.push({
          y: newY,
          height: size.height,
          width: size.width
        });
        placements.push({
          x: 0,
          y: newY,
          placed: true
        });
        atlasHeight = newY + size.height;
        atlasWidth = Math.max(atlasWidth, size.width);
        placed = true;
      }
    }
    if (!placed) {
      placements.push({ x: 0, y: 0, placed: false });
    }
  }
  const finalWidth = nextPowerOf2(atlasWidth);
  const finalHeight = nextPowerOf2(atlasHeight);
  return {
    width: Math.min(finalWidth, maxWidth),
    height: Math.min(finalHeight, maxHeight),
    placements
  };
}
function copyBitmap2(src, dst, dstX, dstY) {
  const bytesPerPixel = src.pixelMode === 2 /* LCD */ ? 3 : 1;
  for (let y = 0;y < src.rows; y++) {
    const srcRow = y * src.pitch;
    const dstRow = (dstY + y) * dst.pitch + dstX * bytesPerPixel;
    for (let x = 0;x < src.width * bytesPerPixel; x++) {
      dst.buffer[dstRow + x] = src.buffer[srcRow + x];
    }
  }
}
function nextPowerOf2(n) {
  if (n <= 0)
    return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  return n + 1;
}
function atlasToRGBA(atlas) {
  const { bitmap } = atlas;
  const rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);
  for (let y = 0;y < bitmap.rows; y++) {
    for (let x = 0;x < bitmap.width; x++) {
      const srcIdx = y * bitmap.pitch + x;
      const dstIdx = (y * bitmap.width + x) * 4;
      const alpha = bitmap.buffer[srcIdx] ?? 0;
      rgba[dstIdx] = 255;
      rgba[dstIdx + 1] = 255;
      rgba[dstIdx + 2] = 255;
      rgba[dstIdx + 3] = alpha;
    }
  }
  return rgba;
}
function atlasToAlpha(atlas) {
  const { bitmap } = atlas;
  if (bitmap.pitch === bitmap.width) {
    return bitmap.buffer;
  }
  const alpha = new Uint8Array(bitmap.width * bitmap.rows);
  for (let y = 0;y < bitmap.rows; y++) {
    for (let x = 0;x < bitmap.width; x++) {
      alpha[y * bitmap.width + x] = bitmap.buffer[y * bitmap.pitch + x];
    }
  }
  return alpha;
}
function getGlyphUV(atlas, glyphId) {
  const metrics = atlas.glyphs.get(glyphId);
  if (!metrics)
    return null;
  const { bitmap } = atlas;
  return {
    u0: metrics.atlasX / bitmap.width,
    v0: metrics.atlasY / bitmap.rows,
    u1: (metrics.atlasX + metrics.width) / bitmap.width,
    v1: (metrics.atlasY + metrics.height) / bitmap.rows
  };
}

// reference/text-shaper/src/raster/msdf.ts
init_types();
function median(a, b, c) {
  return Math.max(Math.min(a, b), Math.min(Math.max(a, b), c));
}
function signedDistanceToLine(px, py, p0, p1) {
  const dx = p1.x - p0.x;
  const dy = p1.y - p0.y;
  const lenSq = dx * dx + dy * dy;
  if (lenSq < 0.0000000001) {
    const dist2 = Math.sqrt((px - p0.x) ** 2 + (py - p0.y) ** 2);
    return { distance: dist2, t: 0 };
  }
  let t = ((px - p0.x) * dx + (py - p0.y) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  const dist = Math.sqrt((px - p0.x - t * dx) ** 2 + (py - p0.y - t * dy) ** 2);
  const cross = dx * (py - p0.y) - dy * (px - p0.x);
  const sign2 = cross >= 0 ? 1 : -1;
  return { distance: sign2 * dist, t };
}
function unsignedDistanceToLine(px, py, p0, p1) {
  const dx = p1.x - p0.x;
  const dy = p1.y - p0.y;
  const lenSq = dx * dx + dy * dy;
  if (lenSq < 0.0000000001)
    return Math.sqrt((px - p0.x) ** 2 + (py - p0.y) ** 2);
  let t = ((px - p0.x) * dx + (py - p0.y) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return Math.sqrt((px - p0.x - t * dx) ** 2 + (py - p0.y - t * dy) ** 2);
}
function signedDistanceToQuadratic(px, py, p0, p1, p2) {
  const ax = p0.x - 2 * p1.x + p2.x;
  const ay = p0.y - 2 * p1.y + p2.y;
  let minDist = Math.min(Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2), Math.sqrt((p2.x - px) ** 2 + (p2.y - py) ** 2));
  let minT = minDist === Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2) ? 0 : 1;
  for (let i = 1;i < 6; i++) {
    let t = i / 6;
    for (let iter = 0;iter < 3; iter++) {
      const ti3 = 1 - t;
      const bx_t3 = ti3 * ti3 * p0.x + 2 * ti3 * t * p1.x + t * t * p2.x;
      const by_t3 = ti3 * ti3 * p0.y + 2 * ti3 * t * p1.y + t * t * p2.y;
      const dx = 2 * (ti3 * (p1.x - p0.x) + t * (p2.x - p1.x));
      const dy = 2 * (ti3 * (p1.y - p0.y) + t * (p2.y - p1.y));
      const vx = bx_t3 - px;
      const vy = by_t3 - py;
      const f = vx * dx + vy * dy;
      const df = dx * dx + dy * dy + vx * 2 * ax + vy * 2 * ay;
      if (Math.abs(df) < 0.0000000001)
        break;
      t = Math.max(0, Math.min(1, t - f / df));
    }
    const ti2 = 1 - t;
    const bx_t2 = ti2 * ti2 * p0.x + 2 * ti2 * t * p1.x + t * t * p2.x;
    const by_t2 = ti2 * ti2 * p0.y + 2 * ti2 * t * p1.y + t * t * p2.y;
    const dist = Math.sqrt((bx_t2 - px) ** 2 + (by_t2 - py) ** 2);
    if (dist < minDist) {
      minDist = dist;
      minT = t;
    }
  }
  const ti = 1 - minT;
  const tangentX = 2 * (ti * (p1.x - p0.x) + minT * (p2.x - p1.x));
  const tangentY = 2 * (ti * (p1.y - p0.y) + minT * (p2.y - p1.y));
  const bx_t = ti * ti * p0.x + 2 * ti * minT * p1.x + minT * minT * p2.x;
  const by_t = ti * ti * p0.y + 2 * ti * minT * p1.y + minT * minT * p2.y;
  const cross = tangentX * (py - by_t) - tangentY * (px - bx_t);
  const minSign = cross >= 0 ? 1 : -1;
  return { distance: minSign * minDist, t: minT };
}
function unsignedDistanceToQuadratic(px, py, p0, p1, p2) {
  const ax = p0.x - 2 * p1.x + p2.x;
  const ay = p0.y - 2 * p1.y + p2.y;
  let minDist = Math.min(Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2), Math.sqrt((p2.x - px) ** 2 + (p2.y - py) ** 2));
  for (let i = 1;i < 6; i++) {
    let t = i / 6;
    for (let iter = 0;iter < 3; iter++) {
      const ti2 = 1 - t;
      const bx = ti2 * ti2 * p0.x + 2 * ti2 * t * p1.x + t * t * p2.x;
      const by = ti2 * ti2 * p0.y + 2 * ti2 * t * p1.y + t * t * p2.y;
      const dx = 2 * (ti2 * (p1.x - p0.x) + t * (p2.x - p1.x));
      const dy = 2 * (ti2 * (p1.y - p0.y) + t * (p2.y - p1.y));
      const vx = bx - px;
      const vy = by - py;
      const df = dx * dx + dy * dy + vx * 2 * ax + vy * 2 * ay;
      if (Math.abs(df) < 0.0000000001)
        break;
      t = Math.max(0, Math.min(1, t - (vx * dx + vy * dy) / df));
    }
    const ti = 1 - t;
    const dist = Math.sqrt((ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x - px) ** 2 + (ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y - py) ** 2);
    if (dist < minDist)
      minDist = dist;
  }
  return minDist;
}
function signedDistanceToCubic(px, py, p0, p1, p2, p3) {
  let minDist = Math.min(Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2), Math.sqrt((p3.x - px) ** 2 + (p3.y - py) ** 2));
  let minT = minDist === Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2) ? 0 : 1;
  for (let i = 1;i < 6; i++) {
    let t = i / 6;
    for (let iter = 0;iter < 3; iter++) {
      const ti5 = 1 - t;
      const ti23 = ti5 * ti5;
      const ti33 = ti23 * ti5;
      const t23 = t * t;
      const t33 = t23 * t;
      const bx_t3 = ti33 * p0.x + 3 * ti23 * t * p1.x + 3 * ti5 * t23 * p2.x + t33 * p3.x;
      const by_t3 = ti33 * p0.y + 3 * ti23 * t * p1.y + 3 * ti5 * t23 * p2.y + t33 * p3.y;
      const dx = 3 * ti23 * (p1.x - p0.x) + 6 * ti5 * t * (p2.x - p1.x) + 3 * t23 * (p3.x - p2.x);
      const dy = 3 * ti23 * (p1.y - p0.y) + 6 * ti5 * t * (p2.y - p1.y) + 3 * t23 * (p3.y - p2.y);
      const ddx = 6 * ti5 * (p2.x - 2 * p1.x + p0.x) + 6 * t * (p3.x - 2 * p2.x + p1.x);
      const ddy = 6 * ti5 * (p2.y - 2 * p1.y + p0.y) + 6 * t * (p3.y - 2 * p2.y + p1.y);
      const vx = bx_t3 - px;
      const vy = by_t3 - py;
      const f = vx * dx + vy * dy;
      const df = dx * dx + dy * dy + vx * ddx + vy * ddy;
      if (Math.abs(df) < 0.0000000001)
        break;
      t = Math.max(0, Math.min(1, t - f / df));
    }
    const ti4 = 1 - t;
    const ti22 = ti4 * ti4;
    const ti32 = ti22 * ti4;
    const t22 = t * t;
    const t32 = t22 * t;
    const bx_t2 = ti32 * p0.x + 3 * ti22 * t * p1.x + 3 * ti4 * t22 * p2.x + t32 * p3.x;
    const by_t2 = ti32 * p0.y + 3 * ti22 * t * p1.y + 3 * ti4 * t22 * p2.y + t32 * p3.y;
    const dist = Math.sqrt((bx_t2 - px) ** 2 + (by_t2 - py) ** 2);
    if (dist < minDist) {
      minDist = dist;
      minT = t;
    }
  }
  const ti = 1 - minT;
  const ti2 = ti * ti;
  const t2 = minT * minT;
  const tangentX = 3 * ti2 * (p1.x - p0.x) + 6 * ti * minT * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x);
  const tangentY = 3 * ti2 * (p1.y - p0.y) + 6 * ti * minT * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y);
  const ti3 = ti2 * ti;
  const t3 = t2 * minT;
  const bx_t = ti3 * p0.x + 3 * ti2 * minT * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x;
  const by_t = ti3 * p0.y + 3 * ti2 * minT * p1.y + 3 * ti * t2 * p2.y + t3 * p3.y;
  const cross = tangentX * (py - by_t) - tangentY * (px - bx_t);
  const minSign = cross >= 0 ? 1 : -1;
  return { distance: minSign * minDist, t: minT };
}
function unsignedDistanceToCubic(px, py, p0, p1, p2, p3) {
  let minDist = Math.min(Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2), Math.sqrt((p3.x - px) ** 2 + (p3.y - py) ** 2));
  for (let i = 1;i < 6; i++) {
    let t = i / 6;
    for (let iter = 0;iter < 3; iter++) {
      const ti4 = 1 - t;
      const ti22 = ti4 * ti4;
      const ti32 = ti22 * ti4;
      const t22 = t * t;
      const t32 = t22 * t;
      const bx = ti32 * p0.x + 3 * ti22 * t * p1.x + 3 * ti4 * t22 * p2.x + t32 * p3.x;
      const by = ti32 * p0.y + 3 * ti22 * t * p1.y + 3 * ti4 * t22 * p2.y + t32 * p3.y;
      const dx = 3 * ti22 * (p1.x - p0.x) + 6 * ti4 * t * (p2.x - p1.x) + 3 * t22 * (p3.x - p2.x);
      const dy = 3 * ti22 * (p1.y - p0.y) + 6 * ti4 * t * (p2.y - p1.y) + 3 * t22 * (p3.y - p2.y);
      const ddx = 6 * ti4 * (p2.x - 2 * p1.x + p0.x) + 6 * t * (p3.x - 2 * p2.x + p1.x);
      const ddy = 6 * ti4 * (p2.y - 2 * p1.y + p0.y) + 6 * t * (p3.y - 2 * p2.y + p1.y);
      const vx = bx - px;
      const vy = by - py;
      const df = dx * dx + dy * dy + vx * ddx + vy * ddy;
      if (Math.abs(df) < 0.0000000001)
        break;
      t = Math.max(0, Math.min(1, t - (vx * dx + vy * dy) / df));
    }
    const ti = 1 - t;
    const ti2 = ti * ti;
    const ti3 = ti2 * ti;
    const t2 = t * t;
    const t3 = t2 * t;
    const dist = Math.sqrt((ti3 * p0.x + 3 * ti2 * t * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x - px) ** 2 + (ti3 * p0.y + 3 * ti2 * t * p1.y + 3 * ti * t2 * p2.y + t3 * p3.y - py) ** 2);
    if (dist < minDist)
      minDist = dist;
  }
  return minDist;
}
function getEdgeStartDirection(edge) {
  switch (edge.type) {
    case "line":
      return { x: edge.p1.x - edge.p0.x, y: edge.p1.y - edge.p0.y };
    case "quadratic":
      return { x: 2 * (edge.p1.x - edge.p0.x), y: 2 * (edge.p1.y - edge.p0.y) };
    case "cubic":
      return { x: 3 * (edge.p1.x - edge.p0.x), y: 3 * (edge.p1.y - edge.p0.y) };
  }
}
function getEdgeEndDirection(edge) {
  switch (edge.type) {
    case "line":
      return { x: edge.p1.x - edge.p0.x, y: edge.p1.y - edge.p0.y };
    case "quadratic":
      return { x: 2 * (edge.p2.x - edge.p1.x), y: 2 * (edge.p2.y - edge.p1.y) };
    case "cubic":
      return { x: 3 * (edge.p3.x - edge.p2.x), y: 3 * (edge.p3.y - edge.p2.y) };
  }
}
function normalize2(v) {
  const len = Math.sqrt(v.x * v.x + v.y * v.y);
  if (len < 0.0000000001)
    return { x: 0, y: 0 };
  return { x: v.x / len, y: v.y / len };
}
function dot(a, b) {
  return a.x * b.x + a.y * b.y;
}
function isSharpCorner(dir1, dir2, threshold = Math.PI / 3) {
  const n1 = normalize2(dir1);
  const n2 = normalize2(dir2);
  const cosAngle = dot(n1, n2);
  const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
  return angle > threshold && angle < Math.PI - threshold;
}
function assignEdgeColors(contours) {
  const CORNER_THRESHOLD = Math.PI / 4;
  for (let i = 0;i < contours.length; i++) {
    const contour = contours[i];
    if (contour.length === 0)
      continue;
    if (contour.length === 1) {
      contour[0].color = 0;
      continue;
    }
    let currentColor = 0;
    for (let j = 0;j < contour.length; j++) {
      const edge = contour[j];
      const prevEdge = contour[(j - 1 + contour.length) % contour.length];
      if (j === 0) {
        edge.color = currentColor;
      } else {
        const prevDir = getEdgeEndDirection(prevEdge);
        const currDir = getEdgeStartDirection(edge);
        if (isSharpCorner(prevDir, currDir, CORNER_THRESHOLD)) {
          currentColor = (currentColor + 1) % 3;
        }
        edge.color = currentColor;
      }
    }
    if (contour.length >= 2) {
      const lastEdge = contour[contour.length - 1];
      const firstEdge = contour[0];
      const lastDir = getEdgeEndDirection(lastEdge);
      const firstDir = getEdgeStartDirection(firstEdge);
      if (isSharpCorner(lastDir, firstDir, CORNER_THRESHOLD)) {
        if (lastEdge.color === firstEdge.color) {
          const prevColor = contour[contour.length - 2]?.color ?? 0;
          const _nextColor = contour[1]?.color ?? 0;
          for (let c = 0;c < 3; c++) {
            if (c !== firstEdge.color && c !== prevColor) {
              lastEdge.color = c;
              break;
            }
          }
        }
      }
    }
  }
}
function extractEdges2(path, scale, offsetX, offsetY, flipY) {
  const contours = [];
  let currentContour = [];
  let currentPoint = null;
  let firstPoint = null;
  const transform = (x, y) => ({
    x: x * scale + offsetX,
    y: flipY ? -(y * scale) + offsetY : y * scale + offsetY
  });
  for (let i = 0;i < path.commands.length; i++) {
    const cmd = path.commands[i];
    switch (cmd.type) {
      case "M":
        if (currentContour.length > 0) {
          contours.push(currentContour);
          currentContour = [];
        }
        currentPoint = transform(cmd.x, cmd.y);
        firstPoint = currentPoint;
        break;
      case "L":
        if (currentPoint) {
          const p1 = transform(cmd.x, cmd.y);
          if (Math.abs(p1.x - currentPoint.x) > 0.000001 || Math.abs(p1.y - currentPoint.y) > 0.000001) {
            currentContour.push({
              type: "line",
              p0: currentPoint,
              p1,
              color: 0,
              minX: Math.min(currentPoint.x, p1.x),
              maxX: Math.max(currentPoint.x, p1.x),
              minY: Math.min(currentPoint.y, p1.y),
              maxY: Math.max(currentPoint.y, p1.y)
            });
          }
          currentPoint = p1;
        }
        break;
      case "Q":
        if (currentPoint) {
          const p1 = transform(cmd.x1, cmd.y1);
          const p2 = transform(cmd.x, cmd.y);
          currentContour.push({
            type: "quadratic",
            p0: currentPoint,
            p1,
            p2,
            color: 0,
            minX: Math.min(currentPoint.x, p1.x, p2.x),
            maxX: Math.max(currentPoint.x, p1.x, p2.x),
            minY: Math.min(currentPoint.y, p1.y, p2.y),
            maxY: Math.max(currentPoint.y, p1.y, p2.y)
          });
          currentPoint = p2;
        }
        break;
      case "C":
        if (currentPoint) {
          const p1 = transform(cmd.x1, cmd.y1);
          const p2 = transform(cmd.x2, cmd.y2);
          const p3 = transform(cmd.x, cmd.y);
          currentContour.push({
            type: "cubic",
            p0: currentPoint,
            p1,
            p2,
            p3,
            color: 0,
            minX: Math.min(currentPoint.x, p1.x, p2.x, p3.x),
            maxX: Math.max(currentPoint.x, p1.x, p2.x, p3.x),
            minY: Math.min(currentPoint.y, p1.y, p2.y, p3.y),
            maxY: Math.max(currentPoint.y, p1.y, p2.y, p3.y)
          });
          currentPoint = p3;
        }
        break;
      case "Z":
        if (currentPoint && firstPoint) {
          if (Math.abs(currentPoint.x - firstPoint.x) > 0.000001 || Math.abs(currentPoint.y - firstPoint.y) > 0.000001) {
            currentContour.push({
              type: "line",
              p0: currentPoint,
              p1: firstPoint,
              color: 0,
              minX: Math.min(currentPoint.x, firstPoint.x),
              maxX: Math.max(currentPoint.x, firstPoint.x),
              minY: Math.min(currentPoint.y, firstPoint.y),
              maxY: Math.max(currentPoint.y, firstPoint.y)
            });
          }
          currentPoint = firstPoint;
        }
        if (currentContour.length > 0) {
          contours.push(currentContour);
          currentContour = [];
        }
        break;
    }
  }
  if (currentContour.length > 0) {
    contours.push(currentContour);
  }
  return contours;
}
function unsignedDistanceToEdge(px, py, edge) {
  switch (edge.type) {
    case "line":
      return unsignedDistanceToLine(px, py, edge.p0, edge.p1);
    case "quadratic":
      return unsignedDistanceToQuadratic(px, py, edge.p0, edge.p1, edge.p2);
    case "cubic":
      return unsignedDistanceToCubic(px, py, edge.p0, edge.p1, edge.p2, edge.p3);
  }
}
function preFlattenContours(contours) {
  const result = [];
  for (let ci = 0;ci < contours.length; ci++) {
    const contour = contours[ci];
    const segments = [];
    for (let ei = 0;ei < contour.length; ei++) {
      const edge = contour[ei];
      if (edge.type === "line") {
        segments.push([edge.p0, edge.p1]);
      } else if (edge.type === "quadratic") {
        let prev = edge.p0;
        for (let i = 1;i <= 4; i++) {
          const t = i / 4;
          const ti = 1 - t;
          const p = {
            x: ti * ti * edge.p0.x + 2 * ti * t * edge.p1.x + t * t * edge.p2.x,
            y: ti * ti * edge.p0.y + 2 * ti * t * edge.p1.y + t * t * edge.p2.y
          };
          segments.push([prev, p]);
          prev = p;
        }
      } else {
        let prev = edge.p0;
        for (let i = 1;i <= 4; i++) {
          const t = i / 4;
          const ti = 1 - t;
          const ti2 = ti * ti;
          const ti3 = ti2 * ti;
          const t2 = t * t;
          const t3 = t2 * t;
          const p = {
            x: ti3 * edge.p0.x + 3 * ti2 * t * edge.p1.x + 3 * ti * t2 * edge.p2.x + t3 * edge.p3.x,
            y: ti3 * edge.p0.y + 3 * ti2 * t * edge.p1.y + 3 * ti * t2 * edge.p2.y + t3 * edge.p3.y
          };
          segments.push([prev, p]);
          prev = p;
        }
      }
    }
    result.push(segments);
  }
  return result;
}
function isPointInsideFast(px, py, flatContours) {
  let crossings = 0;
  for (let i = 0;i < flatContours.length; i++) {
    const segments = flatContours[i];
    for (let j = 0;j < segments.length; j++) {
      const [p0, p1] = segments[j];
      if (p0.y > py !== p1.y > py) {
        const x = p0.x + (p1.x - p0.x) * (py - p0.y) / (p1.y - p0.y);
        if (px < x)
          crossings++;
      }
    }
  }
  return (crossings & 1) === 1;
}
function findMinDistance(px, py, edges) {
  let minDist = Infinity;
  for (let i = 0;i < edges.length; i++) {
    const edge = edges[i];
    const dx = px < edge.minX ? edge.minX - px : px > edge.maxX ? px - edge.maxX : 0;
    const dy = py < edge.minY ? edge.minY - py : py > edge.maxY ? py - edge.maxY : 0;
    if (dx * dx + dy * dy >= minDist * minDist)
      continue;
    const d = unsignedDistanceToEdge(px, py, edge);
    if (d < minDist) {
      minDist = d;
      if (d < 0.5)
        break;
    }
  }
  return minDist;
}
function renderMsdf(path, options) {
  const {
    width,
    height,
    scale,
    offsetX = 0,
    offsetY = 0,
    flipY = false,
    spread = 8
  } = options;
  const bitmap = createBitmap(width, height, 2 /* LCD */);
  const contours = extractEdges2(path, scale, offsetX, offsetY, flipY);
  if (contours.length === 0 || contours.every((c) => c.length === 0)) {
    bitmap.buffer.fill(0);
    return bitmap;
  }
  assignEdgeColors(contours);
  const flatContours = preFlattenContours(contours);
  const allEdges = contours.flat();
  const redEdges = allEdges.filter((e) => e.color === 0);
  const greenEdges = allEdges.filter((e) => e.color === 1);
  const blueEdges = allEdges.filter((e) => e.color === 2);
  const rEdges = redEdges.length > 0 ? redEdges : allEdges;
  const gEdges = greenEdges.length > 0 ? greenEdges : allEdges;
  const bEdges = blueEdges.length > 0 ? blueEdges : allEdges;
  for (let y = 0;y < height; y++) {
    for (let x = 0;x < width; x++) {
      const px = x + 0.5;
      const py = y + 0.5;
      const minR = findMinDistance(px, py, rEdges);
      const minG = findMinDistance(px, py, gEdges);
      const minB = findMinDistance(px, py, bEdges);
      const inside = isPointInsideFast(px, py, flatContours);
      const signCorrection = inside ? 1 : -1;
      const rDist = minR * signCorrection;
      const gDist = minG * signCorrection;
      const bDist = minB * signCorrection;
      const encode = (d) => {
        const normalized = 128 + d / spread * 127;
        return Math.max(0, Math.min(255, Math.round(normalized)));
      };
      const idx = y * bitmap.pitch + x * 3;
      bitmap.buffer[idx] = encode(rDist);
      bitmap.buffer[idx + 1] = encode(gDist);
      bitmap.buffer[idx + 2] = encode(bDist);
    }
  }
  return bitmap;
}
function packGlyphs2(sizes, maxWidth, maxHeight) {
  const shelves = [];
  const placements = [];
  let atlasWidth = 0;
  let atlasHeight = 0;
  for (let i = 0;i < sizes.length; i++) {
    const size = sizes[i];
    let placed = false;
    let bestShelf = -1;
    let bestY = maxHeight;
    for (let j = 0;j < shelves.length; j++) {
      const shelf = shelves[j];
      if (shelf.width + size.width <= maxWidth && size.height <= shelf.height) {
        if (shelf.y < bestY) {
          bestShelf = j;
          bestY = shelf.y;
        }
      }
    }
    if (bestShelf >= 0) {
      const shelf = shelves[bestShelf];
      placements.push({
        x: shelf.width,
        y: shelf.y,
        placed: true
      });
      shelf.width += size.width;
      atlasWidth = Math.max(atlasWidth, shelf.width);
      placed = true;
    } else {
      const newY = atlasHeight;
      if (newY + size.height <= maxHeight && size.width <= maxWidth) {
        shelves.push({
          y: newY,
          height: size.height,
          width: size.width
        });
        placements.push({
          x: 0,
          y: newY,
          placed: true
        });
        atlasHeight = newY + size.height;
        atlasWidth = Math.max(atlasWidth, size.width);
        placed = true;
      }
    }
    if (!placed) {
      placements.push({ x: 0, y: 0, placed: false });
    }
  }
  const finalWidth = nextPowerOf22(atlasWidth);
  const finalHeight = nextPowerOf22(atlasHeight);
  return {
    width: Math.min(finalWidth, maxWidth),
    height: Math.min(finalHeight, maxHeight),
    placements
  };
}
function nextPowerOf22(n) {
  if (n <= 0)
    return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  return n + 1;
}
function copyBitmapRgb(src, dst, dstX, dstY) {
  for (let y = 0;y < src.rows; y++) {
    const srcRow = y * src.pitch;
    const dstRow = (dstY + y) * dst.pitch + dstX * 3;
    for (let x = 0;x < src.width * 3; x++) {
      dst.buffer[dstRow + x] = src.buffer[srcRow + x];
    }
  }
}
function buildMsdfAtlas(font, glyphIds, options) {
  const {
    fontSize,
    sizeMode,
    padding = 2,
    maxWidth = 2048,
    maxHeight = 2048,
    spread = 4
  } = options;
  const scale = resolveFontScale(font, fontSize, sizeMode);
  const glyphData = [];
  for (let i = 0;i < glyphIds.length; i++) {
    const glyphId = glyphIds[i];
    const path = getGlyphPath(font, glyphId);
    if (!path || !path.bounds)
      continue;
    const bounds = path.bounds;
    const glyphWidth = Math.ceil((bounds.xMax - bounds.xMin) * scale) + spread * 2;
    const glyphHeight = Math.ceil((bounds.yMax - bounds.yMin) * scale) + spread * 2;
    if (glyphWidth <= 0 || glyphHeight <= 0)
      continue;
    const bitmap = renderMsdf(path, {
      width: glyphWidth,
      height: glyphHeight,
      scale,
      offsetX: -bounds.xMin * scale + spread,
      offsetY: bounds.yMax * scale + spread,
      flipY: true,
      spread
    });
    const advance = font.advanceWidth(glyphId) * scale;
    const bearingX = bounds.xMin * scale - spread;
    const bearingY = bounds.yMax * scale + spread;
    glyphData.push({
      glyphId,
      bitmap,
      bearingX,
      bearingY,
      advance
    });
  }
  glyphData.sort((a, b) => b.bitmap.rows - a.bitmap.rows);
  const {
    width: atlasWidth,
    height: atlasHeight,
    placements
  } = packGlyphs2(glyphData.map((g) => ({
    width: g.bitmap.width + padding * 2,
    height: g.bitmap.rows + padding * 2
  })), maxWidth, maxHeight);
  const atlas = createBitmap(atlasWidth, atlasHeight, 2 /* LCD */);
  const glyphMetrics = new Map;
  for (let i = 0;i < glyphData.length; i++) {
    const glyph = glyphData[i];
    const placement = placements[i];
    if (!placement.placed)
      continue;
    copyBitmapRgb(glyph.bitmap, atlas, placement.x + padding, placement.y + padding);
    glyphMetrics.set(glyph.glyphId, {
      glyphId: glyph.glyphId,
      atlasX: placement.x + padding,
      atlasY: placement.y + padding,
      width: glyph.bitmap.width,
      height: glyph.bitmap.rows,
      bearingX: glyph.bearingX,
      bearingY: glyph.bearingY,
      advance: glyph.advance
    });
  }
  return {
    bitmap: atlas,
    glyphs: glyphMetrics,
    fontSize
  };
}
function buildMsdfAsciiAtlas(font, options) {
  const glyphIds = [];
  for (let codepoint = 32;codepoint <= 126; codepoint++) {
    const glyphId = font.glyphId(codepoint);
    if (glyphId !== undefined && glyphId !== 0) {
      glyphIds.push(glyphId);
    }
  }
  return buildMsdfAtlas(font, glyphIds, options);
}
function buildMsdfStringAtlas(font, text, options) {
  const glyphIdSet = new Set;
  const textArray = Array.from(text);
  for (let i = 0;i < textArray.length; i++) {
    const char = textArray[i];
    const codepoint = char.codePointAt(0);
    if (codepoint === undefined)
      continue;
    const glyphId = font.glyphId(codepoint);
    if (glyphId !== undefined && glyphId !== 0) {
      glyphIdSet.add(glyphId);
    }
  }
  return buildMsdfAtlas(font, [...glyphIdSet], options);
}
function msdfAtlasToRGB(atlas) {
  const { bitmap } = atlas;
  if (bitmap.pitch === bitmap.width * 3) {
    return bitmap.buffer;
  }
  const rgb = new Uint8Array(bitmap.width * bitmap.rows * 3);
  for (let y = 0;y < bitmap.rows; y++) {
    for (let x = 0;x < bitmap.width * 3; x++) {
      rgb[y * bitmap.width * 3 + x] = bitmap.buffer[y * bitmap.pitch + x];
    }
  }
  return rgb;
}
function msdfAtlasToRGBA(atlas) {
  const { bitmap } = atlas;
  const rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);
  for (let y = 0;y < bitmap.rows; y++) {
    for (let x = 0;x < bitmap.width; x++) {
      const srcIdx = y * bitmap.pitch + x * 3;
      const dstIdx = (y * bitmap.width + x) * 4;
      rgba[dstIdx] = bitmap.buffer[srcIdx];
      rgba[dstIdx + 1] = bitmap.buffer[srcIdx + 1];
      rgba[dstIdx + 2] = bitmap.buffer[srcIdx + 2];
      rgba[dstIdx + 3] = 255;
    }
  }
  return rgba;
}

// reference/text-shaper/src/raster/cascade-blur.ts
init_types();
var PI = Math.PI;
function calcGauss(res, n, r2) {
  const alpha = 0.5 / r2;
  let mul = Math.exp(-alpha);
  const mul2 = mul * mul;
  let cur = Math.sqrt(alpha / PI);
  res[0] = cur;
  cur *= mul;
  res[1] = cur;
  for (let i = 2;i < n; i++) {
    mul *= mul2;
    cur *= mul;
    res[i] = cur;
  }
}
function coeffFilter(coeff, n, kernel) {
  let prev1 = coeff[1];
  let prev2 = coeff[2];
  let prev3 = coeff[3];
  for (let i = 0;i < n; i++) {
    const res = coeff[i] * kernel[0] + (prev1 + coeff[i + 1]) * kernel[1] + (prev2 + coeff[i + 2]) * kernel[2] + (prev3 + coeff[i + 3]) * kernel[3];
    prev3 = prev2;
    prev2 = prev1;
    prev1 = coeff[i];
    coeff[i] = res;
  }
}
function calcMatrix(mat, matFreq, n) {
  for (let i = 0;i < n; i++) {
    mat[i][i] = matFreq[2 * i + 2] + 3 * matFreq[0] - 4 * matFreq[i + 1];
    for (let j = i + 1;j < n; j++) {
      mat[i][j] = mat[j][i] = matFreq[i + j + 2] + matFreq[j - i] + 2 * (matFreq[0] - matFreq[i + 1] - matFreq[j + 1]);
    }
  }
  for (let k = 0;k < n; k++) {
    const z = 1 / mat[k][k];
    mat[k][k] = 1;
    for (let i = 0;i < n; i++) {
      if (i === k)
        continue;
      const mul = mat[i][k] * z;
      mat[i][k] = 0;
      for (let j = 0;j < n; j++) {
        mat[i][j] -= mat[k][j] * mul;
      }
    }
    for (let j = 0;j < n; j++) {
      mat[k][j] *= z;
    }
  }
}
function calcCoeff(mu, n, r2, mul) {
  const w = 12096;
  const kernel = [
    ((3280 / w * mul + 1092 / w) * mul + 2520 / w) * mul + 5204 / w,
    ((-2460 / w * mul - 273 / w) * mul - 210 / w) * mul + 2943 / w,
    ((984 / w * mul - 546 / w) * mul - 924 / w) * mul + 486 / w,
    ((-164 / w * mul + 273 / w) * mul - 126 / w) * mul + 17 / w
  ];
  const matFreq = new Float64Array(17);
  matFreq[0] = kernel[0];
  matFreq[1] = kernel[1];
  matFreq[2] = kernel[2];
  matFreq[3] = kernel[3];
  coeffFilter(matFreq, 7, kernel);
  const vecFreq = new Float64Array(12);
  calcGauss(vecFreq, n + 4, r2 * mul);
  coeffFilter(vecFreq, n + 1, kernel);
  const mat = [];
  for (let i = 0;i < 8; i++) {
    mat.push(new Float64Array(8));
  }
  calcMatrix(mat, matFreq, n);
  const vec = new Float64Array(8);
  for (let i = 0;i < n; i++) {
    vec[i] = matFreq[0] - matFreq[i + 1] - vecFreq[0] + vecFreq[i + 1];
  }
  for (let i = 0;i < n; i++) {
    let res = 0;
    for (let j = 0;j < n; j++) {
      res += mat[i][j] * vec[j];
    }
    mu[i] = Math.max(0, res);
  }
}
function findBestMethod(r2) {
  const mu = new Float64Array(8);
  let level;
  let radius;
  if (r2 < 0.5) {
    level = 0;
    radius = 4;
    mu[1] = 0.085 * r2 * r2 * r2;
    mu[0] = 0.5 * r2 - 4 * mu[1];
    mu[2] = mu[3] = 0;
  } else {
    const sqrtVal = Math.sqrt(0.11569 * r2 + 0.20591047);
    level = Math.floor(Math.log2(sqrtVal)) + 1;
    const frac = sqrtVal / 2 ** (level - 1) - 1;
    const mul = 0.25 ** level;
    radius = 8 - Math.floor((10.1525 + 0.8335 * mul) * (1 - frac));
    radius = Math.max(radius, 4);
    radius = Math.min(radius, 8);
    calcCoeff(mu, radius, r2, mul);
  }
  const coeff = new Float32Array(8);
  for (let i = 0;i < radius; i++) {
    coeff[i] = mu[i];
  }
  return { level, radius, coeff };
}
function shrinkHorz(dst, src, w, h, srcStride, dstStride) {
  const newW = Math.floor((w + 5) / 2);
  for (let y = 0;y < h; y++) {
    const srcRow = y * srcStride;
    const dstRow = y * dstStride;
    for (let x = 0;x < newW; x++) {
      const sx = x * 2;
      let sum = 0;
      sum += (src[srcRow + Math.max(0, sx - 2)] ?? 0) * 1;
      sum += (src[srcRow + Math.max(0, sx - 1)] ?? 0) * 5;
      sum += (src[srcRow + Math.min(w - 1, sx)] ?? 0) * 10;
      sum += (src[srcRow + Math.min(w - 1, sx + 1)] ?? 0) * 10;
      sum += (src[srcRow + Math.min(w - 1, sx + 2)] ?? 0) * 5;
      sum += (src[srcRow + Math.min(w - 1, sx + 3)] ?? 0) * 1;
      dst[dstRow + x] = sum / 32;
    }
  }
}
function shrinkVert(dst, src, w, h, srcStride, dstStride) {
  const newH = Math.floor((h + 5) / 2);
  for (let x = 0;x < w; x++) {
    for (let y = 0;y < newH; y++) {
      const sy = y * 2;
      let sum = 0;
      sum += (src[Math.max(0, sy - 2) * srcStride + x] ?? 0) * 1;
      sum += (src[Math.max(0, sy - 1) * srcStride + x] ?? 0) * 5;
      sum += (src[Math.min(h - 1, sy) * srcStride + x] ?? 0) * 10;
      sum += (src[Math.min(h - 1, sy + 1) * srcStride + x] ?? 0) * 10;
      sum += (src[Math.min(h - 1, sy + 2) * srcStride + x] ?? 0) * 5;
      sum += (src[Math.min(h - 1, sy + 3) * srcStride + x] ?? 0) * 1;
      dst[y * dstStride + x] = sum / 32;
    }
  }
}
function expandHorz(dst, src, w, h, srcStride, dstStride) {
  const newW = w * 2 + 4;
  for (let y = 0;y < h; y++) {
    const srcRow = y * srcStride;
    const dstRow = y * dstStride;
    for (let x = 0;x < newW; x++) {
      const sx = Math.floor((x - 2) / 2);
      const odd = x - 2 & 1;
      let sum = 0;
      if (odd === 0) {
        sum += (src[srcRow + Math.max(0, Math.min(w - 1, sx - 1))] ?? 0) * 1;
        sum += (src[srcRow + Math.max(0, Math.min(w - 1, sx))] ?? 0) * 30;
        sum += (src[srcRow + Math.max(0, Math.min(w - 1, sx + 1))] ?? 0) * 1;
      } else {
        sum += (src[srcRow + Math.max(0, Math.min(w - 1, sx))] ?? 0) * 16;
        sum += (src[srcRow + Math.max(0, Math.min(w - 1, sx + 1))] ?? 0) * 16;
      }
      dst[dstRow + x] = sum / 32;
    }
  }
}
function expandVert(dst, src, w, h, srcStride, dstStride) {
  const newH = h * 2 + 4;
  for (let x = 0;x < w; x++) {
    for (let y = 0;y < newH; y++) {
      const sy = Math.floor((y - 2) / 2);
      const odd = y - 2 & 1;
      let sum = 0;
      if (odd === 0) {
        sum += (src[Math.max(0, Math.min(h - 1, sy - 1)) * srcStride + x] ?? 0) * 1;
        sum += (src[Math.max(0, Math.min(h - 1, sy)) * srcStride + x] ?? 0) * 30;
        sum += (src[Math.max(0, Math.min(h - 1, sy + 1)) * srcStride + x] ?? 0) * 1;
      } else {
        sum += (src[Math.max(0, Math.min(h - 1, sy)) * srcStride + x] ?? 0) * 16;
        sum += (src[Math.max(0, Math.min(h - 1, sy + 1)) * srcStride + x] ?? 0) * 16;
      }
      dst[y * dstStride + x] = sum / 32;
    }
  }
}
function blurHorz(dst, src, w, h, srcStride, dstStride, radius, coeff) {
  const newW = w + 2 * radius;
  for (let y = 0;y < h; y++) {
    const srcRow = y * srcStride;
    const dstRow = y * dstStride;
    for (let x = 0;x < newW; x++) {
      const cx = x - radius;
      let sum = 0;
      for (let i = 0;i < radius; i++) {
        const left = Math.max(0, Math.min(w - 1, cx - i - 1));
        const right = Math.max(0, Math.min(w - 1, cx + i));
        sum += ((src[srcRow + left] ?? 0) + (src[srcRow + right] ?? 0)) * coeff[i];
      }
      dst[dstRow + x] = sum;
    }
  }
}
function blurVert(dst, src, w, h, srcStride, dstStride, radius, coeff) {
  const newH = h + 2 * radius;
  for (let x = 0;x < w; x++) {
    for (let y = 0;y < newH; y++) {
      const cy = y - radius;
      let sum = 0;
      for (let i = 0;i < radius; i++) {
        const top = Math.max(0, Math.min(h - 1, cy - i - 1));
        const bottom = Math.max(0, Math.min(h - 1, cy + i));
        sum += ((src[top * srcStride + x] ?? 0) + (src[bottom * srcStride + x] ?? 0)) * coeff[i];
      }
      dst[y * dstStride + x] = sum;
    }
  }
}
function cascadeBlurRGBA(bitmap, radiusX, radiusY) {
  const avgRadius = (radiusX + radiusY) / 2;
  return gaussianBlur(bitmap, avgRadius);
}
function cascadeBlur(bitmap, radiusX, radiusY = radiusX) {
  if (radiusX <= 0 && radiusY <= 0) {
    return bitmap;
  }
  if (bitmap.pixelMode === 4 /* RGBA */) {
    return cascadeBlurRGBA(bitmap, radiusX, radiusY);
  }
  const r2x = radiusX * radiusX;
  const r2y = radiusY * radiusY;
  const blurX = findBestMethod(r2x);
  const blurY = findBestMethod(r2y);
  let w = bitmap.width;
  let h = bitmap.rows;
  const offsetX = (2 * blurX.radius + 9 << blurX.level) - 5;
  const offsetY = (2 * blurY.radius + 9 << blurY.level) - 5;
  const endW = (w + offsetX & ~((1 << blurX.level) - 1)) - 4;
  const endH = (h + offsetY & ~((1 << blurY.level) - 1)) - 4;
  const maxSize = Math.max(w * h, endW * endH) * 2;
  const buf0 = new Float32Array(maxSize);
  const buf1 = new Float32Array(maxSize);
  for (let y = 0;y < h; y++) {
    for (let x = 0;x < w; x++) {
      buf0[y * w + x] = bitmap.buffer[y * bitmap.pitch + x] ?? 0;
    }
  }
  let src = buf0;
  let dst = buf1;
  let stride = w;
  for (let i = 0;i < blurY.level; i++) {
    const newH = Math.floor((h + 5) / 2);
    shrinkVert(dst, src, w, h, stride, w);
    h = newH;
    [src, dst] = [dst, src];
  }
  for (let i = 0;i < blurX.level; i++) {
    const newW = Math.floor((w + 5) / 2);
    shrinkHorz(dst, src, w, h, stride, newW);
    w = newW;
    stride = newW;
    [src, dst] = [dst, src];
  }
  const blurredW = w + 2 * blurX.radius;
  blurHorz(dst, src, w, h, stride, blurredW, blurX.radius, blurX.coeff);
  w = blurredW;
  stride = blurredW;
  [src, dst] = [dst, src];
  const blurredH = h + 2 * blurY.radius;
  blurVert(dst, src, w, h, stride, stride, blurY.radius, blurY.coeff);
  h = blurredH;
  [src, dst] = [dst, src];
  for (let i = 0;i < blurX.level; i++) {
    const newW = w * 2 + 4;
    expandHorz(dst, src, w, h, stride, newW);
    w = newW;
    stride = newW;
    [src, dst] = [dst, src];
  }
  for (let i = 0;i < blurY.level; i++) {
    const newH = h * 2 + 4;
    expandVert(dst, src, w, h, stride, stride);
    h = newH;
    [src, dst] = [dst, src];
  }
  const outWidth = Math.min(w, endW);
  const outHeight = Math.min(h, endH);
  const outBuffer = new Uint8Array(outWidth * outHeight);
  for (let y = 0;y < outHeight; y++) {
    for (let x = 0;x < outWidth; x++) {
      const val = src[y * stride + x] ?? 0;
      outBuffer[y * outWidth + x] = Math.max(0, Math.min(255, Math.round(val)));
    }
  }
  return {
    buffer: outBuffer,
    width: outWidth,
    rows: outHeight,
    pitch: outWidth,
    pixelMode: 1 /* Gray */,
    numGrays: 256
  };
}
function fastGaussianBlur(bitmap, radius) {
  return cascadeBlur(bitmap, radius, radius);
}
function adaptiveBlur(bitmap, radiusX, radiusY) {
  const ry = radiusY ?? radiusX;
  const maxRadius = Math.max(radiusX, ry);
  if (maxRadius <= 3) {
    return gaussianBlur(bitmap, (radiusX + ry) / 2);
  }
  return cascadeBlur(bitmap, radiusX, ry);
}

// reference/text-shaper/src/fluent/bitmap-builder.ts
init_types();

class BitmapBuilder {
  _bitmap;
  _bearingX;
  _bearingY;
  constructor(_bitmap, _bearingX = 0, _bearingY = 0) {
    this._bitmap = _bitmap;
    this._bearingX = _bearingX;
    this._bearingY = _bearingY;
  }
  static fromBitmap(bitmap) {
    return new BitmapBuilder(copyBitmap(bitmap));
  }
  static fromBitmapWithBearing(bitmap, bearingX, bearingY) {
    return new BitmapBuilder(copyBitmap(bitmap), bearingX, bearingY);
  }
  static fromRasterizedGlyph(glyph) {
    return new BitmapBuilder(copyBitmap(glyph.bitmap), glyph.bearingX, glyph.bearingY);
  }
  static create(width, height, pixelMode = 1 /* Gray */) {
    return new BitmapBuilder(createBitmap(width, height, pixelMode));
  }
  static fromGradient(width, height, gradient) {
    return new BitmapBuilder(createGradientBitmap(width, height, gradient));
  }
  blur(radius) {
    const blurred = gaussianBlur(copyBitmap(this._bitmap), radius);
    return new BitmapBuilder(blurred, this._bearingX, this._bearingY);
  }
  boxBlur(radius) {
    const blurred = boxBlur(copyBitmap(this._bitmap), radius);
    return new BitmapBuilder(blurred, this._bearingX, this._bearingY);
  }
  cascadeBlur(radiusX, radiusY) {
    const blurred = cascadeBlur(copyBitmap(this._bitmap), radiusX, radiusY ?? radiusX);
    return new BitmapBuilder(blurred, this._bearingX, this._bearingY);
  }
  adaptiveBlur(radiusX, radiusY) {
    const blurred = adaptiveBlur(copyBitmap(this._bitmap), radiusX, radiusY ?? radiusX);
    return new BitmapBuilder(blurred, this._bearingX, this._bearingY);
  }
  fastBlur(radius) {
    const blurred = fastGaussianBlur(copyBitmap(this._bitmap), radius);
    return new BitmapBuilder(blurred, this._bearingX, this._bearingY);
  }
  embolden(xStrength, yStrength) {
    const emboldened = emboldenBitmap(this._bitmap, xStrength, yStrength ?? xStrength);
    return new BitmapBuilder(emboldened, this._bearingX, this._bearingY);
  }
  emboldenWithBearing(xStrength, yStrength) {
    const result = emboldenBitmapWithBearing(this._bitmap, this._bearingX, this._bearingY, xStrength, yStrength ?? xStrength);
    return new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);
  }
  transform2D(matrix, options) {
    const result = transformBitmap2D(this._bitmap, matrix, {
      bearingX: this._bearingX,
      bearingY: this._bearingY,
      offsetX26: options?.offsetX26,
      offsetY26: options?.offsetY26
    });
    return new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);
  }
  transform3D(matrix, options) {
    const result = transformBitmap3D(this._bitmap, matrix, {
      bearingX: this._bearingX,
      bearingY: this._bearingY,
      offsetX26: options?.offsetX26,
      offsetY26: options?.offsetY26
    });
    return new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);
  }
  shearX(amount, options) {
    const result = shearBitmapX(this._bitmap, amount, {
      bearingX: this._bearingX,
      bearingY: this._bearingY,
      offsetX26: options?.offsetX26,
      offsetY26: options?.offsetY26
    });
    return new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);
  }
  shearY(amount, options) {
    const result = shearBitmapY(this._bitmap, amount, {
      bearingX: this._bearingX,
      bearingY: this._bearingY,
      offsetX26: options?.offsetX26,
      offsetY26: options?.offsetY26
    });
    return new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);
  }
  shift(dx, dy) {
    const shifted = shiftBitmap(this._bitmap, dx, dy);
    return new BitmapBuilder(shifted, this._bearingX + dx, this._bearingY - dy);
  }
  resize(width, height) {
    const resized = resizeBitmap(this._bitmap, width, height);
    return new BitmapBuilder(resized, this._bearingX, this._bearingY);
  }
  resizeBilinear(width, height) {
    const resized = resizeBitmapBilinear(this._bitmap, width, height);
    return new BitmapBuilder(resized, this._bearingX, this._bearingY);
  }
  pad(leftOrAll, top, right, bottom) {
    const l = leftOrAll;
    const t = top ?? leftOrAll;
    const r = right ?? leftOrAll;
    const b = bottom ?? leftOrAll;
    const padded = padBitmap(this._bitmap, l, t, r, b);
    return new BitmapBuilder(padded, this._bearingX - l, this._bearingY + t);
  }
  measure() {
    return measureRasterGlyph(this._bitmap, this._bearingX, this._bearingY);
  }
  metrics() {
    const { ascent, descent } = this.measure();
    return {
      width: this._bitmap.width,
      height: this._bitmap.rows,
      bearingX: this._bearingX,
      bearingY: this._bearingY,
      ascent,
      descent
    };
  }
  expandMetrics(options) {
    return expandRasterMetrics(this.metrics(), options);
  }
  blend(other, x, y, opacity = 1) {
    const src = other instanceof BitmapBuilder ? other._bitmap : other;
    const dst = copyBitmap(this._bitmap);
    blendBitmap(dst, src, x, y, opacity);
    return new BitmapBuilder(dst, this._bearingX, this._bearingY);
  }
  composite(other, x = 0, y = 0) {
    const src = other instanceof BitmapBuilder ? other._bitmap : other;
    const dst = copyBitmap(this._bitmap);
    compositeBitmaps(dst, src, x, y);
    return new BitmapBuilder(dst, this._bearingX, this._bearingY);
  }
  add(other, x = 0, y = 0) {
    const src = other instanceof BitmapBuilder ? other._bitmap : other;
    const dst = copyBitmap(this._bitmap);
    addBitmaps(dst, src, x, y);
    return new BitmapBuilder(dst, this._bearingX, this._bearingY);
  }
  subtract(other, x = 0, y = 0) {
    const src = other instanceof BitmapBuilder ? other._bitmap : other;
    const dst = copyBitmap(this._bitmap);
    subBitmaps(dst, src, x, y);
    return new BitmapBuilder(dst, this._bearingX, this._bearingY);
  }
  multiply(other, x = 0, y = 0) {
    const src = other instanceof BitmapBuilder ? other._bitmap : other;
    const dst = copyBitmap(this._bitmap);
    mulBitmaps(dst, src, x, y);
    return new BitmapBuilder(dst, this._bearingX, this._bearingY);
  }
  max(other, x = 0, y = 0) {
    const src = other instanceof BitmapBuilder ? other._bitmap : other;
    const dst = copyBitmap(this._bitmap);
    maxBitmaps(dst, src, x, y);
    return new BitmapBuilder(dst, this._bearingX, this._bearingY);
  }
  convert(targetMode) {
    const converted = convertBitmap(this._bitmap, targetMode);
    return new BitmapBuilder(converted, this._bearingX, this._bearingY);
  }
  toRGBA() {
    return bitmapToRGBA(this._bitmap);
  }
  toGray() {
    return bitmapToGray(this._bitmap);
  }
  toBitmap() {
    return copyBitmap(this._bitmap);
  }
  toRasterizedGlyph() {
    return {
      bitmap: copyBitmap(this._bitmap),
      bearingX: this._bearingX,
      bearingY: this._bearingY
    };
  }
  clone() {
    return new BitmapBuilder(copyBitmap(this._bitmap), this._bearingX, this._bearingY);
  }
  get width() {
    return this._bitmap.width;
  }
  get height() {
    return this._bitmap.rows;
  }
  get pixelMode() {
    return this._bitmap.pixelMode;
  }
  get bearingX() {
    return this._bearingX;
  }
  get bearingY() {
    return this._bearingY;
  }
}

// reference/text-shaper/src/fluent/path-builder.ts
init_types();
class PathBuilder {
  _path;
  _transform;
  _font;
  constructor(_path, _transform, _font) {
    this._path = _path;
    this._transform = _transform;
    this._font = _font;
  }
  static fromGlyph(font, glyphId) {
    const path = getGlyphPath(font, glyphId);
    if (!path)
      return null;
    return new PathBuilder(path, { matrix2D: identity2D(), matrix3D: null }, font);
  }
  static fromGlyphWithVariation(font, glyphId, axisCoords) {
    const path = getGlyphPathWithVariation(font, glyphId, axisCoords);
    if (!path)
      return null;
    return new PathBuilder(path, { matrix2D: identity2D(), matrix3D: null }, font);
  }
  static fromPath(path) {
    return new PathBuilder(clonePath(path), { matrix2D: identity2D(), matrix3D: null }, null);
  }
  static combine(...builders) {
    const paths = builders.map((b) => b.toPath());
    const combined = combinePaths(paths);
    return new PathBuilder(combined, { matrix2D: identity2D(), matrix3D: null }, null);
  }
  scale(sx, sy = sx) {
    const newMatrix = multiply2D(this._transform.matrix2D, scale2D(sx, sy));
    return new PathBuilder(this._path, { ...this._transform, matrix2D: newMatrix }, this._font);
  }
  translate(dx, dy) {
    const newMatrix = multiply2D(this._transform.matrix2D, translate2D(dx, dy));
    return new PathBuilder(this._path, { ...this._transform, matrix2D: newMatrix }, this._font);
  }
  rotate(angle) {
    const newMatrix = multiply2D(this._transform.matrix2D, rotate2D(angle));
    return new PathBuilder(this._path, { ...this._transform, matrix2D: newMatrix }, this._font);
  }
  rotateDeg(angleDeg) {
    return this.rotate(angleDeg * Math.PI / 180);
  }
  shear(shearX, shearY) {
    const newMatrix = multiply2D(this._transform.matrix2D, shear2D(shearX, shearY));
    return new PathBuilder(this._path, { ...this._transform, matrix2D: newMatrix }, this._font);
  }
  italic(angleDeg) {
    const shearX = Math.tan(angleDeg * Math.PI / 180);
    return this.shear(shearX, 0);
  }
  matrix(m) {
    const newMatrix = multiply2D(this._transform.matrix2D, m);
    return new PathBuilder(this._path, { ...this._transform, matrix2D: newMatrix }, this._font);
  }
  resetTransform() {
    return new PathBuilder(this._path, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  perspective(m) {
    const newMatrix3D = this._transform.matrix3D ? multiply3x3(this._transform.matrix3D, m) : m;
    return new PathBuilder(this._path, { ...this._transform, matrix3D: newMatrix3D }, this._font);
  }
  perspectiveVanish(vanishingPointX, vanishingPointY, strength) {
    const m = perspectiveMatrix(vanishingPointX, vanishingPointY, strength);
    return this.perspective(m);
  }
  apply() {
    const transformed = this.applyTransformToPath();
    return new PathBuilder(transformed, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  embolden(strength) {
    const transformed = this.applyTransformToPath();
    const emboldened = emboldenPath(transformed, strength);
    return new PathBuilder(emboldened, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  condense(factor) {
    const transformed = this.applyTransformToPath();
    const condensed = condensePath(transformed, factor);
    return new PathBuilder(condensed, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  oblique(slant) {
    const transformed = this.applyTransformToPath();
    const obliqued = obliquePath(transformed, slant);
    return new PathBuilder(obliqued, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  stroke(optionsOrWidth, cap, join) {
    const transformed = this.applyTransformToPath();
    const opts = typeof optionsOrWidth === "number" ? { width: optionsOrWidth, lineCap: cap, lineJoin: join } : optionsOrWidth;
    const stroked = strokePath(transformed, opts);
    return new PathBuilder(stroked, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  strokeAsymmetric(options) {
    const transformed = this.applyTransformToPath();
    const { outer, inner } = strokeAsymmetric(transformed, options);
    return {
      outer: new PathBuilder(outer, { matrix2D: identity2D(), matrix3D: null }, this._font),
      inner: new PathBuilder(inner, { matrix2D: identity2D(), matrix3D: null }, this._font)
    };
  }
  strokeAsymmetricCombined(options) {
    const transformed = this.applyTransformToPath();
    const combined = strokeAsymmetricCombined(transformed, options);
    return new PathBuilder(combined, { matrix2D: identity2D(), matrix3D: null }, this._font);
  }
  controlBox() {
    const transformed = this.applyTransformToPath();
    return computeControlBox(transformed);
  }
  tightBounds() {
    const transformed = this.applyTransformToPath();
    return computeTightBounds(transformed);
  }
  getTransformMatrix() {
    return [...this._transform.matrix2D];
  }
  getTransformMatrix3D() {
    if (!this._transform.matrix3D)
      return null;
    return this._transform.matrix3D.map((row) => [...row]);
  }
  rasterize(options) {
    const transformedPath = this.applyTransformToPath();
    const {
      width = 100,
      height = 100,
      scale = 1,
      offsetX = 0,
      offsetY = 0,
      pixelMode = 1 /* Gray */,
      fillRule = 0 /* NonZero */,
      flipY = true
    } = options;
    const bitmap = rasterizePath(transformedPath, {
      width,
      height,
      scale,
      offsetX,
      offsetY,
      pixelMode,
      fillRule,
      flipY
    });
    return BitmapBuilder.fromBitmap(bitmap);
  }
  rasterizeAuto(options) {
    const transformedPath = this.applyTransformToPath();
    const {
      padding = 1,
      scale = 1,
      pixelMode = 1 /* Gray */,
      fillRule = 0 /* NonZero */,
      flipY = true
    } = options ?? {};
    const bounds = getPathBounds(transformedPath, scale, flipY);
    if (!bounds) {
      const { createBitmap: createBitmap2 } = (init_types(), __toCommonJS(exports_types));
      return BitmapBuilder.fromBitmap(createBitmap2(1, 1, pixelMode));
    }
    const width = bounds.maxX - bounds.minX + padding * 2;
    const height = bounds.maxY - bounds.minY + padding * 2;
    const offsetX = -bounds.minX + padding;
    const offsetY = -bounds.minY + padding;
    const bitmap = rasterizePath(transformedPath, {
      width,
      height,
      scale,
      offsetX,
      offsetY,
      pixelMode,
      fillRule,
      flipY
    });
    return BitmapBuilder.fromBitmapWithBearing(bitmap, bounds.minX - padding, -(bounds.minY - padding));
  }
  rasterizeWithGradient(gradient, options) {
    const transformedPath = this.applyTransformToPath();
    const {
      width = 100,
      height = 100,
      scale = 1,
      offsetX = 0,
      offsetY = 0,
      pixelMode = 1 /* Gray */,
      fillRule = 0 /* NonZero */,
      flipY = true
    } = options;
    const bitmap = rasterizePathWithGradient(transformedPath, gradient, {
      width,
      height,
      scale,
      offsetX,
      offsetY,
      pixelMode,
      fillRule,
      flipY
    });
    return BitmapBuilder.fromBitmap(bitmap);
  }
  toSdf(options) {
    const transformedPath = this.applyTransformToPath();
    const bitmap = renderSdf(transformedPath, options);
    return BitmapBuilder.fromBitmap(bitmap);
  }
  toSdfAuto(options) {
    const transformedPath = this.applyTransformToPath();
    const { padding = 1, scale = 1, spread = 8, flipY = true } = options ?? {};
    const bounds = getPathBounds(transformedPath, scale, flipY);
    if (!bounds) {
      const { createBitmap: createBitmap2 } = (init_types(), __toCommonJS(exports_types));
      return BitmapBuilder.fromBitmap(createBitmap2(1, 1, 1 /* Gray */));
    }
    const width = bounds.maxX - bounds.minX + padding * 2 + spread * 2;
    const height = bounds.maxY - bounds.minY + padding * 2 + spread * 2;
    const offsetX = -bounds.minX + padding + spread;
    const offsetY = flipY ? bounds.maxY + padding + spread : -bounds.minY + padding + spread;
    const bitmap = renderSdf(transformedPath, {
      width,
      height,
      scale,
      offsetX,
      offsetY,
      flipY,
      spread
    });
    return BitmapBuilder.fromBitmapWithBearing(bitmap, bounds.minX - padding - spread, -(bounds.minY - padding - spread));
  }
  toMsdf(options) {
    const transformedPath = this.applyTransformToPath();
    const bitmap = renderMsdf(transformedPath, options);
    return BitmapBuilder.fromBitmap(bitmap);
  }
  toMsdfAuto(options) {
    const transformedPath = this.applyTransformToPath();
    const { padding = 1, scale = 1, spread = 8, flipY = true } = options ?? {};
    const bounds = getPathBounds(transformedPath, scale, flipY);
    if (!bounds) {
      const { createBitmap: createBitmap2 } = (init_types(), __toCommonJS(exports_types));
      return BitmapBuilder.fromBitmap(createBitmap2(1, 1, 2 /* LCD */));
    }
    const width = bounds.maxX - bounds.minX + padding * 2 + spread * 2;
    const height = bounds.maxY - bounds.minY + padding * 2 + spread * 2;
    const offsetX = -bounds.minX + padding + spread;
    const offsetY = flipY ? bounds.maxY + padding + spread : -bounds.minY + padding + spread;
    const bitmap = renderMsdf(transformedPath, {
      width,
      height,
      scale,
      offsetX,
      offsetY,
      flipY,
      spread
    });
    return BitmapBuilder.fromBitmapWithBearing(bitmap, bounds.minX - padding - spread, -(bounds.minY - padding - spread));
  }
  toSVG(options) {
    const { flipY = true, scale = 1 } = options ?? {};
    if (this.hasTransform()) {
      const transformed = this.applyTransformToPath();
      return pathToSVG(transformed, { flipY, scale });
    }
    return pathToSVG(this._path, { flipY, scale });
  }
  toSVGElement(options) {
    const {
      fontSize = 100,
      fill = "currentColor",
      stroke,
      strokeWidth = 1
    } = options ?? {};
    const transformed = this.applyTransformToPath();
    const bounds = computeTightBounds(transformed);
    const scale = this._font ? fontSize / this._font.unitsPerEm : 1;
    const scaledPath = scale !== 1 ? transformOutline2D(transformed, scale2D(scale, scale)) : transformed;
    const scaledBounds = scale !== 1 ? {
      xMin: bounds.xMin * scale,
      yMin: bounds.yMin * scale,
      xMax: bounds.xMax * scale,
      yMax: bounds.yMax * scale
    } : bounds;
    const strokePadding = stroke ? strokeWidth / 2 : 0;
    const width = Math.ceil(scaledBounds.xMax - scaledBounds.xMin + strokePadding * 2);
    const height = Math.ceil(scaledBounds.yMax - scaledBounds.yMin + strokePadding * 2);
    const viewBox = `${scaledBounds.xMin - strokePadding} ${-scaledBounds.yMax - strokePadding} ${scaledBounds.xMax - scaledBounds.xMin + strokePadding * 2} ${scaledBounds.yMax - scaledBounds.yMin + strokePadding * 2}`;
    const pathData = pathToSVG(scaledPath, { flipY: true, scale: 1 });
    const strokeAttr = stroke ? ` stroke="${stroke}" stroke-width="${strokeWidth}"` : "";
    return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="${viewBox}">
  <path d="${pathData}" fill="${fill}"${strokeAttr}/>
</svg>`;
  }
  toCanvas(ctx, options) {
    const {
      flipY = true,
      scale = 1,
      offsetX = 0,
      offsetY = 0,
      fill = "black",
      stroke,
      strokeWidth = 1
    } = options ?? {};
    ctx.beginPath();
    if (this._transform.matrix3D) {
      const combined = this.combinedMatrix3D(scale, offsetX, offsetY);
      pathToCanvasWithMatrix3D(ctx, this._path, combined, { flipY });
    } else if (this.hasTransform2D()) {
      const combined = this.combinedMatrix2D(scale, offsetX, offsetY);
      pathToCanvasWithMatrix(ctx, this._path, combined, { flipY });
    } else {
      pathToCanvas(ctx, this._path, { flipY, scale, offsetX, offsetY });
    }
    if (fill !== "none") {
      ctx.fillStyle = fill;
      ctx.fill();
    }
    if (stroke) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = strokeWidth;
      ctx.stroke();
    }
  }
  toPath2D(options) {
    const transformed = this.applyTransformToPath();
    return createPath2D(transformed, options);
  }
  toPath() {
    return this.applyTransformToPath();
  }
  clone() {
    return new PathBuilder(clonePath(this._path), {
      matrix2D: [...this._transform.matrix2D],
      matrix3D: this._transform.matrix3D ? this._transform.matrix3D.map((row) => [...row]) : null
    }, this._font);
  }
  applyTransformToPath() {
    if (this._transform.matrix3D) {
      const m2d = this._transform.matrix2D;
      const affine3x3 = [
        [m2d[0], m2d[2], m2d[4]],
        [m2d[1], m2d[3], m2d[5]],
        [0, 0, 1]
      ];
      const combined = multiply3x3(this._transform.matrix3D, affine3x3);
      return transformOutline3D(this._path, combined);
    }
    return transformOutline2D(this._path, this._transform.matrix2D);
  }
  hasTransform() {
    return this.hasTransform2D() || this._transform.matrix3D !== null;
  }
  hasTransform2D() {
    const m = this._transform.matrix2D;
    return m[0] !== 1 || m[1] !== 0 || m[2] !== 0 || m[3] !== 1 || m[4] !== 0 || m[5] !== 0;
  }
  combinedMatrix2D(scale, offsetX, offsetY) {
    const m = this._transform.matrix2D;
    return [
      m[0] * scale,
      m[1] * scale,
      m[2] * scale,
      m[3] * scale,
      m[0] * offsetX + m[2] * offsetY + m[4] * scale,
      m[1] * offsetX + m[3] * offsetY + m[5] * scale
    ];
  }
  combinedMatrix3D(scale, offsetX, offsetY) {
    const m2d = this._transform.matrix2D;
    const m3d = this._transform.matrix3D ?? identity3x3();
    const affine3x3 = [
      [m2d[0] * scale, m2d[2] * scale, m2d[4] * scale + offsetX],
      [m2d[1] * scale, m2d[3] * scale, m2d[5] * scale + offsetY],
      [0, 0, 1]
    ];
    return multiply3x3(m3d, affine3x3);
  }
}
// reference/text-shaper/src/fluent/pipe.ts
init_types();
function pipe(initial, ...fns) {
  return fns.reduce((acc, fn) => fn(acc), initial);
}
function fromGlyph(font, glyphId) {
  return getGlyphPath(font, glyphId);
}
function scale(sx, sy) {
  return (path) => transformOutline2D(path, scale2D(sx, sy ?? sx));
}
function translate(dx, dy) {
  return (path) => transformOutline2D(path, translate2D(dx, dy));
}
function rotate(angle) {
  return (path) => transformOutline2D(path, rotate2D(angle));
}
function rotateDeg(angleDeg) {
  return (path) => transformOutline2D(path, rotate2D(angleDeg * Math.PI / 180));
}
function shear(shearX, shearY) {
  return (path) => transformOutline2D(path, shear2D(shearX, shearY));
}
function italic(angleDeg) {
  const shearX = Math.tan(angleDeg * Math.PI / 180);
  return (path) => transformOutline2D(path, shear2D(shearX, 0));
}
function matrix(m) {
  return (path) => transformOutline2D(path, m);
}
function perspective(m) {
  return (path) => transformOutline3D(path, m);
}
function emboldenPath2(strength) {
  return (path) => emboldenPath(path, strength);
}
function condensePath2(factor) {
  return (path) => condensePath(path, factor);
}
function obliquePath2(slant) {
  return (path) => obliquePath(path, slant);
}
function strokePath2(optionsOrWidth, cap, join) {
  const opts = typeof optionsOrWidth === "number" ? { width: optionsOrWidth, lineCap: cap, lineJoin: join } : optionsOrWidth;
  return (path) => strokePath(path, opts);
}
function clone() {
  return (path) => clonePath(path);
}
function combinePaths2(paths) {
  return combinePaths(paths);
}
function strokeAsymmetric2(options) {
  return (path) => strokeAsymmetric(path, options);
}
function strokeAsymmetricCombined2(options) {
  return (path) => strokeAsymmetricCombined(path, options);
}
function rasterize(options) {
  return (path) => rasterizePath(path, {
    width: options.width ?? 100,
    height: options.height ?? 100,
    scale: options.scale ?? 1,
    offsetX: options.offsetX ?? 0,
    offsetY: options.offsetY ?? 0,
    pixelMode: options.pixelMode ?? 1 /* Gray */,
    fillRule: options.fillRule ?? 0 /* NonZero */,
    flipY: options.flipY ?? true
  });
}
function rasterizeAuto(options) {
  const { padding = 1, scale: s = 1, pixelMode = 1 /* Gray */ } = options ?? {};
  return (path) => {
    const bounds = getPathBounds(path, s, true);
    if (!bounds) {
      const { createBitmap: createBitmap2 } = (init_types(), __toCommonJS(exports_types));
      return createBitmap2(1, 1, pixelMode);
    }
    const width = bounds.maxX - bounds.minX + padding * 2;
    const height = bounds.maxY - bounds.minY + padding * 2;
    const offsetX = -bounds.minX + padding;
    const offsetY = -bounds.minY + padding;
    return rasterizePath(path, {
      width,
      height,
      scale: s,
      offsetX,
      offsetY,
      pixelMode,
      fillRule: 0 /* NonZero */,
      flipY: true
    });
  };
}
function rasterizeWithGradient(gradient, options) {
  return (path) => rasterizePathWithGradient(path, gradient, {
    width: options.width ?? 100,
    height: options.height ?? 100,
    scale: options.scale ?? 1,
    offsetX: options.offsetX ?? 0,
    offsetY: options.offsetY ?? 0,
    pixelMode: options.pixelMode ?? 1 /* Gray */,
    fillRule: options.fillRule ?? 0 /* NonZero */,
    flipY: options.flipY ?? true
  });
}
function renderSdf2(options) {
  return (path) => renderSdf(path, options);
}
function renderMsdf2(options) {
  return (path) => renderMsdf(path, options);
}
function blur(radius) {
  return (bitmap) => gaussianBlur(copyBitmap(bitmap), radius);
}
function boxBlur2(radius) {
  return (bitmap) => boxBlur(copyBitmap(bitmap), radius);
}
function cascadeBlur2(radiusX, radiusY) {
  return (bitmap) => cascadeBlur(copyBitmap(bitmap), radiusX, radiusY ?? radiusX);
}
function adaptiveBlur2(radiusX, radiusY) {
  return (bitmap) => adaptiveBlur(copyBitmap(bitmap), radiusX, radiusY ?? radiusX);
}
function fastBlur(radius) {
  return (bitmap) => fastGaussianBlur(copyBitmap(bitmap), radius);
}
function embolden(xStrength, yStrength) {
  return (bitmap) => emboldenBitmap(bitmap, xStrength, yStrength ?? xStrength);
}
function emboldenGlyph(xStrength, yStrength) {
  return (glyph) => emboldenBitmapWithBearing(glyph.bitmap, glyph.bearingX, glyph.bearingY, xStrength, yStrength ?? xStrength);
}
function transformBitmap2D2(matrix2, options) {
  return (bitmap) => transformBitmap2D(bitmap, matrix2, {
    bearingX: 0,
    bearingY: 0,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  }).bitmap;
}
function transformBitmap3D2(matrix2, options) {
  return (bitmap) => transformBitmap3D(bitmap, matrix2, {
    bearingX: 0,
    bearingY: 0,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  }).bitmap;
}
function transformGlyph2D(matrix2, options) {
  return (glyph) => transformBitmap2D(glyph.bitmap, matrix2, {
    bearingX: glyph.bearingX,
    bearingY: glyph.bearingY,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  });
}
function transformGlyph3D(matrix2, options) {
  return (glyph) => transformBitmap3D(glyph.bitmap, matrix2, {
    bearingX: glyph.bearingX,
    bearingY: glyph.bearingY,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  });
}
function shearBitmapX2(amount, options) {
  return (bitmap) => shearBitmapX(bitmap, amount, {
    bearingX: 0,
    bearingY: 0,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  }).bitmap;
}
function shearBitmapY2(amount, options) {
  return (bitmap) => shearBitmapY(bitmap, amount, {
    bearingX: 0,
    bearingY: 0,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  }).bitmap;
}
function shearGlyphX(amount, options) {
  return (glyph) => shearBitmapX(glyph.bitmap, amount, {
    bearingX: glyph.bearingX,
    bearingY: glyph.bearingY,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  });
}
function shearGlyphY(amount, options) {
  return (glyph) => shearBitmapY(glyph.bitmap, amount, {
    bearingX: glyph.bearingX,
    bearingY: glyph.bearingY,
    offsetX26: options?.offsetX26,
    offsetY26: options?.offsetY26
  });
}
function shift(dx, dy) {
  return (bitmap) => shiftBitmap(bitmap, dx, dy);
}
function resize(width, height) {
  return (bitmap) => resizeBitmap(bitmap, width, height);
}
function resizeBilinear(width, height) {
  return (bitmap) => resizeBitmapBilinear(bitmap, width, height);
}
function pad(leftOrAll, top, right, bottom) {
  const l = leftOrAll;
  const t = top ?? leftOrAll;
  const r = right ?? leftOrAll;
  const b = bottom ?? leftOrAll;
  return (bitmap) => padBitmap(bitmap, l, t, r, b);
}
function convert(targetMode) {
  return (bitmap) => convertBitmap(bitmap, targetMode);
}
function toRGBA(bitmap) {
  return bitmapToRGBA(bitmap);
}
function toGray(bitmap) {
  return bitmapToGray(bitmap);
}
function toSVG(options) {
  return (path) => pathToSVG(path, options);
}
function copy(bitmap) {
  return copyBitmap(bitmap);
}

// reference/text-shaper/src/fluent/index.ts
function glyph(font, glyphId) {
  return PathBuilder.fromGlyph(font, glyphId);
}
function char(font, character) {
  const codepoint = character.codePointAt(0);
  if (codepoint === undefined)
    return null;
  const glyphId = font.glyphId(codepoint);
  if (glyphId === undefined)
    return null;
  return PathBuilder.fromGlyph(font, glyphId);
}
function glyphVar(font, glyphId, axisCoords) {
  return PathBuilder.fromGlyphWithVariation(font, glyphId, axisCoords);
}
function path(p) {
  return PathBuilder.fromPath(p);
}
function bitmap(b) {
  return BitmapBuilder.fromBitmap(b);
}
function combine(...paths) {
  return PathBuilder.combine(...paths);
}
// reference/text-shaper/src/font/binary/reader.ts
class Reader {
  data;
  start;
  end;
  pos;
  constructor(buffer, offset = 0, length) {
    if (buffer instanceof ArrayBuffer) {
      this.data = new DataView(buffer);
      this.start = offset;
      this.end = length !== undefined ? offset + length : buffer.byteLength;
    } else {
      this.data = buffer;
      this.start = buffer.byteOffset + offset;
      this.end = length !== undefined ? this.start + length : buffer.byteOffset + buffer.byteLength;
    }
    this.pos = this.start;
  }
  get offset() {
    return this.pos - this.start;
  }
  get remaining() {
    return this.end - this.pos;
  }
  get length() {
    return this.end - this.start;
  }
  seek(offset) {
    this.pos = this.start + offset;
  }
  skip(bytes) {
    this.pos += bytes;
  }
  slice(offset, length) {
    return new Reader(this.data, this.start + offset, length);
  }
  sliceFrom(offset) {
    return new Reader(this.data, this.start + offset, this.end - this.start - offset);
  }
  peek(fn) {
    const savedPos = this.pos;
    const result = fn();
    this.pos = savedPos;
    return result;
  }
  uint8() {
    const value = this.data.getUint8(this.pos);
    this.pos += 1;
    return value;
  }
  int8() {
    const value = this.data.getInt8(this.pos);
    this.pos += 1;
    return value;
  }
  uint16() {
    const value = this.data.getUint16(this.pos, false);
    this.pos += 2;
    return value;
  }
  int16() {
    const value = this.data.getInt16(this.pos, false);
    this.pos += 2;
    return value;
  }
  uint32() {
    const value = this.data.getUint32(this.pos, false);
    this.pos += 4;
    return value;
  }
  int32() {
    const value = this.data.getInt32(this.pos, false);
    this.pos += 4;
    return value;
  }
  fixed() {
    return this.int32() / 65536;
  }
  f2dot14() {
    return this.int16() / 16384;
  }
  fword() {
    return this.int16();
  }
  ufword() {
    return this.uint16();
  }
  longDateTime() {
    const high = this.uint32();
    const low = this.uint32();
    return BigInt(high) << 32n | BigInt(low);
  }
  tag() {
    return this.uint32();
  }
  tagString() {
    const t = this.uint32();
    return String.fromCharCode(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255);
  }
  offset16() {
    return this.uint16();
  }
  offset32() {
    return this.uint32();
  }
  uint24() {
    const b0 = this.data.getUint8(this.pos);
    const b1 = this.data.getUint8(this.pos + 1);
    const b2 = this.data.getUint8(this.pos + 2);
    this.pos += 3;
    return b0 << 16 | b1 << 8 | b2;
  }
  uint8Array(count) {
    const result = new Uint8Array(count);
    for (let i = 0;i < count; i++) {
      result[i] = this.uint8();
    }
    return result;
  }
  uint16Array(count) {
    const result = new Uint16Array(count);
    for (let i = 0;i < count; i++) {
      result[i] = this.uint16();
    }
    return result;
  }
  int16Array(count) {
    const result = new Int16Array(count);
    for (let i = 0;i < count; i++) {
      result[i] = this.int16();
    }
    return result;
  }
  uint32Array(count) {
    const result = new Uint32Array(count);
    for (let i = 0;i < count; i++) {
      result[i] = this.uint32();
    }
    return result;
  }
  array(count, readFn) {
    const result = new Array(count);
    for (let i = 0;i < count; i++) {
      result[i] = readFn(this);
    }
    return result;
  }
  ascii(length) {
    let result = "";
    for (let i = 0;i < length; i++) {
      result += String.fromCharCode(this.uint8());
    }
    return result;
  }
  utf16be(length) {
    const chars = [];
    const charCount = length / 2;
    for (let i = 0;i < charCount; i++) {
      chars.push(this.uint16());
    }
    return String.fromCharCode(...chars);
  }
  hasRemaining(bytes) {
    return this.remaining >= bytes;
  }
  ensureRemaining(bytes) {
    if (this.remaining < bytes) {
      throw new Error(`Unexpected end of data: need ${bytes} bytes, have ${this.remaining}`);
    }
  }
  bytes(length) {
    const result = new Uint8Array(this.data.buffer, this.data.byteOffset + this.pos, length);
    this.pos += length;
    return result;
  }
  readAt(offset, fn) {
    const savedPos = this.pos;
    this.pos = this.start + offset;
    const result = fn(this);
    this.pos = savedPos;
    return result;
  }
}
// reference/text-shaper/src/font/tables/avar.ts
function parseAvar(reader, axisCount) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  reader.skip(2);
  const axisSegmentMaps = [];
  for (let i = 0;i < axisCount; i++) {
    const positionMapCount = reader.uint16();
    const axisValueMaps = [];
    for (let j = 0;j < positionMapCount; j++) {
      axisValueMaps.push({
        fromCoordinate: reader.f2dot14(),
        toCoordinate: reader.f2dot14()
      });
    }
    axisSegmentMaps.push({ axisValueMaps });
  }
  return {
    majorVersion,
    minorVersion,
    axisSegmentMaps
  };
}
function applyAvarMapping(segmentMap, coord) {
  const maps = segmentMap.axisValueMaps;
  if (maps.length === 0)
    return coord;
  for (let i = 0;i < maps.length - 1; i++) {
    const map1 = maps[i];
    const map2 = maps[i + 1];
    if (!map1 || !map2)
      continue;
    if (coord >= map1.fromCoordinate && coord <= map2.fromCoordinate) {
      const t = (coord - map1.fromCoordinate) / (map2.fromCoordinate - map1.fromCoordinate);
      return map1.toCoordinate + t * (map2.toCoordinate - map1.toCoordinate);
    }
  }
  const firstMap = maps[0];
  const lastMap = maps[maps.length - 1];
  if (firstMap && coord <= firstMap.fromCoordinate) {
    return firstMap.toCoordinate;
  }
  return lastMap?.toCoordinate ?? coord;
}
function applyAvar(avar, coords) {
  const result = [];
  for (let i = 0;i < coords.length; i++) {
    const coord = coords[i];
    const segmentMap = avar.axisSegmentMaps[i];
    if (segmentMap) {
      result.push(applyAvarMapping(segmentMap, coord));
    } else {
      result.push(coord);
    }
  }
  return result;
}

// reference/text-shaper/src/font/tables/fvar.ts
function parseFvar(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const axesArrayOffset = reader.offset16();
  reader.skip(2);
  const axisCount = reader.uint16();
  const axisSize = reader.uint16();
  const instanceCount = reader.uint16();
  const instanceSize = reader.uint16();
  const axes = [];
  reader.seek(axesArrayOffset);
  for (let i = 0;i < axisCount; i++) {
    const axisStart = reader.offset;
    const tag2 = reader.uint32();
    const minValue = reader.fixed();
    const defaultValue = reader.fixed();
    const maxValue = reader.fixed();
    const flags = reader.uint16();
    const axisNameId = reader.uint16();
    axes.push({
      tag: tag2,
      minValue,
      defaultValue,
      maxValue,
      flags,
      axisNameId
    });
    reader.seek(axisStart + axisSize);
  }
  const instances = [];
  const hasPostScriptNameId = instanceSize >= 4 + axisCount * 4 + 2;
  for (let i = 0;i < instanceCount; i++) {
    const instanceStart = reader.offset;
    const subfamilyNameId = reader.uint16();
    const flags = reader.uint16();
    const coordinates = [];
    for (let j = 0;j < axisCount; j++) {
      coordinates.push(reader.fixed());
    }
    const instance = {
      subfamilyNameId,
      flags,
      coordinates
    };
    if (hasPostScriptNameId) {
      instance.postScriptNameId = reader.uint16();
    }
    instances.push(instance);
    reader.seek(instanceStart + instanceSize);
  }
  return {
    majorVersion,
    minorVersion,
    axes,
    instances
  };
}
function normalizeAxisValue(axis, value) {
  if (value < axis.defaultValue) {
    if (value < axis.minValue)
      value = axis.minValue;
    if (axis.defaultValue === axis.minValue)
      return 0;
    return (value - axis.defaultValue) / (axis.defaultValue - axis.minValue);
  } else if (value > axis.defaultValue) {
    if (value > axis.maxValue)
      value = axis.maxValue;
    if (axis.defaultValue === axis.maxValue)
      return 0;
    return (value - axis.defaultValue) / (axis.maxValue - axis.defaultValue);
  }
  return 0;
}

// reference/text-shaper/src/font/tables/hvar.ts
function parseHvar(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const itemVariationStoreOffset = reader.offset32();
  const advanceWidthMappingOffset = reader.offset32();
  const lsbMappingOffset = reader.offset32();
  const rsbMappingOffset = reader.offset32();
  const itemVariationStore = parseItemVariationStore(reader.sliceFrom(itemVariationStoreOffset));
  const advanceWidthMapping = advanceWidthMappingOffset !== 0 ? parseDeltaSetIndexMap(reader.sliceFrom(advanceWidthMappingOffset)) : null;
  const lsbMapping = lsbMappingOffset !== 0 ? parseDeltaSetIndexMap(reader.sliceFrom(lsbMappingOffset)) : null;
  const rsbMapping = rsbMappingOffset !== 0 ? parseDeltaSetIndexMap(reader.sliceFrom(rsbMappingOffset)) : null;
  return {
    majorVersion,
    minorVersion,
    itemVariationStore,
    advanceWidthMapping,
    lsbMapping,
    rsbMapping
  };
}
function parseItemVariationStore(reader) {
  const format = reader.uint16();
  const variationRegionListOffset = reader.offset32();
  const itemVariationDataCount = reader.uint16();
  const itemVariationDataOffsets = [];
  for (let i = 0;i < itemVariationDataCount; i++) {
    itemVariationDataOffsets.push(reader.offset32());
  }
  const regionReader = reader.sliceFrom(variationRegionListOffset);
  const axisCount = regionReader.uint16();
  const regionCount = regionReader.uint16();
  const variationRegions = [];
  for (let i = 0;i < regionCount; i++) {
    const regionAxes = [];
    for (let j = 0;j < axisCount; j++) {
      regionAxes.push({
        startCoord: regionReader.f2dot14(),
        peakCoord: regionReader.f2dot14(),
        endCoord: regionReader.f2dot14()
      });
    }
    variationRegions.push({ regionAxes });
  }
  const itemVariationData = [];
  for (let i = 0;i < itemVariationDataOffsets.length; i++) {
    const offset = itemVariationDataOffsets[i];
    const dataReader = reader.sliceFrom(offset);
    const itemCount = dataReader.uint16();
    const wordDeltaCount = dataReader.uint16();
    const regionIndexCount = dataReader.uint16();
    const regionIndexes = [];
    for (let i2 = 0;i2 < regionIndexCount; i2++) {
      regionIndexes.push(dataReader.uint16());
    }
    const longWords = (wordDeltaCount & 32768) !== 0;
    const wordCount = wordDeltaCount & 32767;
    const shortCount = regionIndexCount - wordCount;
    const deltaSets = [];
    for (let i2 = 0;i2 < itemCount; i2++) {
      const deltas = [];
      for (let j = 0;j < wordCount; j++) {
        if (longWords) {
          deltas.push(dataReader.int32());
        } else {
          deltas.push(dataReader.int16());
        }
      }
      for (let j = 0;j < shortCount; j++) {
        if (longWords) {
          deltas.push(dataReader.int16());
        } else {
          deltas.push(dataReader.int8());
        }
      }
      deltaSets.push(deltas);
    }
    itemVariationData.push({ itemCount, regionIndexes, deltaSets });
  }
  return { format, variationRegions, itemVariationData };
}
function parseDeltaSetIndexMap(reader) {
  const format = reader.uint8();
  const entryFormat = reader.uint8();
  const mapCount = format === 0 ? reader.uint16() : reader.uint32();
  const innerIndexBitCount = (entryFormat & 15) + 1;
  const mapEntrySize = (entryFormat >> 4 & 3) + 1;
  const mapData = [];
  for (let i = 0;i < mapCount; i++) {
    let entry = 0;
    for (let j = 0;j < mapEntrySize; j++) {
      entry = entry << 8 | reader.uint8();
    }
    const inner = entry & (1 << innerIndexBitCount) - 1;
    const outer = entry >> innerIndexBitCount;
    mapData.push({ outer, inner });
  }
  return { format, mapCount, entryFormat, innerIndexBitCount, mapData };
}
function calculateRegionScalar(region, coords) {
  let scalar = 1;
  for (let i = 0;i < region.regionAxes.length && i < coords.length; i++) {
    const axis = region.regionAxes[i];
    const coord = coords[i];
    if (axis === undefined || coord === undefined)
      continue;
    if (coord < axis.startCoord || coord > axis.endCoord) {
      return 0;
    }
    if (coord === axis.peakCoord) {
      continue;
    }
    if (coord < axis.peakCoord) {
      if (axis.peakCoord === axis.startCoord) {
        continue;
      }
      scalar *= (coord - axis.startCoord) / (axis.peakCoord - axis.startCoord);
    } else {
      if (axis.peakCoord === axis.endCoord) {
        continue;
      }
      scalar *= (axis.endCoord - coord) / (axis.endCoord - axis.peakCoord);
    }
  }
  return scalar;
}
function getDeltaFromMapping(hvar, glyphId, coords, mapping) {
  let outer;
  let inner;
  if (mapping && glyphId < mapping.mapData.length) {
    const entry = mapping.mapData[glyphId];
    if (!entry) {
      outer = 0;
      inner = glyphId;
    } else {
      outer = entry.outer;
      inner = entry.inner;
    }
  } else {
    outer = 0;
    inner = glyphId;
  }
  const varData = hvar.itemVariationStore.itemVariationData[outer];
  if (!varData || inner >= varData.itemCount) {
    return 0;
  }
  const deltaSet = varData.deltaSets[inner];
  if (!deltaSet) {
    return 0;
  }
  let delta = 0;
  for (let i = 0;i < varData.regionIndexes.length; i++) {
    const regionIndex = varData.regionIndexes[i];
    const region = hvar.itemVariationStore.variationRegions[regionIndex];
    if (!region)
      continue;
    const scalar = calculateRegionScalar(region, coords);
    const regionDelta = deltaSet[i] ?? 0;
    delta += scalar * regionDelta;
  }
  return Math.round(delta);
}
function getAdvanceWidthDelta(hvar, glyphId, coords) {
  return getDeltaFromMapping(hvar, glyphId, coords, hvar.advanceWidthMapping);
}
function getLsbDelta(hvar, glyphId, coords) {
  if (!hvar.lsbMapping) {
    return 0;
  }
  return getDeltaFromMapping(hvar, glyphId, coords, hvar.lsbMapping);
}

// reference/text-shaper/src/font/face.ts
class Face {
  font;
  _coords;
  _variations;
  _advanceDeltas = null;
  constructor(font, variations) {
    this.font = font;
    this._coords = [];
    this._variations = new Map;
    const fvar = font.fvar;
    if (fvar) {
      this._coords = new Array(fvar.axes.length).fill(0);
      if (variations) {
        this.setVariations(variations);
      }
    }
  }
  setVariations(variations) {
    const fvar = this.font.fvar;
    if (!fvar)
      return;
    this._advanceDeltas = null;
    if (Array.isArray(variations)) {
      for (let i = 0;i < variations.length; i++) {
        const v = variations[i];
        this._variations.set(v.tag, v.value);
      }
    } else {
      const entries = Object.entries(variations);
      for (let i = 0;i < entries.length; i++) {
        const [tagStr, value] = entries[i];
        const t = tag(tagStr.padEnd(4, " "));
        this._variations.set(t, value);
      }
    }
    for (let i = 0;i < fvar.axes.length; i++) {
      const axis = fvar.axes[i];
      const userValue = this._variations.get(axis.tag) ?? axis.defaultValue;
      this._coords[i] = normalizeAxisValue(axis, userValue);
    }
    const avar = this.font.avar;
    if (avar) {
      this._coords = applyAvar(avar, this._coords);
    }
  }
  get normalizedCoords() {
    return this._coords;
  }
  get isVariable() {
    return this.font.isVariable;
  }
  get axes() {
    return this.font.fvar?.axes ?? [];
  }
  getAxisValue(axisTag) {
    const t = typeof axisTag === "string" ? tag(axisTag.padEnd(4, " ")) : axisTag;
    const fvar = this.font.fvar;
    if (!fvar)
      return null;
    const value = this._variations.get(t);
    if (value !== undefined)
      return value;
    const axis = fvar.axes.find((a) => a.tag === t);
    return axis?.defaultValue ?? null;
  }
  advanceWidth(glyphId) {
    const advance = this.font.advanceWidth(glyphId);
    if (this._coords.length > 0 && this.font.hvar) {
      if (this._advanceDeltas) {
        const cached = this._advanceDeltas.get(glyphId);
        if (cached !== undefined) {
          return advance + cached;
        }
      } else {
        this._advanceDeltas = new Map;
      }
      const delta = getAdvanceWidthDelta(this.font.hvar, glyphId, this._coords);
      this._advanceDeltas.set(glyphId, delta);
      return advance + delta;
    }
    return advance;
  }
  leftSideBearing(glyphId) {
    let lsb = this.font.leftSideBearing(glyphId);
    if (this._coords.length > 0 && this.font.hvar) {
      const delta = getLsbDelta(this.font.hvar, glyphId, this._coords);
      lsb += delta;
    }
    return lsb;
  }
  get numGlyphs() {
    return this.font.numGlyphs;
  }
  get unitsPerEm() {
    return this.font.unitsPerEm;
  }
  get ascender() {
    return this.font.ascender;
  }
  get descender() {
    return this.font.descender;
  }
  get lineGap() {
    return this.font.lineGap;
  }
  glyphId(codepoint) {
    return this.font.glyphId(codepoint);
  }
  glyphIdForChar(char2) {
    return this.font.glyphIdForChar(char2);
  }
  hasTable(t) {
    return this.font.hasTable(t);
  }
  get gdef() {
    return this.font.gdef;
  }
  get gsub() {
    return this.font.gsub;
  }
  get gpos() {
    return this.font.gpos;
  }
  get kern() {
    return this.font.kern;
  }
  get morx() {
    return this.font.morx;
  }
  get cmap() {
    return this.font.cmap;
  }
  get hmtx() {
    return this.font.hmtx;
  }
  get hhea() {
    return this.font.hhea;
  }
}
function createFace(font, variations) {
  return new Face(font, variations);
}
// reference/text-shaper/src/font/ttc.ts
var TTCF_MAGIC = 1953784678;
function isTtc(buffer) {
  const view = new DataView(buffer);
  return view.getUint32(0, false) === TTCF_MAGIC;
}
function parseTtcHeader(buffer) {
  const reader = new Reader(buffer);
  const tag2 = reader.uint32();
  if (tag2 !== TTCF_MAGIC) {
    throw new Error("Invalid TTC header");
  }
  const version = reader.uint32();
  const numFonts = reader.uint32();
  if (numFonts <= 0) {
    throw new Error("Invalid TTC font count");
  }
  const maxFonts = Math.floor((buffer.byteLength - 12) / 4);
  if (numFonts > maxFonts) {
    throw new Error("Invalid TTC font count");
  }
  const offsets = new Array(numFonts);
  for (let i = 0;i < numFonts; i++) {
    offsets[i] = reader.uint32();
  }
  if (version === 131072 && reader.remaining >= 12) {
    const dsigTag = reader.uint32();
    const dsigOffset = reader.uint32();
    const dsigLength = reader.uint32();
    return { version, numFonts, offsets, dsigTag, dsigOffset, dsigLength };
  }
  return { version, numFonts, offsets };
}

// reference/text-shaper/src/font/woff2.ts
var KNOWN_TAGS = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
function readUIntBase128(data, offset) {
  let result = 0;
  for (let i = 0;i < 5; i++) {
    const byte = data[offset.value++];
    if (i === 0 && byte === 128) {
      throw new Error("Invalid UIntBase128: leading zeros");
    }
    if (result > 2097151) {
      throw new Error("UIntBase128 overflow");
    }
    result = result << 7 | byte & 127;
    if ((byte & 128) === 0) {
      return result;
    }
  }
  throw new Error("UIntBase128 too long");
}
function read255UInt16(data, offset) {
  const code = data[offset.value++];
  if (code === 253) {
    const hi = data[offset.value++];
    const lo = data[offset.value++];
    return hi << 8 | lo;
  } else if (code === 255) {
    return data[offset.value++] + 253 * 2;
  } else if (code === 254) {
    return data[offset.value++] + 253;
  }
  return code;
}
function parseTableDirectory(data, offset, numTables) {
  const tables = [];
  for (let i = 0;i < numTables; i++) {
    const flags = data[offset.value++];
    const tagIndex = flags & 63;
    const transformVersion = flags >> 6 & 3;
    let tag2;
    if (tagIndex === 63) {
      tag2 = String.fromCharCode(data[offset.value++], data[offset.value++], data[offset.value++], data[offset.value++]);
    } else {
      tag2 = KNOWN_TAGS[tagIndex];
    }
    const origLength = readUIntBase128(data, offset);
    let transformLength = origLength;
    const hasTransform = tag2 === "glyf" || tag2 === "loca" ? transformVersion === 0 : transformVersion !== 0;
    if (hasTransform) {
      transformLength = readUIntBase128(data, offset);
    }
    tables.push({ tag: tag2, origLength, transformLength, transformVersion });
  }
  return tables;
}
async function decompressBrotli(data) {
  if (typeof DecompressionStream !== "undefined") {
    try {
      const ds = new DecompressionStream("brotli");
      const blob = new Blob([data.buffer]);
      const decompressedStream = blob.stream().pipeThrough(ds);
      const result = await new Response(decompressedStream).arrayBuffer();
      return new Uint8Array(result);
    } catch {}
  }
  const { decompress: decompress2 } = await Promise.resolve().then(() => (init_decode(), exports_decode));
  return decompress2(data);
}
function writeUint16BE(arr, offset, value) {
  arr[offset] = value >> 8 & 255;
  arr[offset + 1] = value & 255;
}
function writeUint32BE(arr, offset, value) {
  arr[offset] = value >> 24 & 255;
  arr[offset + 1] = value >> 16 & 255;
  arr[offset + 2] = value >> 8 & 255;
  arr[offset + 3] = value & 255;
}
function readUint16BE(arr, offset) {
  return arr[offset] << 8 | arr[offset + 1];
}
function readInt16BE(arr, offset) {
  const val = readUint16BE(arr, offset);
  return val >= 32768 ? val - 65536 : val;
}
function readUint32BE(arr, offset) {
  return (arr[offset] << 24 | arr[offset + 1] << 16 | arr[offset + 2] << 8 | arr[offset + 3]) >>> 0;
}
function calcChecksum(data, offset, length) {
  let sum = 0;
  const nLongs = Math.ceil(length / 4);
  for (let i = 0;i < nLongs; i++) {
    const idx = offset + i * 4;
    sum = sum + ((data[idx] || 0) << 24 | (data[idx + 1] || 0) << 16 | (data[idx + 2] || 0) << 8 | (data[idx + 3] || 0)) >>> 0;
  }
  return sum;
}
function pad4(n) {
  return n + 3 & -4;
}
function decodeTriplets(flagStream, glyphStream, nPoints, flagIdx, glyphIdx) {
  const points = [];
  let x = 0, y = 0;
  function withSign(flag, baseval) {
    return flag & 1 ? baseval : -baseval;
  }
  for (let i = 0;i < nPoints; i++) {
    const flag = flagStream[flagIdx.value++];
    const onCurve = flag >> 7 === 0;
    const flagValue = flag & 127;
    let dx = 0, dy = 0;
    if (flagValue < 10) {
      dx = 0;
      dy = withSign(flag, ((flagValue & 14) << 7) + glyphStream[glyphIdx.value++]);
    } else if (flagValue < 20) {
      dx = withSign(flag, ((flagValue - 10 & 14) << 7) + glyphStream[glyphIdx.value++]);
      dy = 0;
    } else if (flagValue < 84) {
      const b0 = flagValue - 20;
      const b1 = glyphStream[glyphIdx.value++];
      dx = withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flagValue < 120) {
      const b0 = flagValue - 84;
      dx = withSign(flag, 1 + (Math.floor(b0 / 12) << 8) + glyphStream[glyphIdx.value++]);
      dy = withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphStream[glyphIdx.value++]);
    } else if (flagValue < 124) {
      const b1 = glyphStream[glyphIdx.value++];
      const b2 = glyphStream[glyphIdx.value++];
      const b3 = glyphStream[glyphIdx.value++];
      dx = withSign(flag, (b1 << 4) + (b2 >> 4));
      dy = withSign(flag >> 1, ((b2 & 15) << 8) + b3);
    } else {
      dx = withSign(flag, (glyphStream[glyphIdx.value++] << 8) + glyphStream[glyphIdx.value++]);
      dy = withSign(flag >> 1, (glyphStream[glyphIdx.value++] << 8) + glyphStream[glyphIdx.value++]);
    }
    x += dx;
    y += dy;
    points.push({ x, y, onCurve });
  }
  return points;
}
function reconstructGlyfLoca(glyfTransform, numGlyphs, indexFormat) {
  let offset = 0;
  const version = readUint16BE(glyfTransform, offset);
  offset += 2;
  if (version !== 0) {
    throw new Error(`Unsupported glyf transform version: ${version}`);
  }
  const optionFlags = readUint16BE(glyfTransform, offset);
  offset += 2;
  const _numGlyphsHeader = readUint16BE(glyfTransform, offset);
  offset += 2;
  const _indexFormatHeader = readUint16BE(glyfTransform, offset);
  offset += 2;
  const nContourStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const nPointsStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const flagStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const glyphStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const compositeStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const bboxStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const instructionStreamSize = readUint32BE(glyfTransform, offset);
  offset += 4;
  const nContourStream = glyfTransform.slice(offset, offset + nContourStreamSize);
  offset += nContourStreamSize;
  const nPointsStream = glyfTransform.slice(offset, offset + nPointsStreamSize);
  offset += nPointsStreamSize;
  const flagStream = glyfTransform.slice(offset, offset + flagStreamSize);
  offset += flagStreamSize;
  const glyphStream = glyfTransform.slice(offset, offset + glyphStreamSize);
  offset += glyphStreamSize;
  const compositeStream = glyfTransform.slice(offset, offset + compositeStreamSize);
  offset += compositeStreamSize;
  const bboxStream = glyfTransform.slice(offset, offset + bboxStreamSize);
  offset += bboxStreamSize;
  const instructionStream = glyfTransform.slice(offset, offset + instructionStreamSize);
  const nContourIdx = { value: 0 };
  const nPointsIdx = { value: 0 };
  const flagIdx = { value: 0 };
  const glyphIdx = { value: 0 };
  const compositeIdx = { value: 0 };
  const bboxIdx = { value: 0 };
  const instructionIdx = { value: 0 };
  const glyphOffsets = [0];
  const glyphParts = [];
  let totalGlyfSize = 0;
  for (let g = 0;g < numGlyphs; g++) {
    const nContours = readInt16BE(nContourStream, nContourIdx.value);
    nContourIdx.value += 2;
    if (nContours === 0) {
      glyphParts.push(new Uint8Array(0));
      glyphOffsets.push(totalGlyfSize);
      continue;
    }
    if (nContours > 0) {
      const glyphData = reconstructSimpleGlyph(nContours, nPointsStream, nPointsIdx, flagStream, flagIdx, glyphStream, glyphIdx, bboxStream, bboxIdx, instructionStream, instructionIdx, optionFlags);
      glyphParts.push(glyphData);
      totalGlyfSize += pad4(glyphData.length);
      glyphOffsets.push(totalGlyfSize);
    } else {
      const glyphData = reconstructCompositeGlyph(compositeStream, compositeIdx, bboxStream, bboxIdx, instructionStream, instructionIdx, optionFlags);
      glyphParts.push(glyphData);
      totalGlyfSize += pad4(glyphData.length);
      glyphOffsets.push(totalGlyfSize);
    }
  }
  const glyf = new Uint8Array(totalGlyfSize);
  let glyfOffset = 0;
  for (let i = 0;i < glyphParts.length; i++) {
    const part = glyphParts[i];
    glyf.set(part, glyfOffset);
    glyfOffset += pad4(part.length);
  }
  const locaSize = indexFormat === 0 ? (numGlyphs + 1) * 2 : (numGlyphs + 1) * 4;
  const loca = new Uint8Array(locaSize);
  for (let i = 0;i <= numGlyphs; i++) {
    if (indexFormat === 0) {
      writeUint16BE(loca, i * 2, glyphOffsets[i] / 2);
    } else {
      writeUint32BE(loca, i * 4, glyphOffsets[i]);
    }
  }
  return { glyf, loca };
}
function reconstructSimpleGlyph(nContours, nPointsStream, nPointsIdx, flagStream, flagIdx, glyphStream, glyphIdx, bboxStream, bboxIdx, instructionStream, instructionIdx, optionFlags) {
  const endPtsOfContours = [];
  let totalPoints = 0;
  for (let c = 0;c < nContours; c++) {
    const nPoints = read255UInt16(nPointsStream, nPointsIdx);
    totalPoints += nPoints;
    endPtsOfContours.push(totalPoints - 1);
  }
  const points = decodeTriplets(flagStream, glyphStream, totalPoints, flagIdx, glyphIdx);
  let xMin, yMin, xMax, yMax;
  const bboxBitmap = (optionFlags & 1) === 0;
  if (bboxBitmap && bboxIdx.value + 8 <= bboxStream.length) {
    xMin = readInt16BE(bboxStream, bboxIdx.value);
    bboxIdx.value += 2;
    yMin = readInt16BE(bboxStream, bboxIdx.value);
    bboxIdx.value += 2;
    xMax = readInt16BE(bboxStream, bboxIdx.value);
    bboxIdx.value += 2;
    yMax = readInt16BE(bboxStream, bboxIdx.value);
    bboxIdx.value += 2;
  } else {
    xMin = yMin = 32767;
    xMax = yMax = -32768;
    for (let i = 0;i < points.length; i++) {
      const pt = points[i];
      xMin = Math.min(xMin, pt.x);
      yMin = Math.min(yMin, pt.y);
      xMax = Math.max(xMax, pt.x);
      yMax = Math.max(yMax, pt.y);
    }
  }
  const instructionLength = read255UInt16(glyphStream, glyphIdx);
  const instructions = instructionStream.slice(instructionIdx.value, instructionIdx.value + instructionLength);
  instructionIdx.value += instructionLength;
  const xDeltas = [];
  const yDeltas = [];
  let prevX = 0, prevY = 0;
  for (let i = 0;i < points.length; i++) {
    const pt = points[i];
    xDeltas.push(pt.x - prevX);
    yDeltas.push(pt.y - prevY);
    prevX = pt.x;
    prevY = pt.y;
  }
  const encodedFlags = [];
  const encodedX = [];
  const encodedY = [];
  for (let i = 0;i < totalPoints; i++) {
    let flag = points[i].onCurve ? 1 : 0;
    const dx = xDeltas[i];
    const dy = yDeltas[i];
    if (dx === 0) {
      flag |= 16;
    } else if (dx >= -255 && dx <= 255) {
      flag |= 2;
      if (dx > 0)
        flag |= 16;
      encodedX.push(Math.abs(dx));
    } else {
      encodedX.push(dx >> 8 & 255, dx & 255);
    }
    if (dy === 0) {
      flag |= 32;
    } else if (dy >= -255 && dy <= 255) {
      flag |= 4;
      if (dy > 0)
        flag |= 32;
      encodedY.push(Math.abs(dy));
    } else {
      encodedY.push(dy >> 8 & 255, dy & 255);
    }
    encodedFlags.push(flag);
  }
  const headerSize = 10 + nContours * 2 + 2 + instructionLength;
  const totalSize = headerSize + encodedFlags.length + encodedX.length + encodedY.length;
  const data = new Uint8Array(totalSize);
  let off = 0;
  writeUint16BE(data, off, nContours);
  off += 2;
  writeUint16BE(data, off, xMin & 65535);
  off += 2;
  writeUint16BE(data, off, yMin & 65535);
  off += 2;
  writeUint16BE(data, off, xMax & 65535);
  off += 2;
  writeUint16BE(data, off, yMax & 65535);
  off += 2;
  for (let i = 0;i < endPtsOfContours.length; i++) {
    const endPt = endPtsOfContours[i];
    writeUint16BE(data, off, endPt);
    off += 2;
  }
  writeUint16BE(data, off, instructionLength);
  off += 2;
  data.set(instructions, off);
  off += instructionLength;
  for (let i = 0;i < encodedFlags.length; i++) {
    const f = encodedFlags[i];
    data[off++] = f;
  }
  for (let i = 0;i < encodedX.length; i++) {
    const x = encodedX[i];
    data[off++] = x;
  }
  for (let i = 0;i < encodedY.length; i++) {
    const y = encodedY[i];
    data[off++] = y;
  }
  return data.slice(0, off);
}
function reconstructCompositeGlyph(compositeStream, compositeIdx, bboxStream, bboxIdx, instructionStream, instructionIdx, _optionFlags) {
  const parts = [];
  const xMin = readInt16BE(bboxStream, bboxIdx.value);
  bboxIdx.value += 2;
  const yMin = readInt16BE(bboxStream, bboxIdx.value);
  bboxIdx.value += 2;
  const xMax = readInt16BE(bboxStream, bboxIdx.value);
  bboxIdx.value += 2;
  const yMax = readInt16BE(bboxStream, bboxIdx.value);
  bboxIdx.value += 2;
  parts.push(255, 255);
  parts.push(xMin >> 8 & 255, xMin & 255);
  parts.push(yMin >> 8 & 255, yMin & 255);
  parts.push(xMax >> 8 & 255, xMax & 255);
  parts.push(yMax >> 8 & 255, yMax & 255);
  let hasMoreComponents = true;
  let hasInstructions = false;
  while (hasMoreComponents) {
    const flags = readUint16BE(compositeStream, compositeIdx.value);
    compositeIdx.value += 2;
    const glyphIndex = readUint16BE(compositeStream, compositeIdx.value);
    compositeIdx.value += 2;
    parts.push(flags >> 8 & 255, flags & 255);
    parts.push(glyphIndex >> 8 & 255, glyphIndex & 255);
    if (flags & 1) {
      parts.push(compositeStream[compositeIdx.value++]);
      parts.push(compositeStream[compositeIdx.value++]);
      parts.push(compositeStream[compositeIdx.value++]);
      parts.push(compositeStream[compositeIdx.value++]);
    } else {
      parts.push(compositeStream[compositeIdx.value++]);
      parts.push(compositeStream[compositeIdx.value++]);
    }
    if (flags & 8) {
      parts.push(compositeStream[compositeIdx.value++]);
      parts.push(compositeStream[compositeIdx.value++]);
    } else if (flags & 64) {
      for (let i = 0;i < 4; i++)
        parts.push(compositeStream[compositeIdx.value++]);
    } else if (flags & 128) {
      for (let i = 0;i < 8; i++)
        parts.push(compositeStream[compositeIdx.value++]);
    }
    hasMoreComponents = (flags & 32) !== 0;
    if (flags & 256)
      hasInstructions = true;
  }
  if (hasInstructions) {
    const instrLen = read255UInt16(instructionStream, instructionIdx);
    parts.push(instrLen >> 8 & 255, instrLen & 255);
    for (let i = 0;i < instrLen; i++) {
      parts.push(instructionStream[instructionIdx.value++]);
    }
  }
  return new Uint8Array(parts);
}
async function woff2ToSfnt(buffer) {
  const data = new Uint8Array(buffer);
  const view = new DataView(buffer);
  const signature = view.getUint32(0, false);
  if (signature !== 2001684018) {
    throw new Error("Not a valid WOFF2 file");
  }
  const flavor = view.getUint32(4, false);
  const numTables = view.getUint16(12, false);
  const totalCompressedSize = view.getUint32(20, false);
  const offset = { value: 48 };
  const tables = parseTableDirectory(data, offset, numTables);
  const compressedData = data.slice(offset.value, offset.value + totalCompressedSize);
  const decompressedData = await decompressBrotli(compressedData);
  const tableData = new Map;
  let decompOffset = 0;
  for (let i = 0;i < tables.length; i++) {
    const table = tables[i];
    const tdata = decompressedData.slice(decompOffset, decompOffset + table.transformLength);
    tableData.set(table.tag, tdata);
    decompOffset += table.transformLength;
  }
  const maxpData = tableData.get("maxp");
  const headData = tableData.get("head");
  if (!maxpData || !headData) {
    throw new Error("Missing required tables");
  }
  const numGlyphs = readUint16BE(maxpData, 4);
  const indexToLocFormat = readInt16BE(headData, 50);
  const glyfEntry = tables.find((t) => t.tag === "glyf");
  const locaEntry = tables.find((t) => t.tag === "loca");
  if (glyfEntry && glyfEntry.transformVersion === 0) {
    const glyfTransformed = tableData.get("glyf");
    if (!glyfTransformed) {
      throw new Error("Missing glyf table data for transform");
    }
    const { glyf, loca } = reconstructGlyfLoca(glyfTransformed, numGlyphs, indexToLocFormat);
    tableData.set("glyf", glyf);
    tableData.set("loca", loca);
    glyfEntry.origLength = glyf.length;
    if (locaEntry) {
      locaEntry.origLength = loca.length;
    }
  }
  const headerSize = 12;
  const directorySize = numTables * 16;
  let tableOffset = headerSize + directorySize;
  const tableOffsets = [];
  for (let i = 0;i < tables.length; i++) {
    const table = tables[i];
    tableOffsets.push(tableOffset);
    tableOffset += pad4(table.origLength);
  }
  const output = new Uint8Array(tableOffset);
  const searchRange = 2 ** Math.floor(Math.log2(numTables)) * 16;
  const entrySelector = Math.floor(Math.log2(numTables));
  const rangeShift = numTables * 16 - searchRange;
  writeUint32BE(output, 0, flavor);
  writeUint16BE(output, 4, numTables);
  writeUint16BE(output, 6, searchRange);
  writeUint16BE(output, 8, entrySelector);
  writeUint16BE(output, 10, rangeShift);
  let headOffset = -1;
  for (let i = 0;i < tables.length; i++) {
    const table = tables[i];
    const tdata = tableData.get(table.tag);
    if (!tdata) {
      throw new Error(`Missing table data for ${table.tag}`);
    }
    const dirOffset = headerSize + i * 16;
    const tableOff = tableOffsets[i];
    if (table.tag === "head" && tableOff !== undefined) {
      headOffset = tableOff;
    }
    for (let j = 0;j < 4; j++) {
      output[dirOffset + j] = table.tag.charCodeAt(j);
    }
    const checksum = calcChecksum(tdata, 0, tdata.length);
    writeUint32BE(output, dirOffset + 4, checksum);
    writeUint32BE(output, dirOffset + 8, tableOffsets[i]);
    writeUint32BE(output, dirOffset + 12, table.origLength);
    output.set(tdata.slice(0, table.origLength), tableOffsets[i]);
  }
  if (headOffset >= 0) {
    const totalChecksum = calcChecksum(output, 0, output.length);
    const checksumAdjustment = 2981146554 - totalChecksum >>> 0;
    writeUint32BE(output, headOffset + 8, checksumAdjustment);
  }
  return output.buffer;
}

// reference/text-shaper/src/font/tables/base.ts
var BaselineTag = {
  hang: 1751215719,
  icfb: 1768121954,
  icft: 1768121972,
  ideo: 1768187247,
  idtp: 1768191088,
  math: 1835103336,
  romn: 1919905134
};
function parseBaseCoord(reader) {
  const format = reader.uint16();
  const coordinate = reader.int16();
  const result = { format, coordinate };
  if (format === 2) {
    result.referenceGlyph = reader.uint16();
    result.baseCoordPoint = reader.uint16();
  } else if (format === 3) {
    result.deviceOffset = reader.uint16();
  }
  return result;
}
function parseMinMax(reader, minMaxOffset) {
  if (minMaxOffset === 0)
    return null;
  const minMaxReader = reader.sliceFrom(minMaxOffset);
  const minCoordOffset = minMaxReader.uint16();
  const maxCoordOffset = minMaxReader.uint16();
  const featMinMaxCount = minMaxReader.uint16();
  let minCoord = null;
  let maxCoord = null;
  if (minCoordOffset !== 0) {
    const coordReader = reader.sliceFrom(minMaxOffset + minCoordOffset);
    minCoord = parseBaseCoord(coordReader).coordinate;
  }
  if (maxCoordOffset !== 0) {
    const coordReader = reader.sliceFrom(minMaxOffset + maxCoordOffset);
    maxCoord = parseBaseCoord(coordReader).coordinate;
  }
  const featMinMaxRecords = [];
  for (let i = 0;i < featMinMaxCount; i++) {
    const featureTag = minMaxReader.uint32();
    const minOffset = minMaxReader.uint16();
    const maxOffset = minMaxReader.uint16();
    let featMin = null;
    let featMax = null;
    if (minOffset !== 0) {
      const coordReader = reader.sliceFrom(minMaxOffset + minOffset);
      featMin = parseBaseCoord(coordReader).coordinate;
    }
    if (maxOffset !== 0) {
      const coordReader = reader.sliceFrom(minMaxOffset + maxOffset);
      featMax = parseBaseCoord(coordReader).coordinate;
    }
    featMinMaxRecords.push({
      featureTag,
      minCoord: featMin,
      maxCoord: featMax
    });
  }
  return { minCoord, maxCoord, featMinMaxRecords };
}
function parseBaseValues(reader, baseValuesOffset, _baseTagList) {
  if (baseValuesOffset === 0)
    return null;
  const bvReader = reader.sliceFrom(baseValuesOffset);
  const defaultBaselineIndex = bvReader.uint16();
  const baseCoordCount = bvReader.uint16();
  const coordOffsets = [];
  for (let i = 0;i < baseCoordCount; i++) {
    coordOffsets.push(bvReader.uint16());
  }
  const baseCoords = [];
  for (let i = 0;i < coordOffsets.length; i++) {
    const offset = coordOffsets[i];
    if (offset !== 0) {
      const coordReader = reader.sliceFrom(baseValuesOffset + offset);
      baseCoords.push(parseBaseCoord(coordReader).coordinate);
    } else {
      baseCoords.push(0);
    }
  }
  return { defaultBaselineIndex, baseCoords };
}
function parseBaseScriptRecord(reader, scriptOffset, baseTagList) {
  const scriptReader = reader.sliceFrom(scriptOffset);
  const baseValuesOffset = scriptReader.uint16();
  const defaultMinMaxOffset = scriptReader.uint16();
  const baseLangSysCount = scriptReader.uint16();
  const baseLangSysRecords = new Map;
  const langSysData = [];
  for (let i = 0;i < baseLangSysCount; i++) {
    const tag2 = scriptReader.uint32();
    const offset = scriptReader.uint16();
    langSysData.push({ tag: tag2, offset });
  }
  const baseValues = parseBaseValues(reader, scriptOffset + baseValuesOffset, baseTagList);
  const defaultMinMax = parseMinMax(reader, scriptOffset + defaultMinMaxOffset);
  for (let i = 0;i < langSysData.length; i++) {
    const item = langSysData[i];
    const minMax = parseMinMax(reader, scriptOffset + item.offset);
    if (minMax) {
      baseLangSysRecords.set(item.tag, minMax);
    }
  }
  return { baseValues, defaultMinMax, baseLangSysRecords };
}
function parseAxisTable(reader, axisOffset) {
  if (axisOffset === 0)
    return null;
  const axisReader = reader.sliceFrom(axisOffset);
  const baseTagListOffset = axisReader.uint16();
  const baseScriptListOffset = axisReader.uint16();
  const baseTagList = [];
  if (baseTagListOffset !== 0) {
    const tagReader = reader.sliceFrom(axisOffset + baseTagListOffset);
    const baseTagCount = tagReader.uint16();
    for (let i = 0;i < baseTagCount; i++) {
      baseTagList.push(tagReader.uint32());
    }
  }
  const baseScriptList = [];
  if (baseScriptListOffset !== 0) {
    const scriptListReader = reader.sliceFrom(axisOffset + baseScriptListOffset);
    const baseScriptCount = scriptListReader.uint16();
    const scriptData = [];
    for (let i = 0;i < baseScriptCount; i++) {
      const tag2 = scriptListReader.uint32();
      const offset = scriptListReader.uint16();
      scriptData.push({ tag: tag2, offset });
    }
    for (let i = 0;i < scriptData.length; i++) {
      const item = scriptData[i];
      const record = parseBaseScriptRecord(reader, axisOffset + baseScriptListOffset + item.offset, baseTagList);
      baseScriptList.push({ scriptTag: item.tag, ...record });
    }
  }
  return { baseTagList, baseScriptList };
}
function parseBase(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const horizAxisOffset = reader.uint16();
  const vertAxisOffset = reader.uint16();
  const horizAxis = parseAxisTable(reader, horizAxisOffset);
  const vertAxis = parseAxisTable(reader, vertAxisOffset);
  return {
    majorVersion,
    minorVersion,
    horizAxis,
    vertAxis
  };
}
function getBaselineForScript(base, scriptTag, baselineTag, horizontal = true) {
  const axis = horizontal ? base.horizAxis : base.vertAxis;
  if (!axis)
    return null;
  const scriptRecord = axis.baseScriptList.find((r) => r.scriptTag === scriptTag);
  if (!scriptRecord?.baseValues)
    return null;
  const tagIndex = axis.baseTagList.indexOf(baselineTag);
  if (tagIndex === -1)
    return null;
  return scriptRecord.baseValues.baseCoords[tagIndex] ?? null;
}
function getDefaultBaseline(base, scriptTag, horizontal = true) {
  const axis = horizontal ? base.horizAxis : base.vertAxis;
  if (!axis)
    return null;
  const scriptRecord = axis.baseScriptList.find((r) => r.scriptTag === scriptTag);
  if (!scriptRecord?.baseValues)
    return null;
  const index = scriptRecord.baseValues.defaultBaselineIndex;
  const tag2 = axis.baseTagList[index];
  const coordinate = scriptRecord.baseValues.baseCoords[index];
  if (tag2 === undefined || coordinate === undefined)
    return null;
  return { tag: tag2, coordinate };
}
function getMinMaxExtent(base, scriptTag, languageTag, horizontal = true) {
  const axis = horizontal ? base.horizAxis : base.vertAxis;
  if (!axis)
    return null;
  const scriptRecord = axis.baseScriptList.find((r) => r.scriptTag === scriptTag);
  if (!scriptRecord)
    return null;
  if (languageTag !== undefined) {
    const langMinMax = scriptRecord.baseLangSysRecords.get(languageTag);
    if (langMinMax) {
      return { minCoord: langMinMax.minCoord, maxCoord: langMinMax.maxCoord };
    }
  }
  if (scriptRecord.defaultMinMax) {
    return {
      minCoord: scriptRecord.defaultMinMax.minCoord,
      maxCoord: scriptRecord.defaultMinMax.maxCoord
    };
  }
  return null;
}

// reference/text-shaper/src/font/tables/cbdt.ts
var CbdtImageFormat = {
  SmallMetrics: 1,
  SmallMetricsPng: 17,
  BigMetrics: 2,
  BigMetricsPng: 18,
  CompressedPng: 19
};
function parseCblc(reader) {
  const tableStart = reader.offset;
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const numSizes = reader.uint32();
  const bitmapSizes = [];
  for (let i = 0;i < numSizes; i++) {
    const indexSubTableArrayOffset = reader.uint32();
    const indexTablesSize = reader.uint32();
    const numberOfIndexSubTables = reader.uint32();
    const colorRef = reader.uint32();
    const hori = parseSbitLineMetrics(reader);
    const vert = parseSbitLineMetrics(reader);
    const startGlyphIndex = reader.uint16();
    const endGlyphIndex = reader.uint16();
    const ppemX = reader.uint8();
    const ppemY = reader.uint8();
    const bitDepth = reader.uint8();
    const flags = reader.int8();
    bitmapSizes.push({
      indexSubTableArrayOffset,
      indexTablesSize,
      numberOfIndexSubTables,
      colorRef,
      hori,
      vert,
      startGlyphIndex,
      endGlyphIndex,
      ppemX,
      ppemY,
      bitDepth,
      flags,
      indexSubTables: []
    });
  }
  for (let i = 0;i < bitmapSizes.length; i++) {
    const size = bitmapSizes[i];
    const subTableReader = reader.sliceFrom(tableStart + size.indexSubTableArrayOffset);
    const subTableHeaders = [];
    for (let j = 0;j < size.numberOfIndexSubTables; j++) {
      subTableHeaders.push({
        firstGlyphIndex: subTableReader.uint16(),
        lastGlyphIndex: subTableReader.uint16(),
        additionalOffsetToIndexSubtable: subTableReader.uint32()
      });
    }
    for (let j = 0;j < subTableHeaders.length; j++) {
      const header = subTableHeaders[j];
      const indexSubTable = parseIndexSubTable(reader, tableStart + size.indexSubTableArrayOffset + header.additionalOffsetToIndexSubtable, header.firstGlyphIndex, header.lastGlyphIndex);
      size.indexSubTables.push(indexSubTable);
    }
  }
  return { majorVersion, minorVersion, bitmapSizes };
}
function parseSbitLineMetrics(reader) {
  return {
    ascender: reader.int8(),
    descender: reader.int8(),
    widthMax: reader.uint8(),
    caretSlopeNumerator: reader.int8(),
    caretSlopeDenominator: reader.int8(),
    caretOffset: reader.int8(),
    minOriginSB: reader.int8(),
    minAdvanceSB: reader.int8(),
    maxBeforeBL: reader.int8(),
    minAfterBL: reader.int8(),
    pad1: reader.int8(),
    pad2: reader.int8()
  };
}
function parseIndexSubTable(reader, offset, firstGlyph, lastGlyph) {
  const subReader = reader.sliceFrom(offset);
  const indexFormat = subReader.uint16();
  const imageFormat = subReader.uint16();
  const imageDataOffset = subReader.uint32();
  const glyphOffsets = new Map;
  const numGlyphs = lastGlyph - firstGlyph + 1;
  switch (indexFormat) {
    case 1: {
      const offsets = [];
      for (let i = 0;i <= numGlyphs; i++) {
        offsets.push(subReader.uint32());
      }
      for (let i = 0;i < numGlyphs; i++) {
        const glyphOffset = offsets[i];
        const nextOffset = offsets[i + 1];
        if (glyphOffset === undefined || nextOffset === undefined)
          continue;
        if (nextOffset > glyphOffset) {
          glyphOffsets.set(firstGlyph + i, {
            offset: imageDataOffset + glyphOffset,
            length: nextOffset - glyphOffset
          });
        }
      }
      break;
    }
    case 2: {
      const imageSize = subReader.uint32();
      const _bigMetrics = {
        height: subReader.uint8(),
        width: subReader.uint8(),
        horiBearingX: subReader.int8(),
        horiBearingY: subReader.int8(),
        horiAdvance: subReader.uint8(),
        vertBearingX: subReader.int8(),
        vertBearingY: subReader.int8(),
        vertAdvance: subReader.uint8()
      };
      for (let i = 0;i < numGlyphs; i++) {
        glyphOffsets.set(firstGlyph + i, {
          offset: imageDataOffset + i * imageSize,
          length: imageSize
        });
      }
      break;
    }
    case 3: {
      const offsets = [];
      for (let i = 0;i <= numGlyphs; i++) {
        offsets.push(subReader.uint16());
      }
      for (let i = 0;i < numGlyphs; i++) {
        const glyphOffset = offsets[i];
        const nextOffset = offsets[i + 1];
        if (glyphOffset === undefined || nextOffset === undefined)
          continue;
        if (nextOffset > glyphOffset) {
          glyphOffsets.set(firstGlyph + i, {
            offset: imageDataOffset + glyphOffset,
            length: nextOffset - glyphOffset
          });
        }
      }
      break;
    }
    case 4: {
      const numGlyphsActual = subReader.uint32();
      const glyphArray = [];
      for (let i = 0;i <= numGlyphsActual; i++) {
        glyphArray.push({
          glyphId: subReader.uint16(),
          offset: subReader.uint16()
        });
      }
      for (let i = 0;i < numGlyphsActual; i++) {
        const entry = glyphArray[i];
        const nextEntry = glyphArray[i + 1];
        if (entry === undefined || nextEntry === undefined)
          continue;
        glyphOffsets.set(entry.glyphId, {
          offset: imageDataOffset + entry.offset,
          length: nextEntry.offset - entry.offset
        });
      }
      break;
    }
    case 5: {
      const imageSize = subReader.uint32();
      subReader.skip(8);
      const numGlyphsActual = subReader.uint32();
      for (let i = 0;i < numGlyphsActual; i++) {
        const glyphId = subReader.uint16();
        glyphOffsets.set(glyphId, {
          offset: imageDataOffset + i * imageSize,
          length: imageSize
        });
      }
      break;
    }
  }
  return {
    firstGlyphIndex: firstGlyph,
    lastGlyphIndex: lastGlyph,
    indexFormat,
    imageFormat,
    imageDataOffset,
    glyphOffsets
  };
}
function parseCbdt(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const data = reader.bytes(reader.remaining);
  return { majorVersion, minorVersion, data };
}
function getBitmapGlyph(cblc, cbdt, glyphId, ppem) {
  let bestSize = null;
  let bestDiff = Infinity;
  for (let i = 0;i < cblc.bitmapSizes.length; i++) {
    const size = cblc.bitmapSizes[i];
    if (glyphId < size.startGlyphIndex || glyphId > size.endGlyphIndex) {
      continue;
    }
    const diff = Math.abs(size.ppemX - ppem);
    if (diff < bestDiff) {
      bestDiff = diff;
      bestSize = size;
    }
  }
  if (!bestSize)
    return null;
  for (let i = 0;i < bestSize.indexSubTables.length; i++) {
    const subTable = bestSize.indexSubTables[i];
    const glyphInfo = subTable.glyphOffsets.get(glyphId);
    if (!glyphInfo)
      continue;
    const glyphData = cbdt.data.slice(glyphInfo.offset - 4, glyphInfo.offset - 4 + glyphInfo.length);
    return parseGlyphData2(glyphData, subTable.imageFormat);
  }
  return null;
}
function parseGlyphData2(data, imageFormat) {
  if (data.length === 0)
    return null;
  let offset = 0;
  let metrics;
  switch (imageFormat) {
    case 1:
    case 2:
    case 17:
    case 18: {
      if (imageFormat === 1 || imageFormat === 17) {
        if (offset + 5 > data.length)
          return null;
        metrics = {
          height: data[offset++] ?? 0,
          width: data[offset++] ?? 0,
          bearingX: (data[offset++] ?? 0) << 24 >> 24,
          bearingY: (data[offset++] ?? 0) << 24 >> 24,
          advance: data[offset++] ?? 0
        };
      } else {
        if (offset + 8 > data.length)
          return null;
        metrics = {
          height: data[offset++] ?? 0,
          width: data[offset++] ?? 0,
          bearingX: (data[offset++] ?? 0) << 24 >> 24,
          bearingY: (data[offset++] ?? 0) << 24 >> 24,
          advance: data[offset++] ?? 0
        };
        offset += 3;
      }
      break;
    }
    case 19: {
      metrics = { height: 0, width: 0, bearingX: 0, bearingY: 0, advance: 0 };
      break;
    }
    default:
      return null;
  }
  return {
    metrics,
    imageFormat,
    data: data.slice(offset)
  };
}
function hasColorBitmap(cblc, glyphId, ppem) {
  for (let i = 0;i < cblc.bitmapSizes.length; i++) {
    const size = cblc.bitmapSizes[i];
    if (ppem !== undefined && size.ppemX !== ppem)
      continue;
    if (glyphId < size.startGlyphIndex || glyphId > size.endGlyphIndex) {
      continue;
    }
    for (let j = 0;j < size.indexSubTables.length; j++) {
      const subTable = size.indexSubTables[j];
      if (subTable.glyphOffsets.has(glyphId)) {
        return true;
      }
    }
  }
  return false;
}
function getColorBitmapSizes(cblc) {
  const sizes = new Set;
  for (let i = 0;i < cblc.bitmapSizes.length; i++) {
    const size = cblc.bitmapSizes[i];
    sizes.add(size.ppemX);
  }
  return [...sizes].sort((a, b) => a - b);
}

// reference/text-shaper/src/font/tables/cff.ts
var STANDARD_STRINGS = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
function parseCff(reader) {
  const startOffset = reader.offset;
  const major = reader.uint8();
  const minor = reader.uint8();
  const hdrSize = reader.uint8();
  const _offSize = reader.uint8();
  reader.seek(startOffset + hdrSize);
  const names = parseIndex(reader).map((data) => new TextDecoder().decode(data));
  const topDictData = parseIndex(reader);
  const topDicts = [];
  const stringData = parseIndex(reader);
  const strings = stringData.map((data) => new TextDecoder().decode(data));
  const globalSubrs = parseIndex(reader);
  for (let i = 0;i < topDictData.length; i++) {
    const data = topDictData[i];
    topDicts.push(parseTopDict(new Reader(data.buffer, data.byteOffset, data.byteLength), strings));
  }
  const charStrings = [];
  const localSubrs = [];
  const fdArrays = [];
  const fdSelects = [];
  for (let i = 0;i < topDicts.length; i++) {
    const topDict = topDicts[i];
    if (topDict.charStrings !== undefined) {
      reader.seek(startOffset + topDict.charStrings);
      charStrings.push(parseIndex(reader));
    } else {
      charStrings.push([]);
    }
    if (topDict.private) {
      const [privateSize, privateOffset] = topDict.private;
      const privateDict = parsePrivateDict(reader.slice(privateOffset, privateSize), strings);
      if (privateDict.subrs !== undefined) {
        reader.seek(startOffset + privateOffset + privateDict.subrs);
        localSubrs.push(parseIndex(reader));
      } else {
        localSubrs.push([]);
      }
    } else {
      localSubrs.push([]);
    }
    if (topDict.fdArray !== undefined) {
      reader.seek(startOffset + topDict.fdArray);
      const fdData = parseIndex(reader);
      const fds = [];
      for (let j = 0;j < fdData.length; j++) {
        const data = fdData[j];
        const fdDict = parseTopDict(new Reader(data.buffer, data.byteOffset, data.byteLength), strings);
        if (fdDict.private) {
          const [fdPrivateSize, fdPrivateOffset] = fdDict.private;
          const fdPrivateDict = parsePrivateDict(reader.slice(startOffset + fdPrivateOffset, fdPrivateSize), strings);
          Object.assign(fdDict, fdPrivateDict);
          if (fdPrivateDict.subrs !== undefined) {
            reader.seek(startOffset + fdPrivateOffset + fdPrivateDict.subrs);
            fdDict.localSubrs = parseIndex(reader);
          }
        }
        fds.push(fdDict);
      }
      fdArrays.push(fds);
    } else {
      fdArrays.push([]);
    }
    if (topDict.fdSelect !== undefined) {
      reader.seek(startOffset + topDict.fdSelect);
      const lastCharStrings = charStrings[charStrings.length - 1];
      fdSelects.push(parseFDSelect(reader, lastCharStrings?.length ?? 0));
    } else {
      fdSelects.push({ format: 0, select: () => 0 });
    }
  }
  return {
    version: { major, minor },
    names,
    topDicts,
    strings,
    globalSubrs,
    charStrings,
    localSubrs,
    fdArrays,
    fdSelects
  };
}
function parseIndex(reader) {
  const count = reader.uint16();
  if (count === 0)
    return [];
  const offSize = reader.uint8();
  const offsets = [];
  for (let i = 0;i <= count; i++) {
    offsets.push(readOffset(reader, offSize));
  }
  const result = [];
  for (let i = 0;i < count; i++) {
    const start = offsets[i];
    const end = offsets[i + 1];
    if (start === undefined || end === undefined)
      continue;
    const length = end - start;
    result.push(reader.bytes(length));
  }
  return result;
}
function readOffset(reader, offSize) {
  switch (offSize) {
    case 1:
      return reader.uint8();
    case 2:
      return reader.uint16();
    case 3:
      return reader.uint24();
    case 4:
      return reader.uint32();
    default:
      throw new Error(`Invalid offset size: ${offSize}`);
  }
}
function parseDict(reader) {
  const result = new Map;
  const operands = [];
  while (reader.remaining > 0) {
    const b0 = reader.uint8();
    if (b0 <= 21) {
      let op = b0;
      if (b0 === 12) {
        op = 3072 | reader.uint8();
      }
      result.set(op, [...operands]);
      operands.length = 0;
    } else if (b0 === 28) {
      operands.push(reader.int16());
    } else if (b0 === 29) {
      operands.push(reader.int32());
    } else if (b0 === 30) {
      operands.push(parseReal(reader));
    } else if (b0 >= 32 && b0 <= 246) {
      operands.push(b0 - 139);
    } else if (b0 >= 247 && b0 <= 250) {
      const b1 = reader.uint8();
      operands.push((b0 - 247) * 256 + b1 + 108);
    } else if (b0 >= 251 && b0 <= 254) {
      const b1 = reader.uint8();
      operands.push(-(b0 - 251) * 256 - b1 - 108);
    }
  }
  return result;
}
function parseReal(reader) {
  let str = "";
  const nibbleChars = "0123456789.EE -";
  let done = false;
  while (!done) {
    const byte = reader.uint8();
    for (let i = 0;i < 2; i++) {
      const nibble = i === 0 ? byte >> 4 : byte & 15;
      if (nibble === 15) {
        done = true;
        break;
      }
      if (nibble === 12) {
        str += "E-";
      } else {
        str += nibbleChars[nibble];
      }
    }
  }
  return parseFloat(str);
}
function parseTopDict(reader, strings) {
  const dict = parseDict(reader);
  const result = {};
  const getString = (sid) => {
    if (sid < STANDARD_STRINGS.length) {
      const str = STANDARD_STRINGS[sid];
      return str ?? "";
    }
    return strings[sid - STANDARD_STRINGS.length] ?? "";
  };
  const dictEntries = [...dict];
  for (let i = 0;i < dictEntries.length; i++) {
    const [op, operands] = dictEntries[i];
    const op0 = operands[0];
    const op1 = operands[1];
    const op2 = operands[2];
    switch (op) {
      case 0 /* version */:
        if (op0 !== undefined)
          result.version = getString(op0);
        break;
      case 1 /* Notice */:
        if (op0 !== undefined)
          result.notice = getString(op0);
        break;
      case 3072 /* Copyright */:
        if (op0 !== undefined)
          result.copyright = getString(op0);
        break;
      case 2 /* FullName */:
        if (op0 !== undefined)
          result.fullName = getString(op0);
        break;
      case 3 /* FamilyName */:
        if (op0 !== undefined)
          result.familyName = getString(op0);
        break;
      case 4 /* Weight */:
        if (op0 !== undefined)
          result.weight = getString(op0);
        break;
      case 3073 /* isFixedPitch */:
        result.isFixedPitch = op0 !== 0;
        break;
      case 3074 /* ItalicAngle */:
        result.italicAngle = op0;
        break;
      case 3075 /* UnderlinePosition */:
        result.underlinePosition = op0;
        break;
      case 3076 /* UnderlineThickness */:
        result.underlineThickness = op0;
        break;
      case 3077 /* PaintType */:
        result.paintType = op0;
        break;
      case 3078 /* CharstringType */:
        result.charstringType = op0;
        break;
      case 3079 /* FontMatrix */:
        result.fontMatrix = operands;
        break;
      case 13 /* UniqueID */:
        result.uniqueID = op0;
        break;
      case 5 /* FontBBox */:
        result.fontBBox = operands;
        break;
      case 3080 /* StrokeWidth */:
        result.strokeWidth = op0;
        break;
      case 15 /* charset */:
        result.charset = op0;
        break;
      case 16 /* Encoding */:
        result.encoding = op0;
        break;
      case 17 /* CharStrings */:
        result.charStrings = op0;
        break;
      case 18 /* Private */:
        if (op0 !== undefined && op1 !== undefined) {
          result.private = [op0, op1];
        }
        break;
      case 3092 /* SyntheticBase */:
        result.syntheticBase = op0;
        break;
      case 3093 /* PostScript */:
        if (op0 !== undefined)
          result.postScript = getString(op0);
        break;
      case 3094 /* BaseFontName */:
        if (op0 !== undefined)
          result.baseFontName = getString(op0);
        break;
      case 3095 /* BaseFontBlend */:
        result.baseFontBlend = operands;
        break;
      case 3102 /* ROS */:
        if (op0 !== undefined && op1 !== undefined && op2 !== undefined) {
          result.ros = {
            registry: getString(op0),
            ordering: getString(op1),
            supplement: op2
          };
        }
        break;
      case 3103 /* CIDFontVersion */:
        result.cidFontVersion = op0;
        break;
      case 3104 /* CIDFontRevision */:
        result.cidFontRevision = op0;
        break;
      case 3105 /* CIDFontType */:
        result.cidFontType = op0;
        break;
      case 3106 /* CIDCount */:
        result.cidCount = op0;
        break;
      case 3107 /* UIDBase */:
        result.uidBase = op0;
        break;
      case 3108 /* FDArray */:
        result.fdArray = op0;
        break;
      case 3109 /* FDSelect */:
        result.fdSelect = op0;
        break;
      case 3110 /* FontName */:
        if (op0 !== undefined)
          result.fontName = getString(op0);
        break;
    }
  }
  return result;
}
function parsePrivateDict(reader, _strings) {
  const dict = parseDict(reader);
  const result = {};
  const dictEntries = [...dict];
  for (let i = 0;i < dictEntries.length; i++) {
    const [op, operands] = dictEntries[i];
    const op0 = operands[0];
    switch (op) {
      case 6 /* BlueValues */:
        result.blueValues = deltaToAbsolute(operands);
        break;
      case 7 /* OtherBlues */:
        result.otherBlues = deltaToAbsolute(operands);
        break;
      case 8 /* FamilyBlues */:
        result.familyBlues = deltaToAbsolute(operands);
        break;
      case 9 /* FamilyOtherBlues */:
        result.familyOtherBlues = deltaToAbsolute(operands);
        break;
      case 3081 /* BlueScale */:
        result.blueScale = op0;
        break;
      case 3082 /* BlueShift */:
        result.blueShift = op0;
        break;
      case 3083 /* BlueFuzz */:
        result.blueFuzz = op0;
        break;
      case 10 /* StdHW */:
        result.stdHW = op0;
        break;
      case 11 /* StdVW */:
        result.stdVW = op0;
        break;
      case 3084 /* StemSnapH */:
        result.stemSnapH = deltaToAbsolute(operands);
        break;
      case 3085 /* StemSnapV */:
        result.stemSnapV = deltaToAbsolute(operands);
        break;
      case 3086 /* ForceBold */:
        result.forceBold = op0 !== 0;
        break;
      case 3089 /* LanguageGroup */:
        result.languageGroup = op0;
        break;
      case 3090 /* ExpansionFactor */:
        result.expansionFactor = op0;
        break;
      case 3091 /* initialRandomSeed */:
        result.initialRandomSeed = op0;
        break;
      case 19 /* Subrs */:
        result.subrs = op0;
        break;
      case 20 /* defaultWidthX */:
        result.defaultWidthX = op0;
        break;
      case 21 /* nominalWidthX */:
        result.nominalWidthX = op0;
        break;
    }
  }
  return result;
}
function deltaToAbsolute(deltas) {
  const result = [];
  let value = 0;
  for (let i = 0;i < deltas.length; i++) {
    const delta = deltas[i];
    value += delta;
    result.push(value);
  }
  return result;
}
function parseFDSelect(reader, numGlyphs) {
  const format = reader.uint8();
  if (format === 0) {
    const fds = reader.uint8Array(numGlyphs);
    return {
      format,
      select: (glyphId) => fds[glyphId] ?? 0
    };
  } else if (format === 3) {
    const nRanges = reader.uint16();
    const ranges = [];
    for (let i = 0;i < nRanges; i++) {
      ranges.push({
        first: reader.uint16(),
        fd: reader.uint8()
      });
    }
    const _sentinel = reader.uint16();
    return {
      format,
      select: (glyphId) => {
        let lo = 0;
        let hi = ranges.length - 1;
        while (lo < hi) {
          const mid = Math.ceil((lo + hi) / 2);
          const range = ranges[mid];
          if (range && range.first <= glyphId) {
            lo = mid;
          } else {
            hi = mid - 1;
          }
        }
        const foundRange = ranges[lo];
        return foundRange?.fd ?? 0;
      }
    };
  }
  return { format, select: () => 0 };
}
function getCffString(cff, sid) {
  if (sid < STANDARD_STRINGS.length) {
    const str = STANDARD_STRINGS[sid];
    return str ?? "";
  }
  return cff.strings[sid - STANDARD_STRINGS.length] ?? "";
}

// reference/text-shaper/src/font/tables/cff-charstring.ts
function stackLen(state) {
  return state.stack.length - state.stackPos;
}
function stackShift(state) {
  if (state.stackPos >= state.stack.length)
    return;
  return state.stack[state.stackPos++];
}
function stackClear(state) {
  state.stack.length = 0;
  state.stackPos = 0;
}
function executeCffCharString(cff, glyphId, fontIndex = 0) {
  const charStrings = cff.charStrings[fontIndex];
  if (!charStrings || glyphId >= charStrings.length)
    return null;
  const charString = charStrings[glyphId];
  if (!charString)
    return null;
  const globalSubrs = cff.globalSubrs;
  const topDict = cff.topDicts[fontIndex];
  const isCID = topDict?.ros !== undefined;
  let localSubrs = [];
  if (isCID && cff.fdSelects[fontIndex] && cff.fdArrays[fontIndex]) {
    const fdIndex = cff.fdSelects[fontIndex]?.select(glyphId) ?? 0;
    const fdArray = cff.fdArrays[fontIndex];
    const fd = fdArray?.[fdIndex];
    localSubrs = fd?.localSubrs || cff.localSubrs[fontIndex] || [];
  } else {
    localSubrs = cff.localSubrs[fontIndex] || [];
  }
  const state = {
    x: 0,
    y: 0,
    stack: [],
    stackPos: 0,
    nStems: 0,
    haveWidth: false,
    width: 0,
    contours: [],
    currentContour: [],
    transientArray: new Array(32).fill(0),
    callStack: [],
    vsindex: 0,
    axisCoords: null,
    vstore: null
  };
  executeCharString(state, charString, globalSubrs, localSubrs);
  if (state.currentContour.length > 0) {
    state.contours.push(state.currentContour);
  }
  return state.contours;
}
function executeCff2CharString(cff2, glyphId, axisCoords = null) {
  if (glyphId >= cff2.charStrings.length)
    return null;
  const charString = cff2.charStrings[glyphId];
  if (!charString)
    return null;
  const globalSubrs = cff2.globalSubrs;
  const fdIndex = cff2.fdSelect?.select(glyphId) ?? 0;
  const fd = cff2.fdArray[fdIndex];
  const localSubrs = fd?.localSubrs || [];
  const state = {
    x: 0,
    y: 0,
    stack: [],
    stackPos: 0,
    nStems: 0,
    haveWidth: true,
    width: 0,
    contours: [],
    currentContour: [],
    transientArray: new Array(32).fill(0),
    callStack: [],
    vsindex: fd?.private?.vsindex ?? 0,
    axisCoords,
    vstore: cff2.vstore
  };
  executeCharString(state, charString, globalSubrs, localSubrs);
  if (state.currentContour.length > 0) {
    state.contours.push(state.currentContour);
  }
  return state.contours;
}
function executeCharString(state, data, globalSubrs, localSubrs) {
  let pos = 0;
  while (pos < data.length) {
    const b0 = data[pos++];
    if (b0 === undefined)
      return;
    if (b0 === 28) {
      const b1 = data[pos++];
      if (b1 === undefined)
        return;
      const b2 = data[pos++];
      if (b2 === undefined)
        return;
      state.stack.push((b1 << 8 | b2) << 16 >> 16);
    } else if (b0 === 255) {
      const b1 = data[pos++];
      if (b1 === undefined)
        return;
      const b2 = data[pos++];
      if (b2 === undefined)
        return;
      const b3 = data[pos++];
      if (b3 === undefined)
        return;
      const b4 = data[pos++];
      if (b4 === undefined)
        return;
      const val = (b1 << 24 | b2 << 16 | b3 << 8 | b4) >> 0;
      state.stack.push(val / 65536);
    } else if (b0 >= 32 && b0 <= 246) {
      state.stack.push(b0 - 139);
    } else if (b0 >= 247 && b0 <= 250) {
      const b1 = data[pos++];
      if (b1 === undefined)
        return;
      state.stack.push((b0 - 247) * 256 + b1 + 108);
    } else if (b0 >= 251 && b0 <= 254) {
      const b1 = data[pos++];
      if (b1 === undefined)
        return;
      state.stack.push(-(b0 - 251) * 256 - b1 - 108);
    } else if (b0 === 12) {
      const b1 = data[pos++];
      if (b1 === undefined)
        return;
      const op = 3072 | b1;
      executeOperator(state, op, globalSubrs, localSubrs);
    } else if (b0 === 19 /* hintmask */ || b0 === 20 /* cntrmask */) {
      const len = stackLen(state);
      const hasWidth = len % 2 !== 0;
      if (hasWidth && !state.haveWidth) {
        const width = stackShift(state);
        if (width !== undefined) {
          state.width = width;
          state.haveWidth = true;
        }
      }
      state.nStems += stackLen(state) / 2;
      stackClear(state);
      const maskBytes = Math.ceil(state.nStems / 8);
      pos += maskBytes;
    } else {
      executeOperator(state, b0, globalSubrs, localSubrs);
    }
    if (state.callStack.length > 0) {
      const frame = state.callStack[state.callStack.length - 1];
      if (frame && frame.pos >= frame.data.length) {
        state.callStack.pop();
      }
    }
  }
}
function executeOperator(state, op, globalSubrs, localSubrs) {
  const stack = state.stack;
  switch (op) {
    case 1 /* hstem */:
    case 3 /* vstem */:
    case 18 /* hstemhm */:
    case 23 /* vstemhm */: {
      const len = stackLen(state);
      const hasWidth = len % 2 !== 0;
      if (hasWidth && !state.haveWidth) {
        const width = stackShift(state);
        if (width === undefined)
          break;
        state.width = width;
        state.haveWidth = true;
      }
      state.nStems += stackLen(state) / 2;
      stackClear(state);
      break;
    }
    case 19 /* hintmask */:
    case 20 /* cntrmask */:
      break;
    case 21 /* rmoveto */: {
      if (stackLen(state) > 2 && !state.haveWidth) {
        const width = stackShift(state);
        if (width === undefined)
          break;
        state.width = width;
        state.haveWidth = true;
      }
      if (state.currentContour.length > 0) {
        state.contours.push(state.currentContour);
        state.currentContour = [];
      }
      const dx = stackShift(state);
      if (dx === undefined)
        break;
      const dy = stackShift(state);
      if (dy === undefined)
        break;
      state.x += dx;
      state.y += dy;
      state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
      stackClear(state);
      break;
    }
    case 22 /* hmoveto */: {
      if (stackLen(state) > 1 && !state.haveWidth) {
        const width = stackShift(state);
        if (width === undefined)
          break;
        state.width = width;
        state.haveWidth = true;
      }
      if (state.currentContour.length > 0) {
        state.contours.push(state.currentContour);
        state.currentContour = [];
      }
      const dx = stackShift(state);
      if (dx === undefined)
        break;
      state.x += dx;
      state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
      stackClear(state);
      break;
    }
    case 4 /* vmoveto */: {
      if (stackLen(state) > 1 && !state.haveWidth) {
        const width = stackShift(state);
        if (width === undefined)
          break;
        state.width = width;
        state.haveWidth = true;
      }
      if (state.currentContour.length > 0) {
        state.contours.push(state.currentContour);
        state.currentContour = [];
      }
      const dy = stackShift(state);
      if (dy === undefined)
        break;
      state.y += dy;
      state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
      stackClear(state);
      break;
    }
    case 5 /* rlineto */: {
      while (stackLen(state) >= 2) {
        const dx = stackShift(state);
        if (dx === undefined)
          break;
        const dy = stackShift(state);
        if (dy === undefined)
          break;
        state.x += dx;
        state.y += dy;
        state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
      }
      break;
    }
    case 6 /* hlineto */: {
      let isHorizontal = true;
      while (stackLen(state) >= 1) {
        const val = stackShift(state);
        if (val === undefined)
          break;
        if (isHorizontal) {
          state.x += val;
        } else {
          state.y += val;
        }
        state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
        isHorizontal = !isHorizontal;
      }
      break;
    }
    case 7 /* vlineto */: {
      let isVertical = true;
      while (stackLen(state) >= 1) {
        const val = stackShift(state);
        if (val === undefined)
          break;
        if (isVertical) {
          state.y += val;
        } else {
          state.x += val;
        }
        state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
        isVertical = !isVertical;
      }
      break;
    }
    case 8 /* rrcurveto */: {
      while (stackLen(state) >= 6) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dy3 = stackShift(state);
        if (dy3 === undefined)
          break;
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);
      }
      break;
    }
    case 27 /* hhcurveto */: {
      let dy1 = 0;
      if (stackLen(state) % 4 === 1) {
        const val = stackShift(state);
        if (val === undefined)
          break;
        dy1 = val;
      }
      while (stackLen(state) >= 4) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, 0);
        dy1 = 0;
      }
      break;
    }
    case 26 /* vvcurveto */: {
      let dx1 = 0;
      if (stackLen(state) % 4 === 1) {
        const val = stackShift(state);
        if (val === undefined)
          break;
        dx1 = val;
      }
      while (stackLen(state) >= 4) {
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dy3 = stackShift(state);
        if (dy3 === undefined)
          break;
        addCubicBezier(state, dx1, dy1, dx2, dy2, 0, dy3);
        dx1 = 0;
      }
      break;
    }
    case 31 /* hvcurveto */: {
      let isHorizontal = true;
      while (stackLen(state) >= 4) {
        if (isHorizontal) {
          const dx1 = stackShift(state);
          if (dx1 === undefined)
            break;
          const dx2 = stackShift(state);
          if (dx2 === undefined)
            break;
          const dy2 = stackShift(state);
          if (dy2 === undefined)
            break;
          const dy3 = stackShift(state);
          if (dy3 === undefined)
            break;
          const dx3 = stackLen(state) === 1 ? stackShift(state) ?? 0 : 0;
          addCubicBezier(state, dx1, 0, dx2, dy2, dx3, dy3);
        } else {
          const dy1 = stackShift(state);
          if (dy1 === undefined)
            break;
          const dx2 = stackShift(state);
          if (dx2 === undefined)
            break;
          const dy2 = stackShift(state);
          if (dy2 === undefined)
            break;
          const dx3 = stackShift(state);
          if (dx3 === undefined)
            break;
          const dy3 = stackLen(state) === 1 ? stackShift(state) ?? 0 : 0;
          addCubicBezier(state, 0, dy1, dx2, dy2, dx3, dy3);
        }
        isHorizontal = !isHorizontal;
      }
      break;
    }
    case 30 /* vhcurveto */: {
      let isVertical = true;
      while (stackLen(state) >= 4) {
        if (isVertical) {
          const dy1 = stackShift(state);
          if (dy1 === undefined)
            break;
          const dx2 = stackShift(state);
          if (dx2 === undefined)
            break;
          const dy2 = stackShift(state);
          if (dy2 === undefined)
            break;
          const dx3 = stackShift(state);
          if (dx3 === undefined)
            break;
          const dy3 = stackLen(state) === 1 ? stackShift(state) ?? 0 : 0;
          addCubicBezier(state, 0, dy1, dx2, dy2, dx3, dy3);
        } else {
          const dx1 = stackShift(state);
          if (dx1 === undefined)
            break;
          const dx2 = stackShift(state);
          if (dx2 === undefined)
            break;
          const dy2 = stackShift(state);
          if (dy2 === undefined)
            break;
          const dy3 = stackShift(state);
          if (dy3 === undefined)
            break;
          const dx3 = stackLen(state) === 1 ? stackShift(state) ?? 0 : 0;
          addCubicBezier(state, dx1, 0, dx2, dy2, dx3, dy3);
        }
        isVertical = !isVertical;
      }
      break;
    }
    case 24 /* rcurveline */: {
      while (stackLen(state) >= 8) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dy3 = stackShift(state);
        if (dy3 === undefined)
          break;
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);
      }
      if (stackLen(state) >= 2) {
        const dx = stackShift(state);
        if (dx === undefined)
          break;
        const dy = stackShift(state);
        if (dy === undefined)
          break;
        state.x += dx;
        state.y += dy;
        state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
      }
      break;
    }
    case 25 /* rlinecurve */: {
      while (stackLen(state) >= 8) {
        const dx = stackShift(state);
        if (dx === undefined)
          break;
        const dy = stackShift(state);
        if (dy === undefined)
          break;
        state.x += dx;
        state.y += dy;
        state.currentContour.push({ x: state.x, y: state.y, onCurve: true });
      }
      if (stackLen(state) >= 6) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dy3 = stackShift(state);
        if (dy3 === undefined)
          break;
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);
      }
      break;
    }
    case 10 /* callsubr */: {
      const index = stack.pop();
      if (index === undefined)
        break;
      const biasedIndex = index + getSubrBias(localSubrs.length);
      const subr = localSubrs[biasedIndex];
      if (subr) {
        executeCharString(state, subr, globalSubrs, localSubrs);
      }
      break;
    }
    case 29 /* callgsubr */: {
      const index = stack.pop();
      if (index === undefined)
        break;
      const biasedIndex = index + getSubrBias(globalSubrs.length);
      const subr = globalSubrs[biasedIndex];
      if (subr) {
        executeCharString(state, subr, globalSubrs, localSubrs);
      }
      break;
    }
    case 11 /* return_ */:
      break;
    case 14 /* endchar */: {
      if (stackLen(state) > 0 && !state.haveWidth) {
        const width = stackShift(state);
        if (width === undefined)
          break;
        state.width = width;
        state.haveWidth = true;
      }
      if (state.currentContour.length > 0) {
        state.contours.push(state.currentContour);
        state.currentContour = [];
      }
      stackClear(state);
      break;
    }
    case 3107 /* flex */: {
      if (stackLen(state) >= 13) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dy3 = stackShift(state);
        if (dy3 === undefined)
          break;
        const dx4 = stackShift(state);
        if (dx4 === undefined)
          break;
        const dy4 = stackShift(state);
        if (dy4 === undefined)
          break;
        const dx5 = stackShift(state);
        if (dx5 === undefined)
          break;
        const dy5 = stackShift(state);
        if (dy5 === undefined)
          break;
        const dx6 = stackShift(state);
        if (dx6 === undefined)
          break;
        const dy6 = stackShift(state);
        if (dy6 === undefined)
          break;
        stackShift(state);
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);
        addCubicBezier(state, dx4, dy4, dx5, dy5, dx6, dy6);
      }
      break;
    }
    case 3106 /* hflex */: {
      if (stackLen(state) >= 7) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dx4 = stackShift(state);
        if (dx4 === undefined)
          break;
        const dx5 = stackShift(state);
        if (dx5 === undefined)
          break;
        const dx6 = stackShift(state);
        if (dx6 === undefined)
          break;
        addCubicBezier(state, dx1, 0, dx2, dy2, dx3, 0);
        addCubicBezier(state, dx4, 0, dx5, -dy2, dx6, 0);
      }
      break;
    }
    case 3108 /* hflex1 */: {
      if (stackLen(state) >= 9) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dx4 = stackShift(state);
        if (dx4 === undefined)
          break;
        const dx5 = stackShift(state);
        if (dx5 === undefined)
          break;
        const dy5 = stackShift(state);
        if (dy5 === undefined)
          break;
        const dx6 = stackShift(state);
        if (dx6 === undefined)
          break;
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, 0);
        addCubicBezier(state, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));
      }
      break;
    }
    case 3109 /* flex1 */: {
      if (stackLen(state) >= 11) {
        const dx1 = stackShift(state);
        if (dx1 === undefined)
          break;
        const dy1 = stackShift(state);
        if (dy1 === undefined)
          break;
        const dx2 = stackShift(state);
        if (dx2 === undefined)
          break;
        const dy2 = stackShift(state);
        if (dy2 === undefined)
          break;
        const dx3 = stackShift(state);
        if (dx3 === undefined)
          break;
        const dy3 = stackShift(state);
        if (dy3 === undefined)
          break;
        const dx4 = stackShift(state);
        if (dx4 === undefined)
          break;
        const dy4 = stackShift(state);
        if (dy4 === undefined)
          break;
        const dx5 = stackShift(state);
        if (dx5 === undefined)
          break;
        const dy5 = stackShift(state);
        if (dy5 === undefined)
          break;
        const d6 = stackShift(state);
        if (d6 === undefined)
          break;
        const dx = dx1 + dx2 + dx3 + dx4 + dx5;
        const dy = dy1 + dy2 + dy3 + dy4 + dy5;
        let dx6, dy6;
        if (Math.abs(dx) > Math.abs(dy)) {
          dx6 = d6;
          dy6 = -dy;
        } else {
          dx6 = -dx;
          dy6 = d6;
        }
        addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);
        addCubicBezier(state, dx4, dy4, dx5, dy5, dx6, dy6);
      }
      break;
    }
    case 3075 /* and_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a && b ? 1 : 0);
      break;
    }
    case 3076 /* or_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a || b ? 1 : 0);
      break;
    }
    case 3077 /* not_ */: {
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a ? 0 : 1);
      break;
    }
    case 3081 /* abs_ */: {
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(Math.abs(a));
      break;
    }
    case 3082 /* add_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a + b);
      break;
    }
    case 3083 /* sub_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a - b);
      break;
    }
    case 3084 /* div_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a / b);
      break;
    }
    case 3086 /* neg_ */: {
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(-a);
      break;
    }
    case 3087 /* eq_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a === b ? 1 : 0);
      break;
    }
    case 3090 /* drop_ */: {
      stack.pop();
      break;
    }
    case 3092 /* put_ */: {
      const i = stack.pop();
      if (i === undefined)
        break;
      const val = stack.pop();
      if (val === undefined)
        break;
      state.transientArray[i] = val;
      break;
    }
    case 3093 /* get_ */: {
      const i = stack.pop();
      if (i === undefined)
        break;
      stack.push(state.transientArray[i] ?? 0);
      break;
    }
    case 3094 /* ifelse_ */: {
      const v2 = stack.pop();
      if (v2 === undefined)
        break;
      const v1 = stack.pop();
      if (v1 === undefined)
        break;
      const s2 = stack.pop();
      if (s2 === undefined)
        break;
      const s1 = stack.pop();
      if (s1 === undefined)
        break;
      stack.push(v1 <= v2 ? s1 : s2);
      break;
    }
    case 3095 /* random_ */: {
      stack.push(Math.random());
      break;
    }
    case 3096 /* mul_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(a * b);
      break;
    }
    case 3098 /* sqrt_ */: {
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(Math.sqrt(a));
      break;
    }
    case 3099 /* dup_ */: {
      const a = stack[stack.length - 1];
      if (a === undefined)
        break;
      stack.push(a);
      break;
    }
    case 3100 /* exch_ */: {
      const b = stack.pop();
      if (b === undefined)
        break;
      const a = stack.pop();
      if (a === undefined)
        break;
      stack.push(b, a);
      break;
    }
    case 3101 /* index_ */: {
      const i = stack.pop();
      if (i === undefined)
        break;
      const idx = stack.length - 1 - i;
      stack.push(stack[idx] ?? 0);
      break;
    }
    case 3102 /* roll_ */: {
      const j = stack.pop();
      if (j === undefined)
        break;
      const n = stack.pop();
      if (n === undefined)
        break;
      if (n > 0) {
        const items = stack.splice(-n);
        const shift2 = (j % n + n) % n;
        for (let i = 0;i < n; i++) {
          const item = items[(i + shift2) % n];
          if (item !== undefined) {
            stack.push(item);
          }
        }
      }
      break;
    }
    case 16 /* blend */: {
      if (!state.axisCoords || !state.vstore)
        break;
      const n = stack.pop();
      if (n === undefined)
        break;
      const regionCount = state.vstore.itemVariationData[state.vsindex]?.regionIndexCount ?? 0;
      const totalDeltaCount = n * regionCount;
      const deltas = stack.splice(-totalDeltaCount);
      const defaults = stack.splice(-n);
      for (let i = 0;i < n; i++) {
        const defaultVal = defaults[i];
        if (defaultVal === undefined)
          continue;
        let value = defaultVal;
        for (let r = 0;r < regionCount; r++) {
          const delta = deltas[i * regionCount + r];
          if (delta === undefined)
            continue;
          const scalar = computeRegionScalar(state.vstore, state.vsindex, r, state.axisCoords);
          value += delta * scalar;
        }
        stack.push(value);
      }
      break;
    }
    case 15 /* vsindex */: {
      const vsindex = stack.pop();
      if (vsindex === undefined)
        break;
      state.vsindex = vsindex;
      break;
    }
    case 3072 /* dotsection */:
      break;
  }
}
function addCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3) {
  const x0 = state.x;
  const y0 = state.y;
  const x1 = x0 + dx1;
  const y1 = y0 + dy1;
  const x2 = x1 + dx2;
  const y2 = y1 + dy2;
  const x3 = x2 + dx3;
  const y3 = y2 + dy3;
  state.currentContour.push({
    x: x1,
    y: y1,
    onCurve: false,
    cubic: true
  });
  state.currentContour.push({
    x: x2,
    y: y2,
    onCurve: false,
    cubic: true
  });
  state.currentContour.push({ x: x3, y: y3, onCurve: true });
  state.x = x3;
  state.y = y3;
}
function getSubrBias(count) {
  if (count < 1240)
    return 107;
  if (count < 33900)
    return 1131;
  return 32768;
}
function computeRegionScalar(vstore, vsindex, regionIndex, axisCoords) {
  const data = vstore.itemVariationData[vsindex];
  if (!data)
    return 0;
  const actualRegionIndex = data.regionIndexes[regionIndex];
  if (actualRegionIndex === undefined)
    return 0;
  const region = vstore.variationRegionList.regions[actualRegionIndex];
  if (!region)
    return 0;
  let scalar = 1;
  for (let i = 0;i < region.axes.length && i < axisCoords.length; i++) {
    const coords = region.axes[i];
    if (!coords)
      continue;
    const coord = axisCoords[i];
    if (coord === undefined)
      continue;
    if (coord < coords.startCoord || coord > coords.endCoord) {
      return 0;
    }
    if (coord === coords.peakCoord) {
      continue;
    }
    if (coord < coords.peakCoord) {
      scalar *= (coord - coords.startCoord) / (coords.peakCoord - coords.startCoord);
    } else {
      scalar *= (coords.endCoord - coord) / (coords.endCoord - coords.peakCoord);
    }
  }
  return scalar;
}
function getCffGlyphWidth(cff, _glyphId, fontIndex = 0) {
  const _topDict = cff.topDicts[fontIndex];
  return 0;
}

// reference/text-shaper/src/font/tables/cff2.ts
function parseCff2(reader) {
  const startOffset = reader.offset;
  const major = reader.uint8();
  const minor = reader.uint8();
  const headerSize = reader.uint8();
  const topDictLength = reader.uint16();
  reader.seek(startOffset + headerSize);
  const topDictReader = reader.slice(reader.offset - startOffset, topDictLength);
  reader.skip(topDictLength);
  const topDict = parseCff2TopDict(topDictReader);
  const globalSubrs = parseIndex2(reader);
  let charStrings = [];
  if (topDict.charStrings !== undefined) {
    reader.seek(startOffset + topDict.charStrings);
    charStrings = parseIndex2(reader);
  }
  const fdArray = [];
  if (topDict.fdArray !== undefined) {
    reader.seek(startOffset + topDict.fdArray);
    const fdDictData = parseIndex2(reader);
    for (let i = 0;i < fdDictData.length; i++) {
      const data = fdDictData[i];
      const fd = parseCff2FDDict(new Reader(data.buffer, data.byteOffset, data.byteLength));
      if (fd.privateOffset !== undefined && fd.privateSize !== undefined) {
        reader.seek(startOffset + fd.privateOffset);
        const privateReader = reader.slice(0, fd.privateSize);
        fd.private = parseCff2PrivateDict(privateReader);
        if (fd.private.subrs !== undefined) {
          reader.seek(startOffset + fd.privateOffset + fd.private.subrs);
          fd.localSubrs = parseIndex2(reader);
        }
      }
      fdArray.push(fd);
    }
  }
  let fdSelect = null;
  if (topDict.fdSelect !== undefined) {
    reader.seek(startOffset + topDict.fdSelect);
    fdSelect = parseFDSelect2(reader, charStrings.length);
  }
  let vstore = null;
  if (topDict.vstore !== undefined) {
    reader.seek(startOffset + topDict.vstore);
    vstore = parseItemVariationStore2(reader);
  }
  return {
    version: { major, minor },
    topDict,
    globalSubrs,
    charStrings,
    fdArray,
    fdSelect,
    vstore
  };
}
function parseIndex2(reader) {
  const count = reader.uint32();
  if (count === 0)
    return [];
  const offSize = reader.uint8();
  const offsets = [];
  for (let i = 0;i <= count; i++) {
    offsets.push(readOffset2(reader, offSize));
  }
  const result = [];
  for (let i = 0;i < count; i++) {
    const start = offsets[i];
    const end = offsets[i + 1];
    if (start === undefined || end === undefined)
      continue;
    const length = end - start;
    result.push(reader.bytes(length));
  }
  return result;
}
function readOffset2(reader, offSize) {
  switch (offSize) {
    case 1:
      return reader.uint8();
    case 2:
      return reader.uint16();
    case 3:
      return reader.uint24();
    case 4:
      return reader.uint32();
    default:
      throw new Error(`Invalid offset size: ${offSize}`);
  }
}
function parseDict2(reader) {
  const result = new Map;
  const operands = [];
  while (reader.remaining > 0) {
    const b0 = reader.uint8();
    if (b0 <= 21) {
      let op = b0;
      if (b0 === 12) {
        op = 3072 | reader.uint8();
      }
      result.set(op, [...operands]);
      operands.length = 0;
    } else if (b0 === 22) {
      result.set(22, [...operands]);
      operands.length = 0;
    } else if (b0 === 23) {
      result.set(23, [...operands]);
      operands.length = 0;
    } else if (b0 === 24) {
      result.set(24, [...operands]);
      operands.length = 0;
    } else if (b0 === 28) {
      operands.push(reader.int16());
    } else if (b0 === 29) {
      operands.push(reader.int32());
    } else if (b0 === 30) {
      operands.push(parseReal2(reader));
    } else if (b0 >= 32 && b0 <= 246) {
      operands.push(b0 - 139);
    } else if (b0 >= 247 && b0 <= 250) {
      const b1 = reader.uint8();
      operands.push((b0 - 247) * 256 + b1 + 108);
    } else if (b0 >= 251 && b0 <= 254) {
      const b1 = reader.uint8();
      operands.push(-(b0 - 251) * 256 - b1 - 108);
    }
  }
  return result;
}
function parseReal2(reader) {
  let str = "";
  const nibbleChars = "0123456789.EE -";
  let done = false;
  while (!done) {
    const byte = reader.uint8();
    for (let i = 0;i < 2; i++) {
      const nibble = i === 0 ? byte >> 4 : byte & 15;
      if (nibble === 15) {
        done = true;
        break;
      }
      if (nibble === 12) {
        str += "E-";
      } else {
        const char2 = nibbleChars[nibble];
        if (char2 !== undefined)
          str += char2;
      }
    }
  }
  return parseFloat(str);
}
function parseCff2TopDict(reader) {
  const dict = parseDict2(reader);
  const result = {};
  const dictEntries = [...dict];
  for (let i = 0;i < dictEntries.length; i++) {
    const [op, operands] = dictEntries[i];
    switch (op) {
      case 3079 /* FontMatrix */:
        result.fontMatrix = operands;
        break;
      case 17 /* CharStrings */:
        result.charStrings = operands[0];
        break;
      case 3108 /* FDArray */:
        result.fdArray = operands[0];
        break;
      case 3109 /* FDSelect */:
        result.fdSelect = operands[0];
        break;
      case 24 /* vstore */:
        result.vstore = operands[0];
        break;
    }
  }
  return result;
}
function parseCff2FDDict(reader) {
  const dict = parseDict2(reader);
  const result = {};
  const privateOp = dict.get(18);
  if (privateOp && privateOp.length >= 2) {
    result.privateSize = privateOp[0];
    result.privateOffset = privateOp[1];
  }
  return result;
}
function parseCff2PrivateDict(reader) {
  const dict = parseDict2(reader);
  const result = {};
  const dictEntries = [...dict];
  for (let i = 0;i < dictEntries.length; i++) {
    const [op, operands] = dictEntries[i];
    const op0 = operands[0];
    switch (op) {
      case 6 /* BlueValues */:
        result.blueValues = deltaToAbsolute2(operands);
        break;
      case 7 /* OtherBlues */:
        result.otherBlues = deltaToAbsolute2(operands);
        break;
      case 8 /* FamilyBlues */:
        result.familyBlues = deltaToAbsolute2(operands);
        break;
      case 9 /* FamilyOtherBlues */:
        result.familyOtherBlues = deltaToAbsolute2(operands);
        break;
      case 3081 /* BlueScale */:
        result.blueScale = op0;
        break;
      case 3082 /* BlueShift */:
        result.blueShift = op0;
        break;
      case 3083 /* BlueFuzz */:
        result.blueFuzz = op0;
        break;
      case 10 /* StdHW */:
        result.stdHW = op0;
        break;
      case 11 /* StdVW */:
        result.stdVW = op0;
        break;
      case 3084 /* StemSnapH */:
        result.stemSnapH = deltaToAbsolute2(operands);
        break;
      case 3085 /* StemSnapV */:
        result.stemSnapV = deltaToAbsolute2(operands);
        break;
      case 3089 /* LanguageGroup */:
        result.languageGroup = op0;
        break;
      case 3090 /* ExpansionFactor */:
        result.expansionFactor = op0;
        break;
      case 19 /* Subrs */:
        result.subrs = op0;
        break;
      case 22 /* vsindex */:
        result.vsindex = op0;
        break;
      case 23 /* blend */:
        result.blend = operands;
        break;
    }
  }
  return result;
}
function deltaToAbsolute2(deltas) {
  const result = [];
  let value = 0;
  for (let i = 0;i < deltas.length; i++) {
    const delta = deltas[i];
    value += delta;
    result.push(value);
  }
  return result;
}
function parseFDSelect2(reader, numGlyphs) {
  const format = reader.uint8();
  if (format === 0) {
    const fds = reader.uint8Array(numGlyphs);
    return {
      format,
      select: (glyphId) => fds[glyphId] ?? 0
    };
  } else if (format === 3) {
    const nRanges = reader.uint16();
    const ranges = [];
    for (let i = 0;i < nRanges; i++) {
      ranges.push({
        first: reader.uint16(),
        fd: reader.uint8()
      });
    }
    reader.uint16();
    return {
      format,
      select: (glyphId) => {
        let lo = 0;
        let hi = ranges.length - 1;
        while (lo < hi) {
          const mid = Math.ceil((lo + hi) / 2);
          const range = ranges[mid];
          if (range && range.first <= glyphId) {
            lo = mid;
          } else {
            hi = mid - 1;
          }
        }
        const foundRange = ranges[lo];
        return foundRange?.fd ?? 0;
      }
    };
  } else if (format === 4) {
    const nRanges = reader.uint32();
    const ranges = [];
    for (let i = 0;i < nRanges; i++) {
      ranges.push({
        first: reader.uint32(),
        fd: reader.uint16()
      });
    }
    reader.uint32();
    return {
      format,
      select: (glyphId) => {
        let lo = 0;
        let hi = ranges.length - 1;
        while (lo < hi) {
          const mid = Math.ceil((lo + hi) / 2);
          const range = ranges[mid];
          if (range && range.first <= glyphId) {
            lo = mid;
          } else {
            hi = mid - 1;
          }
        }
        const foundRange = ranges[lo];
        return foundRange?.fd ?? 0;
      }
    };
  }
  return { format, select: () => 0 };
}
function parseItemVariationStore2(reader) {
  const startOffset = reader.offset;
  const _length = reader.uint16();
  const format = reader.uint16();
  const variationRegionListOffset = reader.uint32();
  const itemVariationDataCount = reader.uint16();
  const itemVariationDataOffsets = [];
  for (let i = 0;i < itemVariationDataCount; i++) {
    itemVariationDataOffsets.push(reader.uint32());
  }
  reader.seek(startOffset + variationRegionListOffset);
  const variationRegionList = parseVariationRegionList(reader);
  const itemVariationData = [];
  for (let i = 0;i < itemVariationDataOffsets.length; i++) {
    const offset = itemVariationDataOffsets[i];
    reader.seek(startOffset + offset);
    itemVariationData.push(parseItemVariationData(reader));
  }
  return {
    format,
    variationRegionList,
    itemVariationData
  };
}
function parseVariationRegionList(reader) {
  const axisCount = reader.uint16();
  const regionCount = reader.uint16();
  const regions = [];
  for (let i = 0;i < regionCount; i++) {
    const axes = [];
    for (let j = 0;j < axisCount; j++) {
      axes.push({
        startCoord: reader.f2dot14(),
        peakCoord: reader.f2dot14(),
        endCoord: reader.f2dot14()
      });
    }
    regions.push({ axes });
  }
  return { axisCount, regionCount, regions };
}
function parseItemVariationData(reader) {
  const itemCount = reader.uint16();
  const wordDeltaCount = reader.uint16();
  const regionIndexCount = wordDeltaCount & 32767;
  const longWords = (wordDeltaCount & 32768) !== 0;
  const regionIndexes = [];
  for (let i = 0;i < regionIndexCount; i++) {
    regionIndexes.push(reader.uint16());
  }
  const deltaSets = [];
  for (let i = 0;i < itemCount; i++) {
    const deltas = [];
    for (let j = 0;j < regionIndexCount; j++) {
      if (longWords) {
        deltas.push(reader.int32());
      } else {
        deltas.push(reader.int16());
      }
    }
    deltaSets.push(deltas);
  }
  return {
    itemCount,
    regionIndexCount,
    regionIndexes,
    deltaSets
  };
}
function calculateVariationDelta(vstore, outerIndex, innerIndex, normalizedCoords) {
  const itemData = vstore.itemVariationData[outerIndex];
  if (!itemData)
    return 0;
  const deltaSet = itemData.deltaSets[innerIndex];
  if (!deltaSet)
    return 0;
  let delta = 0;
  for (let i = 0;i < itemData.regionIndexCount; i++) {
    const regionIndex = itemData.regionIndexes[i];
    if (regionIndex === undefined)
      continue;
    const region = vstore.variationRegionList.regions[regionIndex];
    if (!region)
      continue;
    let scalar = 1;
    for (let axis = 0;axis < region.axes.length; axis++) {
      const coords = region.axes[axis];
      const coord = normalizedCoords[axis] ?? 0;
      if (coords.peakCoord === 0) {
        continue;
      }
      if (coord < coords.startCoord || coord > coords.endCoord) {
        scalar = 0;
        break;
      }
      if (coord === coords.peakCoord) {
        continue;
      }
      if (coord < coords.peakCoord) {
        scalar *= (coord - coords.startCoord) / (coords.peakCoord - coords.startCoord);
      } else {
        scalar *= (coords.endCoord - coord) / (coords.endCoord - coords.peakCoord);
      }
    }
    delta += scalar * (deltaSet[i] ?? 0);
  }
  return Math.round(delta);
}

// reference/text-shaper/src/font/tables/cmap.ts
function parseCmap(reader, tableLength) {
  const _tableStart = reader.offset;
  const version = reader.uint16();
  const numTables = reader.uint16();
  const encodingRecords = [];
  for (let i = 0;i < numTables; i++) {
    encodingRecords.push({
      platformId: reader.uint16(),
      encodingId: reader.uint16(),
      offset: reader.uint32()
    });
  }
  const subtables = new Map;
  const parsedOffsets = new Set;
  for (let i = 0;i < encodingRecords.length; i++) {
    const record = encodingRecords[i];
    if (parsedOffsets.has(record.offset)) {
      const key = `${record.platformId}-${record.encodingId}`;
      const subtablesEntries = [...subtables.entries()];
      for (let j = 0;j < subtablesEntries.length; j++) {
        const [existingKey, subtable2] = subtablesEntries[j];
        const parts = existingKey.split("@");
        const existingOffset = parts[0];
        if (existingOffset && Number.parseInt(existingOffset, 10) === record.offset) {
          subtables.set(key, subtable2);
          break;
        }
      }
      continue;
    }
    parsedOffsets.add(record.offset);
    const subtableReader = reader.slice(record.offset, tableLength - record.offset);
    const subtable = parseCmapSubtable(subtableReader);
    if (subtable) {
      const key = `${record.platformId}-${record.encodingId}`;
      subtables.set(key, subtable);
    }
  }
  const preferredKeys = ["3-10", "0-4", "3-1", "0-3", "0-6", "1-0"];
  let bestSubtable = null;
  for (let i = 0;i < preferredKeys.length; i++) {
    const key = preferredKeys[i];
    const subtable = subtables.get(key);
    if (subtable && subtable.format !== 14) {
      bestSubtable = subtable;
      break;
    }
  }
  if (!bestSubtable) {
    const subtablesValues = [...subtables.values()];
    for (let i = 0;i < subtablesValues.length; i++) {
      const subtable = subtablesValues[i];
      if (subtable.format !== 14) {
        bestSubtable = subtable;
        break;
      }
    }
  }
  return {
    version,
    numTables,
    encodingRecords,
    subtables,
    bestSubtable
  };
}
function parseCmapSubtable(reader) {
  const format = reader.uint16();
  switch (format) {
    case 0:
      return parseCmapFormat0(reader);
    case 4:
      return parseCmapFormat4(reader);
    case 12:
      return parseCmapFormat12(reader);
    case 14:
      return parseCmapFormat14(reader);
    default:
      return null;
  }
}
function parseCmapFormat0(reader) {
  const _length = reader.uint16();
  const _language = reader.uint16();
  const glyphIdArray = reader.uint8Array(256);
  return {
    format: 0,
    glyphIdArray,
    lookup(codepoint) {
      if (codepoint >= 0 && codepoint < 256) {
        return glyphIdArray[codepoint];
      }
      return;
    }
  };
}
function parseCmapFormat4(reader) {
  const _length = reader.uint16();
  const _language = reader.uint16();
  const segCountX2 = reader.uint16();
  const segCount = segCountX2 / 2;
  reader.skip(6);
  const endCodes = reader.uint16Array(segCount);
  reader.skip(2);
  const startCodes = reader.uint16Array(segCount);
  const idDeltas = reader.int16Array(segCount);
  const _idRangeOffsetPos = reader.offset;
  const idRangeOffsets = reader.uint16Array(segCount);
  const remainingBytes = reader.remaining;
  const glyphIdCount = remainingBytes / 2;
  const glyphIdArray = reader.uint16Array(glyphIdCount);
  const binarySearchLookup = (codepoint) => {
    let low = 0;
    let high = segCount - 1;
    while (low <= high) {
      const mid = low + high >>> 1;
      const endCode = endCodes[mid];
      if (codepoint > endCode) {
        low = mid + 1;
      } else {
        const startCode = startCodes[mid];
        if (codepoint < startCode) {
          high = mid - 1;
        } else {
          const idRangeOffset = idRangeOffsets[mid];
          const idDelta = idDeltas[mid];
          if (idRangeOffset === 0) {
            return codepoint + idDelta & 65535;
          }
          const glyphIdIndex = idRangeOffset / 2 - (segCount - mid) + (codepoint - startCode);
          const glyphId = glyphIdArray[glyphIdIndex];
          if (glyphId === undefined || glyphId === 0) {
            return 0;
          }
          return glyphId + idDelta & 65535;
        }
      }
    }
    return;
  };
  const asciiCache = new Uint16Array(256);
  for (let cp = 0;cp < 256; cp++) {
    const gid = binarySearchLookup(cp);
    asciiCache[cp] = gid !== undefined ? gid + 1 : 0;
  }
  return {
    format: 4,
    segCount,
    endCodes,
    startCodes,
    idDeltas,
    idRangeOffsets,
    glyphIdArray,
    lookup(codepoint) {
      if (codepoint < 256) {
        const cached = asciiCache[codepoint];
        return cached === 0 ? undefined : cached - 1;
      }
      if (codepoint > 65535)
        return;
      return binarySearchLookup(codepoint);
    }
  };
}
function parseCmapFormat12(reader) {
  reader.skip(2);
  const _length = reader.uint32();
  const _language = reader.uint32();
  const numGroups = reader.uint32();
  const groups = new Array(numGroups);
  for (let i = 0;i < numGroups; i++) {
    groups[i] = {
      startCharCode: reader.uint32(),
      endCharCode: reader.uint32(),
      startGlyphId: reader.uint32()
    };
  }
  const binarySearchLookup = (codepoint) => {
    let low = 0;
    let high = groups.length - 1;
    while (low <= high) {
      const mid = low + high >>> 1;
      const group = groups[mid];
      if (!group)
        break;
      if (codepoint > group.endCharCode) {
        low = mid + 1;
      } else if (codepoint < group.startCharCode) {
        high = mid - 1;
      } else {
        return group.startGlyphId + (codepoint - group.startCharCode);
      }
    }
    return;
  };
  const asciiCache = new Uint16Array(128);
  for (let cp = 0;cp < 128; cp++) {
    const gid = binarySearchLookup(cp);
    asciiCache[cp] = gid !== undefined ? gid + 1 : 0;
  }
  return {
    format: 12,
    groups,
    lookup(codepoint) {
      if (codepoint < 128) {
        const cached = asciiCache[codepoint];
        return cached === 0 ? undefined : cached - 1;
      }
      return binarySearchLookup(codepoint);
    }
  };
}
function parseCmapFormat14(reader) {
  const subtableStart = reader.offset - 2;
  const _length = reader.uint32();
  const numVarSelectorRecords = reader.uint32();
  const rawRecords = [];
  for (let i = 0;i < numVarSelectorRecords; i++) {
    rawRecords.push({
      varSelector: reader.uint24(),
      defaultUVSOffset: reader.uint32(),
      nonDefaultUVSOffset: reader.uint32()
    });
  }
  const varSelectorRecords = [];
  for (let i = 0;i < rawRecords.length; i++) {
    const raw = rawRecords[i];
    let defaultUVS = null;
    let nonDefaultUVS = null;
    if (raw.defaultUVSOffset !== 0) {
      const uvsReader = reader.sliceFrom(subtableStart + raw.defaultUVSOffset);
      const numUnicodeValueRanges = uvsReader.uint32();
      defaultUVS = [];
      for (let j = 0;j < numUnicodeValueRanges; j++) {
        defaultUVS.push({
          startUnicodeValue: uvsReader.uint24(),
          additionalCount: uvsReader.uint8()
        });
      }
    }
    if (raw.nonDefaultUVSOffset !== 0) {
      const uvsReader = reader.sliceFrom(subtableStart + raw.nonDefaultUVSOffset);
      const numUVSMappings = uvsReader.uint32();
      nonDefaultUVS = [];
      for (let j = 0;j < numUVSMappings; j++) {
        nonDefaultUVS.push({
          unicodeValue: uvsReader.uint24(),
          glyphId: uvsReader.uint16()
        });
      }
    }
    varSelectorRecords.push({
      varSelector: raw.varSelector,
      defaultUVS,
      nonDefaultUVS
    });
  }
  return {
    format: 14,
    varSelectorRecords,
    lookup(_codepoint) {
      return;
    },
    lookupVariation(codepoint, variationSelector) {
      let low = 0;
      let high = varSelectorRecords.length - 1;
      let record = null;
      while (low <= high) {
        const mid = low + high >>> 1;
        const rec = varSelectorRecords[mid];
        if (!rec)
          break;
        if (variationSelector > rec.varSelector) {
          low = mid + 1;
        } else if (variationSelector < rec.varSelector) {
          high = mid - 1;
        } else {
          record = rec;
          break;
        }
      }
      if (!record) {
        return;
      }
      if (record.nonDefaultUVS) {
        let lo = 0;
        let hi = record.nonDefaultUVS.length - 1;
        while (lo <= hi) {
          const mid = lo + hi >>> 1;
          const mapping = record.nonDefaultUVS[mid];
          if (!mapping)
            break;
          if (codepoint > mapping.unicodeValue) {
            lo = mid + 1;
          } else if (codepoint < mapping.unicodeValue) {
            hi = mid - 1;
          } else {
            return mapping.glyphId;
          }
        }
      }
      if (record.defaultUVS) {
        for (let i = 0;i < record.defaultUVS.length; i++) {
          const range = record.defaultUVS[i];
          const end = range.startUnicodeValue + range.additionalCount;
          if (codepoint >= range.startUnicodeValue && codepoint <= end) {
            return "default";
          }
        }
      }
      return;
    }
  };
}
function getGlyphId(cmap, codepoint) {
  return cmap.bestSubtable?.lookup(codepoint) ?? 0;
}

// reference/text-shaper/src/font/tables/colr.ts
var PaintFormat;
((PaintFormat2) => {
  PaintFormat2[PaintFormat2["ColrLayers"] = 1] = "ColrLayers";
  PaintFormat2[PaintFormat2["Solid"] = 2] = "Solid";
  PaintFormat2[PaintFormat2["VarSolid"] = 3] = "VarSolid";
  PaintFormat2[PaintFormat2["LinearGradient"] = 4] = "LinearGradient";
  PaintFormat2[PaintFormat2["VarLinearGradient"] = 5] = "VarLinearGradient";
  PaintFormat2[PaintFormat2["RadialGradient"] = 6] = "RadialGradient";
  PaintFormat2[PaintFormat2["VarRadialGradient"] = 7] = "VarRadialGradient";
  PaintFormat2[PaintFormat2["SweepGradient"] = 8] = "SweepGradient";
  PaintFormat2[PaintFormat2["VarSweepGradient"] = 9] = "VarSweepGradient";
  PaintFormat2[PaintFormat2["Glyph"] = 10] = "Glyph";
  PaintFormat2[PaintFormat2["ColrGlyph"] = 11] = "ColrGlyph";
  PaintFormat2[PaintFormat2["Transform"] = 12] = "Transform";
  PaintFormat2[PaintFormat2["VarTransform"] = 13] = "VarTransform";
  PaintFormat2[PaintFormat2["Translate"] = 14] = "Translate";
  PaintFormat2[PaintFormat2["VarTranslate"] = 15] = "VarTranslate";
  PaintFormat2[PaintFormat2["Scale"] = 16] = "Scale";
  PaintFormat2[PaintFormat2["VarScale"] = 17] = "VarScale";
  PaintFormat2[PaintFormat2["ScaleAroundCenter"] = 18] = "ScaleAroundCenter";
  PaintFormat2[PaintFormat2["VarScaleAroundCenter"] = 19] = "VarScaleAroundCenter";
  PaintFormat2[PaintFormat2["ScaleUniform"] = 20] = "ScaleUniform";
  PaintFormat2[PaintFormat2["VarScaleUniform"] = 21] = "VarScaleUniform";
  PaintFormat2[PaintFormat2["ScaleUniformAroundCenter"] = 22] = "ScaleUniformAroundCenter";
  PaintFormat2[PaintFormat2["VarScaleUniformAroundCenter"] = 23] = "VarScaleUniformAroundCenter";
  PaintFormat2[PaintFormat2["Rotate"] = 24] = "Rotate";
  PaintFormat2[PaintFormat2["VarRotate"] = 25] = "VarRotate";
  PaintFormat2[PaintFormat2["RotateAroundCenter"] = 26] = "RotateAroundCenter";
  PaintFormat2[PaintFormat2["VarRotateAroundCenter"] = 27] = "VarRotateAroundCenter";
  PaintFormat2[PaintFormat2["Skew"] = 28] = "Skew";
  PaintFormat2[PaintFormat2["VarSkew"] = 29] = "VarSkew";
  PaintFormat2[PaintFormat2["SkewAroundCenter"] = 30] = "SkewAroundCenter";
  PaintFormat2[PaintFormat2["VarSkewAroundCenter"] = 31] = "VarSkewAroundCenter";
  PaintFormat2[PaintFormat2["Composite"] = 32] = "Composite";
})(PaintFormat ||= {});
var Extend;
((Extend2) => {
  Extend2[Extend2["Pad"] = 0] = "Pad";
  Extend2[Extend2["Repeat"] = 1] = "Repeat";
  Extend2[Extend2["Reflect"] = 2] = "Reflect";
})(Extend ||= {});
var CompositeMode;
((CompositeMode2) => {
  CompositeMode2[CompositeMode2["Clear"] = 0] = "Clear";
  CompositeMode2[CompositeMode2["Src"] = 1] = "Src";
  CompositeMode2[CompositeMode2["Dest"] = 2] = "Dest";
  CompositeMode2[CompositeMode2["SrcOver"] = 3] = "SrcOver";
  CompositeMode2[CompositeMode2["DestOver"] = 4] = "DestOver";
  CompositeMode2[CompositeMode2["SrcIn"] = 5] = "SrcIn";
  CompositeMode2[CompositeMode2["DestIn"] = 6] = "DestIn";
  CompositeMode2[CompositeMode2["SrcOut"] = 7] = "SrcOut";
  CompositeMode2[CompositeMode2["DestOut"] = 8] = "DestOut";
  CompositeMode2[CompositeMode2["SrcAtop"] = 9] = "SrcAtop";
  CompositeMode2[CompositeMode2["DestAtop"] = 10] = "DestAtop";
  CompositeMode2[CompositeMode2["Xor"] = 11] = "Xor";
  CompositeMode2[CompositeMode2["Plus"] = 12] = "Plus";
  CompositeMode2[CompositeMode2["Screen"] = 13] = "Screen";
  CompositeMode2[CompositeMode2["Overlay"] = 14] = "Overlay";
  CompositeMode2[CompositeMode2["Darken"] = 15] = "Darken";
  CompositeMode2[CompositeMode2["Lighten"] = 16] = "Lighten";
  CompositeMode2[CompositeMode2["ColorDodge"] = 17] = "ColorDodge";
  CompositeMode2[CompositeMode2["ColorBurn"] = 18] = "ColorBurn";
  CompositeMode2[CompositeMode2["HardLight"] = 19] = "HardLight";
  CompositeMode2[CompositeMode2["SoftLight"] = 20] = "SoftLight";
  CompositeMode2[CompositeMode2["Difference"] = 21] = "Difference";
  CompositeMode2[CompositeMode2["Exclusion"] = 22] = "Exclusion";
  CompositeMode2[CompositeMode2["Multiply"] = 23] = "Multiply";
  CompositeMode2[CompositeMode2["Hue"] = 24] = "Hue";
  CompositeMode2[CompositeMode2["Saturation"] = 25] = "Saturation";
  CompositeMode2[CompositeMode2["Color"] = 26] = "Color";
  CompositeMode2[CompositeMode2["Luminosity"] = 27] = "Luminosity";
})(CompositeMode ||= {});
function parseColr(reader) {
  const startOffset = reader.offset;
  const version = reader.uint16();
  const numBaseGlyphRecords = reader.uint16();
  const baseGlyphRecordsOffset = reader.uint32();
  const layerRecordsOffset = reader.uint32();
  const numLayerRecords = reader.uint16();
  const baseGlyphRecords = [];
  if (baseGlyphRecordsOffset !== 0 && numBaseGlyphRecords > 0) {
    reader.seek(startOffset + baseGlyphRecordsOffset);
    for (let i = 0;i < numBaseGlyphRecords; i++) {
      baseGlyphRecords.push({
        glyphId: reader.uint16(),
        firstLayerIndex: reader.uint16(),
        numLayers: reader.uint16()
      });
    }
  }
  const layerRecords = [];
  if (layerRecordsOffset !== 0 && numLayerRecords > 0) {
    reader.seek(startOffset + layerRecordsOffset);
    for (let i = 0;i < numLayerRecords; i++) {
      layerRecords.push({
        glyphId: reader.uint16(),
        paletteIndex: reader.uint16()
      });
    }
  }
  const result = {
    version,
    baseGlyphRecords,
    layerRecords
  };
  if (version >= 1) {
    reader.seek(startOffset + 14);
    const baseGlyphListOffset = reader.uint32();
    const layerListOffset = reader.uint32();
    const clipListOffset = reader.uint32();
    const varIdxMapOffset = reader.uint32();
    const itemVariationStoreOffset = reader.uint32();
    if (baseGlyphListOffset !== 0) {
      const baseGlyphListStart = startOffset + baseGlyphListOffset;
      reader.seek(baseGlyphListStart);
      const numRecords = reader.uint32();
      result.baseGlyphPaintRecords = [];
      for (let i = 0;i < numRecords; i++) {
        const glyphId = reader.uint16();
        const paintOffset = reader.uint32();
        const savedPos = reader.offset;
        reader.seek(baseGlyphListStart + paintOffset);
        const paint = parsePaint(reader, startOffset);
        reader.seek(savedPos);
        result.baseGlyphPaintRecords.push({ glyphId, paint });
      }
    }
    if (layerListOffset !== 0) {
      reader.seek(startOffset + layerListOffset);
      const numLayers = reader.uint32();
      const paintOffsets = [];
      for (let i = 0;i < numLayers; i++) {
        paintOffsets.push(reader.uint32());
      }
      result.layerList = [];
      for (let i = 0;i < paintOffsets.length; i++) {
        const offset = paintOffsets[i];
        reader.seek(startOffset + layerListOffset + offset);
        result.layerList.push(parsePaint(reader, startOffset));
      }
    }
    if (clipListOffset !== 0) {
      reader.seek(startOffset + clipListOffset);
      result.clipList = parseClipList(reader, startOffset);
    }
    if (varIdxMapOffset !== 0) {
      reader.seek(startOffset + varIdxMapOffset);
      result.varIdxMap = parseDeltaSetIndexMap2(reader);
    }
    if (itemVariationStoreOffset !== 0) {
      reader.seek(startOffset + itemVariationStoreOffset);
      result.itemVariationStore = parseItemVariationStore3(reader);
    }
  }
  return result;
}
function parsePaint(reader, tableOffset) {
  const paintStart = reader.offset;
  const format = reader.uint8();
  switch (format) {
    case 1 /* ColrLayers */:
      return {
        format,
        numLayers: reader.uint8(),
        firstLayerIndex: reader.uint32()
      };
    case 2 /* Solid */:
      return {
        format,
        paletteIndex: reader.uint16(),
        alpha: reader.f2dot14()
      };
    case 3 /* VarSolid */:
      return {
        format,
        paletteIndex: reader.uint16(),
        alpha: reader.f2dot14(),
        varIndexBase: reader.uint32()
      };
    case 4 /* LinearGradient */:
    case 5 /* VarLinearGradient */: {
      const colorLineOffset = reader.uint24();
      const x0 = reader.fword();
      const y0 = reader.fword();
      const x1 = reader.fword();
      const y1 = reader.fword();
      const x2 = reader.fword();
      const y2 = reader.fword();
      const savedPos = reader.offset;
      reader.seek(paintStart + colorLineOffset);
      const colorLine = parseColorLine(reader);
      reader.seek(savedPos);
      return { format, colorLine, x0, y0, x1, y1, x2, y2 };
    }
    case 6 /* RadialGradient */:
    case 7 /* VarRadialGradient */: {
      const colorLineOffset = reader.uint24();
      const x0 = reader.fword();
      const y0 = reader.fword();
      const radius0 = reader.ufword();
      const x1 = reader.fword();
      const y1 = reader.fword();
      const radius1 = reader.ufword();
      const savedPos = reader.offset;
      reader.seek(paintStart + colorLineOffset);
      const colorLine = parseColorLine(reader);
      reader.seek(savedPos);
      return { format, colorLine, x0, y0, radius0, x1, y1, radius1 };
    }
    case 8 /* SweepGradient */:
    case 9 /* VarSweepGradient */: {
      const colorLineOffset = reader.uint24();
      const centerX = reader.fword();
      const centerY = reader.fword();
      const startAngle = reader.f2dot14();
      const endAngle = reader.f2dot14();
      const savedPos = reader.offset;
      reader.seek(paintStart + colorLineOffset);
      const colorLine = parseColorLine(reader);
      reader.seek(savedPos);
      return { format, colorLine, centerX, centerY, startAngle, endAngle };
    }
    case 10 /* Glyph */: {
      const paintOffset = reader.uint24();
      const glyphId = reader.uint16();
      const savedPos = reader.offset;
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      reader.seek(savedPos);
      return { format, paint, glyphId };
    }
    case 11 /* ColrGlyph */:
      return {
        format,
        glyphId: reader.uint16()
      };
    case 12 /* Transform */:
    case 13 /* VarTransform */: {
      const paintOffset = reader.uint24();
      const transformOffset = reader.uint24();
      reader.seek(paintStart + transformOffset);
      const transform = {
        xx: reader.fixed(),
        yx: reader.fixed(),
        xy: reader.fixed(),
        yy: reader.fixed(),
        dx: reader.fixed(),
        dy: reader.fixed()
      };
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, transform };
    }
    case 14 /* Translate */:
    case 15 /* VarTranslate */: {
      const paintOffset = reader.uint24();
      const dx = reader.fword();
      const dy = reader.fword();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, dx, dy };
    }
    case 16 /* Scale */:
    case 17 /* VarScale */: {
      const paintOffset = reader.uint24();
      const scaleX = reader.f2dot14();
      const scaleY = reader.f2dot14();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, scaleX, scaleY };
    }
    case 18 /* ScaleAroundCenter */:
    case 19 /* VarScaleAroundCenter */: {
      const paintOffset = reader.uint24();
      const scaleX = reader.f2dot14();
      const scaleY = reader.f2dot14();
      const centerX = reader.fword();
      const centerY = reader.fword();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, scaleX, scaleY, centerX, centerY };
    }
    case 20 /* ScaleUniform */:
    case 21 /* VarScaleUniform */: {
      const paintOffset = reader.uint24();
      const scale2 = reader.f2dot14();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, scaleX: scale2, scaleY: scale2 };
    }
    case 22 /* ScaleUniformAroundCenter */:
    case 23 /* VarScaleUniformAroundCenter */: {
      const paintOffset = reader.uint24();
      const scale2 = reader.f2dot14();
      const centerX = reader.fword();
      const centerY = reader.fword();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, scaleX: scale2, scaleY: scale2, centerX, centerY };
    }
    case 24 /* Rotate */:
    case 25 /* VarRotate */: {
      const paintOffset = reader.uint24();
      const angle = reader.f2dot14();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, angle };
    }
    case 26 /* RotateAroundCenter */:
    case 27 /* VarRotateAroundCenter */: {
      const paintOffset = reader.uint24();
      const angle = reader.f2dot14();
      const centerX = reader.fword();
      const centerY = reader.fword();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, angle, centerX, centerY };
    }
    case 28 /* Skew */:
    case 29 /* VarSkew */: {
      const paintOffset = reader.uint24();
      const xSkewAngle = reader.f2dot14();
      const ySkewAngle = reader.f2dot14();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, xSkewAngle, ySkewAngle };
    }
    case 30 /* SkewAroundCenter */:
    case 31 /* VarSkewAroundCenter */: {
      const paintOffset = reader.uint24();
      const xSkewAngle = reader.f2dot14();
      const ySkewAngle = reader.f2dot14();
      const centerX = reader.fword();
      const centerY = reader.fword();
      reader.seek(paintStart + paintOffset);
      const paint = parsePaint(reader, tableOffset);
      return { format, paint, xSkewAngle, ySkewAngle, centerX, centerY };
    }
    case 32 /* Composite */: {
      const sourcePaintOffset = reader.uint24();
      const compositeMode = reader.uint8();
      const backdropPaintOffset = reader.uint24();
      reader.seek(paintStart + sourcePaintOffset);
      const sourcePaint = parsePaint(reader, tableOffset);
      reader.seek(paintStart + backdropPaintOffset);
      const backdropPaint = parsePaint(reader, tableOffset);
      return { format, sourcePaint, compositeMode, backdropPaint };
    }
    default:
      throw new Error(`Unknown paint format: ${format}`);
  }
}
function parseColorLine(reader) {
  const extend = reader.uint8();
  const numStops = reader.uint16();
  const colorStops = [];
  for (let i = 0;i < numStops; i++) {
    colorStops.push({
      stopOffset: reader.f2dot14(),
      paletteIndex: reader.uint16(),
      alpha: reader.f2dot14()
    });
  }
  return { extend, colorStops };
}
function parseClipList(reader, _tableOffset) {
  const clipListStart = reader.offset;
  const _format = reader.uint8();
  const numClips = reader.uint32();
  const records = [];
  for (let i = 0;i < numClips; i++) {
    const startGlyphId = reader.uint16();
    const endGlyphId = reader.uint16();
    const clipBoxOffset = reader.uint24();
    const savedPos = reader.offset;
    reader.seek(clipListStart + clipBoxOffset);
    const boxFormat = reader.uint8();
    const clipBox = {
      format: boxFormat,
      xMin: reader.fword(),
      yMin: reader.fword(),
      xMax: reader.fword(),
      yMax: reader.fword()
    };
    if (boxFormat === 2) {
      clipBox.varIndexBase = reader.uint32();
    }
    reader.seek(savedPos);
    records.push({ startGlyphId, endGlyphId, clipBox });
  }
  return records;
}
function getColorLayers(colr, glyphId) {
  const records = colr.baseGlyphRecords;
  let lo = 0;
  let hi = records.length - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const record = records[mid];
    if (!record)
      break;
    if (record.glyphId === glyphId) {
      const layers = [];
      for (let i = 0;i < record.numLayers; i++) {
        const layer = colr.layerRecords[record.firstLayerIndex + i];
        if (layer)
          layers.push(layer);
      }
      return layers;
    } else if (record.glyphId < glyphId) {
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }
  return null;
}
function getColorPaint(colr, glyphId) {
  if (!colr.baseGlyphPaintRecords)
    return null;
  const records = colr.baseGlyphPaintRecords;
  let lo = 0;
  let hi = records.length - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const record = records[mid];
    if (!record)
      break;
    if (record.glyphId === glyphId) {
      return record.paint;
    } else if (record.glyphId < glyphId) {
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }
  return null;
}
function hasColorGlyph(colr, glyphId) {
  return getColorLayers(colr, glyphId) !== null || getColorPaint(colr, glyphId) !== null;
}
function parseDeltaSetIndexMap2(reader) {
  const format = reader.uint8();
  const entryFormat = reader.uint8();
  const mapCount = format === 0 ? reader.uint16() : reader.uint32();
  const innerBits = (entryFormat & 15) + 1;
  const outerBits = (entryFormat >> 4 & 15) + 1;
  const entrySize = Math.ceil((innerBits + outerBits) / 8);
  const result = [];
  for (let i = 0;i < mapCount; i++) {
    let entry = 0;
    for (let b = 0;b < entrySize; b++) {
      entry = entry << 8 | reader.uint8();
    }
    const innerMask = (1 << innerBits) - 1;
    const inner = entry & innerMask;
    const outer = entry >> innerBits;
    result.push(outer << 16 | inner);
  }
  return result;
}
function parseItemVariationStore3(reader) {
  const storeOffset = reader.offset;
  const format = reader.uint16();
  const variationRegionListOffset = reader.uint32();
  const itemVariationDataCount = reader.uint16();
  const itemVariationDataOffsets = [];
  for (let i = 0;i < itemVariationDataCount; i++) {
    itemVariationDataOffsets.push(reader.uint32());
  }
  reader.seek(storeOffset + variationRegionListOffset);
  const axisCount = reader.uint16();
  const regionCount = reader.uint16();
  const variationRegions = [];
  for (let i = 0;i < regionCount; i++) {
    const regionAxes = [];
    for (let j = 0;j < axisCount; j++) {
      regionAxes.push({
        startCoord: reader.f2dot14(),
        peakCoord: reader.f2dot14(),
        endCoord: reader.f2dot14()
      });
    }
    variationRegions.push({ regionAxes });
  }
  const itemVariationData = [];
  for (let i = 0;i < itemVariationDataOffsets.length; i++) {
    const offset = itemVariationDataOffsets[i];
    reader.seek(storeOffset + offset);
    const itemCount = reader.uint16();
    const wordDeltaCount = reader.uint16();
    const regionIndexCount = reader.uint16();
    const regionIndexes = [];
    for (let i2 = 0;i2 < regionIndexCount; i2++) {
      regionIndexes.push(reader.uint16());
    }
    const longWords = (wordDeltaCount & 32768) !== 0;
    const wordCount = wordDeltaCount & 32767;
    const deltaSets = [];
    for (let i2 = 0;i2 < itemCount; i2++) {
      const deltas = [];
      for (let j = 0;j < regionIndexCount; j++) {
        if (j < wordCount) {
          deltas.push(longWords ? reader.int32() : reader.int16());
        } else {
          deltas.push(longWords ? reader.int16() : reader.int8());
        }
      }
      deltaSets.push(deltas);
    }
    itemVariationData.push({
      itemCount,
      wordDeltaCount,
      regionIndexCount,
      regionIndexes,
      deltaSets
    });
  }
  return {
    format,
    variationRegionListOffset,
    itemVariationDataCount,
    itemVariationDataOffsets,
    variationRegions,
    itemVariationData
  };
}
function getClipBox(colr, glyphId) {
  if (!colr.clipList)
    return null;
  for (let i = 0;i < colr.clipList.length; i++) {
    const record = colr.clipList[i];
    if (glyphId >= record.startGlyphId && glyphId <= record.endGlyphId) {
      return record.clipBox;
    }
  }
  return null;
}
function getColorVariationDelta(colr, varIndex, coords) {
  if (!colr.itemVariationStore || !colr.varIdxMap)
    return 0;
  const mappedIndex = colr.varIdxMap[varIndex];
  if (mappedIndex === undefined)
    return 0;
  const outer = mappedIndex >> 16;
  const inner = mappedIndex & 65535;
  const store = colr.itemVariationStore;
  const data = store.itemVariationData[outer];
  if (!data)
    return 0;
  const deltas = data.deltaSets[inner];
  if (!deltas)
    return 0;
  let result = 0;
  for (let i = 0;i < data.regionIndexCount; i++) {
    const regionIndex = data.regionIndexes[i];
    if (regionIndex === undefined)
      continue;
    const region = store.variationRegions[regionIndex];
    if (!region)
      continue;
    let scalar = 1;
    for (let j = 0;j < region.regionAxes.length && j < coords.length; j++) {
      const axis = region.regionAxes[j];
      const coord = coords[j];
      if (axis === undefined || coord === undefined)
        continue;
      scalar *= calculateAxisScalar(coord, axis.startCoord, axis.peakCoord, axis.endCoord);
      if (scalar === 0)
        break;
    }
    const delta = deltas[i];
    if (delta !== undefined) {
      result += delta * scalar;
    }
  }
  return result;
}
function calculateAxisScalar(coord, start, peak, end) {
  if (start === 0 && peak === 0 && end === 0)
    return 1;
  if (coord === peak)
    return 1;
  if (coord < start || coord > end)
    return 0;
  if (coord < peak) {
    if (start === peak)
      return 1;
    return (coord - start) / (peak - start);
  } else {
    if (peak === end)
      return 1;
    return (end - coord) / (end - peak);
  }
}
function isColrV1(colr) {
  return colr.version >= 1 && colr.baseGlyphPaintRecords !== undefined;
}
function getLayerPaint(colr, index) {
  return colr.layerList?.[index] ?? null;
}

// reference/text-shaper/src/font/tables/cpal.ts
var PaletteType;
((PaletteType2) => {
  PaletteType2[PaletteType2["UsableWithLightBackground"] = 1] = "UsableWithLightBackground";
  PaletteType2[PaletteType2["UsableWithDarkBackground"] = 2] = "UsableWithDarkBackground";
})(PaletteType ||= {});
function parseCpal(reader) {
  const startOffset = reader.offset;
  const version = reader.uint16();
  const numPaletteEntries = reader.uint16();
  const numPalettes = reader.uint16();
  const numColorRecords = reader.uint16();
  const colorRecordsArrayOffset = reader.uint32();
  const colorRecordIndices = [];
  for (let i = 0;i < numPalettes; i++) {
    colorRecordIndices.push(reader.uint16());
  }
  reader.seek(startOffset + colorRecordsArrayOffset);
  const colorRecords = [];
  for (let i = 0;i < numColorRecords; i++) {
    colorRecords.push({
      blue: reader.uint8(),
      green: reader.uint8(),
      red: reader.uint8(),
      alpha: reader.uint8()
    });
  }
  const palettes = [];
  for (let i = 0;i < numPalettes; i++) {
    const startIndex = colorRecordIndices[i];
    if (startIndex === undefined)
      continue;
    const colors = [];
    for (let j = 0;j < numPaletteEntries; j++) {
      const color = colorRecords[startIndex + j];
      if (color)
        colors.push(color);
    }
    palettes.push({ colors });
  }
  let paletteTypes;
  let paletteLabels;
  let paletteEntryLabels;
  if (version >= 1) {
    reader.seek(startOffset + 12 + numPalettes * 2);
    const paletteTypesArrayOffset = reader.uint32();
    const paletteLabelsArrayOffset = reader.uint32();
    const paletteEntryLabelsArrayOffset = reader.uint32();
    if (paletteTypesArrayOffset !== 0) {
      reader.seek(startOffset + paletteTypesArrayOffset);
      paletteTypes = [];
      for (let i = 0;i < numPalettes; i++) {
        paletteTypes.push(reader.uint32());
      }
    }
    if (paletteLabelsArrayOffset !== 0) {
      reader.seek(startOffset + paletteLabelsArrayOffset);
      paletteLabels = [];
      for (let i = 0;i < numPalettes; i++) {
        paletteLabels.push(reader.uint16());
      }
    }
    if (paletteEntryLabelsArrayOffset !== 0) {
      reader.seek(startOffset + paletteEntryLabelsArrayOffset);
      paletteEntryLabels = [];
      for (let i = 0;i < numPaletteEntries; i++) {
        paletteEntryLabels.push(reader.uint16());
      }
    }
  }
  return {
    version,
    numPalettes,
    numPaletteEntries,
    palettes,
    paletteTypes,
    paletteLabels,
    paletteEntryLabels
  };
}
function getColor(cpal, paletteIndex, colorIndex) {
  const palette = cpal.palettes[paletteIndex];
  if (!palette)
    return null;
  return palette.colors[colorIndex] ?? null;
}
function colorToRgba(color) {
  return `rgba(${color.red}, ${color.green}, ${color.blue}, ${(color.alpha / 255).toFixed(3)})`;
}
function colorToHex(color) {
  const r = color.red.toString(16).padStart(2, "0");
  const g = color.green.toString(16).padStart(2, "0");
  const b = color.blue.toString(16).padStart(2, "0");
  if (color.alpha === 255) {
    return `#${r}${g}${b}`;
  }
  const a = color.alpha.toString(16).padStart(2, "0");
  return `#${r}${g}${b}${a}`;
}

// reference/text-shaper/src/font/tables/feat.ts
var FeatureType;
((FeatureType2) => {
  FeatureType2[FeatureType2["AllTypographicFeatures"] = 0] = "AllTypographicFeatures";
  FeatureType2[FeatureType2["Ligatures"] = 1] = "Ligatures";
  FeatureType2[FeatureType2["CursiveConnection"] = 2] = "CursiveConnection";
  FeatureType2[FeatureType2["LetterCase"] = 3] = "LetterCase";
  FeatureType2[FeatureType2["VerticalSubstitution"] = 4] = "VerticalSubstitution";
  FeatureType2[FeatureType2["LinguisticRearrangement"] = 5] = "LinguisticRearrangement";
  FeatureType2[FeatureType2["NumberSpacing"] = 6] = "NumberSpacing";
  FeatureType2[FeatureType2["SmartSwashes"] = 8] = "SmartSwashes";
  FeatureType2[FeatureType2["Diacritics"] = 9] = "Diacritics";
  FeatureType2[FeatureType2["VerticalPosition"] = 10] = "VerticalPosition";
  FeatureType2[FeatureType2["Fractions"] = 11] = "Fractions";
  FeatureType2[FeatureType2["OverlappingCharacters"] = 13] = "OverlappingCharacters";
  FeatureType2[FeatureType2["TypographicExtras"] = 14] = "TypographicExtras";
  FeatureType2[FeatureType2["MathematicalExtras"] = 15] = "MathematicalExtras";
  FeatureType2[FeatureType2["OrnamentSets"] = 16] = "OrnamentSets";
  FeatureType2[FeatureType2["CharacterAlternatives"] = 17] = "CharacterAlternatives";
  FeatureType2[FeatureType2["DesignComplexity"] = 18] = "DesignComplexity";
  FeatureType2[FeatureType2["StyleOptions"] = 19] = "StyleOptions";
  FeatureType2[FeatureType2["CharacterShape"] = 20] = "CharacterShape";
  FeatureType2[FeatureType2["NumberCase"] = 21] = "NumberCase";
  FeatureType2[FeatureType2["TextSpacing"] = 22] = "TextSpacing";
  FeatureType2[FeatureType2["Transliteration"] = 23] = "Transliteration";
  FeatureType2[FeatureType2["Annotation"] = 24] = "Annotation";
  FeatureType2[FeatureType2["KanaSpacing"] = 25] = "KanaSpacing";
  FeatureType2[FeatureType2["IdeographicSpacing"] = 26] = "IdeographicSpacing";
  FeatureType2[FeatureType2["UnicodeDecomposition"] = 27] = "UnicodeDecomposition";
  FeatureType2[FeatureType2["RubyKana"] = 28] = "RubyKana";
  FeatureType2[FeatureType2["CJKSymbolAlternatives"] = 29] = "CJKSymbolAlternatives";
  FeatureType2[FeatureType2["IdeographicAlternatives"] = 30] = "IdeographicAlternatives";
  FeatureType2[FeatureType2["CJKVerticalRomanPlacement"] = 31] = "CJKVerticalRomanPlacement";
  FeatureType2[FeatureType2["ItalicCJKRoman"] = 32] = "ItalicCJKRoman";
  FeatureType2[FeatureType2["CaseSensitiveLayout"] = 33] = "CaseSensitiveLayout";
  FeatureType2[FeatureType2["AlternateKana"] = 34] = "AlternateKana";
  FeatureType2[FeatureType2["StylisticAlternatives"] = 35] = "StylisticAlternatives";
  FeatureType2[FeatureType2["ContextualAlternatives"] = 36] = "ContextualAlternatives";
  FeatureType2[FeatureType2["LowerCase"] = 37] = "LowerCase";
  FeatureType2[FeatureType2["UpperCase"] = 38] = "UpperCase";
  FeatureType2[FeatureType2["LanguageTag"] = 39] = "LanguageTag";
  FeatureType2[FeatureType2["CJKRomanSpacing"] = 103] = "CJKRomanSpacing";
})(FeatureType ||= {});
var LigatureSetting;
((LigatureSetting2) => {
  LigatureSetting2[LigatureSetting2["RequiredLigaturesOn"] = 0] = "RequiredLigaturesOn";
  LigatureSetting2[LigatureSetting2["RequiredLigaturesOff"] = 1] = "RequiredLigaturesOff";
  LigatureSetting2[LigatureSetting2["CommonLigaturesOn"] = 2] = "CommonLigaturesOn";
  LigatureSetting2[LigatureSetting2["CommonLigaturesOff"] = 3] = "CommonLigaturesOff";
  LigatureSetting2[LigatureSetting2["RareLigaturesOn"] = 4] = "RareLigaturesOn";
  LigatureSetting2[LigatureSetting2["RareLigaturesOff"] = 5] = "RareLigaturesOff";
  LigatureSetting2[LigatureSetting2["LogosOn"] = 6] = "LogosOn";
  LigatureSetting2[LigatureSetting2["LogosOff"] = 7] = "LogosOff";
  LigatureSetting2[LigatureSetting2["RebusPicturesOn"] = 8] = "RebusPicturesOn";
  LigatureSetting2[LigatureSetting2["RebusPicturesOff"] = 9] = "RebusPicturesOff";
  LigatureSetting2[LigatureSetting2["DiphthongLigaturesOn"] = 10] = "DiphthongLigaturesOn";
  LigatureSetting2[LigatureSetting2["DiphthongLigaturesOff"] = 11] = "DiphthongLigaturesOff";
  LigatureSetting2[LigatureSetting2["SquaredLigaturesOn"] = 12] = "SquaredLigaturesOn";
  LigatureSetting2[LigatureSetting2["SquaredLigaturesOff"] = 13] = "SquaredLigaturesOff";
  LigatureSetting2[LigatureSetting2["AbbrevSquaredLigaturesOn"] = 14] = "AbbrevSquaredLigaturesOn";
  LigatureSetting2[LigatureSetting2["AbbrevSquaredLigaturesOff"] = 15] = "AbbrevSquaredLigaturesOff";
  LigatureSetting2[LigatureSetting2["SymbolLigaturesOn"] = 16] = "SymbolLigaturesOn";
  LigatureSetting2[LigatureSetting2["SymbolLigaturesOff"] = 17] = "SymbolLigaturesOff";
  LigatureSetting2[LigatureSetting2["ContextualLigaturesOn"] = 18] = "ContextualLigaturesOn";
  LigatureSetting2[LigatureSetting2["ContextualLigaturesOff"] = 19] = "ContextualLigaturesOff";
  LigatureSetting2[LigatureSetting2["HistoricalLigaturesOn"] = 20] = "HistoricalLigaturesOn";
  LigatureSetting2[LigatureSetting2["HistoricalLigaturesOff"] = 21] = "HistoricalLigaturesOff";
})(LigatureSetting ||= {});
var VerticalPositionSetting;
((VerticalPositionSetting2) => {
  VerticalPositionSetting2[VerticalPositionSetting2["NormalPosition"] = 0] = "NormalPosition";
  VerticalPositionSetting2[VerticalPositionSetting2["Superiors"] = 1] = "Superiors";
  VerticalPositionSetting2[VerticalPositionSetting2["Inferiors"] = 2] = "Inferiors";
  VerticalPositionSetting2[VerticalPositionSetting2["Ordinals"] = 3] = "Ordinals";
  VerticalPositionSetting2[VerticalPositionSetting2["ScientificInferiors"] = 4] = "ScientificInferiors";
})(VerticalPositionSetting ||= {});
var NumberCaseSetting;
((NumberCaseSetting2) => {
  NumberCaseSetting2[NumberCaseSetting2["LowerCaseNumbers"] = 0] = "LowerCaseNumbers";
  NumberCaseSetting2[NumberCaseSetting2["UpperCaseNumbers"] = 1] = "UpperCaseNumbers";
})(NumberCaseSetting ||= {});
var NumberSpacingSetting;
((NumberSpacingSetting2) => {
  NumberSpacingSetting2[NumberSpacingSetting2["MonospacedNumbers"] = 0] = "MonospacedNumbers";
  NumberSpacingSetting2[NumberSpacingSetting2["ProportionalNumbers"] = 1] = "ProportionalNumbers";
  NumberSpacingSetting2[NumberSpacingSetting2["ThirdWidthNumbers"] = 2] = "ThirdWidthNumbers";
  NumberSpacingSetting2[NumberSpacingSetting2["QuarterWidthNumbers"] = 3] = "QuarterWidthNumbers";
})(NumberSpacingSetting ||= {});
var FractionsSetting;
((FractionsSetting2) => {
  FractionsSetting2[FractionsSetting2["NoFractions"] = 0] = "NoFractions";
  FractionsSetting2[FractionsSetting2["VerticalFractions"] = 1] = "VerticalFractions";
  FractionsSetting2[FractionsSetting2["DiagonalFractions"] = 2] = "DiagonalFractions";
})(FractionsSetting ||= {});
var CaseSensitiveLayoutSetting;
((CaseSensitiveLayoutSetting2) => {
  CaseSensitiveLayoutSetting2[CaseSensitiveLayoutSetting2["CaseSensitiveLayoutOn"] = 0] = "CaseSensitiveLayoutOn";
  CaseSensitiveLayoutSetting2[CaseSensitiveLayoutSetting2["CaseSensitiveLayoutOff"] = 1] = "CaseSensitiveLayoutOff";
  CaseSensitiveLayoutSetting2[CaseSensitiveLayoutSetting2["CaseSensitiveSpacingOn"] = 2] = "CaseSensitiveSpacingOn";
  CaseSensitiveLayoutSetting2[CaseSensitiveLayoutSetting2["CaseSensitiveSpacingOff"] = 3] = "CaseSensitiveSpacingOff";
})(CaseSensitiveLayoutSetting ||= {});
var StylisticAlternativesSetting;
((StylisticAlternativesSetting2) => {
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["NoStylisticAlternates"] = 0] = "NoStylisticAlternates";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltOneOn"] = 2] = "StylisticAltOneOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltOneOff"] = 3] = "StylisticAltOneOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTwoOn"] = 4] = "StylisticAltTwoOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTwoOff"] = 5] = "StylisticAltTwoOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltThreeOn"] = 6] = "StylisticAltThreeOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltThreeOff"] = 7] = "StylisticAltThreeOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFourOn"] = 8] = "StylisticAltFourOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFourOff"] = 9] = "StylisticAltFourOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFiveOn"] = 10] = "StylisticAltFiveOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFiveOff"] = 11] = "StylisticAltFiveOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSixOn"] = 12] = "StylisticAltSixOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSixOff"] = 13] = "StylisticAltSixOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSevenOn"] = 14] = "StylisticAltSevenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSevenOff"] = 15] = "StylisticAltSevenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltEightOn"] = 16] = "StylisticAltEightOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltEightOff"] = 17] = "StylisticAltEightOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltNineOn"] = 18] = "StylisticAltNineOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltNineOff"] = 19] = "StylisticAltNineOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTenOn"] = 20] = "StylisticAltTenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTenOff"] = 21] = "StylisticAltTenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltElevenOn"] = 22] = "StylisticAltElevenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltElevenOff"] = 23] = "StylisticAltElevenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTwelveOn"] = 24] = "StylisticAltTwelveOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTwelveOff"] = 25] = "StylisticAltTwelveOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltThirteenOn"] = 26] = "StylisticAltThirteenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltThirteenOff"] = 27] = "StylisticAltThirteenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFourteenOn"] = 28] = "StylisticAltFourteenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFourteenOff"] = 29] = "StylisticAltFourteenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFifteenOn"] = 30] = "StylisticAltFifteenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltFifteenOff"] = 31] = "StylisticAltFifteenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSixteenOn"] = 32] = "StylisticAltSixteenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSixteenOff"] = 33] = "StylisticAltSixteenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSeventeenOn"] = 34] = "StylisticAltSeventeenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltSeventeenOff"] = 35] = "StylisticAltSeventeenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltEighteenOn"] = 36] = "StylisticAltEighteenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltEighteenOff"] = 37] = "StylisticAltEighteenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltNineteenOn"] = 38] = "StylisticAltNineteenOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltNineteenOff"] = 39] = "StylisticAltNineteenOff";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTwentyOn"] = 40] = "StylisticAltTwentyOn";
  StylisticAlternativesSetting2[StylisticAlternativesSetting2["StylisticAltTwentyOff"] = 41] = "StylisticAltTwentyOff";
})(StylisticAlternativesSetting ||= {});
var ContextualAlternativesSetting;
((ContextualAlternativesSetting2) => {
  ContextualAlternativesSetting2[ContextualAlternativesSetting2["ContextualAlternatesOn"] = 0] = "ContextualAlternatesOn";
  ContextualAlternativesSetting2[ContextualAlternativesSetting2["ContextualAlternatesOff"] = 1] = "ContextualAlternatesOff";
  ContextualAlternativesSetting2[ContextualAlternativesSetting2["SwashAlternatesOn"] = 2] = "SwashAlternatesOn";
  ContextualAlternativesSetting2[ContextualAlternativesSetting2["SwashAlternatesOff"] = 3] = "SwashAlternatesOff";
  ContextualAlternativesSetting2[ContextualAlternativesSetting2["ContextualSwashAlternatesOn"] = 4] = "ContextualSwashAlternatesOn";
  ContextualAlternativesSetting2[ContextualAlternativesSetting2["ContextualSwashAlternatesOff"] = 5] = "ContextualSwashAlternatesOff";
})(ContextualAlternativesSetting ||= {});
var LowerCaseSetting;
((LowerCaseSetting2) => {
  LowerCaseSetting2[LowerCaseSetting2["DefaultLowerCase"] = 0] = "DefaultLowerCase";
  LowerCaseSetting2[LowerCaseSetting2["LowerCaseSmallCaps"] = 1] = "LowerCaseSmallCaps";
  LowerCaseSetting2[LowerCaseSetting2["LowerCasePetiteCaps"] = 2] = "LowerCasePetiteCaps";
})(LowerCaseSetting ||= {});
var UpperCaseSetting;
((UpperCaseSetting2) => {
  UpperCaseSetting2[UpperCaseSetting2["DefaultUpperCase"] = 0] = "DefaultUpperCase";
  UpperCaseSetting2[UpperCaseSetting2["UpperCaseSmallCaps"] = 1] = "UpperCaseSmallCaps";
  UpperCaseSetting2[UpperCaseSetting2["UpperCasePetiteCaps"] = 2] = "UpperCasePetiteCaps";
})(UpperCaseSetting ||= {});
var SmartSwashSetting;
((SmartSwashSetting2) => {
  SmartSwashSetting2[SmartSwashSetting2["WordInitialSwashesOn"] = 0] = "WordInitialSwashesOn";
  SmartSwashSetting2[SmartSwashSetting2["WordInitialSwashesOff"] = 1] = "WordInitialSwashesOff";
  SmartSwashSetting2[SmartSwashSetting2["WordFinalSwashesOn"] = 2] = "WordFinalSwashesOn";
  SmartSwashSetting2[SmartSwashSetting2["WordFinalSwashesOff"] = 3] = "WordFinalSwashesOff";
  SmartSwashSetting2[SmartSwashSetting2["LineInitialSwashesOn"] = 4] = "LineInitialSwashesOn";
  SmartSwashSetting2[SmartSwashSetting2["LineInitialSwashesOff"] = 5] = "LineInitialSwashesOff";
  SmartSwashSetting2[SmartSwashSetting2["LineFinalSwashesOn"] = 6] = "LineFinalSwashesOn";
  SmartSwashSetting2[SmartSwashSetting2["LineFinalSwashesOff"] = 7] = "LineFinalSwashesOff";
  SmartSwashSetting2[SmartSwashSetting2["NonFinalSwashesOn"] = 8] = "NonFinalSwashesOn";
  SmartSwashSetting2[SmartSwashSetting2["NonFinalSwashesOff"] = 9] = "NonFinalSwashesOff";
})(SmartSwashSetting ||= {});
var DiacriticsSetting;
((DiacriticsSetting2) => {
  DiacriticsSetting2[DiacriticsSetting2["ShowDiacritics"] = 0] = "ShowDiacritics";
  DiacriticsSetting2[DiacriticsSetting2["HideDiacritics"] = 1] = "HideDiacritics";
  DiacriticsSetting2[DiacriticsSetting2["DecomposeDiacritics"] = 2] = "DecomposeDiacritics";
})(DiacriticsSetting ||= {});
var CharacterShapeSetting;
((CharacterShapeSetting2) => {
  CharacterShapeSetting2[CharacterShapeSetting2["TraditionalCharacters"] = 0] = "TraditionalCharacters";
  CharacterShapeSetting2[CharacterShapeSetting2["SimplifiedCharacters"] = 1] = "SimplifiedCharacters";
  CharacterShapeSetting2[CharacterShapeSetting2["JIS1978Characters"] = 2] = "JIS1978Characters";
  CharacterShapeSetting2[CharacterShapeSetting2["JIS1983Characters"] = 3] = "JIS1983Characters";
  CharacterShapeSetting2[CharacterShapeSetting2["JIS1990Characters"] = 4] = "JIS1990Characters";
  CharacterShapeSetting2[CharacterShapeSetting2["TraditionalAltOne"] = 5] = "TraditionalAltOne";
  CharacterShapeSetting2[CharacterShapeSetting2["TraditionalAltTwo"] = 6] = "TraditionalAltTwo";
  CharacterShapeSetting2[CharacterShapeSetting2["TraditionalAltThree"] = 7] = "TraditionalAltThree";
  CharacterShapeSetting2[CharacterShapeSetting2["TraditionalAltFour"] = 8] = "TraditionalAltFour";
  CharacterShapeSetting2[CharacterShapeSetting2["TraditionalAltFive"] = 9] = "TraditionalAltFive";
  CharacterShapeSetting2[CharacterShapeSetting2["ExpertCharacters"] = 10] = "ExpertCharacters";
  CharacterShapeSetting2[CharacterShapeSetting2["NLCCharacters"] = 13] = "NLCCharacters";
  CharacterShapeSetting2[CharacterShapeSetting2["JIS2004Characters"] = 11] = "JIS2004Characters";
  CharacterShapeSetting2[CharacterShapeSetting2["HojoCharacters"] = 12] = "HojoCharacters";
})(CharacterShapeSetting ||= {});
var FeatureFlags;
((FeatureFlags2) => {
  FeatureFlags2[FeatureFlags2["Exclusive"] = 32768] = "Exclusive";
  FeatureFlags2[FeatureFlags2["UseDefault"] = 16384] = "UseDefault";
})(FeatureFlags ||= {});
function parseFeat(reader) {
  const tableStart = reader.offset;
  const version = reader.fixed();
  const featureNameCount = reader.uint16();
  reader.skip(2);
  reader.skip(4);
  const features = [];
  for (let i = 0;i < featureNameCount; i++) {
    const featureType = reader.uint16();
    const nSettings = reader.uint16();
    const settingTableOffset = reader.offset32();
    const featureFlags = reader.uint16();
    const defaultSettingIndex = featureFlags & 255;
    const nameId = reader.uint16();
    const settings = [];
    const savedOffset = reader.offset;
    reader.seek(tableStart + settingTableOffset);
    for (let j = 0;j < nSettings; j++) {
      settings.push({
        settingValue: reader.uint16(),
        nameId: reader.uint16()
      });
    }
    reader.seek(savedOffset);
    features.push({
      featureType,
      nSettings,
      settingTableOffset,
      featureFlags,
      defaultSettingIndex,
      nameId,
      settings
    });
  }
  return { version, features };
}
function getFeature(table, featureType) {
  return table.features.find((f) => f.featureType === featureType);
}
function getAllFeatures(table) {
  return table.features;
}
function isExclusiveFeature(feature) {
  return (feature.featureFlags & 32768 /* Exclusive */) !== 0;
}
function getDefaultSetting(feature) {
  return feature.settings[feature.defaultSettingIndex];
}
function getSettingByValue(feature, settingValue) {
  return feature.settings.find((s) => s.settingValue === settingValue);
}
function hasSettingValue(feature, settingValue) {
  return feature.settings.some((s) => s.settingValue === settingValue);
}
function aatToOpenTypeTag(featureType, settingValue) {
  switch (featureType) {
    case 1 /* Ligatures */:
      switch (settingValue) {
        case 2 /* CommonLigaturesOn */:
          return "liga";
        case 4 /* RareLigaturesOn */:
          return "dlig";
        case 20 /* HistoricalLigaturesOn */:
          return "hlig";
        case 18 /* ContextualLigaturesOn */:
          return "clig";
        case 0 /* RequiredLigaturesOn */:
          return "rlig";
      }
      break;
    case 10 /* VerticalPosition */:
      switch (settingValue) {
        case 1 /* Superiors */:
          return "sups";
        case 2 /* Inferiors */:
          return "subs";
        case 3 /* Ordinals */:
          return "ordn";
        case 4 /* ScientificInferiors */:
          return "sinf";
      }
      break;
    case 11 /* Fractions */:
      if (settingValue === 1 /* VerticalFractions */ || settingValue === 2 /* DiagonalFractions */) {
        return "frac";
      }
      break;
    case 21 /* NumberCase */:
      switch (settingValue) {
        case 0 /* LowerCaseNumbers */:
          return "onum";
        case 1 /* UpperCaseNumbers */:
          return "lnum";
      }
      break;
    case 6 /* NumberSpacing */:
      switch (settingValue) {
        case 0 /* MonospacedNumbers */:
          return "tnum";
        case 1 /* ProportionalNumbers */:
          return "pnum";
      }
      break;
    case 33 /* CaseSensitiveLayout */:
      if (settingValue === 0 /* CaseSensitiveLayoutOn */) {
        return "case";
      }
      break;
    case 37 /* LowerCase */:
      switch (settingValue) {
        case 1 /* LowerCaseSmallCaps */:
          return "smcp";
        case 2 /* LowerCasePetiteCaps */:
          return "pcap";
      }
      break;
    case 38 /* UpperCase */:
      switch (settingValue) {
        case 1 /* UpperCaseSmallCaps */:
          return "c2sc";
        case 2 /* UpperCasePetiteCaps */:
          return "c2pc";
      }
      break;
    case 8 /* SmartSwashes */:
      if (settingValue === 0 /* WordInitialSwashesOn */ || settingValue === 2 /* WordFinalSwashesOn */) {
        return "swsh";
      }
      break;
    case 36 /* ContextualAlternatives */:
      switch (settingValue) {
        case 0 /* ContextualAlternatesOn */:
          return "calt";
        case 2 /* SwashAlternatesOn */:
          return "swsh";
      }
      break;
    case 35 /* StylisticAlternatives */:
      if (settingValue >= 2 && settingValue <= 41) {
        const setNum = Math.floor((settingValue - 2) / 2) + 1;
        if (setNum <= 20) {
          return `ss${setNum.toString().padStart(2, "0")}`;
        }
      }
      break;
    case 20 /* CharacterShape */:
      switch (settingValue) {
        case 0 /* TraditionalCharacters */:
          return "trad";
        case 1 /* SimplifiedCharacters */:
          return "smpl";
        case 2 /* JIS1978Characters */:
          return "jp78";
        case 3 /* JIS1983Characters */:
          return "jp83";
        case 4 /* JIS1990Characters */:
          return "jp90";
        case 11 /* JIS2004Characters */:
          return "jp04";
        case 13 /* NLCCharacters */:
          return "nlck";
        case 10 /* ExpertCharacters */:
          return "expt";
        case 12 /* HojoCharacters */:
          return "hojo";
      }
      break;
    case 4 /* VerticalSubstitution */:
      return "vert";
    case 24 /* Annotation */:
      return "nalt";
    case 28 /* RubyKana */:
      return "ruby";
  }
  return null;
}
function openTypeTagToAat(tag2) {
  switch (tag2) {
    case "liga":
      return {
        featureType: 1 /* Ligatures */,
        settingValue: 2 /* CommonLigaturesOn */
      };
    case "dlig":
      return {
        featureType: 1 /* Ligatures */,
        settingValue: 4 /* RareLigaturesOn */
      };
    case "hlig":
      return {
        featureType: 1 /* Ligatures */,
        settingValue: 20 /* HistoricalLigaturesOn */
      };
    case "clig":
      return {
        featureType: 1 /* Ligatures */,
        settingValue: 18 /* ContextualLigaturesOn */
      };
    case "rlig":
      return {
        featureType: 1 /* Ligatures */,
        settingValue: 0 /* RequiredLigaturesOn */
      };
    case "sups":
      return {
        featureType: 10 /* VerticalPosition */,
        settingValue: 1 /* Superiors */
      };
    case "subs":
      return {
        featureType: 10 /* VerticalPosition */,
        settingValue: 2 /* Inferiors */
      };
    case "ordn":
      return {
        featureType: 10 /* VerticalPosition */,
        settingValue: 3 /* Ordinals */
      };
    case "sinf":
      return {
        featureType: 10 /* VerticalPosition */,
        settingValue: 4 /* ScientificInferiors */
      };
    case "frac":
      return {
        featureType: 11 /* Fractions */,
        settingValue: 2 /* DiagonalFractions */
      };
    case "onum":
      return {
        featureType: 21 /* NumberCase */,
        settingValue: 0 /* LowerCaseNumbers */
      };
    case "lnum":
      return {
        featureType: 21 /* NumberCase */,
        settingValue: 1 /* UpperCaseNumbers */
      };
    case "tnum":
      return {
        featureType: 6 /* NumberSpacing */,
        settingValue: 0 /* MonospacedNumbers */
      };
    case "pnum":
      return {
        featureType: 6 /* NumberSpacing */,
        settingValue: 1 /* ProportionalNumbers */
      };
    case "case":
      return {
        featureType: 33 /* CaseSensitiveLayout */,
        settingValue: 0 /* CaseSensitiveLayoutOn */
      };
    case "smcp":
      return {
        featureType: 37 /* LowerCase */,
        settingValue: 1 /* LowerCaseSmallCaps */
      };
    case "pcap":
      return {
        featureType: 37 /* LowerCase */,
        settingValue: 2 /* LowerCasePetiteCaps */
      };
    case "c2sc":
      return {
        featureType: 38 /* UpperCase */,
        settingValue: 1 /* UpperCaseSmallCaps */
      };
    case "c2pc":
      return {
        featureType: 38 /* UpperCase */,
        settingValue: 2 /* UpperCasePetiteCaps */
      };
    case "swsh":
      return {
        featureType: 8 /* SmartSwashes */,
        settingValue: 0 /* WordInitialSwashesOn */
      };
    case "calt":
      return {
        featureType: 36 /* ContextualAlternatives */,
        settingValue: 0 /* ContextualAlternatesOn */
      };
    case "trad":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 0 /* TraditionalCharacters */
      };
    case "smpl":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 1 /* SimplifiedCharacters */
      };
    case "jp78":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 2 /* JIS1978Characters */
      };
    case "jp83":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 3 /* JIS1983Characters */
      };
    case "jp90":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 4 /* JIS1990Characters */
      };
    case "jp04":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 11 /* JIS2004Characters */
      };
    case "nlck":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 13 /* NLCCharacters */
      };
    case "expt":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 10 /* ExpertCharacters */
      };
    case "hojo":
      return {
        featureType: 20 /* CharacterShape */,
        settingValue: 12 /* HojoCharacters */
      };
    case "vert":
      return { featureType: 4 /* VerticalSubstitution */, settingValue: 0 };
    case "nalt":
      return { featureType: 24 /* Annotation */, settingValue: 0 };
    case "ruby":
      return { featureType: 28 /* RubyKana */, settingValue: 0 };
  }
  if (tag2.startsWith("ss") && tag2.length === 4) {
    const num = parseInt(tag2.slice(2), 10);
    if (num >= 1 && num <= 20) {
      return {
        featureType: 35 /* StylisticAlternatives */,
        settingValue: (num - 1) * 2 + 2
      };
    }
  }
  return null;
}

// reference/text-shaper/src/font/tables/gasp.ts
var GaspFlag = {
  GridFit: 1,
  DoGray: 2,
  SymmetricGridFit: 4,
  SymmetricSmoothing: 8
};
function parseGasp(reader) {
  const version = reader.uint16();
  const numRanges = reader.uint16();
  const ranges = [];
  for (let i = 0;i < numRanges; i++) {
    const maxPPEM = reader.uint16();
    const behavior = reader.uint16();
    ranges.push({ maxPPEM, behavior });
  }
  ranges.sort((a, b) => a.maxPPEM - b.maxPPEM);
  return { version, ranges };
}
function getGaspBehavior(gasp, ppem) {
  for (let i = 0;i < gasp.ranges.length; i++) {
    const range = gasp.ranges[i];
    if (ppem <= range.maxPPEM) {
      return range.behavior;
    }
  }
  if (gasp.ranges.length > 0) {
    return gasp.ranges[gasp.ranges.length - 1]?.behavior;
  }
  return GaspFlag.GridFit | GaspFlag.DoGray;
}
function shouldGridFit(gasp, ppem) {
  return (getGaspBehavior(gasp, ppem) & GaspFlag.GridFit) !== 0;
}
function shouldDoGray(gasp, ppem) {
  return (getGaspBehavior(gasp, ppem) & GaspFlag.DoGray) !== 0;
}

// reference/text-shaper/src/layout/structures/class-def.ts
class ClassDef {
  startGlyphId;
  classValueArray;
  ranges;
  glyphMap;
  isEmpty;
  constructor(startGlyphId, classValueArray, ranges, glyphMap, isEmpty) {
    this.startGlyphId = startGlyphId;
    this.classValueArray = classValueArray;
    this.ranges = ranges;
    this.glyphMap = glyphMap;
    this.isEmpty = isEmpty;
  }
  static empty() {
    return new ClassDef(0, null, null, null, true);
  }
  static format1(startGlyphId, classValueArray) {
    return new ClassDef(startGlyphId, classValueArray, null, null, false);
  }
  static format2(ranges) {
    let totalGlyphs = 0;
    for (let i = 0;i < ranges.length; i++) {
      const range = ranges[i];
      totalGlyphs += range.endGlyphId - range.startGlyphId + 1;
    }
    let glyphMap = null;
    if (totalGlyphs < 1e4) {
      glyphMap = new Map;
      for (let i = 0;i < ranges.length; i++) {
        const range = ranges[i];
        for (let g = range.startGlyphId;g <= range.endGlyphId; g++) {
          glyphMap.set(g, range.classValue);
        }
      }
    }
    return new ClassDef(0, null, ranges, glyphMap, false);
  }
  get(glyphId) {
    if (this.isEmpty) {
      return 0;
    }
    if (this.classValueArray) {
      const index = glyphId - this.startGlyphId;
      return index >= 0 && index < this.classValueArray.length ? this.classValueArray[index] : 0;
    }
    if (this.glyphMap) {
      return this.glyphMap.get(glyphId) ?? 0;
    }
    const ranges = this.ranges;
    let low = 0;
    let high = ranges.length - 1;
    while (low <= high) {
      const mid = low + high >>> 1;
      const range = ranges[mid];
      if (glyphId > range.endGlyphId) {
        low = mid + 1;
      } else if (glyphId < range.startGlyphId) {
        high = mid - 1;
      } else {
        return range.classValue;
      }
    }
    return 0;
  }
  glyphsInClass(classValue) {
    if (this.isEmpty) {
      return [];
    }
    if (this.classValueArray) {
      const result2 = [];
      for (let i = 0;i < this.classValueArray.length; i++) {
        if (this.classValueArray[i] === classValue) {
          result2.push(this.startGlyphId + i);
        }
      }
      return result2;
    }
    const result = [];
    const ranges = this.ranges;
    for (let i = 0;i < ranges.length; i++) {
      const range = ranges[i];
      if (range.classValue === classValue) {
        for (let g = range.startGlyphId;g <= range.endGlyphId; g++) {
          result.push(g);
        }
      }
    }
    return result;
  }
}
var EMPTY_CLASS_DEF = ClassDef.empty();
function parseClassDef(reader) {
  const format = reader.uint16();
  if (format === 1) {
    const startGlyphId = reader.uint16();
    const glyphCount = reader.uint16();
    const classValueArray = reader.uint16Array(glyphCount);
    return ClassDef.format1(startGlyphId, classValueArray);
  }
  if (format === 2) {
    const classRangeCount = reader.uint16();
    const ranges = new Array(classRangeCount);
    for (let i = 0;i < classRangeCount; i++) {
      ranges[i] = {
        startGlyphId: reader.uint16(),
        endGlyphId: reader.uint16(),
        classValue: reader.uint16()
      };
    }
    return ClassDef.format2(ranges);
  }
  throw new Error(`Unknown ClassDef format: ${format}`);
}
function parseClassDefAt(reader, offset) {
  if (offset === 0) {
    return EMPTY_CLASS_DEF;
  }
  return parseClassDef(reader.sliceFrom(offset));
}

// reference/text-shaper/src/font/tables/gdef.ts
function parseGdef(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const glyphClassDefOffset = reader.offset16();
  const attachListOffset = reader.offset16();
  const ligCaretListOffset = reader.offset16();
  const markAttachClassDefOffset = reader.offset16();
  let markGlyphSetsDefOffset = 0;
  if (majorVersion === 1 && minorVersion >= 2) {
    markGlyphSetsDefOffset = reader.offset16();
  }
  const glyphClassDef = parseClassDefAt(reader, glyphClassDefOffset);
  let attachList = null;
  if (attachListOffset !== 0) {
    attachList = parseAttachList(reader.sliceFrom(attachListOffset));
  }
  let ligCaretList = null;
  if (ligCaretListOffset !== 0) {
    ligCaretList = parseLigCaretList(reader.sliceFrom(ligCaretListOffset));
  }
  const markAttachClassDef = parseClassDefAt(reader, markAttachClassDefOffset);
  let markGlyphSets = null;
  if (markGlyphSetsDefOffset !== 0) {
    markGlyphSets = parseMarkGlyphSets(reader.sliceFrom(markGlyphSetsDefOffset));
  }
  return {
    version: { major: majorVersion, minor: minorVersion },
    glyphClassDef,
    attachList,
    ligCaretList,
    markAttachClassDef,
    markGlyphSets
  };
}
function parseAttachList(reader) {
  const coverageOffset = reader.offset16();
  const glyphCount = reader.uint16();
  const attachPointOffsets = reader.uint16Array(glyphCount);
  const coverageReader = reader.sliceFrom(coverageOffset);
  const format = coverageReader.uint16();
  const glyphIds = [];
  if (format === 1) {
    const count = coverageReader.uint16();
    for (let i = 0;i < count; i++) {
      glyphIds.push(coverageReader.uint16());
    }
  } else if (format === 2) {
    const rangeCount = coverageReader.uint16();
    for (let i = 0;i < rangeCount; i++) {
      const start = coverageReader.uint16();
      const end = coverageReader.uint16();
      coverageReader.skip(2);
      for (let g = start;g <= end; g++) {
        glyphIds.push(g);
      }
    }
  }
  const result = new Map;
  for (let i = 0;i < attachPointOffsets.length; i++) {
    const offset = attachPointOffsets[i];
    const glyphId = glyphIds[i];
    if (glyphId === undefined)
      continue;
    const pointReader = reader.sliceFrom(offset);
    const pointCount = pointReader.uint16();
    const typedIndices = pointReader.uint16Array(pointCount);
    const pointIndices = new Array(typedIndices.length);
    for (let j = 0;j < typedIndices.length; j++)
      pointIndices[j] = typedIndices[j];
    result.set(glyphId, { pointIndices });
  }
  return result;
}
function parseLigCaretList(reader) {
  const coverageOffset = reader.offset16();
  const ligGlyphCount = reader.uint16();
  const ligGlyphOffsets = reader.uint16Array(ligGlyphCount);
  const coverageReader = reader.sliceFrom(coverageOffset);
  const format = coverageReader.uint16();
  const glyphIds = [];
  if (format === 1) {
    const count = coverageReader.uint16();
    for (let i = 0;i < count; i++) {
      glyphIds.push(coverageReader.uint16());
    }
  } else if (format === 2) {
    const rangeCount = coverageReader.uint16();
    for (let i = 0;i < rangeCount; i++) {
      const start = coverageReader.uint16();
      const end = coverageReader.uint16();
      coverageReader.skip(2);
      for (let g = start;g <= end; g++) {
        glyphIds.push(g);
      }
    }
  }
  const result = new Map;
  for (let i = 0;i < ligGlyphOffsets.length; i++) {
    const offset = ligGlyphOffsets[i];
    const glyphId = glyphIds[i];
    if (glyphId === undefined)
      continue;
    const ligReader = reader.sliceFrom(offset);
    const caretCount = ligReader.uint16();
    const caretValueOffsets = ligReader.uint16Array(caretCount);
    const caretValues = [];
    for (let j = 0;j < caretValueOffsets.length; j++) {
      const caretOffset = caretValueOffsets[j];
      const caretReader = reader.sliceFrom(offset + caretOffset);
      const caretFormat = caretReader.uint16();
      if (caretFormat === 1) {
        caretValues.push(caretReader.int16());
      } else if (caretFormat === 2) {
        caretValues.push(caretReader.uint16());
      } else if (caretFormat === 3) {
        caretValues.push(caretReader.int16());
      }
    }
    result.set(glyphId, { caretValues });
  }
  return result;
}
function parseMarkGlyphSets(reader) {
  const _format = reader.uint16();
  const markSetCount = reader.uint16();
  const coverageOffsets = reader.uint32Array(markSetCount);
  const markSets = [];
  for (let i = 0;i < coverageOffsets.length; i++) {
    const offset = coverageOffsets[i];
    const coverageReader = reader.sliceFrom(offset);
    const coverageFormat = coverageReader.uint16();
    const glyphSet = new Set;
    if (coverageFormat === 1) {
      const count = coverageReader.uint16();
      for (let j = 0;j < count; j++) {
        glyphSet.add(coverageReader.uint16());
      }
    } else if (coverageFormat === 2) {
      const rangeCount = coverageReader.uint16();
      for (let j = 0;j < rangeCount; j++) {
        const start = coverageReader.uint16();
        const end = coverageReader.uint16();
        coverageReader.skip(2);
        for (let g = start;g <= end; g++) {
          glyphSet.add(g);
        }
      }
    }
    markSets.push(glyphSet);
  }
  return {
    has(setIndex, glyphId) {
      const set = markSets[setIndex];
      return set ? set.has(glyphId) : false;
    }
  };
}
function getGlyphClass2(gdef, glyphId) {
  if (!gdef)
    return 0;
  const cls = gdef.glyphClassDef.get(glyphId);
  return cls;
}

// reference/text-shaper/src/layout/structures/coverage.ts
class Coverage {
  glyphMap;
  ranges;
  glyphArray;
  size;
  constructor(glyphMap, ranges, glyphArray, size) {
    this.glyphMap = glyphMap;
    this.ranges = ranges;
    this.glyphArray = glyphArray;
    this.size = size;
  }
  static format1(glyphArray) {
    const glyphMap = new Map;
    for (let i = 0;i < glyphArray.length; i++) {
      glyphMap.set(glyphArray[i], i);
    }
    return new Coverage(glyphMap, null, glyphArray, glyphArray.length);
  }
  static format2(ranges) {
    let size = 0;
    if (ranges.length > 0) {
      const lastRange = ranges[ranges.length - 1];
      if (lastRange) {
        size = lastRange.startCoverageIndex + (lastRange.endGlyphId - lastRange.startGlyphId + 1);
      }
    }
    return new Coverage(null, ranges, null, size);
  }
  get(glyphId) {
    if (this.glyphMap) {
      return this.glyphMap.get(glyphId) ?? null;
    }
    const ranges = this.ranges;
    let low = 0;
    let high = ranges.length - 1;
    while (low <= high) {
      const mid = low + high >>> 1;
      const range = ranges[mid];
      if (glyphId > range.endGlyphId) {
        low = mid + 1;
      } else if (glyphId < range.startGlyphId) {
        high = mid - 1;
      } else {
        return range.startCoverageIndex + (glyphId - range.startGlyphId);
      }
    }
    return null;
  }
  covers(glyphId) {
    return this.get(glyphId) !== null;
  }
  glyphs() {
    if (this.glyphArray) {
      const arr = this.glyphArray;
      const result2 = new Array(arr.length);
      for (let i = 0;i < arr.length; i++) {
        result2[i] = arr[i];
      }
      return result2;
    }
    const result = [];
    const ranges = this.ranges;
    for (let i = 0;i < ranges.length; i++) {
      const range = ranges[i];
      for (let g = range.startGlyphId;g <= range.endGlyphId; g++) {
        result.push(g);
      }
    }
    return result;
  }
}
function parseCoverage(reader) {
  const format = reader.uint16();
  if (format === 1) {
    const glyphCount = reader.uint16();
    const glyphArray = reader.uint16Array(glyphCount);
    return Coverage.format1(glyphArray);
  }
  if (format === 2) {
    const rangeCount = reader.uint16();
    const ranges = new Array(rangeCount);
    for (let i = 0;i < rangeCount; i++) {
      ranges[i] = {
        startGlyphId: reader.uint16(),
        endGlyphId: reader.uint16(),
        startCoverageIndex: reader.uint16()
      };
    }
    return Coverage.format2(ranges);
  }
  throw new Error(`Unknown Coverage format: ${format}`);
}
function parseCoverageAt(reader, offset) {
  return parseCoverage(reader.sliceFrom(offset));
}

// reference/text-shaper/src/layout/structures/device.ts
function isVariationIndexTable(table) {
  return "deltaSetOuterIndex" in table;
}
function parseDeviceAt(reader, offset) {
  if (offset === 0)
    return null;
  return parseDevice(reader.sliceFrom(offset));
}
function parseDevice(reader) {
  const startSize = reader.uint16();
  const endSize = reader.uint16();
  const deltaFormat = reader.uint16();
  if (deltaFormat === 32768) {
    return {
      deltaSetOuterIndex: startSize,
      deltaSetInnerIndex: endSize
    };
  }
  const deltaValues = [];
  if (deltaFormat >= 1 && deltaFormat <= 3) {
    const count = endSize - startSize + 1;
    const bitsPerValue = 1 << deltaFormat;
    const valuesPerWord = 16 / bitsPerValue;
    const mask = (1 << bitsPerValue) - 1;
    const signBit = 1 << bitsPerValue - 1;
    const wordCount = Math.ceil(count / valuesPerWord);
    let valueIndex = 0;
    for (let w = 0;w < wordCount; w++) {
      const word = reader.uint16();
      for (let v = 0;v < valuesPerWord && valueIndex < count; v++, valueIndex++) {
        const shift2 = 16 - bitsPerValue * (v + 1);
        let delta = word >> shift2 & mask;
        if (delta & signBit) {
          delta = delta - (1 << bitsPerValue);
        }
        deltaValues.push(delta);
      }
    }
  }
  return {
    startSize,
    endSize,
    deltaFormat,
    deltaValues
  };
}
function getDeviceDelta(device, ppem) {
  if (ppem < device.startSize || ppem > device.endSize) {
    return 0;
  }
  const index = ppem - device.startSize;
  return device.deltaValues[index] ?? 0;
}
function applyDeviceAdjustment(device, value, ppem) {
  if (!device)
    return value;
  if (isVariationIndexTable(device)) {
    return value;
  }
  return value + getDeviceDelta(device, ppem);
}

// reference/text-shaper/src/layout/structures/layout-common.ts
var LookupFlag = {
  RightToLeft: 1,
  IgnoreBaseGlyphs: 2,
  IgnoreLigatures: 4,
  IgnoreMarks: 8,
  UseMarkFilteringSet: 16,
  MarkAttachmentTypeMask: 65280
};
function getMarkAttachmentType(lookupFlag) {
  return (lookupFlag & LookupFlag.MarkAttachmentTypeMask) >> 8;
}
function parseScriptList(reader) {
  const scriptCount = reader.uint16();
  const scriptRecords = [];
  for (let i = 0;i < scriptCount; i++) {
    scriptRecords.push({
      tag: reader.tag(),
      offset: reader.offset16()
    });
  }
  const scripts = [];
  for (let i = 0;i < scriptRecords.length; i++) {
    const record = scriptRecords[i];
    const scriptReader = reader.sliceFrom(record.offset);
    const script = parseScript(scriptReader);
    scripts.push({
      scriptTag: record.tag,
      script
    });
  }
  return { scripts };
}
function parseScript(reader) {
  const defaultLangSysOffset = reader.offset16();
  const langSysCount = reader.uint16();
  const langSysRecords = [];
  for (let i = 0;i < langSysCount; i++) {
    langSysRecords.push({
      tag: reader.tag(),
      offset: reader.offset16()
    });
  }
  let defaultLangSys = null;
  if (defaultLangSysOffset !== 0) {
    defaultLangSys = parseLangSys(reader.sliceFrom(defaultLangSysOffset));
  }
  const parsedLangSysRecords = [];
  for (let i = 0;i < langSysRecords.length; i++) {
    const record = langSysRecords[i];
    const langSys = parseLangSys(reader.sliceFrom(record.offset));
    parsedLangSysRecords.push({
      langSysTag: record.tag,
      langSys
    });
  }
  return {
    defaultLangSys,
    langSysRecords: parsedLangSysRecords
  };
}
function parseLangSys(reader) {
  const _lookupOrderOffset = reader.offset16();
  const requiredFeatureIndex = reader.uint16();
  const featureIndexCount = reader.uint16();
  const uint16Array = reader.uint16Array(featureIndexCount);
  const featureIndices = new Array(featureIndexCount);
  for (let i = 0;i < featureIndexCount; i++) {
    featureIndices[i] = uint16Array[i];
  }
  return {
    requiredFeatureIndex,
    featureIndices
  };
}
function parseFeatureList(reader) {
  const featureCount = reader.uint16();
  const featureRecords = [];
  for (let i = 0;i < featureCount; i++) {
    featureRecords.push({
      tag: reader.tag(),
      offset: reader.offset16()
    });
  }
  const features = [];
  for (let i = 0;i < featureRecords.length; i++) {
    const record = featureRecords[i];
    const featureReader = reader.sliceFrom(record.offset);
    const feature = parseFeature(featureReader);
    features.push({
      featureTag: record.tag,
      feature
    });
  }
  return { features };
}
function parseFeature(reader) {
  const featureParamsOffset = reader.offset16();
  const lookupIndexCount = reader.uint16();
  const uint16Array = reader.uint16Array(lookupIndexCount);
  const lookupListIndices = new Array(lookupIndexCount);
  for (let i = 0;i < lookupIndexCount; i++) {
    lookupListIndices[i] = uint16Array[i];
  }
  return {
    featureParamsOffset,
    lookupListIndices
  };
}
function parseLookupHeaders(reader) {
  const lookupCount = reader.uint16();
  const lookupOffsets = reader.uint16Array(lookupCount);
  const headers = [];
  for (let i = 0;i < lookupOffsets.length; i++) {
    const offset = lookupOffsets[i];
    const lookupReader = reader.sliceFrom(offset);
    headers.push(parseLookupHeader(lookupReader));
  }
  return headers;
}
function parseLookupHeader(reader) {
  const lookupType = reader.uint16();
  const lookupFlag = reader.uint16();
  const subtableCount = reader.uint16();
  const uint16Array = reader.uint16Array(subtableCount);
  const subtableOffsets = new Array(subtableCount);
  for (let i = 0;i < subtableCount; i++) {
    subtableOffsets[i] = uint16Array[i];
  }
  let markFilteringSet;
  if (lookupFlag & LookupFlag.UseMarkFilteringSet) {
    markFilteringSet = reader.uint16();
  }
  return {
    lookupType,
    lookupFlag,
    subtableOffsets,
    markFilteringSet
  };
}
function findScript(scriptList, scriptTag) {
  for (let i = 0;i < scriptList.scripts.length; i++) {
    const record = scriptList.scripts[i];
    if (record.scriptTag === scriptTag) {
      return record.script;
    }
  }
  return null;
}
function findLangSys(script, langSysTag) {
  if (langSysTag === null) {
    return script.defaultLangSys;
  }
  for (let i = 0;i < script.langSysRecords.length; i++) {
    const record = script.langSysRecords[i];
    if (record.langSysTag === langSysTag) {
      return record.langSys;
    }
  }
  return script.defaultLangSys;
}
function getFeature2(featureList, index) {
  return featureList.features[index] ?? null;
}

// reference/text-shaper/src/layout/structures/set-digest.ts
class SetDigest {
  mask0 = 0;
  mask1 = 0;
  mask2 = 0;
  add(glyphId) {
    this.mask0 |= 1 << (glyphId & 31);
    this.mask1 |= 1 << (glyphId >> 4 & 31);
    this.mask2 |= 1 << (glyphId >> 9 & 31);
  }
  addRange(start, end) {
    if (end - start < 32) {
      for (let gid = start;gid <= end; gid++) {
        this.add(gid);
      }
    } else {
      this.mask0 = 4294967295;
      this.mask1 = 4294967295;
      this.mask2 = 4294967295;
    }
  }
  mayHave(glyphId) {
    return (this.mask0 & 1 << (glyphId & 31)) !== 0 && (this.mask1 & 1 << (glyphId >> 4 & 31)) !== 0 && (this.mask2 & 1 << (glyphId >> 9 & 31)) !== 0;
  }
  addCoverage(coverage) {
    const glyphs = coverage.glyphs();
    for (let i = 0;i < glyphs.length; i++) {
      const gid = glyphs[i];
      this.add(gid);
    }
  }
  mayIntersect(other) {
    return (this.mask0 & other.mask0) !== 0 && (this.mask1 & other.mask1) !== 0 && (this.mask2 & other.mask2) !== 0;
  }
  getMasks() {
    return { mask0: this.mask0, mask1: this.mask1, mask2: this.mask2 };
  }
}
function createLookupDigest(coverages) {
  const digest = new SetDigest;
  for (let i = 0;i < coverages.length; i++) {
    const coverage = coverages[i];
    digest.addCoverage(coverage);
  }
  return digest;
}

// reference/text-shaper/src/font/tables/gpos-contextual.ts
function parseContextPos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    switch (format) {
      case 1:
        subtables.push(parseContextPosFormat1(r));
        break;
      case 2:
        subtables.push(parseContextPosFormat2(r));
        break;
      case 3:
        subtables.push(parseContextPosFormat3(r));
        break;
    }
  }
  return subtables;
}
function parseContextPosFormat1(reader) {
  const coverageOffset = reader.offset16();
  const ruleSetCount = reader.uint16();
  const ruleSetOffsets = reader.uint16Array(ruleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const ruleSets = [];
  for (let i = 0;i < ruleSetOffsets.length; i++) {
    const ruleSetOffset = ruleSetOffsets[i];
    if (ruleSetOffset === 0) {
      ruleSets.push(null);
      continue;
    }
    const rsReader = reader.sliceFrom(ruleSetOffset);
    const ruleCount = rsReader.uint16();
    const ruleOffsets = rsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = rsReader.sliceFrom(ruleOffset);
      const glyphCount = ruleReader.uint16();
      const lookupCount = ruleReader.uint16();
      const typedArr = ruleReader.uint16Array(glyphCount - 1);
      const inputSequence = new Array(typedArr.length);
      for (let k = 0;k < typedArr.length; k++)
        inputSequence[k] = typedArr[k];
      const lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);
      rules.push({ glyphCount, inputSequence, lookupRecords });
    }
    ruleSets.push(rules);
  }
  return { format: 1, coverage, ruleSets };
}
function parseContextPosFormat2(reader) {
  const coverageOffset = reader.offset16();
  const classDefOffset = reader.offset16();
  const classRuleSetCount = reader.uint16();
  const classRuleSetOffsets = reader.uint16Array(classRuleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const classDef = parseClassDefAt(reader, classDefOffset);
  const classRuleSets = [];
  for (let i = 0;i < classRuleSetOffsets.length; i++) {
    const crsOffset = classRuleSetOffsets[i];
    if (crsOffset === 0) {
      classRuleSets.push(null);
      continue;
    }
    const crsReader = reader.sliceFrom(crsOffset);
    const ruleCount = crsReader.uint16();
    const ruleOffsets = crsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = crsReader.sliceFrom(ruleOffset);
      const glyphCount = ruleReader.uint16();
      const lookupCount = ruleReader.uint16();
      const typedArr = ruleReader.uint16Array(glyphCount - 1);
      const inputClasses = new Array(typedArr.length);
      for (let k = 0;k < typedArr.length; k++)
        inputClasses[k] = typedArr[k];
      const lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);
      rules.push({ glyphCount, inputClasses, lookupRecords });
    }
    classRuleSets.push(rules);
  }
  return { format: 2, coverage, classDef, classRuleSets };
}
function parseContextPosFormat3(reader) {
  const glyphCount = reader.uint16();
  const lookupCount = reader.uint16();
  const coverageOffsets = reader.uint16Array(glyphCount);
  const coverages = [];
  for (let i = 0;i < coverageOffsets.length; i++) {
    const offset = coverageOffsets[i];
    coverages.push(parseCoverageAt(reader, offset));
  }
  const lookupRecords = parsePosLookupRecords(reader, lookupCount);
  return { format: 3, coverages, lookupRecords };
}
function parseChainingContextPos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    switch (format) {
      case 1:
        subtables.push(parseChainingPosFormat1(r));
        break;
      case 2:
        subtables.push(parseChainingPosFormat2(r));
        break;
      case 3:
        subtables.push(parseChainingPosFormat3(r));
        break;
    }
  }
  return subtables;
}
function parseChainingPosFormat1(reader) {
  const coverageOffset = reader.offset16();
  const chainRuleSetCount = reader.uint16();
  const chainRuleSetOffsets = reader.uint16Array(chainRuleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const chainRuleSets = [];
  for (let i = 0;i < chainRuleSetOffsets.length; i++) {
    const crsOffset = chainRuleSetOffsets[i];
    if (crsOffset === 0) {
      chainRuleSets.push(null);
      continue;
    }
    const crsReader = reader.sliceFrom(crsOffset);
    const ruleCount = crsReader.uint16();
    const ruleOffsets = crsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = crsReader.sliceFrom(ruleOffset);
      const backtrackCount = ruleReader.uint16();
      const backtrackTyped = ruleReader.uint16Array(backtrackCount);
      const backtrackSequence = new Array(backtrackTyped.length);
      for (let k = 0;k < backtrackTyped.length; k++)
        backtrackSequence[k] = backtrackTyped[k];
      const inputCount = ruleReader.uint16();
      const inputTyped = ruleReader.uint16Array(inputCount - 1);
      const inputSequence = new Array(inputTyped.length);
      for (let k = 0;k < inputTyped.length; k++)
        inputSequence[k] = inputTyped[k];
      const lookaheadCount = ruleReader.uint16();
      const lookaheadTyped = ruleReader.uint16Array(lookaheadCount);
      const lookaheadSequence = new Array(lookaheadTyped.length);
      for (let k = 0;k < lookaheadTyped.length; k++)
        lookaheadSequence[k] = lookaheadTyped[k];
      const lookupCount = ruleReader.uint16();
      const lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);
      rules.push({
        backtrackSequence,
        inputSequence,
        lookaheadSequence,
        lookupRecords
      });
    }
    chainRuleSets.push(rules);
  }
  return { format: 1, coverage, chainRuleSets };
}
function parseChainingPosFormat2(reader) {
  const coverageOffset = reader.offset16();
  const backtrackClassDefOffset = reader.offset16();
  const inputClassDefOffset = reader.offset16();
  const lookaheadClassDefOffset = reader.offset16();
  const chainClassRuleSetCount = reader.uint16();
  const chainClassRuleSetOffsets = reader.uint16Array(chainClassRuleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const backtrackClassDef = parseClassDefAt(reader, backtrackClassDefOffset);
  const inputClassDef = parseClassDefAt(reader, inputClassDefOffset);
  const lookaheadClassDef = parseClassDefAt(reader, lookaheadClassDefOffset);
  const chainClassRuleSets = [];
  for (let i = 0;i < chainClassRuleSetOffsets.length; i++) {
    const ccrsOffset = chainClassRuleSetOffsets[i];
    if (ccrsOffset === 0) {
      chainClassRuleSets.push(null);
      continue;
    }
    const ccrsReader = reader.sliceFrom(ccrsOffset);
    const ruleCount = ccrsReader.uint16();
    const ruleOffsets = ccrsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = ccrsReader.sliceFrom(ruleOffset);
      const backtrackCount = ruleReader.uint16();
      const backtrackTyped = ruleReader.uint16Array(backtrackCount);
      const backtrackClasses = new Array(backtrackTyped.length);
      for (let k = 0;k < backtrackTyped.length; k++)
        backtrackClasses[k] = backtrackTyped[k];
      const inputCount = ruleReader.uint16();
      const inputTyped = ruleReader.uint16Array(inputCount - 1);
      const inputClasses = new Array(inputTyped.length);
      for (let k = 0;k < inputTyped.length; k++)
        inputClasses[k] = inputTyped[k];
      const lookaheadCount = ruleReader.uint16();
      const lookaheadTyped = ruleReader.uint16Array(lookaheadCount);
      const lookaheadClasses = new Array(lookaheadTyped.length);
      for (let k = 0;k < lookaheadTyped.length; k++)
        lookaheadClasses[k] = lookaheadTyped[k];
      const lookupCount = ruleReader.uint16();
      const lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);
      rules.push({
        backtrackClasses,
        inputClasses,
        lookaheadClasses,
        lookupRecords
      });
    }
    chainClassRuleSets.push(rules);
  }
  return {
    format: 2,
    coverage,
    backtrackClassDef,
    inputClassDef,
    lookaheadClassDef,
    chainClassRuleSets
  };
}
function parseChainingPosFormat3(reader) {
  const backtrackCount = reader.uint16();
  const backtrackCoverageOffsets = reader.uint16Array(backtrackCount);
  const inputCount = reader.uint16();
  const inputCoverageOffsets = reader.uint16Array(inputCount);
  const lookaheadCount = reader.uint16();
  const lookaheadCoverageOffsets = reader.uint16Array(lookaheadCount);
  const lookupCount = reader.uint16();
  const lookupRecords = parsePosLookupRecords(reader, lookupCount);
  const backtrackCoverages = [];
  for (let i = 0;i < backtrackCoverageOffsets.length; i++) {
    const offset = backtrackCoverageOffsets[i];
    backtrackCoverages.push(parseCoverageAt(reader, offset));
  }
  const inputCoverages = [];
  for (let i = 0;i < inputCoverageOffsets.length; i++) {
    const offset = inputCoverageOffsets[i];
    inputCoverages.push(parseCoverageAt(reader, offset));
  }
  const lookaheadCoverages = [];
  for (let i = 0;i < lookaheadCoverageOffsets.length; i++) {
    const offset = lookaheadCoverageOffsets[i];
    lookaheadCoverages.push(parseCoverageAt(reader, offset));
  }
  return {
    format: 3,
    backtrackCoverages,
    inputCoverages,
    lookaheadCoverages,
    lookupRecords
  };
}
function parsePosLookupRecords(reader, count) {
  const records = [];
  for (let i = 0;i < count; i++) {
    records.push({
      sequenceIndex: reader.uint16(),
      lookupListIndex: reader.uint16()
    });
  }
  return records;
}

// reference/text-shaper/src/font/tables/gpos-mark.ts
function parseAnchor(reader) {
  const format = reader.uint16();
  const xCoordinate = reader.int16();
  const yCoordinate = reader.int16();
  const anchor = { xCoordinate, yCoordinate };
  if (format === 2) {
    anchor.anchorPoint = reader.uint16();
  } else if (format === 3) {
    anchor.xDeviceOffset = reader.uint16();
    anchor.yDeviceOffset = reader.uint16();
  }
  return anchor;
}
function parseAnchorAt(reader, offset) {
  if (offset === 0)
    return null;
  return parseAnchor(reader.sliceFrom(offset));
}
function parseMarkArray(reader) {
  const markCount = reader.uint16();
  const markRecords = [];
  const recordData = [];
  for (let i = 0;i < markCount; i++) {
    recordData.push({
      markClass: reader.uint16(),
      anchorOffset: reader.uint16()
    });
  }
  for (let i = 0;i < recordData.length; i++) {
    const data = recordData[i];
    const markAnchor = parseAnchor(reader.sliceFrom(data.anchorOffset));
    markRecords.push({
      markClass: data.markClass,
      markAnchor
    });
  }
  return { markRecords };
}
function parseCursivePos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const entryExitCount = r.uint16();
      const entryExitData = [];
      for (let j = 0;j < entryExitCount; j++) {
        entryExitData.push({
          entryOffset: r.uint16(),
          exitOffset: r.uint16()
        });
      }
      const coverage = parseCoverageAt(r, coverageOffset);
      const entryExitRecords = [];
      for (let j = 0;j < entryExitData.length; j++) {
        const data = entryExitData[j];
        entryExitRecords.push({
          entryAnchor: parseAnchorAt(r, data.entryOffset),
          exitAnchor: parseAnchorAt(r, data.exitOffset)
        });
      }
      subtables.push({ coverage, entryExitRecords });
    }
  }
  return subtables;
}
function parseMarkBasePos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const markCoverageOffset = r.offset16();
      const baseCoverageOffset = r.offset16();
      const markClassCount = r.uint16();
      const markArrayOffset = r.offset16();
      const baseArrayOffset = r.offset16();
      const markCoverage = parseCoverageAt(r, markCoverageOffset);
      const baseCoverage = parseCoverageAt(r, baseCoverageOffset);
      const markArray = parseMarkArray(r.sliceFrom(markArrayOffset));
      const baseArrayReader = r.sliceFrom(baseArrayOffset);
      const baseCount = baseArrayReader.uint16();
      const baseArray = [];
      const baseRecordData = [];
      for (let j = 0;j < baseCount; j++) {
        const anchorOffsets = [];
        for (let k = 0;k < markClassCount; k++) {
          anchorOffsets.push(baseArrayReader.uint16());
        }
        baseRecordData.push(anchorOffsets);
      }
      for (let j = 0;j < baseRecordData.length; j++) {
        const anchorOffsets = baseRecordData[j];
        const baseAnchors = [];
        for (let k = 0;k < anchorOffsets.length; k++) {
          const anchorOffset = anchorOffsets[k];
          baseAnchors.push(parseAnchorAt(baseArrayReader, anchorOffset));
        }
        baseArray.push({ baseAnchors });
      }
      subtables.push({
        markCoverage,
        baseCoverage,
        markClassCount,
        markArray,
        baseArray
      });
    }
  }
  return subtables;
}
function parseMarkLigaturePos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const markCoverageOffset = r.offset16();
      const ligatureCoverageOffset = r.offset16();
      const markClassCount = r.uint16();
      const markArrayOffset = r.offset16();
      const ligatureArrayOffset = r.offset16();
      const markCoverage = parseCoverageAt(r, markCoverageOffset);
      const ligatureCoverage = parseCoverageAt(r, ligatureCoverageOffset);
      const markArray = parseMarkArray(r.sliceFrom(markArrayOffset));
      const ligArrayReader = r.sliceFrom(ligatureArrayOffset);
      const ligatureCount = ligArrayReader.uint16();
      const ligatureAttachOffsets = ligArrayReader.uint16Array(ligatureCount);
      const ligatureArray = [];
      for (let j = 0;j < ligatureAttachOffsets.length; j++) {
        const ligAttachOffset = ligatureAttachOffsets[j];
        const ligAttachReader = ligArrayReader.sliceFrom(ligAttachOffset);
        const componentCount = ligAttachReader.uint16();
        const componentRecords = [];
        const componentData = [];
        for (let k = 0;k < componentCount; k++) {
          const anchorOffsets = [];
          for (let l = 0;l < markClassCount; l++) {
            anchorOffsets.push(ligAttachReader.uint16());
          }
          componentData.push(anchorOffsets);
        }
        for (let k = 0;k < componentData.length; k++) {
          const anchorOffsets = componentData[k];
          const ligatureAnchors = [];
          for (let l = 0;l < anchorOffsets.length; l++) {
            const anchorOffset = anchorOffsets[l];
            ligatureAnchors.push(parseAnchorAt(ligAttachReader, anchorOffset));
          }
          componentRecords.push({ ligatureAnchors });
        }
        ligatureArray.push({ componentRecords });
      }
      subtables.push({
        markCoverage,
        ligatureCoverage,
        markClassCount,
        markArray,
        ligatureArray
      });
    }
  }
  return subtables;
}
function parseMarkMarkPos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const mark1CoverageOffset = r.offset16();
      const mark2CoverageOffset = r.offset16();
      const markClassCount = r.uint16();
      const mark1ArrayOffset = r.offset16();
      const mark2ArrayOffset = r.offset16();
      const mark1Coverage = parseCoverageAt(r, mark1CoverageOffset);
      const mark2Coverage = parseCoverageAt(r, mark2CoverageOffset);
      const mark1Array = parseMarkArray(r.sliceFrom(mark1ArrayOffset));
      const mark2ArrayReader = r.sliceFrom(mark2ArrayOffset);
      const mark2Count = mark2ArrayReader.uint16();
      const mark2Array = [];
      const mark2Data = [];
      for (let j = 0;j < mark2Count; j++) {
        const anchorOffsets = [];
        for (let k = 0;k < markClassCount; k++) {
          anchorOffsets.push(mark2ArrayReader.uint16());
        }
        mark2Data.push(anchorOffsets);
      }
      for (let j = 0;j < mark2Data.length; j++) {
        const anchorOffsets = mark2Data[j];
        const mark2Anchors = [];
        for (let k = 0;k < anchorOffsets.length; k++) {
          const anchorOffset = anchorOffsets[k];
          mark2Anchors.push(parseAnchorAt(mark2ArrayReader, anchorOffset));
        }
        mark2Array.push({ mark2Anchors });
      }
      subtables.push({
        mark1Coverage,
        mark2Coverage,
        markClassCount,
        mark1Array,
        mark2Array
      });
    }
  }
  return subtables;
}

// reference/text-shaper/src/font/tables/gpos.ts
var ValueFormat = {
  XPlacement: 1,
  YPlacement: 2,
  XAdvance: 4,
  YAdvance: 8,
  XPlaDevice: 16,
  YPlaDevice: 32,
  XAdvDevice: 64,
  YAdvDevice: 128
};
function parseGpos(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const scriptListOffset = reader.offset16();
  const featureListOffset = reader.offset16();
  const lookupListOffset = reader.offset16();
  if (majorVersion === 1 && minorVersion >= 1) {
    reader.offset32();
  }
  const scriptList = parseScriptList(reader.sliceFrom(scriptListOffset));
  const featureList = parseFeatureList(reader.sliceFrom(featureListOffset));
  const lookupListReader = reader.sliceFrom(lookupListOffset);
  const lookupCount = lookupListReader.uint16();
  const lookupOffsets = lookupListReader.uint16Array(lookupCount);
  const lookups = [];
  for (let i = 0;i < lookupOffsets.length; i++) {
    const lookupOffset = lookupOffsets[i];
    const lookupReader = lookupListReader.sliceFrom(lookupOffset);
    const lookup = parseGposLookup(lookupReader);
    if (lookup) {
      lookups.push(lookup);
    }
  }
  return {
    version: { major: majorVersion, minor: minorVersion },
    scriptList,
    featureList,
    lookups
  };
}
function parseGposLookup(reader) {
  const lookupType = reader.uint16();
  const lookupFlag = reader.uint16();
  const subtableCount = reader.uint16();
  const typedOffsets = reader.uint16Array(subtableCount);
  const subtableOffsets = new Array(typedOffsets.length);
  for (let i = 0;i < typedOffsets.length; i++)
    subtableOffsets[i] = typedOffsets[i];
  let markFilteringSet;
  if (lookupFlag & LookupFlag.UseMarkFilteringSet) {
    markFilteringSet = reader.uint16();
  }
  const baseProps = { flag: lookupFlag, markFilteringSet };
  const buildDigest = (subtables) => {
    const digest = new SetDigest;
    for (let i = 0;i < subtables.length; i++) {
      const st = subtables[i];
      digest.addCoverage(st.coverage);
    }
    return digest;
  };
  const buildMarkDigest = (subtables) => {
    const digest = new SetDigest;
    for (let i = 0;i < subtables.length; i++) {
      const st = subtables[i];
      digest.addCoverage(st.markCoverage);
    }
    return digest;
  };
  switch (lookupType) {
    case 1 /* Single */: {
      const subtables = parseSinglePos(reader, subtableOffsets);
      return {
        type: 1 /* Single */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 2 /* Pair */: {
      const subtables = parsePairPos(reader, subtableOffsets);
      return {
        type: 2 /* Pair */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 3 /* Cursive */: {
      const subtables = parseCursivePos(reader, subtableOffsets);
      return {
        type: 3 /* Cursive */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 4 /* MarkToBase */: {
      const subtables = parseMarkBasePos(reader, subtableOffsets);
      return {
        type: 4 /* MarkToBase */,
        ...baseProps,
        subtables,
        digest: buildMarkDigest(subtables)
      };
    }
    case 5 /* MarkToLigature */: {
      const subtables = parseMarkLigaturePos(reader, subtableOffsets);
      return {
        type: 5 /* MarkToLigature */,
        ...baseProps,
        subtables,
        digest: buildMarkDigest(subtables)
      };
    }
    case 6 /* MarkToMark */: {
      const subtables = parseMarkMarkPos(reader, subtableOffsets);
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        digest.addCoverage(st.mark1Coverage);
      }
      return {
        type: 6 /* MarkToMark */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 7 /* Context */: {
      const subtables = parseContextPos(reader, subtableOffsets);
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        }
      }
      return {
        type: 7 /* Context */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 8 /* ChainingContext */: {
      const subtables = parseChainingContextPos(reader, subtableOffsets);
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        } else if ("inputCoverages" in st && st.inputCoverages?.[0]) {
          digest.addCoverage(st.inputCoverages[0]);
        }
      }
      return {
        type: 8 /* ChainingContext */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 9 /* Extension */:
      return parseExtensionLookup(reader, subtableOffsets, baseProps);
    default:
      return null;
  }
}
function parseValueRecord(reader, valueFormat, subtableReader) {
  const record = {};
  if (valueFormat & ValueFormat.XPlacement)
    record.xPlacement = reader.int16();
  if (valueFormat & ValueFormat.YPlacement)
    record.yPlacement = reader.int16();
  if (valueFormat & ValueFormat.XAdvance)
    record.xAdvance = reader.int16();
  if (valueFormat & ValueFormat.YAdvance)
    record.yAdvance = reader.int16();
  const deviceReader = subtableReader ?? reader;
  if (valueFormat & ValueFormat.XPlaDevice) {
    const offset = reader.uint16();
    if (offset !== 0)
      record.xPlaDevice = parseDeviceAt(deviceReader, offset) ?? undefined;
  }
  if (valueFormat & ValueFormat.YPlaDevice) {
    const offset = reader.uint16();
    if (offset !== 0)
      record.yPlaDevice = parseDeviceAt(deviceReader, offset) ?? undefined;
  }
  if (valueFormat & ValueFormat.XAdvDevice) {
    const offset = reader.uint16();
    if (offset !== 0)
      record.xAdvDevice = parseDeviceAt(deviceReader, offset) ?? undefined;
  }
  if (valueFormat & ValueFormat.YAdvDevice) {
    const offset = reader.uint16();
    if (offset !== 0)
      record.yAdvDevice = parseDeviceAt(deviceReader, offset) ?? undefined;
  }
  return record;
}
function parseSinglePos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const subtableReader = reader.sliceFrom(offset);
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const valueFormat = r.uint16();
      const value = parseValueRecord(r, valueFormat, subtableReader);
      const coverage = parseCoverageAt(subtableReader, coverageOffset);
      subtables.push({ format: 1, coverage, valueFormat, value });
    } else if (format === 2) {
      const coverageOffset = r.offset16();
      const valueFormat = r.uint16();
      const valueCount = r.uint16();
      const values = [];
      for (let j = 0;j < valueCount; j++) {
        values.push(parseValueRecord(r, valueFormat, subtableReader));
      }
      const coverage = parseCoverageAt(subtableReader, coverageOffset);
      subtables.push({ format: 2, coverage, valueFormat, values });
    }
  }
  return subtables;
}
function parsePairPos(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const subtableReader = reader.sliceFrom(offset);
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      subtables.push(parsePairPosFormat1(r, subtableReader));
    } else if (format === 2) {
      subtables.push(parsePairPosFormat2(r, subtableReader));
    }
  }
  return subtables;
}
function parsePairPosFormat1(reader, subtableReader) {
  const coverageOffset = reader.offset16();
  const valueFormat1 = reader.uint16();
  const valueFormat2 = reader.uint16();
  const pairSetCount = reader.uint16();
  const pairSetOffsets = reader.uint16Array(pairSetCount);
  const coverage = parseCoverageAt(subtableReader, coverageOffset);
  const pairSets = [];
  for (let i = 0;i < pairSetOffsets.length; i++) {
    const pairSetOffset = pairSetOffsets[i];
    const pairSetReader = subtableReader.sliceFrom(pairSetOffset);
    const r = subtableReader.sliceFrom(pairSetOffset);
    const pairValueCount = r.uint16();
    const pairValueRecords = [];
    for (let j = 0;j < pairValueCount; j++) {
      const secondGlyph = r.uint16();
      const value1 = parseValueRecord(r, valueFormat1, pairSetReader);
      const value2 = parseValueRecord(r, valueFormat2, pairSetReader);
      pairValueRecords.push({ secondGlyph, value1, value2 });
    }
    pairSets.push({ pairValueRecords });
  }
  return { format: 1, coverage, valueFormat1, valueFormat2, pairSets };
}
function parsePairPosFormat2(reader, subtableReader) {
  const coverageOffset = reader.offset16();
  const valueFormat1 = reader.uint16();
  const valueFormat2 = reader.uint16();
  const classDef1Offset = reader.offset16();
  const classDef2Offset = reader.offset16();
  const class1Count = reader.uint16();
  const class2Count = reader.uint16();
  const coverage = parseCoverageAt(subtableReader, coverageOffset);
  const classDef1 = parseClassDefAt(subtableReader, classDef1Offset);
  const classDef2 = parseClassDefAt(subtableReader, classDef2Offset);
  const class1Records = [];
  for (let i = 0;i < class1Count; i++) {
    const class2Records = [];
    for (let j = 0;j < class2Count; j++) {
      const value1 = parseValueRecord(reader, valueFormat1, subtableReader);
      const value2 = parseValueRecord(reader, valueFormat2, subtableReader);
      class2Records.push({ value1, value2 });
    }
    class1Records.push({ class2Records });
  }
  return {
    format: 2,
    coverage,
    valueFormat1,
    valueFormat2,
    classDef1,
    classDef2,
    class1Count,
    class2Count,
    class1Records
  };
}
function parseExtensionLookup(reader, subtableOffsets, baseProps) {
  if (subtableOffsets.length === 0)
    return null;
  const extSubtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const extReader = reader.sliceFrom(offset);
    const format = extReader.uint16();
    if (format !== 1)
      continue;
    const extensionLookupType = extReader.uint16();
    const extensionOffset = extReader.uint32();
    extSubtables.push({
      type: extensionLookupType,
      reader: extReader.sliceFrom(extensionOffset)
    });
  }
  if (extSubtables.length === 0)
    return null;
  const actualType = extSubtables[0]?.type;
  const buildDigest = (subtables) => {
    const digest = new SetDigest;
    for (let i = 0;i < subtables.length; i++) {
      const st = subtables[i];
      digest.addCoverage(st.coverage);
    }
    return digest;
  };
  const buildMarkDigest = (subtables) => {
    const digest = new SetDigest;
    for (let i = 0;i < subtables.length; i++) {
      const st = subtables[i];
      digest.addCoverage(st.markCoverage);
    }
    return digest;
  };
  switch (actualType) {
    case 1 /* Single */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseSinglePos(ext.reader, [0]));
      }
      return {
        type: 1 /* Single */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 2 /* Pair */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parsePairPos(ext.reader, [0]));
      }
      return {
        type: 2 /* Pair */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 3 /* Cursive */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseCursivePos(ext.reader, [0]));
      }
      return {
        type: 3 /* Cursive */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 4 /* MarkToBase */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseMarkBasePos(ext.reader, [0]));
      }
      return {
        type: 4 /* MarkToBase */,
        ...baseProps,
        subtables,
        digest: buildMarkDigest(subtables)
      };
    }
    case 5 /* MarkToLigature */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseMarkLigaturePos(ext.reader, [0]));
      }
      return {
        type: 5 /* MarkToLigature */,
        ...baseProps,
        subtables,
        digest: buildMarkDigest(subtables)
      };
    }
    case 6 /* MarkToMark */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseMarkMarkPos(ext.reader, [0]));
      }
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        digest.addCoverage(st.mark1Coverage);
      }
      return {
        type: 6 /* MarkToMark */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 7 /* Context */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseContextPos(ext.reader, [0]));
      }
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        }
      }
      return { type: 7 /* Context */, ...baseProps, subtables, digest };
    }
    case 8 /* ChainingContext */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseChainingContextPos(ext.reader, [0]));
      }
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        } else if ("inputCoverages" in st && st.inputCoverages?.[0]) {
          digest.addCoverage(st.inputCoverages[0]);
        }
      }
      return {
        type: 8 /* ChainingContext */,
        ...baseProps,
        subtables,
        digest
      };
    }
    default:
      return null;
  }
}
function findPairValueRecord(records, secondGlyph) {
  let low = 0;
  let high = records.length - 1;
  while (low <= high) {
    const mid = low + high >>> 1;
    const record = records[mid];
    const sg = record.secondGlyph;
    if (sg < secondGlyph) {
      low = mid + 1;
    } else if (sg > secondGlyph) {
      high = mid - 1;
    } else {
      return record;
    }
  }
  return null;
}
function applyKerningDirect(lookup, firstGlyph, secondGlyph, pos1, pos2) {
  for (let i = 0;i < lookup.subtables.length; i++) {
    const subtable = lookup.subtables[i];
    const coverageIndex = subtable.coverage.get(firstGlyph);
    if (coverageIndex === null)
      continue;
    if (subtable.format === 1) {
      const pairSet = subtable.pairSets[coverageIndex];
      if (!pairSet)
        continue;
      const record = findPairValueRecord(pairSet.pairValueRecords, secondGlyph);
      if (record) {
        const xAdv1 = record.value1.xAdvance;
        const xAdv2 = record.value2.xAdvance;
        if (xAdv1)
          pos1.xAdvance += xAdv1;
        if (xAdv2)
          pos2.xAdvance += xAdv2;
        return true;
      }
    } else if (subtable.format === 2) {
      const class1 = subtable.classDef1.get(firstGlyph);
      const class1Records = subtable.class1Records;
      if (class1 >= class1Records.length)
        continue;
      const class1Record = class1Records[class1];
      const class2 = subtable.classDef2.get(secondGlyph);
      const class2Records = class1Record.class2Records;
      if (class2 >= class2Records.length)
        continue;
      const class2Record = class2Records[class2];
      const xAdv1 = class2Record.value1.xAdvance;
      const xAdv2 = class2Record.value2.xAdvance;
      if (xAdv1)
        pos1.xAdvance += xAdv1;
      if (xAdv2)
        pos2.xAdvance += xAdv2;
      return true;
    }
  }
  return false;
}

// reference/text-shaper/src/font/tables/gsub-contextual.ts
function parseContextSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    switch (format) {
      case 1:
        subtables.push(parseContextFormat1(r));
        break;
      case 2:
        subtables.push(parseContextFormat2(r));
        break;
      case 3:
        subtables.push(parseContextFormat3(r));
        break;
    }
  }
  return subtables;
}
function parseContextFormat1(reader) {
  const coverageOffset = reader.offset16();
  const ruleSetCount = reader.uint16();
  const ruleSetOffsets = reader.uint16Array(ruleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const ruleSets = [];
  for (let i = 0;i < ruleSetOffsets.length; i++) {
    const ruleSetOffset = ruleSetOffsets[i];
    if (ruleSetOffset === 0) {
      ruleSets.push(null);
      continue;
    }
    const rsReader = reader.sliceFrom(ruleSetOffset);
    const ruleCount = rsReader.uint16();
    const ruleOffsets = rsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = rsReader.sliceFrom(ruleOffset);
      const glyphCount = ruleReader.uint16();
      const lookupCount = ruleReader.uint16();
      const typedArr = ruleReader.uint16Array(glyphCount - 1);
      const inputSequence = new Array(typedArr.length);
      for (let k = 0;k < typedArr.length; k++)
        inputSequence[k] = typedArr[k];
      const lookupRecords = parseLookupRecords(ruleReader, lookupCount);
      rules.push({ glyphCount, inputSequence, lookupRecords });
    }
    ruleSets.push(rules);
  }
  return { format: 1, coverage, ruleSets };
}
function parseContextFormat2(reader) {
  const coverageOffset = reader.offset16();
  const classDefOffset = reader.offset16();
  const classRuleSetCount = reader.uint16();
  const classRuleSetOffsets = reader.uint16Array(classRuleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const classDef = parseClassDefAt(reader, classDefOffset);
  const classRuleSets = [];
  for (let i = 0;i < classRuleSetOffsets.length; i++) {
    const crsOffset = classRuleSetOffsets[i];
    if (crsOffset === 0) {
      classRuleSets.push(null);
      continue;
    }
    const crsReader = reader.sliceFrom(crsOffset);
    const ruleCount = crsReader.uint16();
    const ruleOffsets = crsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = crsReader.sliceFrom(ruleOffset);
      const glyphCount = ruleReader.uint16();
      const lookupCount = ruleReader.uint16();
      const typedArr = ruleReader.uint16Array(glyphCount - 1);
      const inputClasses = new Array(typedArr.length);
      for (let k = 0;k < typedArr.length; k++)
        inputClasses[k] = typedArr[k];
      const lookupRecords = parseLookupRecords(ruleReader, lookupCount);
      rules.push({ glyphCount, inputClasses, lookupRecords });
    }
    classRuleSets.push(rules);
  }
  return { format: 2, coverage, classDef, classRuleSets };
}
function parseContextFormat3(reader) {
  const glyphCount = reader.uint16();
  const lookupCount = reader.uint16();
  const coverageOffsets = reader.uint16Array(glyphCount);
  const coverages = [];
  for (let i = 0;i < coverageOffsets.length; i++) {
    const offset = coverageOffsets[i];
    coverages.push(parseCoverageAt(reader, offset));
  }
  const lookupRecords = parseLookupRecords(reader, lookupCount);
  return { format: 3, coverages, lookupRecords };
}
function parseChainingContextSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    switch (format) {
      case 1:
        subtables.push(parseChainingFormat1(r));
        break;
      case 2:
        subtables.push(parseChainingFormat2(r));
        break;
      case 3:
        subtables.push(parseChainingFormat3(r));
        break;
    }
  }
  return subtables;
}
function parseChainingFormat1(reader) {
  const coverageOffset = reader.offset16();
  const chainRuleSetCount = reader.uint16();
  const chainRuleSetOffsets = reader.uint16Array(chainRuleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const chainRuleSets = [];
  for (let i = 0;i < chainRuleSetOffsets.length; i++) {
    const crsOffset = chainRuleSetOffsets[i];
    if (crsOffset === 0) {
      chainRuleSets.push(null);
      continue;
    }
    const crsReader = reader.sliceFrom(crsOffset);
    const ruleCount = crsReader.uint16();
    const ruleOffsets = crsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = crsReader.sliceFrom(ruleOffset);
      const backtrackCount = ruleReader.uint16();
      const backtrackTyped = ruleReader.uint16Array(backtrackCount);
      const backtrackSequence = new Array(backtrackTyped.length);
      for (let k = 0;k < backtrackTyped.length; k++)
        backtrackSequence[k] = backtrackTyped[k];
      const inputCount = ruleReader.uint16();
      const inputTyped = ruleReader.uint16Array(inputCount - 1);
      const inputSequence = new Array(inputTyped.length);
      for (let k = 0;k < inputTyped.length; k++)
        inputSequence[k] = inputTyped[k];
      const lookaheadCount = ruleReader.uint16();
      const lookaheadTyped = ruleReader.uint16Array(lookaheadCount);
      const lookaheadSequence = new Array(lookaheadTyped.length);
      for (let k = 0;k < lookaheadTyped.length; k++)
        lookaheadSequence[k] = lookaheadTyped[k];
      const lookupCount = ruleReader.uint16();
      const lookupRecords = parseLookupRecords(ruleReader, lookupCount);
      rules.push({
        backtrackSequence,
        inputSequence,
        lookaheadSequence,
        lookupRecords
      });
    }
    chainRuleSets.push(rules);
  }
  return { format: 1, coverage, chainRuleSets };
}
function parseChainingFormat2(reader) {
  const coverageOffset = reader.offset16();
  const backtrackClassDefOffset = reader.offset16();
  const inputClassDefOffset = reader.offset16();
  const lookaheadClassDefOffset = reader.offset16();
  const chainClassRuleSetCount = reader.uint16();
  const chainClassRuleSetOffsets = reader.uint16Array(chainClassRuleSetCount);
  const coverage = parseCoverageAt(reader, coverageOffset);
  const backtrackClassDef = parseClassDefAt(reader, backtrackClassDefOffset);
  const inputClassDef = parseClassDefAt(reader, inputClassDefOffset);
  const lookaheadClassDef = parseClassDefAt(reader, lookaheadClassDefOffset);
  const chainClassRuleSets = [];
  for (let i = 0;i < chainClassRuleSetOffsets.length; i++) {
    const ccrsOffset = chainClassRuleSetOffsets[i];
    if (ccrsOffset === 0) {
      chainClassRuleSets.push(null);
      continue;
    }
    const ccrsReader = reader.sliceFrom(ccrsOffset);
    const ruleCount = ccrsReader.uint16();
    const ruleOffsets = ccrsReader.uint16Array(ruleCount);
    const rules = [];
    for (let j = 0;j < ruleOffsets.length; j++) {
      const ruleOffset = ruleOffsets[j];
      const ruleReader = ccrsReader.sliceFrom(ruleOffset);
      const backtrackCount = ruleReader.uint16();
      const backtrackTyped = ruleReader.uint16Array(backtrackCount);
      const backtrackClasses = new Array(backtrackTyped.length);
      for (let k = 0;k < backtrackTyped.length; k++)
        backtrackClasses[k] = backtrackTyped[k];
      const inputCount = ruleReader.uint16();
      const inputTyped = ruleReader.uint16Array(inputCount - 1);
      const inputClasses = new Array(inputTyped.length);
      for (let k = 0;k < inputTyped.length; k++)
        inputClasses[k] = inputTyped[k];
      const lookaheadCount = ruleReader.uint16();
      const lookaheadTyped = ruleReader.uint16Array(lookaheadCount);
      const lookaheadClasses = new Array(lookaheadTyped.length);
      for (let k = 0;k < lookaheadTyped.length; k++)
        lookaheadClasses[k] = lookaheadTyped[k];
      const lookupCount = ruleReader.uint16();
      const lookupRecords = parseLookupRecords(ruleReader, lookupCount);
      rules.push({
        backtrackClasses,
        inputClasses,
        lookaheadClasses,
        lookupRecords
      });
    }
    chainClassRuleSets.push(rules);
  }
  return {
    format: 2,
    coverage,
    backtrackClassDef,
    inputClassDef,
    lookaheadClassDef,
    chainClassRuleSets
  };
}
function parseChainingFormat3(reader) {
  const backtrackCount = reader.uint16();
  const backtrackCoverageOffsets = reader.uint16Array(backtrackCount);
  const inputCount = reader.uint16();
  const inputCoverageOffsets = reader.uint16Array(inputCount);
  const lookaheadCount = reader.uint16();
  const lookaheadCoverageOffsets = reader.uint16Array(lookaheadCount);
  const lookupCount = reader.uint16();
  const lookupRecords = parseLookupRecords(reader, lookupCount);
  const backtrackCoverages = [];
  for (let i = 0;i < backtrackCoverageOffsets.length; i++) {
    const offset = backtrackCoverageOffsets[i];
    backtrackCoverages.push(parseCoverageAt(reader, offset));
  }
  const inputCoverages = [];
  for (let i = 0;i < inputCoverageOffsets.length; i++) {
    const offset = inputCoverageOffsets[i];
    inputCoverages.push(parseCoverageAt(reader, offset));
  }
  const lookaheadCoverages = [];
  for (let i = 0;i < lookaheadCoverageOffsets.length; i++) {
    const offset = lookaheadCoverageOffsets[i];
    lookaheadCoverages.push(parseCoverageAt(reader, offset));
  }
  return {
    format: 3,
    backtrackCoverages,
    inputCoverages,
    lookaheadCoverages,
    lookupRecords
  };
}
function parseLookupRecords(reader, count) {
  const records = [];
  for (let i = 0;i < count; i++) {
    records.push({
      sequenceIndex: reader.uint16(),
      lookupListIndex: reader.uint16()
    });
  }
  return records;
}

// reference/text-shaper/src/font/tables/gsub.ts
function parseGsub(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const scriptListOffset = reader.offset16();
  const featureListOffset = reader.offset16();
  const lookupListOffset = reader.offset16();
  if (majorVersion === 1 && minorVersion >= 1) {
    reader.offset32();
  }
  const scriptList = parseScriptList(reader.sliceFrom(scriptListOffset));
  const featureList = parseFeatureList(reader.sliceFrom(featureListOffset));
  const lookupListReader = reader.sliceFrom(lookupListOffset);
  const lookupCount = lookupListReader.uint16();
  const lookupOffsets = lookupListReader.uint16Array(lookupCount);
  const lookups = [];
  for (let i = 0;i < lookupOffsets.length; i++) {
    const lookupOffset = lookupOffsets[i];
    const lookupReader = lookupListReader.sliceFrom(lookupOffset);
    const lookup = parseGsubLookup(lookupReader, lookupListReader, lookupOffset);
    if (lookup) {
      lookups.push(lookup);
    }
  }
  return {
    version: { major: majorVersion, minor: minorVersion },
    scriptList,
    featureList,
    lookups
  };
}
function parseGsubLookup(reader, _lookupListReader, _lookupOffset) {
  const lookupType = reader.uint16();
  const lookupFlag = reader.uint16();
  const subtableCount = reader.uint16();
  const typedOffsets = reader.uint16Array(subtableCount);
  const subtableOffsets = new Array(typedOffsets.length);
  for (let i = 0;i < typedOffsets.length; i++)
    subtableOffsets[i] = typedOffsets[i];
  let markFilteringSet;
  if (lookupFlag & LookupFlag.UseMarkFilteringSet) {
    markFilteringSet = reader.uint16();
  }
  const baseProps = { flag: lookupFlag, markFilteringSet };
  const buildDigest = (subtables) => {
    const digest = new SetDigest;
    for (let i = 0;i < subtables.length; i++) {
      const st = subtables[i];
      digest.addCoverage(st.coverage);
    }
    return digest;
  };
  switch (lookupType) {
    case 1 /* Single */: {
      const subtables = parseSingleSubst(reader, subtableOffsets);
      return {
        type: 1 /* Single */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 2 /* Multiple */: {
      const subtables = parseMultipleSubst(reader, subtableOffsets);
      return {
        type: 2 /* Multiple */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 3 /* Alternate */: {
      const subtables = parseAlternateSubst(reader, subtableOffsets);
      return {
        type: 3 /* Alternate */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 4 /* Ligature */: {
      const subtables = parseLigatureSubst(reader, subtableOffsets);
      return {
        type: 4 /* Ligature */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 5 /* Context */: {
      const subtables = parseContextSubst(reader, subtableOffsets);
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        }
      }
      return {
        type: 5 /* Context */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 6 /* ChainingContext */: {
      const subtables = parseChainingContextSubst(reader, subtableOffsets);
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        } else if ("inputCoverages" in st && st.inputCoverages?.[0]) {
          digest.addCoverage(st.inputCoverages[0]);
        }
      }
      return {
        type: 6 /* ChainingContext */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 7 /* Extension */:
      return parseExtensionLookup2(reader, subtableOffsets, baseProps);
    case 8 /* ReverseChainingSingle */: {
      const subtables = parseReverseChainingSingleSubst(reader, subtableOffsets);
      return {
        type: 8 /* ReverseChainingSingle */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    default:
      return null;
  }
}
function parseSingleSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const deltaGlyphId = r.int16();
      const coverage = parseCoverageAt(r, coverageOffset);
      subtables.push({ format: 1, coverage, deltaGlyphId });
    } else if (format === 2) {
      const coverageOffset = r.offset16();
      const glyphCount = r.uint16();
      const typedIds = r.uint16Array(glyphCount);
      const substituteGlyphIds = new Array(typedIds.length);
      for (let j = 0;j < typedIds.length; j++)
        substituteGlyphIds[j] = typedIds[j];
      const coverage = parseCoverageAt(r, coverageOffset);
      subtables.push({ format: 2, coverage, substituteGlyphIds });
    }
  }
  return subtables;
}
function parseMultipleSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const sequenceCount = r.uint16();
      const sequenceOffsets = r.uint16Array(sequenceCount);
      const coverage = parseCoverageAt(r, coverageOffset);
      const sequences = [];
      for (let j = 0;j < sequenceOffsets.length; j++) {
        const seqOffset = sequenceOffsets[j];
        const seqReader = r.sliceFrom(seqOffset);
        const glyphCount = seqReader.uint16();
        const typedSeq = seqReader.uint16Array(glyphCount);
        const seq = new Array(typedSeq.length);
        for (let k = 0;k < typedSeq.length; k++)
          seq[k] = typedSeq[k];
        sequences.push(seq);
      }
      subtables.push({ coverage, sequences });
    }
  }
  return subtables;
}
function parseAlternateSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const alternateSetCount = r.uint16();
      const alternateSetOffsets = r.uint16Array(alternateSetCount);
      const coverage = parseCoverageAt(r, coverageOffset);
      const alternateSets = [];
      for (let j = 0;j < alternateSetOffsets.length; j++) {
        const altOffset = alternateSetOffsets[j];
        const altReader = r.sliceFrom(altOffset);
        const glyphCount = altReader.uint16();
        const typedAlts = altReader.uint16Array(glyphCount);
        const alts = new Array(typedAlts.length);
        for (let k = 0;k < typedAlts.length; k++)
          alts[k] = typedAlts[k];
        alternateSets.push(alts);
      }
      subtables.push({ coverage, alternateSets });
    }
  }
  return subtables;
}
function parseLigatureSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const ligatureSetCount = r.uint16();
      const ligatureSetOffsets = r.uint16Array(ligatureSetCount);
      const coverage = parseCoverageAt(r, coverageOffset);
      const ligatureSets = [];
      for (let j = 0;j < ligatureSetOffsets.length; j++) {
        const setOffset = ligatureSetOffsets[j];
        const setReader = r.sliceFrom(setOffset);
        const ligatureCount = setReader.uint16();
        const ligatureOffsets = setReader.uint16Array(ligatureCount);
        const ligatures = [];
        for (let k = 0;k < ligatureOffsets.length; k++) {
          const ligOffset = ligatureOffsets[k];
          const ligReader = setReader.sliceFrom(ligOffset);
          const ligatureGlyph = ligReader.uint16();
          const componentCount = ligReader.uint16();
          const typedComps = ligReader.uint16Array(componentCount - 1);
          const componentGlyphIds = new Array(typedComps.length);
          for (let m = 0;m < typedComps.length; m++)
            componentGlyphIds[m] = typedComps[m];
          ligatures.push({ ligatureGlyph, componentGlyphIds });
        }
        ligatureSets.push({ ligatures });
      }
      subtables.push({ coverage, ligatureSets });
    }
  }
  return subtables;
}
function parseReverseChainingSingleSubst(reader, subtableOffsets) {
  const subtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const r = reader.sliceFrom(offset);
    const format = r.uint16();
    if (format === 1) {
      const coverageOffset = r.offset16();
      const backtrackCount = r.uint16();
      const backtrackCoverageOffsets = r.uint16Array(backtrackCount);
      const lookaheadCount = r.uint16();
      const lookaheadCoverageOffsets = r.uint16Array(lookaheadCount);
      const glyphCount = r.uint16();
      const typedIds = r.uint16Array(glyphCount);
      const substituteGlyphIds = new Array(typedIds.length);
      for (let j = 0;j < typedIds.length; j++)
        substituteGlyphIds[j] = typedIds[j];
      const coverage = parseCoverageAt(r, coverageOffset);
      const backtrackCoverages = [];
      for (let j = 0;j < backtrackCoverageOffsets.length; j++) {
        const covOffset = backtrackCoverageOffsets[j];
        backtrackCoverages.push(parseCoverageAt(r, covOffset));
      }
      const lookaheadCoverages = [];
      for (let j = 0;j < lookaheadCoverageOffsets.length; j++) {
        const covOffset = lookaheadCoverageOffsets[j];
        lookaheadCoverages.push(parseCoverageAt(r, covOffset));
      }
      subtables.push({
        coverage,
        backtrackCoverages,
        lookaheadCoverages,
        substituteGlyphIds
      });
    }
  }
  return subtables;
}
function parseExtensionLookup2(reader, subtableOffsets, baseProps) {
  if (subtableOffsets.length === 0)
    return null;
  const extSubtables = [];
  for (let i = 0;i < subtableOffsets.length; i++) {
    const offset = subtableOffsets[i];
    const extReader = reader.sliceFrom(offset);
    const format = extReader.uint16();
    if (format !== 1)
      continue;
    const extensionLookupType = extReader.uint16();
    const extensionOffset = extReader.uint32();
    extSubtables.push({
      type: extensionLookupType,
      reader: extReader.sliceFrom(extensionOffset)
    });
  }
  if (extSubtables.length === 0)
    return null;
  const actualType = extSubtables[0]?.type;
  const _actualOffsets = extSubtables.map((_, _i) => 0);
  const buildDigest = (subtables) => {
    const digest = new SetDigest;
    for (let i = 0;i < subtables.length; i++) {
      const st = subtables[i];
      digest.addCoverage(st.coverage);
    }
    return digest;
  };
  switch (actualType) {
    case 1 /* Single */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseSingleSubst(ext.reader, [0]));
      }
      return {
        type: 1 /* Single */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 2 /* Multiple */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseMultipleSubst(ext.reader, [0]));
      }
      return {
        type: 2 /* Multiple */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 3 /* Alternate */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseAlternateSubst(ext.reader, [0]));
      }
      return {
        type: 3 /* Alternate */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 4 /* Ligature */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseLigatureSubst(ext.reader, [0]));
      }
      return {
        type: 4 /* Ligature */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    case 5 /* Context */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseContextSubst(ext.reader, [0]));
      }
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        }
      }
      return { type: 5 /* Context */, ...baseProps, subtables, digest };
    }
    case 6 /* ChainingContext */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseChainingContextSubst(ext.reader, [0]));
      }
      const digest = new SetDigest;
      for (let i = 0;i < subtables.length; i++) {
        const st = subtables[i];
        if ("coverage" in st && st.coverage) {
          digest.addCoverage(st.coverage);
        } else if ("inputCoverages" in st && st.inputCoverages?.[0]) {
          digest.addCoverage(st.inputCoverages[0]);
        }
      }
      return {
        type: 6 /* ChainingContext */,
        ...baseProps,
        subtables,
        digest
      };
    }
    case 8 /* ReverseChainingSingle */: {
      const subtables = [];
      for (let i = 0;i < extSubtables.length; i++) {
        const ext = extSubtables[i];
        subtables.push(...parseReverseChainingSingleSubst(ext.reader, [0]));
      }
      return {
        type: 8 /* ReverseChainingSingle */,
        ...baseProps,
        subtables,
        digest: buildDigest(subtables)
      };
    }
    default:
      return null;
  }
}
function applySingleSubst(lookup, glyphId) {
  for (let i = 0;i < lookup.subtables.length; i++) {
    const subtable = lookup.subtables[i];
    const coverageIndex = subtable.coverage.get(glyphId);
    if (coverageIndex === null)
      continue;
    if (subtable.format === 1 && subtable.deltaGlyphId !== undefined) {
      return glyphId + subtable.deltaGlyphId & 65535;
    }
    if (subtable.format === 2 && subtable.substituteGlyphIds) {
      return subtable.substituteGlyphIds[coverageIndex] ?? null;
    }
  }
  return null;
}
function applyLigatureSubstDirect(lookup, glyphIds, matchLen, startIndex) {
  const firstGlyph = glyphIds[startIndex];
  if (firstGlyph === undefined)
    return null;
  for (let i = 0;i < lookup.subtables.length; i++) {
    const subtable = lookup.subtables[i];
    const coverageIndex = subtable.coverage.get(firstGlyph);
    if (coverageIndex === null)
      continue;
    const ligatureSet = subtable.ligatureSets[coverageIndex];
    if (!ligatureSet)
      continue;
    for (let j = 0;j < ligatureSet.ligatures.length; j++) {
      const ligature = ligatureSet.ligatures[j];
      const componentCount = ligature.componentGlyphIds.length;
      if (startIndex + 1 + componentCount > matchLen)
        continue;
      let matches = true;
      for (let k = 0;k < componentCount; k++) {
        if (glyphIds[startIndex + 1 + k] !== ligature.componentGlyphIds[k]) {
          matches = false;
          break;
        }
      }
      if (matches) {
        return {
          ligatureGlyph: ligature.ligatureGlyph,
          consumed: 1 + componentCount
        };
      }
    }
  }
  return null;
}

// reference/text-shaper/src/font/tables/head.ts
var HEAD_MAGIC_NUMBER = 1594834165;
function parseHead(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const fontRevision = reader.fixed();
  const checksumAdjustment = reader.uint32();
  const magicNumber = reader.uint32();
  if (magicNumber !== HEAD_MAGIC_NUMBER) {
    throw new Error(`Invalid head table magic number: 0x${magicNumber.toString(16)}`);
  }
  const flags = reader.uint16();
  const unitsPerEm = reader.uint16();
  const created = reader.longDateTime();
  const modified = reader.longDateTime();
  const xMin = reader.fword();
  const yMin = reader.fword();
  const xMax = reader.fword();
  const yMax = reader.fword();
  const macStyle = reader.uint16();
  const lowestRecPPEM = reader.uint16();
  const fontDirectionHint = reader.int16();
  const indexToLocFormat = reader.int16();
  const glyphDataFormat = reader.int16();
  return {
    majorVersion,
    minorVersion,
    fontRevision,
    checksumAdjustment,
    magicNumber,
    flags,
    unitsPerEm,
    created,
    modified,
    xMin,
    yMin,
    xMax,
    yMax,
    macStyle,
    lowestRecPPEM,
    fontDirectionHint,
    indexToLocFormat,
    glyphDataFormat
  };
}

// reference/text-shaper/src/font/tables/hhea.ts
function parseHhea(reader) {
  return {
    majorVersion: reader.uint16(),
    minorVersion: reader.uint16(),
    ascender: reader.fword(),
    descender: reader.fword(),
    lineGap: reader.fword(),
    advanceWidthMax: reader.ufword(),
    minLeftSideBearing: reader.fword(),
    minRightSideBearing: reader.fword(),
    xMaxExtent: reader.fword(),
    caretSlopeRise: reader.int16(),
    caretSlopeRun: reader.int16(),
    caretOffset: reader.int16(),
    reserved1: reader.int16(),
    reserved2: reader.int16(),
    reserved3: reader.int16(),
    reserved4: reader.int16(),
    metricDataFormat: reader.int16(),
    numberOfHMetrics: reader.uint16()
  };
}

// reference/text-shaper/src/font/tables/hinting.ts
function parseFpgm(reader) {
  const instructions = reader.bytes(reader.remaining);
  return { instructions };
}
function parsePrep(reader) {
  const instructions = reader.bytes(reader.remaining);
  return { instructions };
}
function parseCvt(reader) {
  const count = Math.floor(reader.remaining / 2);
  const values = new Int16Array(count);
  for (let i = 0;i < count; i++) {
    values[i] = reader.int16();
  }
  return { values };
}

// reference/text-shaper/src/font/tables/hmtx.ts
function parseHmtx(reader, numberOfHMetrics, numGlyphs) {
  const hMetrics = new Array(numberOfHMetrics);
  for (let i = 0;i < numberOfHMetrics; i++) {
    hMetrics[i] = {
      advanceWidth: reader.ufword(),
      lsb: reader.fword()
    };
  }
  const numLeftSideBearings = numGlyphs - numberOfHMetrics;
  const leftSideBearings = new Array(numLeftSideBearings);
  for (let i = 0;i < numLeftSideBearings; i++) {
    leftSideBearings[i] = reader.fword();
  }
  return { hMetrics, leftSideBearings };
}
function getAdvanceWidth(hmtx, glyphId) {
  if (glyphId < hmtx.hMetrics.length) {
    return hmtx.hMetrics[glyphId]?.advanceWidth;
  }
  return hmtx.hMetrics[hmtx.hMetrics.length - 1]?.advanceWidth;
}
function getLeftSideBearing(hmtx, glyphId) {
  if (glyphId < hmtx.hMetrics.length) {
    return hmtx.hMetrics[glyphId]?.lsb;
  }
  const idx = glyphId - hmtx.hMetrics.length;
  return hmtx.leftSideBearings[idx] ?? 0;
}

// reference/text-shaper/src/font/tables/jstf.ts
var JstfPriority = {
  ShrinkGpos: 0,
  DisableGpos: 1,
  ShrinkGsub: 2,
  DisableGsub: 3,
  EnableGpos: 4,
  EnableGsub: 5,
  MaxExtendGpos: 6,
  MaxExtendGsub: 7
};
function parseJstfModList(reader, offset) {
  if (offset === 0)
    return null;
  const modReader = reader.sliceFrom(offset);
  const lookupCount = modReader.uint16();
  const lookupIndices = [];
  for (let i = 0;i < lookupCount; i++) {
    lookupIndices.push(modReader.uint16());
  }
  return { lookupIndices };
}
function parseJstfMax(reader, offset) {
  if (offset === 0)
    return null;
  const maxReader = reader.sliceFrom(offset);
  const lookupCount = maxReader.uint16();
  const lookupIndices = [];
  for (let i = 0;i < lookupCount; i++) {
    lookupIndices.push(maxReader.uint16());
  }
  return { lookupIndices };
}
function parseJstfPriority(reader, offset) {
  const priReader = reader.sliceFrom(offset);
  const shrinkageEnableGsubOffset = priReader.uint16();
  const shrinkageDisableGsubOffset = priReader.uint16();
  const shrinkageEnableGposOffset = priReader.uint16();
  const shrinkageDisableGposOffset = priReader.uint16();
  const shrinkageJstfMaxOffset = priReader.uint16();
  const extensionEnableGsubOffset = priReader.uint16();
  const extensionDisableGsubOffset = priReader.uint16();
  const extensionEnableGposOffset = priReader.uint16();
  const extensionDisableGposOffset = priReader.uint16();
  const extensionJstfMaxOffset = priReader.uint16();
  return {
    shrinkageEnableGsub: parseJstfModList(reader, offset + shrinkageEnableGsubOffset),
    shrinkageDisableGsub: parseJstfModList(reader, offset + shrinkageDisableGsubOffset),
    shrinkageEnableGpos: parseJstfModList(reader, offset + shrinkageEnableGposOffset),
    shrinkageDisableGpos: parseJstfModList(reader, offset + shrinkageDisableGposOffset),
    shrinkageJstfMax: parseJstfMax(reader, offset + shrinkageJstfMaxOffset),
    extensionEnableGsub: parseJstfModList(reader, offset + extensionEnableGsubOffset),
    extensionDisableGsub: parseJstfModList(reader, offset + extensionDisableGsubOffset),
    extensionEnableGpos: parseJstfModList(reader, offset + extensionEnableGposOffset),
    extensionDisableGpos: parseJstfModList(reader, offset + extensionDisableGposOffset),
    extensionJstfMax: parseJstfMax(reader, offset + extensionJstfMaxOffset)
  };
}
function parseJstfLangSys(reader, offset) {
  const langReader = reader.sliceFrom(offset);
  const jstfPriorityCount = langReader.uint16();
  const priorityOffsets = [];
  for (let i = 0;i < jstfPriorityCount; i++) {
    priorityOffsets.push(langReader.uint16());
  }
  const priorities = [];
  for (let i = 0;i < priorityOffsets.length; i++) {
    const priOffset = priorityOffsets[i];
    priorities.push(parseJstfPriority(reader, offset + priOffset));
  }
  return { priorities };
}
function parseJstfScript(reader, offset) {
  const scriptReader = reader.sliceFrom(offset);
  const extenderGlyphOffset = scriptReader.uint16();
  const defJstfLangSysOffset = scriptReader.uint16();
  const jstfLangSysCount = scriptReader.uint16();
  const langSysData = [];
  for (let i = 0;i < jstfLangSysCount; i++) {
    const tag2 = scriptReader.uint32();
    const langOffset = scriptReader.uint16();
    langSysData.push({ tag: tag2, offset: langOffset });
  }
  const extenderGlyphs = [];
  if (extenderGlyphOffset !== 0) {
    const extReader = reader.sliceFrom(offset + extenderGlyphOffset);
    const glyphCount = extReader.uint16();
    for (let i = 0;i < glyphCount; i++) {
      extenderGlyphs.push(extReader.uint16());
    }
  }
  const defaultLangSys = defJstfLangSysOffset !== 0 ? parseJstfLangSys(reader, offset + defJstfLangSysOffset) : null;
  const langSysRecords = new Map;
  for (let i = 0;i < langSysData.length; i++) {
    const { tag: tag2, offset: langOffset } = langSysData[i];
    langSysRecords.set(tag2, parseJstfLangSys(reader, offset + langOffset));
  }
  return { extenderGlyphs, defaultLangSys, langSysRecords };
}
function parseJstf(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const jstfScriptCount = reader.uint16();
  const scriptData = [];
  for (let i = 0;i < jstfScriptCount; i++) {
    const tag2 = reader.uint32();
    const offset = reader.uint16();
    scriptData.push({ tag: tag2, offset });
  }
  const scripts = [];
  for (let i = 0;i < scriptData.length; i++) {
    const { tag: tag2, offset } = scriptData[i];
    const script = parseJstfScript(reader, offset);
    scripts.push({ scriptTag: tag2, ...script });
  }
  return {
    majorVersion,
    minorVersion,
    scripts
  };
}
function getExtenderGlyphs(jstf, scriptTag) {
  const script = jstf.scripts.find((s) => s.scriptTag === scriptTag);
  return script?.extenderGlyphs ?? [];
}
function getJstfPriorities(jstf, scriptTag, languageTag) {
  const script = jstf.scripts.find((s) => s.scriptTag === scriptTag);
  if (!script)
    return [];
  if (languageTag !== undefined) {
    const langSys = script.langSysRecords.get(languageTag);
    if (langSys)
      return langSys.priorities;
  }
  return script.defaultLangSys?.priorities ?? [];
}
function getShrinkageMods(priority) {
  return {
    enableGsub: priority.shrinkageEnableGsub?.lookupIndices ?? [],
    disableGsub: priority.shrinkageDisableGsub?.lookupIndices ?? [],
    enableGpos: priority.shrinkageEnableGpos?.lookupIndices ?? [],
    disableGpos: priority.shrinkageDisableGpos?.lookupIndices ?? [],
    maxLookups: priority.shrinkageJstfMax?.lookupIndices ?? []
  };
}
function getExtensionMods(priority) {
  return {
    enableGsub: priority.extensionEnableGsub?.lookupIndices ?? [],
    disableGsub: priority.extensionDisableGsub?.lookupIndices ?? [],
    enableGpos: priority.extensionEnableGpos?.lookupIndices ?? [],
    disableGpos: priority.extensionDisableGpos?.lookupIndices ?? [],
    maxLookups: priority.extensionJstfMax?.lookupIndices ?? []
  };
}

// reference/text-shaper/src/font/tables/kern.ts
function parseKern(reader) {
  const version = reader.uint16();
  const subtables = [];
  if (version === 0) {
    const nTables = reader.uint16();
    for (let i = 0;i < nTables; i++) {
      const subtable = parseKernSubtable(reader);
      if (subtable)
        subtables.push(subtable);
    }
  } else if (version === 1) {
    reader.skip(2);
    const nTables = reader.uint32();
    for (let i = 0;i < nTables; i++) {
      const subtable = parseAppleKernSubtable(reader);
      if (subtable)
        subtables.push(subtable);
    }
  }
  return { version, subtables };
}
function parseKernSubtable(reader) {
  const _version = reader.uint16();
  const length = reader.uint16();
  const coverageBits = reader.uint16();
  const coverage = {
    horizontal: (coverageBits & 1) !== 0,
    minimum: (coverageBits & 2) !== 0,
    crossStream: (coverageBits & 4) !== 0,
    override: (coverageBits & 8) !== 0
  };
  const format = coverageBits >> 8 & 255;
  if (format === 0) {
    return parseKernFormat0(reader, coverage);
  } else if (format === 2) {
    return parseKernFormat2(reader, coverage, length - 6);
  }
  reader.skip(length - 6);
  return null;
}
function parseAppleKernSubtable(reader) {
  const length = reader.uint32();
  const coverageBits = reader.uint16();
  const _tupleIndex = reader.uint16();
  const coverage = {
    horizontal: (coverageBits & 32768) === 0,
    minimum: false,
    crossStream: (coverageBits & 16384) !== 0,
    override: (coverageBits & 8192) !== 0
  };
  const format = coverageBits & 255;
  if (format === 0) {
    return parseKernFormat0(reader, coverage);
  } else if (format === 2) {
    return parseKernFormat2(reader, coverage, length - 8);
  }
  reader.skip(length - 8);
  return null;
}
function parseKernFormat0(reader, coverage) {
  const nPairs = reader.uint16();
  reader.skip(6);
  const pairs = new Map;
  for (let i = 0;i < nPairs; i++) {
    const left = reader.uint16();
    const right = reader.uint16();
    const value = reader.int16();
    const key = left << 16 | right;
    pairs.set(key, value);
  }
  return { format: 0, coverage, pairs };
}
function parseKernFormat2(reader, coverage, dataLength) {
  const startOffset = reader.offset;
  const rowWidth = reader.uint16();
  const leftClassOffset = reader.uint16();
  const rightClassOffset = reader.uint16();
  const arrayOffset = reader.uint16();
  const leftClassTable = new Map;
  reader.seek(startOffset + leftClassOffset);
  const leftFirstGlyph = reader.uint16();
  const leftNGlyphs = reader.uint16();
  for (let i = 0;i < leftNGlyphs; i++) {
    const classValue = reader.uint16();
    if (classValue !== 0) {
      leftClassTable.set(leftFirstGlyph + i, classValue);
    }
  }
  const rightClassTable = new Map;
  reader.seek(startOffset + rightClassOffset);
  const rightFirstGlyph = reader.uint16();
  const rightNGlyphs = reader.uint16();
  for (let i = 0;i < rightNGlyphs; i++) {
    const classValue = reader.uint16();
    if (classValue !== 0) {
      rightClassTable.set(rightFirstGlyph + i, classValue);
    }
  }
  reader.seek(startOffset + arrayOffset);
  const numRows = rowWidth > 0 ? Math.floor(dataLength / rowWidth) : 0;
  const numCols = rowWidth / 2;
  const kerningValues = [];
  for (let row = 0;row < numRows; row++) {
    const rowValues = [];
    for (let col = 0;col < numCols; col++) {
      rowValues.push(reader.int16());
    }
    kerningValues.push(rowValues);
  }
  return {
    format: 2,
    coverage,
    rowWidth,
    leftClassTable,
    rightClassTable,
    kerningValues
  };
}
function getKernValue(kern, left, right) {
  let total = 0;
  for (let i = 0;i < kern.subtables.length; i++) {
    const subtable = kern.subtables[i];
    if (!subtable.coverage.horizontal)
      continue;
    if (subtable.format === 0) {
      const key = left << 16 | right;
      const value = subtable.pairs.get(key);
      if (value !== undefined) {
        if (subtable.coverage.override) {
          total = value;
        } else {
          total += value;
        }
      }
    } else if (subtable.format === 2) {
      const leftClass = subtable.leftClassTable.get(left) ?? 0;
      const rightClass = subtable.rightClassTable.get(right) ?? 0;
      if (leftClass > 0 && rightClass > 0) {
        const rowIndex = Math.floor(leftClass / 2);
        const colIndex = Math.floor(rightClass / 2);
        const row = subtable.kerningValues[rowIndex];
        if (row) {
          const value = row[colIndex];
          if (value !== undefined) {
            if (subtable.coverage.override) {
              total = value;
            } else {
              total += value;
            }
          }
        }
      }
    }
  }
  return total;
}

// reference/text-shaper/src/font/tables/kerx.ts
function parseKerx(reader) {
  const version = reader.uint16();
  reader.skip(2);
  const nTables = reader.uint32();
  const subtables = [];
  for (let i = 0;i < nTables; i++) {
    const subtable = parseKerxSubtable(reader);
    if (subtable)
      subtables.push(subtable);
  }
  return { version, nTables, subtables };
}
function parseKerxSubtable(reader) {
  const length = reader.uint32();
  const coverageAndFormat = reader.uint32();
  const tupleCount = reader.uint16();
  reader.skip(2);
  const format = coverageAndFormat & 255;
  const coverage = {
    vertical: (coverageAndFormat & 2147483648) !== 0,
    crossStream: (coverageAndFormat & 1073741824) !== 0,
    variation: (coverageAndFormat & 536870912) !== 0
  };
  const base = { length, coverage, tupleCount };
  const subtableEnd = reader.offset + length - 12;
  let subtable = null;
  switch (format) {
    case 0 /* OrderedList */:
      subtable = parseKerxFormat0(reader, base);
      break;
    case 1 /* StateTable */:
      subtable = parseKerxFormat1(reader, base);
      break;
    case 2 /* SimpleArray */:
      subtable = parseKerxFormat2(reader, base);
      break;
    case 6 /* Format6 */:
      subtable = parseKerxFormat6(reader, base);
      break;
  }
  reader.seek(subtableEnd);
  return subtable;
}
function parseKerxFormat0(reader, base) {
  const nPairs = reader.uint32();
  reader.skip(12);
  const pairs = [];
  for (let i = 0;i < nPairs; i++) {
    pairs.push({
      left: reader.uint16(),
      right: reader.uint16(),
      value: reader.int16()
    });
    reader.skip(2);
  }
  return {
    ...base,
    format: 0 /* OrderedList */,
    nPairs,
    pairs
  };
}
function parseKerxFormat1(reader, base) {
  const stateHeader = {
    nClasses: reader.uint32(),
    classTableOffset: reader.offset32(),
    stateArrayOffset: reader.offset32(),
    entryTableOffset: reader.offset32(),
    valueTableOffset: reader.offset32()
  };
  return {
    ...base,
    format: 1 /* StateTable */,
    stateHeader
  };
}
function parseKerxFormat2(reader, base) {
  const rowWidth = reader.uint16();
  reader.skip(2);
  const leftClassTableOffset = reader.offset32();
  const rightClassTableOffset = reader.offset32();
  const kerningArrayOffset = reader.offset32();
  const leftClassTable = parseKerxClassTable(reader.sliceFrom(leftClassTableOffset));
  const rightClassTable = parseKerxClassTable(reader.sliceFrom(rightClassTableOffset));
  const arrayReader = reader.sliceFrom(kerningArrayOffset);
  const numRows = leftClassTable.nGlyphs > 0 ? Math.max(...[...leftClassTable.classes]) + 1 : 0;
  const numCols = rowWidth / 2;
  const kerningArray = new Int16Array(numRows * numCols);
  for (let i = 0;i < kerningArray.length; i++) {
    kerningArray[i] = arrayReader.int16();
  }
  return {
    ...base,
    format: 2 /* SimpleArray */,
    rowWidth,
    leftClassTable,
    rightClassTable,
    kerningArray
  };
}
function parseKerxClassTable(reader) {
  const firstGlyph = reader.uint16();
  const nGlyphs = reader.uint16();
  const classes = new Uint8Array(nGlyphs);
  for (let i = 0;i < nGlyphs; i++) {
    classes[i] = reader.uint8();
  }
  return { firstGlyph, nGlyphs, classes };
}
function parseKerxFormat6(reader, base) {
  const flags = reader.uint32();
  const rowCount = reader.uint16();
  const columnCount = reader.uint16();
  const rowIndexTableOffset = reader.offset32();
  const columnIndexTableOffset = reader.offset32();
  const kerningArrayOffset = reader.offset32();
  const kerningVectorOffset = reader.offset32();
  return {
    ...base,
    format: 6 /* Format6 */,
    flags,
    rowCount,
    columnCount,
    rowIndexTableOffset,
    columnIndexTableOffset,
    kerningArrayOffset,
    kerningVectorOffset
  };
}
function getKerxValue(kerx, left, right) {
  for (let i = 0;i < kerx.subtables.length; i++) {
    const subtable = kerx.subtables[i];
    if (subtable.coverage.vertical)
      continue;
    switch (subtable.format) {
      case 0 /* OrderedList */: {
        const pairs = subtable.pairs;
        let lo = 0;
        let hi = pairs.length - 1;
        while (lo <= hi) {
          const mid = lo + hi >> 1;
          const pair = pairs[mid];
          if (!pair)
            break;
          const key = pair.left << 16 | pair.right;
          const target = left << 16 | right;
          if (key === target) {
            return pair.value;
          } else if (key < target) {
            lo = mid + 1;
          } else {
            hi = mid - 1;
          }
        }
        break;
      }
      case 2 /* SimpleArray */: {
        const leftTable = subtable.leftClassTable;
        const rightTable = subtable.rightClassTable;
        if (left < leftTable.firstGlyph || left >= leftTable.firstGlyph + leftTable.nGlyphs) {
          continue;
        }
        if (right < rightTable.firstGlyph || right >= rightTable.firstGlyph + rightTable.nGlyphs) {
          continue;
        }
        const leftClass = leftTable.classes[left - leftTable.firstGlyph];
        const rightClass = rightTable.classes[right - rightTable.firstGlyph];
        if (leftClass === undefined || rightClass === undefined)
          continue;
        const numCols = subtable.rowWidth / 2;
        const index = leftClass * numCols + rightClass;
        if (index < subtable.kerningArray.length) {
          const value = subtable.kerningArray[index];
          if (value !== undefined && value !== 0)
            return value;
        }
        break;
      }
    }
  }
  return 0;
}

// reference/text-shaper/src/font/tables/math.ts
function parseMathValueRecord(reader, tableReader) {
  const value = reader.int16();
  const deviceOffset = reader.uint16();
  return {
    value,
    device: parseDeviceAt(tableReader, deviceOffset)
  };
}
function parseMathConstants(reader) {
  const tableReader = reader;
  const scriptPercentScaleDown = reader.int16();
  const scriptScriptPercentScaleDown = reader.int16();
  const delimitedSubFormulaMinHeight = reader.uint16();
  const displayOperatorMinHeight = reader.uint16();
  return {
    scriptPercentScaleDown,
    scriptScriptPercentScaleDown,
    delimitedSubFormulaMinHeight,
    displayOperatorMinHeight,
    mathLeading: parseMathValueRecord(reader, tableReader),
    axisHeight: parseMathValueRecord(reader, tableReader),
    accentBaseHeight: parseMathValueRecord(reader, tableReader),
    flattenedAccentBaseHeight: parseMathValueRecord(reader, tableReader),
    subscriptShiftDown: parseMathValueRecord(reader, tableReader),
    subscriptTopMax: parseMathValueRecord(reader, tableReader),
    subscriptBaselineDropMin: parseMathValueRecord(reader, tableReader),
    superscriptShiftUp: parseMathValueRecord(reader, tableReader),
    superscriptShiftUpCramped: parseMathValueRecord(reader, tableReader),
    superscriptBottomMin: parseMathValueRecord(reader, tableReader),
    superscriptBaselineDropMax: parseMathValueRecord(reader, tableReader),
    subSuperscriptGapMin: parseMathValueRecord(reader, tableReader),
    superscriptBottomMaxWithSubscript: parseMathValueRecord(reader, tableReader),
    spaceAfterScript: parseMathValueRecord(reader, tableReader),
    upperLimitGapMin: parseMathValueRecord(reader, tableReader),
    upperLimitBaselineRiseMin: parseMathValueRecord(reader, tableReader),
    lowerLimitGapMin: parseMathValueRecord(reader, tableReader),
    lowerLimitBaselineDropMin: parseMathValueRecord(reader, tableReader),
    stackTopShiftUp: parseMathValueRecord(reader, tableReader),
    stackTopDisplayStyleShiftUp: parseMathValueRecord(reader, tableReader),
    stackBottomShiftDown: parseMathValueRecord(reader, tableReader),
    stackBottomDisplayStyleShiftDown: parseMathValueRecord(reader, tableReader),
    stackGapMin: parseMathValueRecord(reader, tableReader),
    stackDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),
    stretchStackTopShiftUp: parseMathValueRecord(reader, tableReader),
    stretchStackBottomShiftDown: parseMathValueRecord(reader, tableReader),
    stretchStackGapAboveMin: parseMathValueRecord(reader, tableReader),
    stretchStackGapBelowMin: parseMathValueRecord(reader, tableReader),
    fractionNumeratorShiftUp: parseMathValueRecord(reader, tableReader),
    fractionNumeratorDisplayStyleShiftUp: parseMathValueRecord(reader, tableReader),
    fractionDenominatorShiftDown: parseMathValueRecord(reader, tableReader),
    fractionDenominatorDisplayStyleShiftDown: parseMathValueRecord(reader, tableReader),
    fractionNumeratorGapMin: parseMathValueRecord(reader, tableReader),
    fractionNumDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),
    fractionRuleThickness: parseMathValueRecord(reader, tableReader),
    fractionDenominatorGapMin: parseMathValueRecord(reader, tableReader),
    fractionDenomDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),
    skewedFractionHorizontalGap: parseMathValueRecord(reader, tableReader),
    skewedFractionVerticalGap: parseMathValueRecord(reader, tableReader),
    overbarVerticalGap: parseMathValueRecord(reader, tableReader),
    overbarRuleThickness: parseMathValueRecord(reader, tableReader),
    overbarExtraAscender: parseMathValueRecord(reader, tableReader),
    underbarVerticalGap: parseMathValueRecord(reader, tableReader),
    underbarRuleThickness: parseMathValueRecord(reader, tableReader),
    underbarExtraDescender: parseMathValueRecord(reader, tableReader),
    radicalVerticalGap: parseMathValueRecord(reader, tableReader),
    radicalDisplayStyleVerticalGap: parseMathValueRecord(reader, tableReader),
    radicalRuleThickness: parseMathValueRecord(reader, tableReader),
    radicalExtraAscender: parseMathValueRecord(reader, tableReader),
    radicalKernBeforeDegree: parseMathValueRecord(reader, tableReader),
    radicalKernAfterDegree: parseMathValueRecord(reader, tableReader),
    radicalDegreeBottomRaisePercent: reader.int16()
  };
}
function parseMathItalicsCorrection(reader) {
  const coverageOffset = reader.uint16();
  const count = reader.uint16();
  const values = [];
  for (let i = 0;i < count; i++) {
    values.push(parseMathValueRecord(reader, reader));
  }
  const coverage = parseCoverageAt(reader, coverageOffset);
  return { coverage, values };
}
function parseMathTopAccentAttachment(reader) {
  const coverageOffset = reader.uint16();
  const count = reader.uint16();
  const values = [];
  for (let i = 0;i < count; i++) {
    values.push(parseMathValueRecord(reader, reader));
  }
  const coverage = parseCoverageAt(reader, coverageOffset);
  return { coverage, values };
}
function parseMathKernRecord(reader, offset) {
  const kernReader = reader.sliceFrom(offset);
  const heightCount = kernReader.uint16();
  const correctionHeights = [];
  for (let i = 0;i < heightCount; i++) {
    correctionHeights.push(parseMathValueRecord(kernReader, kernReader));
  }
  const kernValues = [];
  for (let i = 0;i < heightCount + 1; i++) {
    kernValues.push(parseMathValueRecord(kernReader, kernReader));
  }
  return { correctionHeights, kernValues };
}
function parseMathKernInfoTable(reader) {
  const coverageOffset = reader.uint16();
  const count = reader.uint16();
  const kernInfoRecords = [];
  for (let i = 0;i < count; i++) {
    kernInfoRecords.push({
      topRightOffset: reader.uint16(),
      topLeftOffset: reader.uint16(),
      bottomRightOffset: reader.uint16(),
      bottomLeftOffset: reader.uint16()
    });
  }
  const coverage = parseCoverageAt(reader, coverageOffset);
  const kernInfo = kernInfoRecords.map((record) => ({
    topRight: record.topRightOffset !== 0 ? parseMathKernRecord(reader, record.topRightOffset) : null,
    topLeft: record.topLeftOffset !== 0 ? parseMathKernRecord(reader, record.topLeftOffset) : null,
    bottomRight: record.bottomRightOffset !== 0 ? parseMathKernRecord(reader, record.bottomRightOffset) : null,
    bottomLeft: record.bottomLeftOffset !== 0 ? parseMathKernRecord(reader, record.bottomLeftOffset) : null
  }));
  return { coverage, kernInfo };
}
function parseMathGlyphInfo(reader) {
  const italicsCorrectionOffset = reader.uint16();
  const topAccentAttachmentOffset = reader.uint16();
  const extendedShapeCoverageOffset = reader.uint16();
  const kernInfoOffset = reader.uint16();
  let italicsCorrection = null;
  if (italicsCorrectionOffset !== 0) {
    italicsCorrection = parseMathItalicsCorrection(reader.sliceFrom(italicsCorrectionOffset));
  }
  let topAccentAttachment = null;
  if (topAccentAttachmentOffset !== 0) {
    topAccentAttachment = parseMathTopAccentAttachment(reader.sliceFrom(topAccentAttachmentOffset));
  }
  let extendedShapeCoverage = null;
  if (extendedShapeCoverageOffset !== 0) {
    const coverage = parseCoverageAt(reader, extendedShapeCoverageOffset);
    extendedShapeCoverage = { coverage };
  }
  let kernInfo = null;
  if (kernInfoOffset !== 0) {
    kernInfo = parseMathKernInfoTable(reader.sliceFrom(kernInfoOffset));
  }
  return {
    italicsCorrection,
    topAccentAttachment,
    extendedShapeCoverage,
    kernInfo
  };
}
function parseGlyphAssembly(reader) {
  const italicsCorrection = parseMathValueRecord(reader, reader);
  const partCount = reader.uint16();
  const parts = [];
  for (let i = 0;i < partCount; i++) {
    parts.push({
      glyphId: reader.uint16(),
      startConnectorLength: reader.uint16(),
      endConnectorLength: reader.uint16(),
      fullAdvance: reader.uint16(),
      partFlags: reader.uint16()
    });
  }
  return { italicsCorrection, parts };
}
function parseMathGlyphConstruction(reader) {
  const glyphAssemblyOffset = reader.uint16();
  const variantCount = reader.uint16();
  const variants = [];
  for (let i = 0;i < variantCount; i++) {
    variants.push({
      variantGlyph: reader.uint16(),
      advanceMeasurement: reader.uint16()
    });
  }
  let glyphAssembly = null;
  if (glyphAssemblyOffset !== 0) {
    glyphAssembly = parseGlyphAssembly(reader.sliceFrom(glyphAssemblyOffset));
  }
  return { glyphAssembly, variants };
}
function parseMathVariants(reader) {
  const minConnectorOverlap = reader.uint16();
  const vertGlyphCoverageOffset = reader.uint16();
  const horizGlyphCoverageOffset = reader.uint16();
  const vertGlyphCount = reader.uint16();
  const horizGlyphCount = reader.uint16();
  const vertGlyphConstructionOffsets = [];
  for (let i = 0;i < vertGlyphCount; i++) {
    vertGlyphConstructionOffsets.push(reader.uint16());
  }
  const horizGlyphConstructionOffsets = [];
  for (let i = 0;i < horizGlyphCount; i++) {
    horizGlyphConstructionOffsets.push(reader.uint16());
  }
  const vertGlyphCoverage = vertGlyphCoverageOffset !== 0 ? parseCoverageAt(reader, vertGlyphCoverageOffset) : null;
  const horizGlyphCoverage = horizGlyphCoverageOffset !== 0 ? parseCoverageAt(reader, horizGlyphCoverageOffset) : null;
  const vertGlyphConstruction = vertGlyphConstructionOffsets.map((offset) => parseMathGlyphConstruction(reader.sliceFrom(offset)));
  const horizGlyphConstruction = horizGlyphConstructionOffsets.map((offset) => parseMathGlyphConstruction(reader.sliceFrom(offset)));
  return {
    minConnectorOverlap,
    vertGlyphCoverage,
    horizGlyphCoverage,
    vertGlyphConstruction,
    horizGlyphConstruction
  };
}
function parseMath(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const mathConstantsOffset = reader.uint16();
  const mathGlyphInfoOffset = reader.uint16();
  const mathVariantsOffset = reader.uint16();
  let constants = null;
  if (mathConstantsOffset !== 0) {
    constants = parseMathConstants(reader.sliceFrom(mathConstantsOffset));
  }
  let glyphInfo = null;
  if (mathGlyphInfoOffset !== 0) {
    glyphInfo = parseMathGlyphInfo(reader.sliceFrom(mathGlyphInfoOffset));
  }
  let variants = null;
  if (mathVariantsOffset !== 0) {
    variants = parseMathVariants(reader.sliceFrom(mathVariantsOffset));
  }
  return {
    majorVersion,
    minorVersion,
    constants,
    glyphInfo,
    variants
  };
}
function getItalicsCorrection(math, glyphId) {
  const italics = math.glyphInfo?.italicsCorrection;
  if (!italics)
    return null;
  const index = italics.coverage.get(glyphId);
  if (index === null)
    return null;
  return italics.values[index] ?? null;
}
function getTopAccentAttachment(math, glyphId) {
  const attachment = math.glyphInfo?.topAccentAttachment;
  if (!attachment)
    return null;
  const index = attachment.coverage.get(glyphId);
  if (index === null)
    return null;
  return attachment.values[index] ?? null;
}
function isExtendedShape(math, glyphId) {
  const extended = math.glyphInfo?.extendedShapeCoverage;
  if (!extended)
    return false;
  return extended.coverage.get(glyphId) !== null;
}
function getVerticalVariants(math, glyphId) {
  const variants = math.variants;
  if (!variants?.vertGlyphCoverage)
    return null;
  const index = variants.vertGlyphCoverage.get(glyphId);
  if (index === null)
    return null;
  return variants.vertGlyphConstruction[index]?.variants ?? null;
}
function getHorizontalVariants(math, glyphId) {
  const variants = math.variants;
  if (!variants?.horizGlyphCoverage)
    return null;
  const index = variants.horizGlyphCoverage.get(glyphId);
  if (index === null)
    return null;
  return variants.horizGlyphConstruction[index]?.variants ?? null;
}
function getVerticalAssembly(math, glyphId) {
  const variants = math.variants;
  if (!variants?.vertGlyphCoverage)
    return null;
  const index = variants.vertGlyphCoverage.get(glyphId);
  if (index === null)
    return null;
  return variants.vertGlyphConstruction[index]?.glyphAssembly ?? null;
}
function getHorizontalAssembly(math, glyphId) {
  const variants = math.variants;
  if (!variants?.horizGlyphCoverage)
    return null;
  const index = variants.horizGlyphCoverage.get(glyphId);
  if (index === null)
    return null;
  return variants.horizGlyphConstruction[index]?.glyphAssembly ?? null;
}

// reference/text-shaper/src/font/tables/maxp.ts
function parseMaxp(reader) {
  const version = reader.uint32();
  const numGlyphs = reader.uint16();
  if (version === 20480) {
    return { version, numGlyphs };
  }
  if (version === 65536) {
    return {
      version,
      numGlyphs,
      maxPoints: reader.uint16(),
      maxContours: reader.uint16(),
      maxCompositePoints: reader.uint16(),
      maxCompositeContours: reader.uint16(),
      maxZones: reader.uint16(),
      maxTwilightPoints: reader.uint16(),
      maxStorage: reader.uint16(),
      maxFunctionDefs: reader.uint16(),
      maxInstructionDefs: reader.uint16(),
      maxStackElements: reader.uint16(),
      maxSizeOfInstructions: reader.uint16(),
      maxComponentElements: reader.uint16(),
      maxComponentDepth: reader.uint16()
    };
  }
  throw new Error(`Unknown maxp version: 0x${version.toString(16)}`);
}

// reference/text-shaper/src/font/tables/morx.ts
var MorxSubtableType;
((MorxSubtableType2) => {
  MorxSubtableType2[MorxSubtableType2["Rearrangement"] = 0] = "Rearrangement";
  MorxSubtableType2[MorxSubtableType2["Contextual"] = 1] = "Contextual";
  MorxSubtableType2[MorxSubtableType2["Ligature"] = 2] = "Ligature";
  MorxSubtableType2[MorxSubtableType2["NonContextual"] = 4] = "NonContextual";
  MorxSubtableType2[MorxSubtableType2["Insertion"] = 5] = "Insertion";
})(MorxSubtableType ||= {});
function parseMorx(reader) {
  const version = reader.uint16();
  reader.skip(2);
  if (version < 2) {
    return { version, chains: [] };
  }
  const nChains = reader.uint32();
  const chains = [];
  for (let i = 0;i < nChains; i++) {
    const chain = parseMorxChain(reader);
    chains.push(chain);
  }
  return { version, chains };
}
function parseMorxChain(reader) {
  const defaultFlags = reader.uint32();
  const _chainLength = reader.uint32();
  const nFeatureEntries = reader.uint32();
  const nSubtables = reader.uint32();
  const features = [];
  for (let i = 0;i < nFeatureEntries; i++) {
    features.push({
      featureType: reader.uint16(),
      featureSetting: reader.uint16(),
      enableFlags: reader.uint32(),
      disableFlags: reader.uint32()
    });
  }
  const subtables = [];
  for (let i = 0;i < nSubtables; i++) {
    const subtable = parseMorxSubtable(reader);
    if (subtable)
      subtables.push(subtable);
  }
  return { defaultFlags, features, subtables };
}
function parseMorxSubtable(reader) {
  const length = reader.uint32();
  const coverageBits = reader.uint32();
  const subFeatureFlags = reader.uint32();
  const type = coverageBits & 255;
  const coverage = {
    vertical: (coverageBits & 2147483648) !== 0,
    descending: (coverageBits & 1073741824) !== 0,
    logical: (coverageBits & 268435456) !== 0
  };
  const subtableStart = reader.offset;
  const subtableEnd = subtableStart + length - 12;
  let subtable = null;
  switch (type) {
    case 0 /* Rearrangement */:
      subtable = parseRearrangementSubtable(reader, coverage, subFeatureFlags);
      break;
    case 1 /* Contextual */:
      subtable = parseContextualSubtable(reader, coverage, subFeatureFlags);
      break;
    case 2 /* Ligature */:
      subtable = parseLigatureSubtable(reader, coverage, subFeatureFlags);
      break;
    case 4 /* NonContextual */:
      subtable = parseNonContextualSubtable(reader, coverage, subFeatureFlags);
      break;
    case 5 /* Insertion */:
      subtable = parseInsertionSubtable(reader, coverage, subFeatureFlags);
      break;
  }
  reader.seek(subtableEnd);
  return subtable;
}
function parseNonContextualSubtable(reader, coverage, subFeatureFlags) {
  const lookupTable = parseLookupTable(reader);
  return {
    type: 4 /* NonContextual */,
    coverage,
    subFeatureFlags,
    lookupTable
  };
}
function parseContextualSubtable(reader, coverage, subFeatureFlags) {
  const stateTableOffset = reader.offset;
  const nClasses = reader.uint32();
  const classTableOffset = reader.offset32();
  const _stateArrayOffset = reader.offset32();
  const _entryTableOffset = reader.offset32();
  const _substitutionTableOffset = reader.offset32();
  const classTable = parseClassTable(reader.sliceFrom(stateTableOffset + classTableOffset));
  const stateTable = {
    nClasses,
    classTable,
    stateArray: []
  };
  const substitutionTable = [];
  return {
    type: 1 /* Contextual */,
    coverage,
    subFeatureFlags,
    stateTable,
    substitutionTable
  };
}
function parseLigatureSubtable(reader, coverage, subFeatureFlags) {
  const stateTableOffset = reader.offset;
  const nClasses = reader.uint32();
  const classTableOffset = reader.offset32();
  const _stateArrayOffset = reader.offset32();
  const _entryTableOffset = reader.offset32();
  const _ligatureActionsOffset = reader.offset32();
  const _componentsOffset = reader.offset32();
  const _ligaturesOffset = reader.offset32();
  const classTable = parseClassTable(reader.sliceFrom(stateTableOffset + classTableOffset));
  const stateTable = {
    nClasses,
    classTable,
    stateArray: []
  };
  return {
    type: 2 /* Ligature */,
    coverage,
    subFeatureFlags,
    stateTable,
    ligatureActions: [],
    components: [],
    ligatures: []
  };
}
function parseRearrangementSubtable(reader, coverage, subFeatureFlags) {
  const stateTableOffset = reader.offset;
  const nClasses = reader.uint32();
  const classTableOffset = reader.offset32();
  const stateArrayOffset = reader.offset32();
  const entryTableOffset = reader.offset32();
  const classTable = parseClassTable(reader.sliceFrom(stateTableOffset + classTableOffset));
  const stateArrayReader = reader.sliceFrom(stateTableOffset + stateArrayOffset);
  const entryReader = reader.sliceFrom(stateTableOffset + entryTableOffset);
  const entries = [];
  const entryCount = 256;
  for (let i = 0;i < entryCount; i++) {
    entries.push({
      newState: entryReader.uint16(),
      flags: entryReader.uint16()
    });
  }
  const stateArray = [];
  const stateCount = Math.min(256, Math.ceil((entryTableOffset - stateArrayOffset) / (nClasses * 2)));
  for (let s = 0;s < stateCount; s++) {
    const row = [];
    for (let c = 0;c < nClasses; c++) {
      const entryIndex = stateArrayReader.uint16();
      row.push(entries[entryIndex] ?? { newState: 0, flags: 0 });
    }
    stateArray.push(row);
  }
  return {
    type: 0 /* Rearrangement */,
    coverage,
    subFeatureFlags,
    stateTable: {
      nClasses,
      classTable,
      stateArray
    }
  };
}
function parseInsertionSubtable(reader, coverage, subFeatureFlags) {
  const stateTableOffset = reader.offset;
  const nClasses = reader.uint32();
  const classTableOffset = reader.offset32();
  const stateArrayOffset = reader.offset32();
  const entryTableOffset = reader.offset32();
  const insertionActionOffset = reader.offset32();
  const classTable = parseClassTable(reader.sliceFrom(stateTableOffset + classTableOffset));
  const insertionReader = reader.sliceFrom(stateTableOffset + insertionActionOffset);
  const insertionGlyphs = [];
  const maxInsertionGlyphs = 1024;
  for (let i = 0;i < maxInsertionGlyphs; i++) {
    try {
      insertionGlyphs.push(insertionReader.uint16());
    } catch {
      break;
    }
  }
  const entryReader = reader.sliceFrom(stateTableOffset + entryTableOffset);
  const entries = [];
  const entryCount = 256;
  for (let i = 0;i < entryCount; i++) {
    entries.push({
      newState: entryReader.uint16(),
      flags: entryReader.uint16(),
      currentInsertIndex: entryReader.uint16(),
      markedInsertIndex: entryReader.uint16()
    });
  }
  const stateArrayReader = reader.sliceFrom(stateTableOffset + stateArrayOffset);
  const stateArray = [];
  const stateCount = Math.min(256, Math.ceil((entryTableOffset - stateArrayOffset) / (nClasses * 2)));
  for (let s = 0;s < stateCount; s++) {
    const row = [];
    for (let c = 0;c < nClasses; c++) {
      const entryIndex = stateArrayReader.uint16();
      row.push(entries[entryIndex] ?? {
        newState: 0,
        flags: 0,
        currentInsertIndex: 65535,
        markedInsertIndex: 65535
      });
    }
    stateArray.push(row);
  }
  return {
    type: 5 /* Insertion */,
    coverage,
    subFeatureFlags,
    stateTable: {
      nClasses,
      classTable,
      stateArray
    },
    insertionGlyphs
  };
}
function parseLookupTable(reader) {
  const format = reader.uint16();
  const mapping = new Map;
  switch (format) {
    case 0: {
      break;
    }
    case 2: {
      const _unitSize = reader.uint16();
      const nUnits = reader.uint16();
      reader.skip(6);
      for (let i = 0;i < nUnits; i++) {
        const lastGlyph = reader.uint16();
        const firstGlyph = reader.uint16();
        const value = reader.uint16();
        for (let g = firstGlyph;g <= lastGlyph; g++) {
          mapping.set(g, value);
        }
      }
      break;
    }
    case 4: {
      const _unitSize = reader.uint16();
      const nUnits = reader.uint16();
      reader.skip(6);
      for (let i = 0;i < nUnits; i++) {
        const _lastGlyph = reader.uint16();
        const _firstGlyph = reader.uint16();
        const _valueOffset = reader.uint16();
      }
      break;
    }
    case 6: {
      const _unitSize = reader.uint16();
      const nUnits = reader.uint16();
      reader.skip(6);
      for (let i = 0;i < nUnits; i++) {
        const glyph2 = reader.uint16();
        const value = reader.uint16();
        mapping.set(glyph2, value);
      }
      break;
    }
    case 8: {
      const firstGlyph = reader.uint16();
      const glyphCount = reader.uint16();
      for (let i = 0;i < glyphCount; i++) {
        const value = reader.uint16();
        if (value !== 0) {
          mapping.set(firstGlyph + i, value);
        }
      }
      break;
    }
  }
  return { format, mapping };
}
function parseClassTable(reader) {
  const format = reader.uint16();
  const classArray = [];
  if (format === 2) {
    const _unitSize = reader.uint16();
    const nUnits = reader.uint16();
    reader.skip(6);
    const segments = [];
    for (let i = 0;i < nUnits; i++) {
      segments.push({
        last: reader.uint16(),
        first: reader.uint16(),
        classValue: reader.uint16()
      });
    }
    const maxGlyph = Math.max(...segments.map((s) => s.last), 0);
    for (let g = 0;g <= maxGlyph; g++) {
      const seg = segments.find((s) => g >= s.first && g <= s.last);
      classArray[g] = seg?.classValue ?? 1;
    }
  }
  return { format, classArray };
}
function applyNonContextual(subtable, glyphId) {
  return subtable.lookupTable.mapping.get(glyphId) ?? null;
}

// reference/text-shaper/src/font/tables/mvar.ts
var MvarTags = {
  hasc: tag("hasc"),
  hdsc: tag("hdsc"),
  hlgp: tag("hlgp"),
  hcla: tag("hcla"),
  hcld: tag("hcld"),
  hcof: tag("hcof"),
  hcrn: tag("hcrn"),
  hcrs: tag("hcrs"),
  vasc: tag("vasc"),
  vdsc: tag("vdsc"),
  vlgp: tag("vlgp"),
  vcof: tag("vcof"),
  vcrn: tag("vcrn"),
  vcrs: tag("vcrs"),
  xhgt: tag("xhgt"),
  cpht: tag("cpht"),
  sbxs: tag("sbxs"),
  sbys: tag("sbys"),
  sbxo: tag("sbxo"),
  sbyo: tag("sbyo"),
  spxs: tag("spxs"),
  spys: tag("spys"),
  spxo: tag("spxo"),
  spyo: tag("spyo"),
  strs: tag("strs"),
  stro: tag("stro"),
  undo: tag("undo"),
  unds: tag("unds"),
  gsp0: tag("gsp0"),
  gsp1: tag("gsp1"),
  gsp2: tag("gsp2"),
  gsp3: tag("gsp3")
};
function parseMvar(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  reader.uint16();
  const valueRecordSize = reader.uint16();
  const valueRecordCount = reader.uint16();
  const itemVariationStoreOffset = reader.offset16();
  const valueRecords = [];
  for (let i = 0;i < valueRecordCount; i++) {
    valueRecords.push({
      valueTag: reader.tag(),
      deltaSetOuterIndex: reader.uint16(),
      deltaSetInnerIndex: reader.uint16()
    });
    if (valueRecordSize > 8) {
      reader.skip(valueRecordSize - 8);
    }
  }
  const itemVariationStore = parseItemVariationStore4(reader.sliceFrom(itemVariationStoreOffset));
  return {
    majorVersion,
    minorVersion,
    itemVariationStore,
    valueRecords
  };
}
function parseItemVariationStore4(reader) {
  const format = reader.uint16();
  const variationRegionListOffset = reader.offset32();
  const itemVariationDataCount = reader.uint16();
  const itemVariationDataOffsets = [];
  for (let i = 0;i < itemVariationDataCount; i++) {
    itemVariationDataOffsets.push(reader.offset32());
  }
  const regionReader = reader.sliceFrom(variationRegionListOffset);
  const axisCount = regionReader.uint16();
  const regionCount = regionReader.uint16();
  const variationRegions = [];
  for (let i = 0;i < regionCount; i++) {
    const regionAxes = [];
    for (let j = 0;j < axisCount; j++) {
      regionAxes.push({
        startCoord: regionReader.f2dot14(),
        peakCoord: regionReader.f2dot14(),
        endCoord: regionReader.f2dot14()
      });
    }
    variationRegions.push({ regionAxes });
  }
  const itemVariationData = [];
  for (let i = 0;i < itemVariationDataOffsets.length; i++) {
    const offset = itemVariationDataOffsets[i];
    const dataReader = reader.sliceFrom(offset);
    const itemCount = dataReader.uint16();
    const wordDeltaCount = dataReader.uint16();
    const regionIndexCount = dataReader.uint16();
    const regionIndexes = [];
    for (let i2 = 0;i2 < regionIndexCount; i2++) {
      regionIndexes.push(dataReader.uint16());
    }
    const longWords = (wordDeltaCount & 32768) !== 0;
    const wordCount = wordDeltaCount & 32767;
    const shortCount = regionIndexCount - wordCount;
    const deltaSets = [];
    for (let i2 = 0;i2 < itemCount; i2++) {
      const deltas = [];
      for (let j = 0;j < wordCount; j++) {
        if (longWords) {
          deltas.push(dataReader.int32());
        } else {
          deltas.push(dataReader.int16());
        }
      }
      for (let j = 0;j < shortCount; j++) {
        if (longWords) {
          deltas.push(dataReader.int16());
        } else {
          deltas.push(dataReader.int8());
        }
      }
      deltaSets.push(deltas);
    }
    itemVariationData.push({ itemCount, regionIndexes, deltaSets });
  }
  return { format, variationRegions, itemVariationData };
}
function getMetricDelta(mvar, valueTag, coords) {
  const record = mvar.valueRecords.find((r) => r.valueTag === valueTag);
  if (!record)
    return 0;
  const outer = record.deltaSetOuterIndex;
  const inner = record.deltaSetInnerIndex;
  const varData = mvar.itemVariationStore.itemVariationData[outer];
  if (!varData || inner >= varData.itemCount) {
    return 0;
  }
  const deltaSet = varData.deltaSets[inner];
  if (!deltaSet) {
    return 0;
  }
  let delta = 0;
  for (let i = 0;i < varData.regionIndexes.length; i++) {
    const regionIndex = varData.regionIndexes[i];
    const region = mvar.itemVariationStore.variationRegions[regionIndex];
    if (!region)
      continue;
    const scalar = calculateRegionScalar(region, coords);
    const regionDelta = deltaSet[i] ?? 0;
    delta += scalar * regionDelta;
  }
  return Math.round(delta);
}
function getHAscenderDelta(mvar, coords) {
  return getMetricDelta(mvar, MvarTags.hasc, coords);
}
function getHDescenderDelta(mvar, coords) {
  return getMetricDelta(mvar, MvarTags.hdsc, coords);
}
function getXHeightDelta(mvar, coords) {
  return getMetricDelta(mvar, MvarTags.xhgt, coords);
}
function getCapHeightDelta(mvar, coords) {
  return getMetricDelta(mvar, MvarTags.cpht, coords);
}

// reference/text-shaper/src/font/tables/name.ts
var NameId = {
  Copyright: 0,
  FontFamily: 1,
  FontSubfamily: 2,
  UniqueID: 3,
  FullName: 4,
  Version: 5,
  PostScriptName: 6,
  Trademark: 7,
  Manufacturer: 8,
  Designer: 9,
  Description: 10,
  ManufacturerURL: 11,
  DesignerURL: 12,
  License: 13,
  LicenseURL: 14,
  Reserved: 15,
  TypographicFamily: 16,
  TypographicSubfamily: 17,
  CompatibleFullName: 18,
  SampleText: 19,
  PostScriptCIDFindfontName: 20,
  WWSFamily: 21,
  WWSSubfamily: 22,
  LightBackgroundPalette: 23,
  DarkBackgroundPalette: 24,
  VariationsPostScriptNamePrefix: 25
};
var PlatformId = {
  Unicode: 0,
  Macintosh: 1,
  Reserved: 2,
  Windows: 3
};
var WindowsEncodingId = {
  Symbol: 0,
  UnicodeBMP: 1,
  ShiftJIS: 2,
  PRC: 3,
  Big5: 4,
  Wansung: 5,
  Johab: 6,
  UnicodeFullRepertoire: 10
};
function parseName(reader) {
  const format = reader.uint16();
  const count = reader.uint16();
  const stringOffset = reader.uint16();
  const records = [];
  const recordData = [];
  for (let i = 0;i < count; i++) {
    recordData.push({
      platformId: reader.uint16(),
      encodingId: reader.uint16(),
      languageId: reader.uint16(),
      nameId: reader.uint16(),
      length: reader.uint16(),
      offset: reader.uint16()
    });
  }
  for (let i = 0;i < recordData.length; i++) {
    const rd = recordData[i];
    const strReader = reader.sliceFrom(stringOffset + rd.offset);
    const value = decodeNameString(strReader, rd.length, rd.platformId, rd.encodingId);
    if (value !== null) {
      records.push({
        platformId: rd.platformId,
        encodingId: rd.encodingId,
        languageId: rd.languageId,
        nameId: rd.nameId,
        value
      });
    }
  }
  return { format, records };
}
function decodeNameString(reader, length, platformId, encodingId) {
  if (platformId === PlatformId.Unicode || platformId === PlatformId.Windows && (encodingId === 1 || encodingId === 10)) {
    const chars = [];
    for (let i = 0;i < length; i += 2) {
      const code = reader.uint16();
      chars.push(String.fromCharCode(code));
    }
    return chars.join("");
  }
  if (platformId === PlatformId.Macintosh && encodingId === 0) {
    const bytes = [];
    for (let i = 0;i < length; i++) {
      bytes.push(reader.uint8());
    }
    return String.fromCharCode(...bytes);
  }
  return null;
}
function getNameById(table, nameId, languageId) {
  for (let i = 0;i < table.records.length; i++) {
    const record = table.records[i];
    if (record.nameId !== nameId)
      continue;
    if (record.platformId === PlatformId.Windows && record.encodingId === 1) {
      if (languageId === undefined || record.languageId === languageId) {
        return record.value;
      }
    }
  }
  for (let i = 0;i < table.records.length; i++) {
    const record = table.records[i];
    if (record.nameId !== nameId)
      continue;
    if (record.platformId === PlatformId.Unicode) {
      if (languageId === undefined || record.languageId === languageId) {
        return record.value;
      }
    }
  }
  for (let i = 0;i < table.records.length; i++) {
    const record = table.records[i];
    if (record.nameId !== nameId)
      continue;
    if (languageId === undefined || record.languageId === languageId) {
      return record.value;
    }
  }
  return null;
}
function getFontFamily(table) {
  return getNameById(table, NameId.TypographicFamily) ?? getNameById(table, NameId.FontFamily);
}
function getFontSubfamily(table) {
  return getNameById(table, NameId.TypographicSubfamily) ?? getNameById(table, NameId.FontSubfamily);
}
function getFullName(table) {
  return getNameById(table, NameId.FullName);
}
function getPostScriptName(table) {
  return getNameById(table, NameId.PostScriptName);
}
function getVersion(table) {
  return getNameById(table, NameId.Version);
}

// reference/text-shaper/src/font/tables/os2.ts
var WeightClass = {
  Thin: 100,
  ExtraLight: 200,
  Light: 300,
  Normal: 400,
  Medium: 500,
  SemiBold: 600,
  Bold: 700,
  ExtraBold: 800,
  Black: 900
};
var WidthClass = {
  UltraCondensed: 1,
  ExtraCondensed: 2,
  Condensed: 3,
  SemiCondensed: 4,
  Normal: 5,
  SemiExpanded: 6,
  Expanded: 7,
  ExtraExpanded: 8,
  UltraExpanded: 9
};
var FsSelection = {
  Italic: 1,
  Underscore: 2,
  Negative: 4,
  Outlined: 8,
  Strikeout: 16,
  Bold: 32,
  Regular: 64,
  UseTypoMetrics: 128,
  WWS: 256,
  Oblique: 512
};
var FsType = {
  InstallableEmbedding: 0,
  RestrictedLicense: 2,
  PreviewAndPrint: 4,
  Editable: 8,
  NoSubsetting: 256,
  BitmapOnly: 512
};
function parseOs2(reader) {
  const version = reader.uint16();
  const xAvgCharWidth = reader.int16();
  const usWeightClass = reader.uint16();
  const usWidthClass = reader.uint16();
  const fsType = reader.uint16();
  const ySubscriptXSize = reader.int16();
  const ySubscriptYSize = reader.int16();
  const ySubscriptXOffset = reader.int16();
  const ySubscriptYOffset = reader.int16();
  const ySuperscriptXSize = reader.int16();
  const ySuperscriptYSize = reader.int16();
  const ySuperscriptXOffset = reader.int16();
  const ySuperscriptYOffset = reader.int16();
  const yStrikeoutSize = reader.int16();
  const yStrikeoutPosition = reader.int16();
  const sFamilyClass = reader.int16();
  const panose = [];
  for (let i = 0;i < 10; i++) {
    panose.push(reader.uint8());
  }
  const ulUnicodeRange1 = reader.uint32();
  const ulUnicodeRange2 = reader.uint32();
  const ulUnicodeRange3 = reader.uint32();
  const ulUnicodeRange4 = reader.uint32();
  const achVendID = String.fromCharCode(reader.uint8(), reader.uint8(), reader.uint8(), reader.uint8());
  const fsSelection = reader.uint16();
  const usFirstCharIndex = reader.uint16();
  const usLastCharIndex = reader.uint16();
  const sTypoAscender = reader.int16();
  const sTypoDescender = reader.int16();
  const sTypoLineGap = reader.int16();
  const usWinAscent = reader.uint16();
  const usWinDescent = reader.uint16();
  const result = {
    version,
    xAvgCharWidth,
    usWeightClass,
    usWidthClass,
    fsType,
    ySubscriptXSize,
    ySubscriptYSize,
    ySubscriptXOffset,
    ySubscriptYOffset,
    ySuperscriptXSize,
    ySuperscriptYSize,
    ySuperscriptXOffset,
    ySuperscriptYOffset,
    yStrikeoutSize,
    yStrikeoutPosition,
    sFamilyClass,
    panose,
    ulUnicodeRange1,
    ulUnicodeRange2,
    ulUnicodeRange3,
    ulUnicodeRange4,
    achVendID,
    fsSelection,
    usFirstCharIndex,
    usLastCharIndex,
    sTypoAscender,
    sTypoDescender,
    sTypoLineGap,
    usWinAscent,
    usWinDescent
  };
  if (version >= 1) {
    result.ulCodePageRange1 = reader.uint32();
    result.ulCodePageRange2 = reader.uint32();
  }
  if (version >= 2) {
    result.sxHeight = reader.int16();
    result.sCapHeight = reader.int16();
    result.usDefaultChar = reader.uint16();
    result.usBreakChar = reader.uint16();
    result.usMaxContext = reader.uint16();
  }
  if (version >= 5) {
    result.usLowerOpticalPointSize = reader.uint16();
    result.usUpperOpticalPointSize = reader.uint16();
  }
  return result;
}
function isItalic(os2) {
  return (os2.fsSelection & FsSelection.Italic) !== 0;
}
function isBold(os2) {
  return (os2.fsSelection & FsSelection.Bold) !== 0;
}
function useTypoMetrics(os2) {
  return (os2.fsSelection & FsSelection.UseTypoMetrics) !== 0;
}
function getEmbeddingPermission(os2) {
  const fsType = os2.fsType;
  if ((fsType & FsType.RestrictedLicense) !== 0)
    return "restricted";
  if ((fsType & FsType.PreviewAndPrint) !== 0)
    return "preview";
  if ((fsType & FsType.Editable) !== 0)
    return "editable";
  return "installable";
}

// reference/text-shaper/src/font/tables/post.ts
var standardNames = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
function parsePost(reader) {
  const versionMajor = reader.uint16();
  const versionMinor = reader.uint16();
  const version = versionMajor + versionMinor / 65536;
  const italicAngle = reader.fixed();
  const underlinePosition = reader.int16();
  const underlineThickness = reader.int16();
  const isFixedPitch = reader.uint32();
  const minMemType42 = reader.uint32();
  const maxMemType42 = reader.uint32();
  const minMemType1 = reader.uint32();
  const maxMemType1 = reader.uint32();
  const result = {
    version,
    italicAngle,
    underlinePosition,
    underlineThickness,
    isFixedPitch,
    minMemType42,
    maxMemType42,
    minMemType1,
    maxMemType1
  };
  if (version === 2) {
    const numberOfGlyphs = reader.uint16();
    const glyphNameIndex = [];
    for (let i = 0;i < numberOfGlyphs; i++) {
      glyphNameIndex.push(reader.uint16());
    }
    const customNames = [];
    let maxIndex = 0;
    for (let i = 0;i < glyphNameIndex.length; i++) {
      const idx = glyphNameIndex[i];
      if (idx >= 258 && idx > maxIndex) {
        maxIndex = idx;
      }
    }
    const numCustomNames = maxIndex >= 258 ? maxIndex - 257 : 0;
    for (let i = 0;i < numCustomNames; i++) {
      const length = reader.uint8();
      const chars = [];
      for (let j = 0;j < length; j++) {
        chars.push(String.fromCharCode(reader.uint8()));
      }
      customNames.push(chars.join(""));
    }
    result.numberOfGlyphs = numberOfGlyphs;
    result.glyphNameIndex = glyphNameIndex;
    result.names = customNames;
  }
  return result;
}
function getGlyphName(post, glyphId) {
  if (post.version === 1) {
    const name = standardNames[glyphId];
    return name !== undefined ? name : null;
  }
  if (post.version === 2 && post.glyphNameIndex) {
    const index = post.glyphNameIndex[glyphId];
    if (index === undefined)
      return null;
    if (index < 258) {
      return standardNames[index] ?? null;
    }
    const customIndex = index - 258;
    return post.names?.[customIndex] ?? null;
  }
  return null;
}
function isMonospaced(post) {
  return post.isFixedPitch !== 0;
}

// reference/text-shaper/src/font/tables/sbix.ts
var SbixGraphicType = {
  PNG: "png ",
  JPG: "jpg ",
  TIFF: "tiff",
  PDF: "pdf ",
  MASK: "mask",
  DUPE: "dupe"
};
function parseSbix(reader, numGlyphs) {
  const tableStart = reader.offset;
  const version = reader.uint16();
  const flags = reader.uint16();
  const numStrikes = reader.uint32();
  const strikeOffsets = [];
  for (let i = 0;i < numStrikes; i++) {
    strikeOffsets.push(reader.uint32());
  }
  const strikes = [];
  for (let i = 0;i < strikeOffsets.length; i++) {
    const strikeOffset = strikeOffsets[i];
    const strike = parseStrike(reader, tableStart + strikeOffset, numGlyphs);
    strikes.push(strike);
  }
  return { version, flags, strikes };
}
function parseStrike(reader, strikeOffset, numGlyphs) {
  const strikeReader = reader.sliceFrom(strikeOffset);
  const ppem = strikeReader.uint16();
  const ppi = strikeReader.uint16();
  const glyphDataOffsets = [];
  for (let i = 0;i <= numGlyphs; i++) {
    glyphDataOffsets.push(strikeReader.uint32());
  }
  const glyphData = new Map;
  for (let glyphId = 0;glyphId < numGlyphs; glyphId++) {
    const offset = glyphDataOffsets[glyphId];
    const nextOffset = glyphDataOffsets[glyphId + 1];
    if (offset === undefined || nextOffset === undefined)
      continue;
    const dataLength = nextOffset - offset;
    if (dataLength <= 8) {
      continue;
    }
    const glyphReader = reader.sliceFrom(strikeOffset + offset);
    const originOffsetX = glyphReader.int16();
    const originOffsetY = glyphReader.int16();
    const graphicType = glyphReader.tagString();
    const imageDataLength = dataLength - 8;
    const data = glyphReader.bytes(imageDataLength);
    glyphData.set(glyphId, {
      originOffsetX,
      originOffsetY,
      graphicType,
      data
    });
  }
  return { ppem, ppi, glyphData };
}
function getGlyphBitmap(sbix, glyphId, ppem) {
  let bestStrike = null;
  let bestDiff = Infinity;
  for (let i = 0;i < sbix.strikes.length; i++) {
    const strike = sbix.strikes[i];
    const diff = Math.abs(strike.ppem - ppem);
    if (diff < bestDiff) {
      bestDiff = diff;
      bestStrike = strike;
    }
  }
  if (!bestStrike)
    return null;
  return bestStrike.glyphData.get(glyphId) ?? null;
}
function getStrikeForPpem(sbix, ppem) {
  return sbix.strikes.find((s) => s.ppem === ppem) ?? null;
}
function getAvailablePpemSizes(sbix) {
  return sbix.strikes.map((s) => s.ppem).sort((a, b) => a - b);
}
function hasGlyphBitmap(sbix, glyphId, ppem) {
  if (ppem !== undefined) {
    const strike = getStrikeForPpem(sbix, ppem);
    return strike?.glyphData.has(glyphId) ?? false;
  }
  for (let i = 0;i < sbix.strikes.length; i++) {
    const strike = sbix.strikes[i];
    if (strike.glyphData.has(glyphId)) {
      return true;
    }
  }
  return false;
}
function resolveDupeGlyph(sbix, strike, glyph2) {
  if (glyph2.graphicType !== SbixGraphicType.DUPE) {
    return glyph2;
  }
  if (glyph2.data.length < 2)
    return null;
  const dupeGlyphId = (glyph2.data[0] ?? 0) << 8 | (glyph2.data[1] ?? 0);
  const resolved = strike.glyphData.get(dupeGlyphId);
  if (!resolved)
    return null;
  if (resolved.graphicType === SbixGraphicType.DUPE) {
    return resolveDupeGlyph(sbix, strike, resolved);
  }
  return resolved;
}

// reference/text-shaper/src/font/tables/sfnt.ts
var SFNT_VERSION_TRUETYPE = 65536;
var SFNT_VERSION_OPENTYPE = 1330926671;
var SFNT_VERSION_TRUE = 1953658213;
function parseFontDirectory(reader) {
  const sfntVersion = reader.uint32();
  if (sfntVersion !== SFNT_VERSION_TRUETYPE && sfntVersion !== SFNT_VERSION_OPENTYPE && sfntVersion !== SFNT_VERSION_TRUE) {
    throw new Error(`Invalid sfnt version: 0x${sfntVersion.toString(16).padStart(8, "0")}`);
  }
  const numTables = reader.uint16();
  const searchRange = reader.uint16();
  const entrySelector = reader.uint16();
  const rangeShift = reader.uint16();
  const tables = new Map;
  for (let i = 0;i < numTables; i++) {
    const tag2 = reader.tag();
    const checksum = reader.uint32();
    const offset = reader.uint32();
    const length = reader.uint32();
    tables.set(tag2, { tag: tag2, checksum, offset, length });
  }
  return {
    sfntVersion,
    numTables,
    searchRange,
    entrySelector,
    rangeShift,
    tables
  };
}
function isTrueType(directory) {
  return directory.sfntVersion === SFNT_VERSION_TRUETYPE || directory.sfntVersion === SFNT_VERSION_TRUE;
}
function isCFF(directory) {
  return directory.sfntVersion === SFNT_VERSION_OPENTYPE;
}

// reference/text-shaper/src/font/tables/stat.ts
var AxisValueFlags = {
  OlderSiblingFontAttribute: 1,
  ElidableAxisValueName: 2
};
function parseStat(reader) {
  const tableStart = reader.offset;
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const designAxisSize = reader.uint16();
  const designAxisCount = reader.uint16();
  const designAxesOffset = reader.offset32();
  const axisValueCount = reader.uint16();
  const axisValueArrayOffset = reader.offset32();
  let elidedFallbackNameID;
  if (majorVersion >= 1 && minorVersion >= 1) {
    elidedFallbackNameID = reader.uint16();
  }
  const designAxes = [];
  if (designAxesOffset !== 0) {
    const axesReader = reader.sliceFrom(tableStart + designAxesOffset);
    for (let i = 0;i < designAxisCount; i++) {
      designAxes.push({
        axisTag: axesReader.tag(),
        axisNameID: axesReader.uint16(),
        axisOrdering: axesReader.uint16()
      });
      if (designAxisSize > 8) {
        axesReader.skip(designAxisSize - 8);
      }
    }
  }
  const axisValues = [];
  if (axisValueArrayOffset !== 0 && axisValueCount > 0) {
    const arrayReader = reader.sliceFrom(tableStart + axisValueArrayOffset);
    const axisValueOffsets = [];
    for (let i = 0;i < axisValueCount; i++) {
      axisValueOffsets.push(arrayReader.uint16());
    }
    for (let i = 0;i < axisValueOffsets.length; i++) {
      const offset = axisValueOffsets[i];
      const valueReader = reader.sliceFrom(tableStart + axisValueArrayOffset + offset);
      const axisValue = parseAxisValue(valueReader);
      if (axisValue) {
        axisValues.push(axisValue);
      }
    }
  }
  return {
    majorVersion,
    minorVersion,
    designAxisCount,
    designAxes,
    axisValueCount,
    axisValues,
    elidedFallbackNameID
  };
}
function parseAxisValue(reader) {
  const format = reader.uint16();
  switch (format) {
    case 1: {
      return {
        format: 1,
        axisIndex: reader.uint16(),
        flags: reader.uint16(),
        valueNameID: reader.uint16(),
        value: reader.fixed()
      };
    }
    case 2: {
      return {
        format: 2,
        axisIndex: reader.uint16(),
        flags: reader.uint16(),
        valueNameID: reader.uint16(),
        nominalValue: reader.fixed(),
        rangeMinValue: reader.fixed(),
        rangeMaxValue: reader.fixed()
      };
    }
    case 3: {
      return {
        format: 3,
        axisIndex: reader.uint16(),
        flags: reader.uint16(),
        valueNameID: reader.uint16(),
        value: reader.fixed(),
        linkedValue: reader.fixed()
      };
    }
    case 4: {
      const axisCount = reader.uint16();
      const flags = reader.uint16();
      const valueNameID = reader.uint16();
      const axisValues = [];
      for (let i = 0;i < axisCount; i++) {
        axisValues.push({
          axisIndex: reader.uint16(),
          value: reader.fixed()
        });
      }
      return {
        format: 4,
        axisCount,
        flags,
        valueNameID,
        axisValues
      };
    }
    default:
      return null;
  }
}
function getAxisRecord(stat, axisTag) {
  return stat.designAxes.find((a) => a.axisTag === axisTag) ?? null;
}
function getAxisIndex(stat, axisTag) {
  return stat.designAxes.findIndex((a) => a.axisTag === axisTag);
}
function getAxisValuesForAxis(stat, axisIndex) {
  return stat.axisValues.filter((v) => {
    if (v.format === 4) {
      return v.axisValues.some((av) => av.axisIndex === axisIndex);
    }
    return v.axisIndex === axisIndex;
  });
}
function findAxisValueByNameId(stat, nameId) {
  return stat.axisValues.find((v) => v.valueNameID === nameId) ?? null;
}
function isElidableAxisValue(axisValue) {
  return (axisValue.flags & AxisValueFlags.ElidableAxisValueName) !== 0;
}
function isOlderSiblingFont(axisValue) {
  return (axisValue.flags & AxisValueFlags.OlderSiblingFontAttribute) !== 0;
}
function getAxisValueNumber(axisValue) {
  switch (axisValue.format) {
    case 1:
    case 3:
      return axisValue.value;
    case 2:
      return axisValue.nominalValue;
    case 4:
      return null;
  }
}
function matchAxisValue(axisValue, coords) {
  switch (axisValue.format) {
    case 1:
    case 3: {
      const coord = coords.get(axisValue.axisIndex);
      return coord !== undefined && coord === axisValue.value;
    }
    case 2: {
      const coord = coords.get(axisValue.axisIndex);
      return coord !== undefined && coord >= axisValue.rangeMinValue && coord <= axisValue.rangeMaxValue;
    }
    case 4: {
      return axisValue.axisValues.every((av) => {
        const coord = coords.get(av.axisIndex);
        return coord !== undefined && coord === av.value;
      });
    }
  }
}

// reference/text-shaper/src/font/tables/svg.ts
function parseSvg(reader) {
  const version = reader.uint16();
  const svgDocumentListOffset = reader.offset32();
  reader.skip(4);
  const listReader = reader.sliceFrom(svgDocumentListOffset);
  const numEntries = listReader.uint16();
  if (numEntries === 0) {
    return { version, documentRecords: [] };
  }
  const entries = [];
  for (let i = 0;i < numEntries; i++) {
    entries.push({
      startGlyphID: listReader.uint16(),
      endGlyphID: listReader.uint16(),
      svgDocOffset: listReader.offset32(),
      svgDocLength: listReader.uint32()
    });
  }
  const documentRecords = [];
  const decoder = new TextDecoder("utf-8");
  for (let i = 0;i < entries.length; i++) {
    const entry = entries[i];
    const docReader = listReader.sliceFrom(entry.svgDocOffset);
    const svgBytes = docReader.bytes(entry.svgDocLength);
    let svgDoc;
    if (svgBytes[0] === 31 && svgBytes[1] === 139) {
      try {
        const decompressed = decompressGzip(svgBytes);
        svgDoc = decoder.decode(decompressed);
      } catch {
        svgDoc = decoder.decode(svgBytes);
      }
    } else {
      svgDoc = decoder.decode(svgBytes);
    }
    documentRecords.push({
      startGlyphID: entry.startGlyphID,
      endGlyphID: entry.endGlyphID,
      svgDoc
    });
  }
  return { version, documentRecords };
}
function getSvgDocument(svg, glyphId) {
  for (let i = 0;i < svg.documentRecords.length; i++) {
    const record = svg.documentRecords[i];
    if (glyphId >= record.startGlyphID && glyphId <= record.endGlyphID) {
      return record.svgDoc;
    }
  }
  return null;
}
function hasSvgGlyph(svg, glyphId) {
  return getSvgDocument(svg, glyphId) !== null;
}
function getSvgGlyphIds(svg) {
  const glyphIds = [];
  for (let i = 0;i < svg.documentRecords.length; i++) {
    const record = svg.documentRecords[i];
    for (let gid = record.startGlyphID;gid <= record.endGlyphID; gid++) {
      glyphIds.push(gid);
    }
  }
  return glyphIds;
}
function decompressGzip(data) {
  if (typeof DecompressionStream !== "undefined") {
    return data;
  }
  return data;
}

// reference/text-shaper/src/font/tables/trak.ts
function parseTrak(reader) {
  const tableReader = reader;
  const version = reader.uint32() / 65536;
  const format = reader.uint16();
  const horizOffset = reader.offset16();
  const vertOffset = reader.offset16();
  reader.skip(2);
  let horizData = null;
  let vertData = null;
  if (horizOffset !== 0) {
    horizData = parseTrackData(reader.sliceFrom(horizOffset), tableReader);
  }
  if (vertOffset !== 0) {
    vertData = parseTrackData(reader.sliceFrom(vertOffset), tableReader);
  }
  return {
    version,
    format,
    horizData,
    vertData
  };
}
function parseTrackData(reader, tableReader) {
  const nTracks = reader.uint16();
  const nSizes = reader.uint16();
  const sizeTableOffset = reader.offset32();
  const trackTable = [];
  for (let i = 0;i < nTracks; i++) {
    const track = reader.int32() / 65536;
    const nameIndex = reader.uint16();
    const offset = reader.uint16();
    trackTable.push({
      track,
      nameIndex,
      offset,
      perSizeTracking: []
    });
  }
  for (let i = 0;i < trackTable.length; i++) {
    const entry = trackTable[i];
    const trackReader = tableReader.sliceFrom(entry.offset);
    entry.perSizeTracking = [];
    for (let j = 0;j < nSizes; j++) {
      entry.perSizeTracking.push(trackReader.int16());
    }
  }
  const sizeReader = tableReader.sliceFrom(sizeTableOffset);
  const sizeTable = [];
  for (let i = 0;i < nSizes; i++) {
    sizeTable.push(sizeReader.int32() / 65536);
  }
  return {
    nTracks,
    nSizes,
    sizeTableOffset,
    trackTable,
    sizeTable
  };
}
function getTrackingValue(trackData, track, pointSize) {
  let trackEntry = null;
  for (let i = 0;i < trackData.trackTable.length; i++) {
    const entry = trackData.trackTable[i];
    if (entry.track === track) {
      trackEntry = entry;
      break;
    }
  }
  if (!trackEntry) {
    let lower = null;
    let upper = null;
    for (let i = 0;i < trackData.trackTable.length; i++) {
      const entry = trackData.trackTable[i];
      if (entry.track <= track && (!lower || entry.track > lower.track)) {
        lower = entry;
      }
      if (entry.track >= track && (!upper || entry.track < upper.track)) {
        upper = entry;
      }
    }
    if (lower && upper && lower !== upper) {
      const t = (track - lower.track) / (upper.track - lower.track);
      const lowerValue = getSizeValue(trackData, lower, pointSize);
      const upperValue = getSizeValue(trackData, upper, pointSize);
      return Math.round(lowerValue + t * (upperValue - lowerValue));
    } else if (lower) {
      trackEntry = lower;
    } else if (upper) {
      trackEntry = upper;
    } else {
      return 0;
    }
  }
  if (!trackEntry)
    return 0;
  return getSizeValue(trackData, trackEntry, pointSize);
}
function getSizeValue(trackData, entry, pointSize) {
  const sizes = trackData.sizeTable;
  const values = entry.perSizeTracking;
  if (sizes.length === 0 || values.length === 0)
    return 0;
  const firstSize = sizes[0];
  const firstValue = values[0];
  if (firstSize === undefined || firstValue === undefined)
    return 0;
  if (pointSize <= firstSize) {
    return firstValue;
  }
  const lastSize = sizes[sizes.length - 1];
  const lastValue = values[values.length - 1];
  if (lastSize === undefined || lastValue === undefined)
    return 0;
  if (pointSize >= lastSize) {
    return lastValue;
  }
  for (let i = 0;i < sizes.length - 1; i++) {
    const size1 = sizes[i];
    const size2 = sizes[i + 1];
    const value1 = values[i];
    const value2 = values[i + 1];
    if (size1 === undefined || size2 === undefined || value1 === undefined || value2 === undefined)
      continue;
    if (pointSize >= size1 && pointSize <= size2) {
      const t = (pointSize - size1) / (size2 - size1);
      return Math.round(value1 + t * (value2 - value1));
    }
  }
  return 0;
}
function applyTracking(trak, advances, pointSize, track = 0, vertical = false) {
  const trackData = vertical ? trak.vertData : trak.horizData;
  if (!trackData)
    return;
  const trackingValue = getTrackingValue(trackData, track, pointSize);
  if (trackingValue === 0)
    return;
  for (let i = 0;i < advances.length; i++) {
    const advance = advances[i];
    advances[i] = (advance ?? 0) + trackingValue;
  }
}

// reference/text-shaper/src/font/tables/vhea.ts
function parseVhea(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const ascender = reader.fword();
  const descender = reader.fword();
  const lineGap = reader.fword();
  const advanceHeightMax = reader.uint16();
  const minTopSideBearing = reader.fword();
  const minBottomSideBearing = reader.fword();
  const yMaxExtent = reader.fword();
  const caretSlopeRise = reader.int16();
  const caretSlopeRun = reader.int16();
  const caretOffset = reader.int16();
  reader.skip(8);
  const metricDataFormat = reader.int16();
  const numberOfVMetrics = reader.uint16();
  return {
    version: { major: majorVersion, minor: minorVersion },
    ascender,
    descender,
    lineGap,
    advanceHeightMax,
    minTopSideBearing,
    minBottomSideBearing,
    yMaxExtent,
    caretSlopeRise,
    caretSlopeRun,
    caretOffset,
    metricDataFormat,
    numberOfVMetrics
  };
}

// reference/text-shaper/src/font/tables/vmtx.ts
function parseVmtx(reader, numberOfVMetrics, numGlyphs) {
  const vMetrics = [];
  for (let i = 0;i < numberOfVMetrics; i++) {
    vMetrics.push({
      advanceHeight: reader.uint16(),
      topSideBearing: reader.int16()
    });
  }
  const topSideBearings = [];
  const remaining = numGlyphs - numberOfVMetrics;
  for (let i = 0;i < remaining; i++) {
    topSideBearings.push(reader.int16());
  }
  return { vMetrics, topSideBearings };
}
function getVerticalMetrics(vmtx, glyphId) {
  if (glyphId < vmtx.vMetrics.length) {
    const metric = vmtx.vMetrics[glyphId];
    if (metric) {
      return {
        advanceHeight: metric.advanceHeight,
        topSideBearing: metric.topSideBearing
      };
    }
  }
  const lastMetric = vmtx.vMetrics[vmtx.vMetrics.length - 1];
  const advanceHeight = lastMetric?.advanceHeight ?? 0;
  const tsbIndex = glyphId - vmtx.vMetrics.length;
  const topSideBearing = vmtx.topSideBearings[tsbIndex] ?? 0;
  return { advanceHeight, topSideBearing };
}

// reference/text-shaper/src/font/tables/vorg.ts
function parseVorg(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const defaultVertOriginY = reader.int16();
  const numVertOriginYMetrics = reader.uint16();
  const vertOriginYMetrics = [];
  for (let i = 0;i < numVertOriginYMetrics; i++) {
    vertOriginYMetrics.push({
      glyphIndex: reader.uint16(),
      vertOriginY: reader.int16()
    });
  }
  vertOriginYMetrics.sort((a, b) => a.glyphIndex - b.glyphIndex);
  return {
    majorVersion,
    minorVersion,
    defaultVertOriginY,
    vertOriginYMetrics
  };
}
function getVertOriginY(vorg, glyphId) {
  const metrics = vorg.vertOriginYMetrics;
  let lo = 0;
  let hi = metrics.length - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const metric = metrics[mid];
    if (metric === undefined)
      break;
    if (metric.glyphIndex === glyphId) {
      return metric.vertOriginY;
    } else if (metric.glyphIndex < glyphId) {
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }
  return vorg.defaultVertOriginY;
}
function hasVertOriginY(vorg, glyphId) {
  const metrics = vorg.vertOriginYMetrics;
  let lo = 0;
  let hi = metrics.length - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const metric = metrics[mid];
    if (metric === undefined)
      break;
    if (metric.glyphIndex === glyphId) {
      return true;
    } else if (metric.glyphIndex < glyphId) {
      lo = mid + 1;
    } else {
      hi = mid - 1;
    }
  }
  return false;
}

// reference/text-shaper/src/font/tables/vvar.ts
function parseVvar(reader) {
  const majorVersion = reader.uint16();
  const minorVersion = reader.uint16();
  const itemVariationStoreOffset = reader.offset32();
  const advanceHeightMappingOffset = reader.offset32();
  const tsbMappingOffset = reader.offset32();
  const bsbMappingOffset = reader.offset32();
  const vOrgMappingOffset = reader.offset32();
  const itemVariationStore = parseItemVariationStore5(reader.sliceFrom(itemVariationStoreOffset));
  const advanceHeightMapping = advanceHeightMappingOffset !== 0 ? parseDeltaSetIndexMap3(reader.sliceFrom(advanceHeightMappingOffset)) : null;
  const tsbMapping = tsbMappingOffset !== 0 ? parseDeltaSetIndexMap3(reader.sliceFrom(tsbMappingOffset)) : null;
  const bsbMapping = bsbMappingOffset !== 0 ? parseDeltaSetIndexMap3(reader.sliceFrom(bsbMappingOffset)) : null;
  const vOrgMapping = vOrgMappingOffset !== 0 ? parseDeltaSetIndexMap3(reader.sliceFrom(vOrgMappingOffset)) : null;
  return {
    majorVersion,
    minorVersion,
    itemVariationStore,
    advanceHeightMapping,
    tsbMapping,
    bsbMapping,
    vOrgMapping
  };
}
function parseItemVariationStore5(reader) {
  const format = reader.uint16();
  const variationRegionListOffset = reader.offset32();
  const itemVariationDataCount = reader.uint16();
  const itemVariationDataOffsets = [];
  for (let i = 0;i < itemVariationDataCount; i++) {
    itemVariationDataOffsets.push(reader.offset32());
  }
  const regionReader = reader.sliceFrom(variationRegionListOffset);
  const axisCount = regionReader.uint16();
  const regionCount = regionReader.uint16();
  const variationRegions = [];
  for (let i = 0;i < regionCount; i++) {
    const regionAxes = [];
    for (let j = 0;j < axisCount; j++) {
      regionAxes.push({
        startCoord: regionReader.f2dot14(),
        peakCoord: regionReader.f2dot14(),
        endCoord: regionReader.f2dot14()
      });
    }
    variationRegions.push({ regionAxes });
  }
  const itemVariationData = [];
  for (let i = 0;i < itemVariationDataOffsets.length; i++) {
    const offset = itemVariationDataOffsets[i];
    const dataReader = reader.sliceFrom(offset);
    const itemCount = dataReader.uint16();
    const wordDeltaCount = dataReader.uint16();
    const regionIndexCount = dataReader.uint16();
    const regionIndexes = [];
    for (let j = 0;j < regionIndexCount; j++) {
      regionIndexes.push(dataReader.uint16());
    }
    const longWords = (wordDeltaCount & 32768) !== 0;
    const wordCount = wordDeltaCount & 32767;
    const shortCount = regionIndexCount - wordCount;
    const deltaSets = [];
    for (let j = 0;j < itemCount; j++) {
      const deltas = [];
      for (let k = 0;k < wordCount; k++) {
        if (longWords) {
          deltas.push(dataReader.int32());
        } else {
          deltas.push(dataReader.int16());
        }
      }
      for (let k = 0;k < shortCount; k++) {
        if (longWords) {
          deltas.push(dataReader.int16());
        } else {
          deltas.push(dataReader.int8());
        }
      }
      deltaSets.push(deltas);
    }
    itemVariationData.push({ itemCount, regionIndexes, deltaSets });
  }
  return { format, variationRegions, itemVariationData };
}
function parseDeltaSetIndexMap3(reader) {
  const format = reader.uint8();
  const entryFormat = reader.uint8();
  const mapCount = format === 0 ? reader.uint16() : reader.uint32();
  const innerIndexBitCount = (entryFormat & 15) + 1;
  const mapEntrySize = (entryFormat >> 4 & 3) + 1;
  const mapData = [];
  for (let i = 0;i < mapCount; i++) {
    let entry = 0;
    for (let j = 0;j < mapEntrySize; j++) {
      entry = entry << 8 | reader.uint8();
    }
    const inner = entry & (1 << innerIndexBitCount) - 1;
    const outer = entry >> innerIndexBitCount;
    mapData.push({ outer, inner });
  }
  return { format, mapCount, entryFormat, innerIndexBitCount, mapData };
}
function getAdvanceHeightDelta(vvar, glyphId, coords) {
  const mapping = vvar.advanceHeightMapping;
  let outer;
  let inner;
  if (mapping && glyphId < mapping.mapData.length) {
    const entry = mapping.mapData[glyphId];
    if (!entry) {
      return 0;
    }
    outer = entry.outer;
    inner = entry.inner;
  } else {
    outer = 0;
    inner = glyphId;
  }
  return calculateDelta(vvar.itemVariationStore, outer, inner, coords);
}
function getTsbDelta(vvar, glyphId, coords) {
  const mapping = vvar.tsbMapping;
  if (!mapping)
    return 0;
  if (glyphId >= mapping.mapData.length)
    return 0;
  const entry = mapping.mapData[glyphId];
  if (!entry)
    return 0;
  return calculateDelta(vvar.itemVariationStore, entry.outer, entry.inner, coords);
}
function getBsbDelta(vvar, glyphId, coords) {
  const mapping = vvar.bsbMapping;
  if (!mapping)
    return 0;
  if (glyphId >= mapping.mapData.length)
    return 0;
  const entry = mapping.mapData[glyphId];
  if (!entry)
    return 0;
  return calculateDelta(vvar.itemVariationStore, entry.outer, entry.inner, coords);
}
function getVorgDelta(vvar, glyphId, coords) {
  const mapping = vvar.vOrgMapping;
  if (!mapping)
    return 0;
  if (glyphId >= mapping.mapData.length)
    return 0;
  const entry = mapping.mapData[glyphId];
  if (!entry)
    return 0;
  return calculateDelta(vvar.itemVariationStore, entry.outer, entry.inner, coords);
}
function calculateDelta(store, outer, inner, coords) {
  const varData = store.itemVariationData[outer];
  if (!varData || inner >= varData.itemCount) {
    return 0;
  }
  const deltaSet = varData.deltaSets[inner];
  if (!deltaSet) {
    return 0;
  }
  let delta = 0;
  for (let i = 0;i < varData.regionIndexes.length; i++) {
    const regionIndex = varData.regionIndexes[i];
    const region = store.variationRegions[regionIndex];
    if (!region)
      continue;
    const scalar = calculateRegionScalar(region, coords);
    const regionDelta = deltaSet[i] ?? 0;
    delta += scalar * regionDelta;
  }
  return Math.round(delta);
}

// reference/text-shaper/src/font/font.ts
var WOFF_MAGIC = 2001684038;
var WOFF2_MAGIC = 2001684018;
function isWoff2(buffer) {
  const view = new DataView(buffer);
  return view.getUint32(0, false) === WOFF2_MAGIC;
}
function isWoff(buffer) {
  const view = new DataView(buffer);
  return view.getUint32(0, false) === WOFF_MAGIC;
}

class FontCollection {
  buffer;
  header;
  loadFace;
  namesCache = null;
  constructor(buffer, header, loadFace) {
    this.buffer = buffer;
    this.header = header;
    this.loadFace = loadFace;
  }
  get count() {
    return this.header.numFonts;
  }
  get(index, options) {
    return this.loadFace(index, options);
  }
  names() {
    if (this.namesCache)
      return this.namesCache;
    const names = [];
    const reader = new Reader(this.buffer);
    for (let i = 0;i < this.header.numFonts; i++) {
      const offset = this.header.offsets[i] ?? 0;
      const entry = { index: i };
      if (offset >= 0 && offset < this.buffer.byteLength) {
        try {
          const directory = parseFontDirectory(new Reader(this.buffer, offset));
          const record = directory.tables.get(Tags.name);
          if (record) {
            const nameReader = reader.slice(record.offset, record.length);
            const table = parseName(nameReader);
            entry.fullName = getNameById(table, NameId.FullName) ?? undefined;
            entry.family = getNameById(table, NameId.FontFamily) ?? undefined;
            entry.subfamily = getNameById(table, NameId.FontSubfamily) ?? undefined;
            entry.postScriptName = getNameById(table, NameId.PostScriptName) ?? undefined;
          }
        } catch {}
      }
      names.push(entry);
    }
    this.namesCache = names;
    return names;
  }
}

class Font {
  reader;
  directory;
  _head = null;
  _maxp = null;
  _hhea = null;
  _hmtx = null;
  _cmap = null;
  _gdef = undefined;
  _gsub = undefined;
  _gpos = undefined;
  _kern = undefined;
  _fvar = undefined;
  _hvar = undefined;
  _vhea = undefined;
  _vmtx = undefined;
  _morx = undefined;
  _gvar = undefined;
  _avar = undefined;
  _kerx = undefined;
  _trak = undefined;
  _cff = undefined;
  _cff2 = undefined;
  _colr = undefined;
  _cpal = undefined;
  _vvar = undefined;
  _mvar = undefined;
  _os2 = undefined;
  _name = undefined;
  _post = undefined;
  _base = undefined;
  _jstf = undefined;
  _math = undefined;
  _loca = undefined;
  _glyf = undefined;
  _svg = undefined;
  _vorg = undefined;
  _sbix = undefined;
  _stat = undefined;
  _cbdt = undefined;
  _cblc = undefined;
  _feat = undefined;
  _fpgm = undefined;
  _prep = undefined;
  _cvt = undefined;
  _gasp = undefined;
  constructor(reader, directory, _options = {}) {
    this.reader = reader;
    this.directory = directory;
  }
  static load(buffer, options) {
    if (isWoff2(buffer)) {
      throw new Error("WOFF2 requires async loading. Use Font.loadAsync() instead.");
    }
    if (isWoff(buffer)) {
      throw new Error("WOFF format is not supported. Please use TTF, OTF, or WOFF2.");
    }
    return Font.loadFromBuffer(buffer, options);
  }
  static async loadAsync(buffer, options) {
    if (isWoff2(buffer)) {
      buffer = await woff2ToSfnt(buffer);
    } else if (isWoff(buffer)) {
      throw new Error("WOFF format is not supported. Please use TTF, OTF, or WOFF2.");
    }
    return Font.loadFromBuffer(buffer, options);
  }
  static async fromURL(url, options) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch font: ${response.status} ${response.statusText}`);
    }
    const buffer = await response.arrayBuffer();
    return Font.loadAsync(buffer, options);
  }
  static async fromFile(path2, options) {
    const file = Bun.file(path2);
    const buffer = await file.arrayBuffer();
    return Font.loadAsync(buffer, options);
  }
  static collection(buffer) {
    if (!isTtc(buffer))
      return null;
    const header = parseTtcHeader(buffer);
    return new FontCollection(buffer, header, (index, options) => Font.loadFromTtc(buffer, options, header, index));
  }
  static loadFromBuffer(buffer, options) {
    if (isTtc(buffer)) {
      return Font.loadFromTtc(buffer, options);
    }
    const reader = new Reader(buffer);
    const directory = parseFontDirectory(reader);
    return new Font(reader, directory, options);
  }
  static loadFromTtc(buffer, options, header, indexOverride) {
    const ttcHeader = header ?? parseTtcHeader(buffer);
    const index = indexOverride ?? options?.collectionIndex ?? 0;
    if (!Number.isInteger(index) || index < 0) {
      throw new Error(`Invalid TTC collection index: ${index}`);
    }
    if (index >= ttcHeader.numFonts) {
      throw new Error(`TTC collection index out of range: ${index} (count ${ttcHeader.numFonts})`);
    }
    const offset = ttcHeader.offsets[index] ?? 0;
    if (!Number.isFinite(offset) || offset < 0 || offset >= buffer.byteLength) {
      throw new Error(`Invalid TTC font offset: ${offset}`);
    }
    const reader = new Reader(buffer);
    const directory = parseFontDirectory(new Reader(buffer, offset));
    return new Font(reader, directory, options);
  }
  hasTable(tag2) {
    return this.directory.tables.has(tag2);
  }
  getTableRecord(tag2) {
    return this.directory.tables.get(tag2);
  }
  getTableReader(tag2) {
    const record = this.directory.tables.get(tag2);
    if (!record)
      return null;
    return this.reader.slice(record.offset, record.length);
  }
  get head() {
    if (!this._head) {
      const reader = this.getTableReader(Tags.head);
      if (!reader)
        throw new Error("Missing required 'head' table");
      this._head = parseHead(reader);
    }
    return this._head;
  }
  get maxp() {
    if (!this._maxp) {
      const reader = this.getTableReader(Tags.maxp);
      if (!reader)
        throw new Error("Missing required 'maxp' table");
      this._maxp = parseMaxp(reader);
    }
    return this._maxp;
  }
  get hhea() {
    if (!this._hhea) {
      const reader = this.getTableReader(Tags.hhea);
      if (!reader)
        throw new Error("Missing required 'hhea' table");
      this._hhea = parseHhea(reader);
    }
    return this._hhea;
  }
  get hmtx() {
    if (!this._hmtx) {
      const reader = this.getTableReader(Tags.hmtx);
      if (!reader)
        throw new Error("Missing required 'hmtx' table");
      this._hmtx = parseHmtx(reader, this.hhea.numberOfHMetrics, this.numGlyphs);
    }
    return this._hmtx;
  }
  get cmap() {
    if (!this._cmap) {
      const record = this.getTableRecord(Tags.cmap);
      const reader = this.getTableReader(Tags.cmap);
      if (!reader || !record)
        throw new Error("Missing required 'cmap' table");
      this._cmap = parseCmap(reader, record.length);
    }
    return this._cmap;
  }
  get gdef() {
    if (this._gdef === undefined) {
      const reader = this.getTableReader(Tags.GDEF);
      this._gdef = reader ? parseGdef(reader) : null;
    }
    return this._gdef;
  }
  get gsub() {
    if (this._gsub === undefined) {
      const reader = this.getTableReader(Tags.GSUB);
      this._gsub = reader ? parseGsub(reader) : null;
    }
    return this._gsub;
  }
  get gpos() {
    if (this._gpos === undefined) {
      const reader = this.getTableReader(Tags.GPOS);
      this._gpos = reader ? parseGpos(reader) : null;
    }
    return this._gpos;
  }
  get kern() {
    if (this._kern === undefined) {
      const reader = this.getTableReader(Tags.kern);
      this._kern = reader ? parseKern(reader) : null;
    }
    return this._kern;
  }
  get fvar() {
    if (this._fvar === undefined) {
      const reader = this.getTableReader(Tags.fvar);
      this._fvar = reader ? parseFvar(reader) : null;
    }
    return this._fvar;
  }
  get hvar() {
    if (this._hvar === undefined) {
      const reader = this.getTableReader(Tags.HVAR);
      this._hvar = reader ? parseHvar(reader) : null;
    }
    return this._hvar;
  }
  get vhea() {
    if (this._vhea === undefined) {
      const reader = this.getTableReader(Tags.vhea);
      this._vhea = reader ? parseVhea(reader) : null;
    }
    return this._vhea;
  }
  get vmtx() {
    if (this._vmtx === undefined) {
      const vhea = this.vhea;
      if (!vhea) {
        this._vmtx = null;
      } else {
        const reader = this.getTableReader(Tags.vmtx);
        this._vmtx = reader ? parseVmtx(reader, vhea.numberOfVMetrics, this.numGlyphs) : null;
      }
    }
    return this._vmtx;
  }
  get morx() {
    if (this._morx === undefined) {
      const reader = this.getTableReader(Tags.morx);
      this._morx = reader ? parseMorx(reader) : null;
    }
    return this._morx;
  }
  get gvar() {
    if (this._gvar === undefined) {
      const reader = this.getTableReader(Tags.gvar);
      this._gvar = reader ? parseGvar(reader, this.numGlyphs) : null;
    }
    return this._gvar;
  }
  get avar() {
    if (this._avar === undefined) {
      const fvar = this.fvar;
      if (!fvar) {
        this._avar = null;
      } else {
        const reader = this.getTableReader(Tags.avar);
        this._avar = reader ? parseAvar(reader, fvar.axes.length) : null;
      }
    }
    return this._avar;
  }
  get kerx() {
    if (this._kerx === undefined) {
      const reader = this.getTableReader(Tags.kerx);
      this._kerx = reader ? parseKerx(reader) : null;
    }
    return this._kerx;
  }
  get trak() {
    if (this._trak === undefined) {
      const reader = this.getTableReader(Tags.trak);
      this._trak = reader ? parseTrak(reader) : null;
    }
    return this._trak;
  }
  get cff() {
    if (this._cff === undefined) {
      const reader = this.getTableReader(Tags.CFF);
      this._cff = reader ? parseCff(reader) : null;
    }
    return this._cff;
  }
  get cff2() {
    if (this._cff2 === undefined) {
      const reader = this.getTableReader(Tags.CFF2);
      this._cff2 = reader ? parseCff2(reader) : null;
    }
    return this._cff2;
  }
  get colr() {
    if (this._colr === undefined) {
      const reader = this.getTableReader(Tags.COLR);
      this._colr = reader ? parseColr(reader) : null;
    }
    return this._colr;
  }
  get cpal() {
    if (this._cpal === undefined) {
      const reader = this.getTableReader(Tags.CPAL);
      this._cpal = reader ? parseCpal(reader) : null;
    }
    return this._cpal;
  }
  get vvar() {
    if (this._vvar === undefined) {
      const reader = this.getTableReader(Tags.VVAR);
      this._vvar = reader ? parseVvar(reader) : null;
    }
    return this._vvar;
  }
  get mvar() {
    if (this._mvar === undefined) {
      const reader = this.getTableReader(Tags.MVAR);
      this._mvar = reader ? parseMvar(reader) : null;
    }
    return this._mvar;
  }
  get os2() {
    if (this._os2 === undefined) {
      const reader = this.getTableReader(Tags.OS2);
      this._os2 = reader ? parseOs2(reader) : null;
    }
    return this._os2;
  }
  get name() {
    if (this._name === undefined) {
      const reader = this.getTableReader(Tags.name);
      this._name = reader ? parseName(reader) : null;
    }
    return this._name;
  }
  get post() {
    if (this._post === undefined) {
      const reader = this.getTableReader(Tags.post);
      this._post = reader ? parsePost(reader) : null;
    }
    return this._post;
  }
  get base() {
    if (this._base === undefined) {
      const reader = this.getTableReader(Tags.BASE);
      this._base = reader ? parseBase(reader) : null;
    }
    return this._base;
  }
  get jstf() {
    if (this._jstf === undefined) {
      const reader = this.getTableReader(Tags.JSTF);
      this._jstf = reader ? parseJstf(reader) : null;
    }
    return this._jstf;
  }
  get math() {
    if (this._math === undefined) {
      const reader = this.getTableReader(Tags.MATH);
      this._math = reader ? parseMath(reader) : null;
    }
    return this._math;
  }
  get loca() {
    if (this._loca === undefined) {
      const reader = this.getTableReader(Tags.loca);
      this._loca = reader ? parseLoca(reader, this.numGlyphs, this.head.indexToLocFormat) : null;
    }
    return this._loca;
  }
  get glyf() {
    if (this._glyf === undefined) {
      const reader = this.getTableReader(Tags.glyf);
      this._glyf = reader ? parseGlyf(reader) : null;
    }
    return this._glyf;
  }
  get svg() {
    if (this._svg === undefined) {
      const reader = this.getTableReader(Tags.SVG);
      this._svg = reader ? parseSvg(reader) : null;
    }
    return this._svg;
  }
  get vorg() {
    if (this._vorg === undefined) {
      const reader = this.getTableReader(Tags.VORG);
      this._vorg = reader ? parseVorg(reader) : null;
    }
    return this._vorg;
  }
  get sbix() {
    if (this._sbix === undefined) {
      const reader = this.getTableReader(Tags.sbix);
      this._sbix = reader ? parseSbix(reader, this.numGlyphs) : null;
    }
    return this._sbix;
  }
  get stat() {
    if (this._stat === undefined) {
      const reader = this.getTableReader(Tags.STAT);
      this._stat = reader ? parseStat(reader) : null;
    }
    return this._stat;
  }
  get cblc() {
    if (this._cblc === undefined) {
      const reader = this.getTableReader(Tags.CBLC);
      this._cblc = reader ? parseCblc(reader) : null;
    }
    return this._cblc;
  }
  get cbdt() {
    if (this._cbdt === undefined) {
      const reader = this.getTableReader(Tags.CBDT);
      this._cbdt = reader ? parseCbdt(reader) : null;
    }
    return this._cbdt;
  }
  get feat() {
    if (this._feat === undefined) {
      const reader = this.getTableReader(Tags.feat);
      this._feat = reader ? parseFeat(reader) : null;
    }
    return this._feat;
  }
  get fpgm() {
    if (this._fpgm === undefined) {
      const reader = this.getTableReader(Tags.fpgm);
      this._fpgm = reader ? parseFpgm(reader) : null;
    }
    return this._fpgm;
  }
  get prep() {
    if (this._prep === undefined) {
      const reader = this.getTableReader(Tags.prep);
      this._prep = reader ? parsePrep(reader) : null;
    }
    return this._prep;
  }
  get cvtTable() {
    if (this._cvt === undefined) {
      const reader = this.getTableReader(Tags.cvt);
      this._cvt = reader ? parseCvt(reader) : null;
    }
    return this._cvt;
  }
  get gasp() {
    if (this._gasp === undefined) {
      const reader = this.getTableReader(Tags.gasp);
      this._gasp = reader ? parseGasp(reader) : null;
    }
    return this._gasp;
  }
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  get ascender() {
    return this.hhea.ascender;
  }
  get descender() {
    return this.hhea.descender;
  }
  get lineGap() {
    return this.hhea.lineGap;
  }
  get height() {
    const baseHeight = this.ascender - this.descender;
    return baseHeight;
  }
  scaleForSize(sizePx, mode) {
    if (mode === "height") {
      const h = this.height;
      if (!Number.isFinite(h) || h <= 0)
        return sizePx / this.unitsPerEm;
      return sizePx / h;
    }
    return sizePx / this.unitsPerEm;
  }
  get isTrueType() {
    return isTrueType(this.directory);
  }
  get isCFF() {
    return this.hasTable(Tags.CFF) || this.hasTable(Tags.CFF2);
  }
  get isVariable() {
    return this.hasTable(Tags.fvar);
  }
  get hasOpenTypeLayout() {
    return this.hasTable(Tags.GSUB) || this.hasTable(Tags.GPOS);
  }
  get hasAATLayout() {
    return this.hasTable(Tags.morx) || this.hasTable(Tags.kerx);
  }
  get isColorFont() {
    return this.hasTable(Tags.COLR) || this.hasTable(Tags.SVG) || this.hasTable(Tags.sbix) || this.hasTable(Tags.CBDT);
  }
  get hasHinting() {
    return this.isTrueType && (this.hasTable(Tags.fpgm) || this.hasTable(Tags.prep));
  }
  glyphId(codepoint) {
    return getGlyphId(this.cmap, codepoint);
  }
  glyphIdForChar(char2) {
    const codepoint = char2.codePointAt(0);
    if (codepoint === undefined)
      return 0;
    return this.glyphId(codepoint);
  }
  advanceWidth(glyphId) {
    return getAdvanceWidth(this.hmtx, glyphId);
  }
  leftSideBearing(glyphId) {
    return getLeftSideBearing(this.hmtx, glyphId);
  }
  listTables() {
    return [...this.directory.tables.keys()].map(tagToString);
  }
  getGlyph(glyphId) {
    if (!this.glyf || !this.loca)
      return null;
    return parseGlyph(this.glyf, this.loca, glyphId);
  }
  getGlyphContours(glyphId) {
    if (this.glyf && this.loca) {
      return getGlyphContours(this.glyf, this.loca, glyphId);
    }
    if (this.cff) {
      return executeCffCharString(this.cff, glyphId, 0);
    }
    if (this.cff2) {
      return executeCff2CharString(this.cff2, glyphId, null);
    }
    return null;
  }
  getGlyphBounds(glyphId) {
    if (this.glyf && this.loca) {
      return getGlyphBounds(this.glyf, this.loca, glyphId);
    }
    const contours = this.getGlyphContours(glyphId);
    if (!contours || contours.length === 0)
      return null;
    let xMin = Infinity;
    let yMin = Infinity;
    let xMax = -Infinity;
    let yMax = -Infinity;
    for (let i = 0;i < contours.length; i++) {
      const contour = contours[i];
      for (let j = 0;j < contour.length; j++) {
        const point = contour[j];
        xMin = Math.min(xMin, point.x);
        yMin = Math.min(yMin, point.y);
        xMax = Math.max(xMax, point.x);
        yMax = Math.max(yMax, point.y);
      }
    }
    if (xMin === Infinity)
      return null;
    return { xMin, yMin, xMax, yMax };
  }
  getGlyphContoursAndBounds(glyphId) {
    if (this.glyf && this.loca) {
      return getGlyphContoursAndBounds(this.glyf, this.loca, glyphId);
    }
    const contours = this.getGlyphContours(glyphId);
    if (!contours)
      return null;
    if (contours.length === 0) {
      return { contours, bounds: null };
    }
    let xMin = Infinity;
    let yMin = Infinity;
    let xMax = -Infinity;
    let yMax = -Infinity;
    for (let i = 0;i < contours.length; i++) {
      const contour = contours[i];
      for (let j = 0;j < contour.length; j++) {
        const point = contour[j];
        xMin = Math.min(xMin, point.x);
        yMin = Math.min(yMin, point.y);
        xMax = Math.max(xMax, point.x);
        yMax = Math.max(yMax, point.y);
      }
    }
    const bounds = xMin === Infinity ? null : { xMin, yMin, xMax, yMax };
    return { contours, bounds };
  }
  getGlyphContoursWithVariation(glyphId, axisCoords) {
    if (this.glyf && this.loca) {
      return getGlyphContoursWithVariation(this.glyf, this.loca, this.gvar, glyphId, axisCoords);
    }
    if (this.cff2) {
      return executeCff2CharString(this.cff2, glyphId, axisCoords);
    }
    return this.getGlyphContours(glyphId);
  }
}
// reference/text-shaper/src/layout/justify.ts
var JustifyMode;
((JustifyMode2) => {
  JustifyMode2["Shrink"] = "shrink";
  JustifyMode2["Extend"] = "extend";
  JustifyMode2["Auto"] = "auto";
})(JustifyMode ||= {});
function calculateLineWidth(buffer) {
  let width = 0;
  for (let i = 0;i < buffer.positions.length; i++) {
    const pos = buffer.positions[i];
    width += pos.xAdvance;
  }
  return width;
}
function justify(font, buffer, options) {
  const {
    targetWidth,
    script = tag("DFLT"),
    language,
    mode = "auto" /* Auto */,
    maxPriority = 10,
    enableKashida = true,
    minWordSpacingFactor = 0.8,
    maxWordSpacingFactor = 1.5,
    enableLetterSpacing = true,
    maxLetterSpacing = 100
  } = options;
  const currentWidth = calculateLineWidth(buffer);
  const delta = targetWidth - currentWidth;
  if (Math.abs(delta) < 1) {
    return {
      success: true,
      finalWidth: currentWidth,
      delta: 0,
      priorityLevel: 0,
      adjustments: []
    };
  }
  let actualMode;
  if (mode === "auto" /* Auto */) {
    actualMode = delta > 0 ? "extend" /* Extend */ : "shrink" /* Shrink */;
  } else {
    actualMode = mode;
  }
  const adjustments = [];
  let remainingDelta = delta;
  let priorityLevel = 0;
  const jstf = font.jstf;
  if (jstf) {
    const priorities = getJstfPriorities(jstf, script, language);
    for (let i = 0;i < Math.min(priorities.length, maxPriority); i++) {
      const priority = priorities[i];
      const mods = actualMode === "shrink" /* Shrink */ ? getShrinkageMods(priority) : getExtensionMods(priority);
      if (mods.enableGsub.length > 0 || mods.disableGsub.length > 0 || mods.enableGpos.length > 0 || mods.disableGpos.length > 0) {
        adjustments.push({
          type: "lookup",
          glyphIndices: [],
          value: i
        });
        priorityLevel = i;
      }
    }
    if (enableKashida && actualMode === "extend" /* Extend */) {
      const extenderGlyphs = getExtenderGlyphs(jstf, script);
      if (extenderGlyphs.length > 0) {
        const kashidaResult = insertKashida(buffer, extenderGlyphs[0], remainingDelta, font);
        remainingDelta -= kashidaResult.totalExtension;
        adjustments.push(...kashidaResult.adjustments);
      }
    }
  }
  const spaceGlyphId = font.glyphId(32);
  if (spaceGlyphId !== 0) {
    const spaceResult = adjustWordSpacing(buffer, spaceGlyphId, remainingDelta, actualMode === "shrink" /* Shrink */ ? minWordSpacingFactor : maxWordSpacingFactor);
    remainingDelta -= spaceResult.totalAdjustment;
    adjustments.push(...spaceResult.adjustments);
  }
  if (enableLetterSpacing && Math.abs(remainingDelta) > 1) {
    const letterResult = adjustLetterSpacing(buffer, remainingDelta, maxLetterSpacing);
    remainingDelta -= letterResult.totalAdjustment;
    adjustments.push(...letterResult.adjustments);
  }
  const finalWidth = calculateLineWidth(buffer);
  return {
    success: Math.abs(remainingDelta) < 1,
    finalWidth,
    delta: targetWidth - finalWidth,
    priorityLevel,
    adjustments
  };
}
function insertKashida(buffer, kashidaGlyph, targetExtension, font) {
  const adjustments = [];
  let totalExtension = 0;
  const insertionPoints = [];
  for (let i = 0;i < buffer.infos.length - 1; i++) {
    const info = buffer.infos[i];
    if (isValidKashidaPoint(info.codepoint)) {
      insertionPoints.push(i);
    }
  }
  if (insertionPoints.length === 0) {
    return { totalExtension: 0, adjustments: [] };
  }
  const kashidaWidth = font.advanceWidth(kashidaGlyph);
  if (kashidaWidth <= 0) {
    return { totalExtension: 0, adjustments: [] };
  }
  const kashidaPerPoint = Math.ceil(targetExtension / kashidaWidth / insertionPoints.length);
  const adjustmentPerPoint = Math.min(kashidaPerPoint * kashidaWidth, targetExtension / insertionPoints.length);
  for (let i = 0;i < insertionPoints.length; i++) {
    if (totalExtension >= targetExtension)
      break;
    const point = insertionPoints[i];
    buffer.positions[point].xAdvance += adjustmentPerPoint;
    totalExtension += adjustmentPerPoint;
    adjustments.push({
      type: "kashida",
      glyphIndices: [point],
      value: adjustmentPerPoint
    });
  }
  return { totalExtension, adjustments };
}
function isValidKashidaPoint(codepoint) {
  return codepoint >= 1568 && codepoint <= 1791;
}
function adjustWordSpacing(buffer, spaceGlyph, targetAdjustment, limitFactor) {
  const adjustments = [];
  let totalAdjustment = 0;
  const spaceIndices = [];
  let totalSpaceWidth = 0;
  for (let i = 0;i < buffer.infos.length; i++) {
    if (buffer.infos[i]?.glyphId === spaceGlyph) {
      spaceIndices.push(i);
      totalSpaceWidth += buffer.positions[i]?.xAdvance;
    }
  }
  if (spaceIndices.length === 0) {
    return { totalAdjustment: 0, adjustments: [] };
  }
  const adjustmentPerSpace = targetAdjustment / spaceIndices.length;
  const originalSpaceWidth = totalSpaceWidth / spaceIndices.length;
  const maxAdjustment = originalSpaceWidth * (limitFactor - 1);
  const clampedAdjustment = targetAdjustment > 0 ? Math.min(adjustmentPerSpace, maxAdjustment) : Math.max(adjustmentPerSpace, -maxAdjustment);
  for (let i = 0;i < spaceIndices.length; i++) {
    const idx = spaceIndices[i];
    buffer.positions[idx].xAdvance += clampedAdjustment;
    totalAdjustment += clampedAdjustment;
  }
  if (totalAdjustment !== 0) {
    adjustments.push({
      type: "spacing",
      glyphIndices: spaceIndices,
      value: clampedAdjustment
    });
  }
  return { totalAdjustment, adjustments };
}
function adjustLetterSpacing(buffer, targetAdjustment, maxAdjustment) {
  const adjustments = [];
  const numGlyphs = buffer.infos.length;
  if (numGlyphs <= 1) {
    return { totalAdjustment: 0, adjustments: [] };
  }
  const numGaps = numGlyphs - 1;
  const adjustmentPerGap = targetAdjustment / numGaps;
  const clampedAdjustment = targetAdjustment > 0 ? Math.min(adjustmentPerGap, maxAdjustment) : Math.max(adjustmentPerGap, -maxAdjustment);
  const affectedIndices = [];
  let totalAdjustment = 0;
  for (let i = 0;i < numGlyphs - 1; i++) {
    buffer.positions[i].xAdvance += clampedAdjustment;
    totalAdjustment += clampedAdjustment;
    affectedIndices.push(i);
  }
  if (totalAdjustment !== 0) {
    adjustments.push({
      type: "spacing",
      glyphIndices: affectedIndices,
      value: clampedAdjustment
    });
  }
  return { totalAdjustment, adjustments };
}
function breakIntoLines(buffer, maxWidth, spaceGlyph) {
  const lines = [];
  const breakPoints = [];
  if (buffer.infos.length === 0) {
    return { lines: [], breakPoints: [] };
  }
  let lineStart = 0;
  let currentWidth = 0;
  let lastBreakPoint = -1;
  let _lastBreakWidth = 0;
  for (let i = 0;i < buffer.infos.length; i++) {
    const pos = buffer.positions[i];
    const info = buffer.infos[i];
    currentWidth += pos.xAdvance;
    if (spaceGlyph !== undefined && info.glyphId === spaceGlyph) {
      lastBreakPoint = i;
      _lastBreakWidth = currentWidth;
    }
    if (currentWidth > maxWidth && lineStart < i) {
      let breakAt;
      if (lastBreakPoint > lineStart) {
        breakAt = lastBreakPoint + 1;
      } else {
        breakAt = i;
      }
      const lineBuffer = createLineBuffer(buffer, lineStart, breakAt);
      lines.push(lineBuffer);
      breakPoints.push(breakAt);
      lineStart = breakAt;
      currentWidth = 0;
      lastBreakPoint = -1;
      for (let j = lineStart;j <= i; j++) {
        currentWidth += buffer.positions[j]?.xAdvance;
      }
    }
  }
  if (lineStart < buffer.infos.length) {
    const lineBuffer = createLineBuffer(buffer, lineStart, buffer.infos.length);
    lines.push(lineBuffer);
  }
  return { lines, breakPoints };
}
function createLineBuffer(source, start, end) {
  const lineBuffer = new GlyphBuffer;
  lineBuffer.direction = source.direction;
  lineBuffer.script = source.script;
  lineBuffer.language = source.language;
  for (let i = start;i < end; i++) {
    lineBuffer.infos.push({ ...source.infos[i] });
    lineBuffer.positions.push({ ...source.positions[i] });
  }
  return lineBuffer;
}
function justifyParagraph(font, lines, options) {
  const results = [];
  for (let i = 0;i < lines.length; i++) {
    const line = lines[i];
    const isLastLine = i === lines.length - 1;
    if (isLastLine) {
      results.push({
        success: true,
        finalWidth: calculateLineWidth(line),
        delta: 0,
        priorityLevel: 0,
        adjustments: []
      });
    } else {
      results.push(justify(font, line, options));
    }
  }
  return results;
}
// reference/text-shaper/src/layout/structures/feature-variations.ts
function evaluateConditionSet(conditionSet, axisCoords) {
  for (let i = 0;i < conditionSet.conditions.length; i++) {
    const condition = conditionSet.conditions[i];
    const axisValue = axisCoords[condition.axisIndex] ?? 0;
    if (axisValue < condition.filterRangeMinValue || axisValue > condition.filterRangeMaxValue) {
      return false;
    }
  }
  return true;
}
function findMatchingFeatureVariation(featureVariations, axisCoords) {
  for (let i = 0;i < featureVariations.featureVariationRecords.length; i++) {
    const record = featureVariations.featureVariationRecords[i];
    if (evaluateConditionSet(record.conditionSet, axisCoords)) {
      return record;
    }
  }
  return null;
}
function getSubstitutedLookups(featureVariations, featureIndex, originalLookups, axisCoords) {
  if (!featureVariations || !axisCoords) {
    return originalLookups;
  }
  const matchingRecord = findMatchingFeatureVariation(featureVariations, axisCoords);
  if (!matchingRecord) {
    return originalLookups;
  }
  const substitution = matchingRecord.featureTableSubstitution.substitutions.find((s) => s.featureIndex === featureIndex);
  if (substitution) {
    return substitution.alternateFeature.lookupListIndices;
  }
  return originalLookups;
}
function applyFeatureVariations(featureVariations, featureLookups, featureIndices, axisCoords) {
  if (!featureVariations || !axisCoords) {
    return featureLookups;
  }
  const matchingRecord = findMatchingFeatureVariation(featureVariations, axisCoords);
  if (!matchingRecord) {
    return featureLookups;
  }
  const result = new Map(featureLookups);
  const substitutions = matchingRecord.featureTableSubstitution.substitutions;
  for (let i = 0;i < substitutions.length; i++) {
    const substitution = substitutions[i];
    const entries = [...featureIndices.entries()];
    for (let j = 0;j < entries.length; j++) {
      const [tag2, index] = entries[j];
      if (index === substitution.featureIndex) {
        result.set(tag2, substitution.alternateFeature.lookupListIndices);
        break;
      }
    }
  }
  return result;
}
// reference/text-shaper/src/raster/lcd-filter.ts
init_types();
var LCD_FILTER_LIGHT = [0, 85, 86, 85, 0];
var LCD_FILTER_DEFAULT = [8, 77, 86, 77, 8];
var LCD_FILTER_LEGACY = [0, 64, 128, 64, 0];
var LcdMode;
((LcdMode2) => {
  LcdMode2[LcdMode2["RGB"] = 0] = "RGB";
  LcdMode2[LcdMode2["BGR"] = 1] = "BGR";
  LcdMode2[LcdMode2["RGB_V"] = 2] = "RGB_V";
  LcdMode2[LcdMode2["BGR_V"] = 3] = "BGR_V";
})(LcdMode ||= {});
function rasterizeLcd(path2, width, height, scale2, offsetX, offsetY, mode = 0 /* RGB */, filterWeights = LCD_FILTER_DEFAULT) {
  const isVertical = mode === 2 /* RGB_V */ || mode === 3 /* BGR_V */;
  if (isVertical) {
    return rasterizeLcdVertical(path2, width, height, scale2, offsetX, offsetY, mode, filterWeights);
  }
  const subpixelWidth = width * 3;
  const grayscale = createBitmap(subpixelWidth, height, 1 /* Gray */);
  const raster = new GrayRaster;
  raster.setClip(0, 0, subpixelWidth, height);
  raster.reset();
  decomposePath(raster, path2, scale2 * 3, offsetX * 3, offsetY, true);
  raster.sweep(grayscale);
  const lcd = createBitmap(width, height, 2 /* LCD */);
  const isBgr = mode === 1 /* BGR */;
  applyLcdFilterHorizontal(grayscale, lcd, filterWeights, isBgr);
  return lcd;
}
function rasterizeLcdVertical(path2, width, height, scale2, offsetX, offsetY, mode, filterWeights) {
  const subpixelHeight = height * 3;
  const grayscale = createBitmap(width, subpixelHeight, 1 /* Gray */);
  const raster = new GrayRaster;
  raster.setClip(0, 0, width, subpixelHeight);
  raster.reset();
  decomposePath(raster, path2, scale2, offsetX, offsetY * 3, true);
  raster.sweep(grayscale);
  const lcd = createBitmap(width, height, 3 /* LCD_V */);
  const isBgr = mode === 3 /* BGR_V */;
  applyLcdFilterVertical(grayscale, lcd, filterWeights, isBgr);
  return lcd;
}
function applyLcdFilterHorizontal(src, dst, weights, isBgr) {
  const [w0, w1, w2, w3, w4] = weights;
  const weightSum = w0 + w1 + w2 + w3 + w4;
  for (let y = 0;y < dst.rows; y++) {
    const srcRow = y * src.pitch;
    const dstRow = y * dst.pitch;
    for (let x = 0;x < dst.width; x++) {
      const subX = x * 3;
      const r0 = subX - 2 >= 0 ? src.buffer[srcRow + subX - 2] : 0;
      const r1 = subX - 1 >= 0 ? src.buffer[srcRow + subX - 1] : 0;
      const r2 = src.buffer[srcRow + subX];
      const r3 = subX + 1 < src.width ? src.buffer[srcRow + subX + 1] : 0;
      const r4 = subX + 2 < src.width ? src.buffer[srcRow + subX + 2] : 0;
      const rv = Math.min(255, Math.round((r0 * w0 + r1 * w1 + r2 * w2 + r3 * w3 + r4 * w4) / weightSum));
      const g0 = subX - 1 >= 0 ? src.buffer[srcRow + subX - 1] : 0;
      const g1 = src.buffer[srcRow + subX];
      const g2 = subX + 1 < src.width ? src.buffer[srcRow + subX + 1] : 0;
      const g3 = subX + 2 < src.width ? src.buffer[srcRow + subX + 2] : 0;
      const g4 = subX + 3 < src.width ? src.buffer[srcRow + subX + 3] : 0;
      const gv = Math.min(255, Math.round((g0 * w0 + g1 * w1 + g2 * w2 + g3 * w3 + g4 * w4) / weightSum));
      const b0 = src.buffer[srcRow + subX];
      const b1 = subX + 1 < src.width ? src.buffer[srcRow + subX + 1] : 0;
      const b2 = subX + 2 < src.width ? src.buffer[srcRow + subX + 2] : 0;
      const b3 = subX + 3 < src.width ? src.buffer[srcRow + subX + 3] : 0;
      const b4 = subX + 4 < src.width ? src.buffer[srcRow + subX + 4] : 0;
      const bv = Math.min(255, Math.round((b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3 + b4 * w4) / weightSum));
      const dstIdx = dstRow + x * 3;
      if (isBgr) {
        dst.buffer[dstIdx] = bv;
        dst.buffer[dstIdx + 1] = gv;
        dst.buffer[dstIdx + 2] = rv;
      } else {
        dst.buffer[dstIdx] = rv;
        dst.buffer[dstIdx + 1] = gv;
        dst.buffer[dstIdx + 2] = bv;
      }
    }
  }
}
function applyLcdFilterVertical(src, dst, weights, isBgr) {
  const [w0, w1, w2, w3, w4] = weights;
  const weightSum = w0 + w1 + w2 + w3 + w4;
  for (let y = 0;y < dst.rows; y++) {
    const subY = y * 3;
    const dstRow = y * dst.pitch;
    for (let x = 0;x < dst.width; x++) {
      const r0 = subY - 2 >= 0 ? src.buffer[(subY - 2) * src.pitch + x] : 0;
      const r1 = subY - 1 >= 0 ? src.buffer[(subY - 1) * src.pitch + x] : 0;
      const r2 = src.buffer[subY * src.pitch + x];
      const r3 = subY + 1 < src.rows ? src.buffer[(subY + 1) * src.pitch + x] : 0;
      const r4 = subY + 2 < src.rows ? src.buffer[(subY + 2) * src.pitch + x] : 0;
      const rv = Math.min(255, Math.round((r0 * w0 + r1 * w1 + r2 * w2 + r3 * w3 + r4 * w4) / weightSum));
      const g0 = subY - 1 >= 0 ? src.buffer[(subY - 1) * src.pitch + x] : 0;
      const g1 = src.buffer[subY * src.pitch + x];
      const g2 = subY + 1 < src.rows ? src.buffer[(subY + 1) * src.pitch + x] : 0;
      const g3 = subY + 2 < src.rows ? src.buffer[(subY + 2) * src.pitch + x] : 0;
      const g4 = subY + 3 < src.rows ? src.buffer[(subY + 3) * src.pitch + x] : 0;
      const gv = Math.min(255, Math.round((g0 * w0 + g1 * w1 + g2 * w2 + g3 * w3 + g4 * w4) / weightSum));
      const b0 = src.buffer[subY * src.pitch + x];
      const b1 = subY + 1 < src.rows ? src.buffer[(subY + 1) * src.pitch + x] : 0;
      const b2 = subY + 2 < src.rows ? src.buffer[(subY + 2) * src.pitch + x] : 0;
      const b3 = subY + 3 < src.rows ? src.buffer[(subY + 3) * src.pitch + x] : 0;
      const b4 = subY + 4 < src.rows ? src.buffer[(subY + 4) * src.pitch + x] : 0;
      const bv = Math.min(255, Math.round((b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3 + b4 * w4) / weightSum));
      const dstIdx = dstRow + x * 3;
      if (isBgr) {
        dst.buffer[dstIdx] = bv;
        dst.buffer[dstIdx + 1] = gv;
        dst.buffer[dstIdx + 2] = rv;
      } else {
        dst.buffer[dstIdx] = rv;
        dst.buffer[dstIdx + 1] = gv;
        dst.buffer[dstIdx + 2] = bv;
      }
    }
  }
}
function lcdToRGBA(lcd, bgColor = [255, 255, 255], fgColor = [0, 0, 0]) {
  const rgba = new Uint8Array(lcd.width * lcd.rows * 4);
  const [bgR, bgG, bgB] = bgColor;
  const [fgR, fgG, fgB] = fgColor;
  for (let y = 0;y < lcd.rows; y++) {
    const srcRow = y * lcd.pitch;
    const dstRow = y * lcd.width * 4;
    for (let x = 0;x < lcd.width; x++) {
      const srcIdx = srcRow + x * 3;
      const dstIdx = dstRow + x * 4;
      const r = lcd.buffer[srcIdx];
      const g = lcd.buffer[srcIdx + 1];
      const b = lcd.buffer[srcIdx + 2];
      rgba[dstIdx] = blendChannel(bgR, fgR, r);
      rgba[dstIdx + 1] = blendChannel(bgG, fgG, g);
      rgba[dstIdx + 2] = blendChannel(bgB, fgB, b);
      rgba[dstIdx + 3] = 255;
    }
  }
  return rgba;
}
function blendChannel(bg, fg, alpha) {
  return Math.round(bg + (fg - bg) * alpha / 255);
}

// reference/text-shaper/src/index.ts
init_types();

// reference/text-shaper/src/unicode/normalize.ts
var NormalizationMode;
((NormalizationMode2) => {
  NormalizationMode2[NormalizationMode2["None"] = 0] = "None";
  NormalizationMode2[NormalizationMode2["Decompose"] = 1] = "Decompose";
  NormalizationMode2[NormalizationMode2["Compose"] = 2] = "Compose";
  NormalizationMode2[NormalizationMode2["Auto"] = 3] = "Auto";
})(NormalizationMode ||= {});
function getCombiningClass(cp) {
  if (cp < 768)
    return 0;
  if (cp >= 880 && cp < 1328)
    return 0;
  if (cp >= 12288) {
    if (cp >= 44032 && cp <= 55215)
      return 0;
    if (cp >= 19968 && cp <= 40959)
      return 0;
    if (cp >= 13312 && cp <= 19903)
      return 0;
    if (cp >= 12352 && cp < 12441)
      return 0;
    if (cp >= 12443 && cp <= 12543)
      return 0;
    if (cp >= 12544 && cp <= 12591)
      return 0;
    if (cp >= 12800 && cp <= 13055)
      return 0;
  }
  if (cp >= 768 && cp <= 879)
    return getLatinCcc(cp);
  if (cp >= 1425 && cp <= 1469)
    return getHebrewCcc(cp);
  if (cp === 1471)
    return 23;
  if (cp === 1473)
    return 24;
  if (cp === 1474)
    return 25;
  if (cp === 1476)
    return 230;
  if (cp === 1477)
    return 220;
  if (cp === 1479)
    return 18;
  if (cp >= 1611 && cp <= 1631)
    return getArabicCcc(cp);
  if (cp === 1648)
    return 35;
  if (cp >= 1552 && cp <= 1562)
    return 230;
  if (cp >= 1750 && cp <= 1756)
    return 230;
  if (cp >= 1759 && cp <= 1764)
    return 230;
  if (cp >= 1767 && cp <= 1768)
    return 230;
  if (cp >= 1770 && cp <= 1773)
    return 220;
  if (cp === 2260)
    return 230;
  if (cp >= 2275 && cp <= 2303)
    return 220;
  if (cp === 2364)
    return 7;
  if (cp === 2381)
    return 9;
  if (cp >= 2385 && cp <= 2388)
    return 230;
  if (cp === 2389)
    return 0;
  if (cp >= 2390 && cp <= 2391)
    return 0;
  if (cp === 2492)
    return 7;
  if (cp === 2509)
    return 9;
  if (cp === 2558)
    return 230;
  if (cp === 2620)
    return 7;
  if (cp === 2637)
    return 9;
  if (cp === 2748)
    return 7;
  if (cp === 2765)
    return 9;
  if (cp === 2876)
    return 7;
  if (cp === 2893)
    return 9;
  if (cp === 3021)
    return 9;
  if (cp === 3149)
    return 9;
  if (cp === 3157)
    return 84;
  if (cp === 3158)
    return 91;
  if (cp === 3260)
    return 7;
  if (cp === 3277)
    return 9;
  if (cp === 3405)
    return 9;
  if (cp === 3530)
    return 9;
  if (cp >= 3633 && cp <= 3642)
    return 0;
  if (cp >= 3655 && cp <= 3662)
    return getThaiCcc(cp);
  if (cp >= 3761 && cp <= 3772)
    return 0;
  if (cp >= 3784 && cp <= 3789)
    return getThaiCcc(cp);
  if (cp >= 3864 && cp <= 3865)
    return 220;
  if (cp === 3893)
    return 220;
  if (cp === 3895)
    return 220;
  if (cp === 3897)
    return 216;
  if (cp >= 3953 && cp <= 3966)
    return getTibetanCcc(cp);
  if (cp >= 3968 && cp <= 3972)
    return getTibetanCcc(cp);
  if (cp >= 3974 && cp <= 3975)
    return 230;
  if (cp === 4151)
    return 7;
  if (cp === 4153)
    return 9;
  if (cp === 4154)
    return 9;
  if (cp >= 12330 && cp <= 12335)
    return getHangulCcc(cp);
  if (cp >= 12441 && cp <= 12442)
    return 8;
  if (cp >= 6832 && cp <= 6911)
    return getCdmeClass(cp);
  if (cp >= 7616 && cp <= 7679)
    return getCdmsClass(cp);
  if (cp >= 65056 && cp <= 65071)
    return 230;
  return 0;
}
function getThaiCcc(cp) {
  if (cp >= 3656 && cp <= 3659)
    return 107;
  if (cp === 3660)
    return 0;
  if (cp === 3661)
    return 0;
  if (cp === 3662)
    return 0;
  if (cp >= 3784 && cp <= 3787)
    return 122;
  return 0;
}
function getTibetanCcc(cp) {
  if (cp === 3953)
    return 129;
  if (cp === 3954)
    return 130;
  if (cp === 3955)
    return 0;
  if (cp === 3956)
    return 132;
  if (cp === 3957)
    return 0;
  if (cp === 3958)
    return 0;
  if (cp === 3959)
    return 0;
  if (cp === 3960)
    return 0;
  if (cp === 3961)
    return 0;
  if (cp === 3962)
    return 130;
  if (cp === 3963)
    return 130;
  if (cp === 3964)
    return 130;
  if (cp === 3965)
    return 130;
  if (cp === 3966)
    return 0;
  if (cp === 3968)
    return 130;
  if (cp === 3969)
    return 0;
  if (cp === 3970)
    return 230;
  if (cp === 3971)
    return 230;
  return 9;
}
function getHangulCcc(cp) {
  if (cp === 12330)
    return 218;
  if (cp === 12331)
    return 228;
  if (cp === 12332)
    return 232;
  if (cp === 12333)
    return 222;
  if (cp === 12334)
    return 224;
  return 224;
}
function getCdmeClass(cp) {
  if (cp >= 6832 && cp <= 6846)
    return 230;
  if (cp === 6847)
    return 220;
  if (cp === 6848)
    return 220;
  return 230;
}
function getCdmsClass(cp) {
  if (cp >= 7616 && cp <= 7617)
    return 230;
  if (cp === 7618)
    return 220;
  if (cp >= 7619 && cp <= 7626)
    return 230;
  if (cp === 7627)
    return 230;
  if (cp === 7628)
    return 230;
  if (cp === 7629)
    return 234;
  if (cp === 7630)
    return 214;
  if (cp === 7631)
    return 220;
  if (cp === 7632)
    return 202;
  if (cp >= 7633 && cp <= 7669)
    return 230;
  if (cp >= 7670 && cp <= 7672)
    return 232;
  if (cp === 7673)
    return 220;
  if (cp === 7674)
    return 218;
  return 230;
}
function getHebrewCcc(cp) {
  if (cp >= 1425 && cp <= 1441)
    return 220;
  if (cp >= 1442 && cp <= 1455)
    return 230;
  if (cp >= 1456 && cp <= 1465) {
    if (cp === 1456)
      return 10;
    if (cp === 1457)
      return 11;
    if (cp === 1458)
      return 12;
    if (cp === 1459)
      return 13;
    if (cp === 1460)
      return 14;
    if (cp === 1461)
      return 15;
    if (cp === 1462)
      return 16;
    if (cp === 1463)
      return 17;
    if (cp === 1464)
      return 18;
    return 19;
  }
  if (cp === 1466)
    return 19;
  if (cp === 1467)
    return 20;
  if (cp === 1468)
    return 21;
  return 22;
}
function getArabicCcc(cp) {
  if (cp === 1611)
    return 27;
  if (cp === 1612)
    return 28;
  if (cp === 1613)
    return 29;
  if (cp === 1614)
    return 30;
  if (cp === 1615)
    return 31;
  if (cp === 1616)
    return 32;
  if (cp === 1617)
    return 33;
  if (cp === 1618)
    return 34;
  if (cp >= 1619 && cp <= 1621)
    return 230;
  if (cp === 1622)
    return 220;
  if (cp === 1623)
    return 230;
  if (cp === 1624)
    return 230;
  return 230;
}
function getLatinCcc(cp) {
  if (cp >= 768 && cp <= 788)
    return 230;
  if (cp >= 789 && cp <= 789)
    return 232;
  if (cp >= 790 && cp <= 793)
    return 220;
  if (cp >= 794 && cp <= 794)
    return 232;
  if (cp >= 795 && cp <= 795)
    return 216;
  if (cp >= 796 && cp <= 800)
    return 220;
  if (cp >= 801 && cp <= 802)
    return 202;
  if (cp >= 803 && cp <= 806)
    return 220;
  if (cp >= 807 && cp <= 808)
    return 202;
  if (cp >= 809 && cp <= 819)
    return 220;
  if (cp >= 820 && cp <= 824)
    return 1;
  if (cp >= 825 && cp <= 828)
    return 220;
  if (cp >= 829 && cp <= 836)
    return 230;
  if (cp === 837)
    return 240;
  if (cp >= 838 && cp <= 846)
    return 230;
  if (cp === 847)
    return 0;
  if (cp >= 848 && cp <= 850)
    return 230;
  if (cp >= 851 && cp <= 854)
    return 220;
  if (cp >= 855 && cp <= 856)
    return 230;
  if (cp >= 857 && cp <= 858)
    return 220;
  if (cp >= 859 && cp <= 859)
    return 230;
  if (cp >= 860 && cp <= 860)
    return 233;
  if (cp >= 861 && cp <= 862)
    return 234;
  if (cp >= 863 && cp <= 863)
    return 233;
  if (cp >= 864 && cp <= 865)
    return 234;
  if (cp >= 866 && cp <= 866)
    return 233;
  if (cp >= 867 && cp <= 879)
    return 230;
  return 0;
}
function reorderMarks(infos) {
  const n = infos.length;
  let i = 1;
  while (i < n) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const ccc = getCombiningClass(info.codepoint);
    if (ccc === 0) {
      i++;
      continue;
    }
    let j = i;
    while (j > 0) {
      const prevInfo = infos[j - 1];
      if (!prevInfo)
        break;
      const prevCcc = getCombiningClass(prevInfo.codepoint);
      if (prevCcc === 0)
        break;
      if (prevCcc <= ccc)
        break;
      infos[j] = prevInfo;
      infos[j - 1] = info;
      j--;
    }
    i++;
  }
}
var DECOMPOSITIONS = new Map([
  [192, [65, 768]],
  [193, [65, 769]],
  [194, [65, 770]],
  [195, [65, 771]],
  [196, [65, 776]],
  [197, [65, 778]],
  [199, [67, 807]],
  [200, [69, 768]],
  [201, [69, 769]],
  [202, [69, 770]],
  [203, [69, 776]],
  [204, [73, 768]],
  [205, [73, 769]],
  [206, [73, 770]],
  [207, [73, 776]],
  [209, [78, 771]],
  [210, [79, 768]],
  [211, [79, 769]],
  [212, [79, 770]],
  [213, [79, 771]],
  [214, [79, 776]],
  [217, [85, 768]],
  [218, [85, 769]],
  [219, [85, 770]],
  [220, [85, 776]],
  [221, [89, 769]],
  [224, [97, 768]],
  [225, [97, 769]],
  [226, [97, 770]],
  [227, [97, 771]],
  [228, [97, 776]],
  [229, [97, 778]],
  [231, [99, 807]],
  [232, [101, 768]],
  [233, [101, 769]],
  [234, [101, 770]],
  [235, [101, 776]],
  [236, [105, 768]],
  [237, [105, 769]],
  [238, [105, 770]],
  [239, [105, 776]],
  [241, [110, 771]],
  [242, [111, 768]],
  [243, [111, 769]],
  [244, [111, 770]],
  [245, [111, 771]],
  [246, [111, 776]],
  [249, [117, 768]],
  [250, [117, 769]],
  [251, [117, 770]],
  [252, [117, 776]],
  [253, [121, 769]],
  [255, [121, 776]],
  [256, [65, 772]],
  [257, [97, 772]],
  [258, [65, 774]],
  [259, [97, 774]],
  [260, [65, 808]],
  [261, [97, 808]],
  [262, [67, 769]],
  [263, [99, 769]],
  [264, [67, 770]],
  [265, [99, 770]],
  [266, [67, 775]],
  [267, [99, 775]],
  [268, [67, 780]],
  [269, [99, 780]],
  [270, [68, 780]],
  [271, [100, 780]],
  [274, [69, 772]],
  [275, [101, 772]],
  [276, [69, 774]],
  [277, [101, 774]],
  [278, [69, 775]],
  [279, [101, 775]],
  [280, [69, 808]],
  [281, [101, 808]],
  [282, [69, 780]],
  [283, [101, 780]],
  [284, [71, 770]],
  [285, [103, 770]],
  [286, [71, 774]],
  [287, [103, 774]],
  [288, [71, 775]],
  [289, [103, 775]],
  [290, [71, 807]],
  [291, [103, 807]],
  [292, [72, 770]],
  [293, [104, 770]],
  [296, [73, 771]],
  [297, [105, 771]],
  [298, [73, 772]],
  [299, [105, 772]],
  [300, [73, 774]],
  [301, [105, 774]],
  [302, [73, 808]],
  [303, [105, 808]],
  [304, [73, 775]],
  [308, [74, 770]],
  [309, [106, 770]],
  [310, [75, 807]],
  [311, [107, 807]],
  [313, [76, 769]],
  [314, [108, 769]],
  [315, [76, 807]],
  [316, [108, 807]],
  [317, [76, 780]],
  [318, [108, 780]],
  [323, [78, 769]],
  [324, [110, 769]],
  [325, [78, 807]],
  [326, [110, 807]],
  [327, [78, 780]],
  [328, [110, 780]],
  [332, [79, 772]],
  [333, [111, 772]],
  [334, [79, 774]],
  [335, [111, 774]],
  [336, [79, 779]],
  [337, [111, 779]],
  [340, [82, 769]],
  [341, [114, 769]],
  [342, [82, 807]],
  [343, [114, 807]],
  [344, [82, 780]],
  [345, [114, 780]],
  [346, [83, 769]],
  [347, [115, 769]],
  [348, [83, 770]],
  [349, [115, 770]],
  [350, [83, 807]],
  [351, [115, 807]],
  [352, [83, 780]],
  [353, [115, 780]],
  [354, [84, 807]],
  [355, [116, 807]],
  [356, [84, 780]],
  [357, [116, 780]],
  [360, [85, 771]],
  [361, [117, 771]],
  [362, [85, 772]],
  [363, [117, 772]],
  [364, [85, 774]],
  [365, [117, 774]],
  [366, [85, 778]],
  [367, [117, 778]],
  [368, [85, 779]],
  [369, [117, 779]],
  [370, [85, 808]],
  [371, [117, 808]],
  [372, [87, 770]],
  [373, [119, 770]],
  [374, [89, 770]],
  [375, [121, 770]],
  [376, [89, 776]],
  [377, [90, 769]],
  [378, [122, 769]],
  [379, [90, 775]],
  [380, [122, 775]],
  [381, [90, 780]],
  [382, [122, 780]],
  [7840, [65, 803]],
  [7841, [97, 803]],
  [7842, [65, 777]],
  [7843, [97, 777]],
  [7864, [69, 803]],
  [7865, [101, 803]],
  [7866, [69, 777]],
  [7867, [101, 777]],
  [7868, [69, 771]],
  [7869, [101, 771]],
  [7880, [73, 777]],
  [7881, [105, 777]],
  [7882, [73, 803]],
  [7883, [105, 803]],
  [7884, [79, 803]],
  [7885, [111, 803]],
  [7886, [79, 777]],
  [7887, [111, 777]],
  [7908, [85, 803]],
  [7909, [117, 803]],
  [7910, [85, 777]],
  [7911, [117, 777]],
  [7922, [89, 768]],
  [7923, [121, 768]],
  [7924, [89, 803]],
  [7925, [121, 803]],
  [7926, [89, 777]],
  [7927, [121, 777]],
  [7928, [89, 771]],
  [7929, [121, 771]],
  [7936, [945, 787]],
  [7937, [945, 788]],
  [7944, [913, 787]],
  [7945, [913, 788]],
  [1081, [1080, 774]],
  [1049, [1048, 774]],
  [1105, [1077, 776]],
  [1025, [1045, 776]]
]);
function decompose(cp) {
  return DECOMPOSITIONS.get(cp) ?? null;
}
var COMPOSITIONS = new Map([
  [
    65,
    new Map([
      [768, 192],
      [769, 193],
      [770, 194],
      [771, 195],
      [776, 196],
      [778, 197],
      [808, 260],
      [780, 461],
      [772, 256],
      [774, 258]
    ])
  ],
  [
    67,
    new Map([
      [807, 199],
      [769, 262],
      [770, 264],
      [780, 268],
      [775, 266]
    ])
  ],
  [
    69,
    new Map([
      [768, 200],
      [769, 201],
      [770, 202],
      [776, 203],
      [808, 280],
      [780, 282],
      [772, 274],
      [774, 276],
      [775, 278]
    ])
  ],
  [
    73,
    new Map([
      [768, 204],
      [769, 205],
      [770, 206],
      [776, 207],
      [771, 296],
      [772, 298],
      [774, 300],
      [808, 302],
      [775, 304]
    ])
  ],
  [
    78,
    new Map([
      [771, 209],
      [769, 323],
      [807, 325],
      [780, 327]
    ])
  ],
  [
    79,
    new Map([
      [768, 210],
      [769, 211],
      [770, 212],
      [771, 213],
      [776, 214],
      [772, 332],
      [774, 334],
      [779, 336],
      [808, 490]
    ])
  ],
  [
    85,
    new Map([
      [768, 217],
      [769, 218],
      [770, 219],
      [776, 220],
      [771, 360],
      [772, 362],
      [774, 364],
      [778, 366],
      [779, 368],
      [808, 370],
      [780, 467]
    ])
  ],
  [
    89,
    new Map([
      [769, 221],
      [770, 374],
      [776, 376]
    ])
  ],
  [
    97,
    new Map([
      [768, 224],
      [769, 225],
      [770, 226],
      [771, 227],
      [776, 228],
      [778, 229],
      [808, 261],
      [780, 462],
      [772, 257],
      [774, 259]
    ])
  ],
  [
    99,
    new Map([
      [807, 231],
      [769, 263],
      [770, 265],
      [780, 269],
      [775, 267]
    ])
  ],
  [
    101,
    new Map([
      [768, 232],
      [769, 233],
      [770, 234],
      [776, 235],
      [808, 281],
      [780, 283],
      [772, 275],
      [774, 277],
      [775, 279]
    ])
  ],
  [
    105,
    new Map([
      [768, 236],
      [769, 237],
      [770, 238],
      [776, 239],
      [771, 297],
      [772, 299],
      [774, 301],
      [808, 303]
    ])
  ],
  [
    110,
    new Map([
      [771, 241],
      [769, 324],
      [807, 326],
      [780, 328]
    ])
  ],
  [
    111,
    new Map([
      [768, 242],
      [769, 243],
      [770, 244],
      [771, 245],
      [776, 246],
      [772, 333],
      [774, 335],
      [779, 337],
      [808, 491]
    ])
  ],
  [
    117,
    new Map([
      [768, 249],
      [769, 250],
      [770, 251],
      [776, 252],
      [771, 361],
      [772, 363],
      [774, 365],
      [778, 367],
      [779, 369],
      [808, 371],
      [780, 468]
    ])
  ],
  [
    121,
    new Map([
      [769, 253],
      [776, 255],
      [770, 375]
    ])
  ],
  [
    83,
    new Map([
      [769, 346],
      [770, 348],
      [807, 350],
      [780, 352]
    ])
  ],
  [
    115,
    new Map([
      [769, 347],
      [770, 349],
      [807, 351],
      [780, 353]
    ])
  ],
  [
    90,
    new Map([
      [769, 377],
      [775, 379],
      [780, 381]
    ])
  ],
  [
    122,
    new Map([
      [769, 378],
      [775, 380],
      [780, 382]
    ])
  ]
]);
function tryCompose(base, combining) {
  const baseCompositions = COMPOSITIONS.get(base);
  if (!baseCompositions)
    return null;
  return baseCompositions.get(combining) ?? null;
}
function composeMarks(infos) {
  if (infos.length === 0)
    return infos;
  const result = [];
  let i = 0;
  while (i < infos.length) {
    const current = infos[i];
    const currentCcc = getCombiningClass(current.codepoint);
    if (currentCcc === 0) {
      let composedCp = current.codepoint;
      let lastCcc = 0;
      let j = i + 1;
      while (j < infos.length) {
        const mark = infos[j];
        const markCcc = getCombiningClass(mark.codepoint);
        if (markCcc === 0)
          break;
        if (markCcc > lastCcc || lastCcc === 0) {
          const composed = tryCompose(composedCp, mark.codepoint);
          if (composed !== null) {
            composedCp = composed;
            j++;
            continue;
          }
        }
        lastCcc = markCcc;
        j++;
      }
      result.push({
        glyphId: current.glyphId,
        cluster: current.cluster,
        mask: current.mask,
        codepoint: composedCp
      });
      for (let k = i + 1;k < j; k++) {
        const mark = infos[k];
        if (!mark)
          continue;
        const markCcc = getCombiningClass(mark.codepoint);
        const compositionExists = tryCompose(composedCp, mark.codepoint) !== null;
        if (!compositionExists && markCcc !== 0) {
          result.push(mark);
        }
      }
      i = j;
    } else {
      result.push(current);
      i++;
    }
  }
  return result;
}
function normalize3(infos, mode) {
  if (mode === 0 /* None */) {
    return infos;
  }
  if (mode === 1 /* Decompose */) {
    const result = [];
    for (let i = 0;i < infos.length; i++) {
      const info = infos[i];
      const decomposed = decompose(info.codepoint);
      if (decomposed) {
        for (let j = 0;j < decomposed.length; j++) {
          const cp = decomposed[j];
          result.push({
            glyphId: info.glyphId,
            cluster: info.cluster,
            mask: info.mask,
            codepoint: cp
          });
        }
      } else {
        result.push(info);
      }
    }
    reorderMarks(result);
    return result;
  }
  if (mode === 2 /* Compose */) {
    const decomposed = [];
    for (let i = 0;i < infos.length; i++) {
      const info = infos[i];
      const dec = decompose(info.codepoint);
      if (dec) {
        for (let j = 0;j < dec.length; j++) {
          const cp = dec[j];
          decomposed.push({
            glyphId: info.glyphId,
            cluster: info.cluster,
            mask: info.mask,
            codepoint: cp
          });
        }
      } else {
        decomposed.push(info);
      }
    }
    reorderMarks(decomposed);
    return composeMarks(decomposed);
  }
  if (mode === 3 /* Auto */) {
    const result = [];
    for (let i = 0;i < infos.length; i++) {
      const info = infos[i];
      const decomposed = decompose(info.codepoint);
      if (decomposed) {
        for (let j = 0;j < decomposed.length; j++) {
          const cp = decomposed[j];
          result.push({
            glyphId: info.glyphId,
            cluster: info.cluster,
            mask: info.mask,
            codepoint: cp
          });
        }
      } else {
        result.push(info);
      }
    }
    reorderMarks(result);
    return result;
  }
  return infos;
}

// reference/text-shaper/src/shaper/fallback.ts
function hasAnyMarks(infos) {
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    if (!info)
      continue;
    const cp = info.codepoint;
    if (cp >= 768 && cp < 880)
      return true;
    if (cp >= 1425 && cp < 1480)
      return true;
    if (cp >= 1552 && cp < 2304)
      return true;
    if (cp >= 2364 && cp < 2416)
      return true;
    if (cp >= 2492 && cp < 2559)
      return true;
    if (cp >= 2620 && cp < 2677)
      return true;
    if (cp >= 2748 && cp < 2815)
      return true;
    if (cp >= 2876 && cp < 2928)
      return true;
    if (cp >= 3021 && cp < 3032)
      return true;
    if (cp >= 3149 && cp < 3184)
      return true;
    if (cp >= 3260 && cp < 3327)
      return true;
    if (cp >= 3405 && cp < 3440)
      return true;
    if (cp >= 3530 && cp < 3573)
      return true;
    if (cp >= 3633 && cp < 3664)
      return true;
    if (cp >= 3761 && cp < 3792)
      return true;
    if (cp >= 3864 && cp < 3976)
      return true;
    if (cp >= 4151 && cp < 4155)
      return true;
    if (cp >= 6832 && cp < 6912)
      return true;
    if (cp >= 7616 && cp < 7680)
      return true;
    if (cp >= 12330 && cp < 12336)
      return true;
    if (cp >= 12441 && cp < 12443)
      return true;
    if (cp >= 65056 && cp < 65072)
      return true;
  }
  return false;
}
function applyFallbackMarkPositioning(font, infos, positions) {
  if (!hasAnyMarks(infos))
    return;
  const glyphClassCache = new Map;
  const getClass = (glyphId) => {
    let cls = glyphClassCache.get(glyphId);
    if (cls === undefined) {
      cls = font.gdef ? getGlyphClass2(font.gdef, glyphId) : 0;
      glyphClassCache.set(glyphId, cls);
    }
    return cls;
  };
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    const pos = positions[i];
    const glyphClass = getClass(info.glyphId);
    const ccc = getCombiningClass(info.codepoint);
    if (glyphClass !== 3 /* Mark */ && ccc === 0)
      continue;
    let baseIndex = -1;
    for (let j = i - 1;j >= 0; j--) {
      const prevInfo = infos[j];
      const prevClass = getClass(prevInfo.glyphId);
      const prevCcc = getCombiningClass(prevInfo.codepoint);
      if (prevClass === 1 /* Base */ || prevClass === 0 && prevCcc === 0) {
        baseIndex = j;
        break;
      }
    }
    if (baseIndex < 0)
      continue;
    const baseInfo = infos[baseIndex];
    const basePos = positions[baseIndex];
    const baseAdvance = font.advanceWidth(baseInfo.glyphId);
    positionMarkFallback(font, info, pos, baseInfo, basePos, baseAdvance, ccc);
    pos.xAdvance = 0;
    pos.yAdvance = 0;
  }
}
function positionMarkFallback(font, markInfo, markPos, _baseInfo, basePos, baseAdvance, ccc) {
  const markAdvance = font.advanceWidth(markInfo.glyphId);
  const unitsPerEm = font.unitsPerEm;
  let xOffset = (baseAdvance - markAdvance) / 2;
  let yOffset = 0;
  if (ccc >= 200 && ccc <= 240) {
    yOffset = unitsPerEm * 0.7;
    xOffset = (baseAdvance - markAdvance) / 2;
  } else if (ccc >= 202 && ccc <= 220) {
    yOffset = -unitsPerEm * 0.15;
    xOffset = (baseAdvance - markAdvance) / 2;
  } else if (ccc === 1) {
    xOffset = (baseAdvance - markAdvance) / 2;
    yOffset = unitsPerEm * 0.3;
  } else if (ccc >= 7 && ccc <= 9) {
    yOffset = -unitsPerEm * 0.1;
    xOffset = (baseAdvance - markAdvance) / 2;
  } else if (ccc >= 10 && ccc <= 35) {
    if (ccc <= 22) {
      yOffset = -unitsPerEm * 0.2;
    } else {
      yOffset = ccc < 30 ? -unitsPerEm * 0.15 : unitsPerEm * 0.6;
    }
    xOffset = (baseAdvance - markAdvance) / 2;
  }
  markPos.xOffset = basePos.xOffset + xOffset - baseAdvance;
  markPos.yOffset = basePos.yOffset + yOffset;
}
function applyFallbackKerning(font, infos, positions) {
  const kern = font.kern;
  if (!kern)
    return;
  for (let i = 0;i < infos.length - 1; i++) {
    const info1 = infos[i];
    const info2 = infos[i + 1];
    if (!info1 || !info2)
      continue;
    const pos1 = positions[i];
    if (!pos1)
      continue;
    const class1 = font.gdef ? getGlyphClass2(font.gdef, info1.glyphId) : 0;
    const class2 = font.gdef ? getGlyphClass2(font.gdef, info2.glyphId) : 0;
    if (class1 === 3 /* Mark */ || class2 === 3 /* Mark */)
      continue;
    const kernValue = getKernValueFromTable(font, info1.glyphId, info2.glyphId);
    if (kernValue !== 0) {
      pos1.xAdvance += kernValue;
    }
  }
}
function getKernValueFromTable(font, left, right) {
  const kern = font.kern;
  if (!kern)
    return 0;
  return getKernValue(kern, left, right);
}
// reference/text-shaper/src/shaper/features.ts
function stylisticSet(setNumber, enabled = true) {
  if (setNumber < 1 || setNumber > 20) {
    throw new Error(`Stylistic set number must be 1-20, got ${setNumber}`);
  }
  const tagStr = `ss${setNumber.toString().padStart(2, "0")}`;
  return { tag: tag(tagStr), enabled };
}
function stylisticSets(setNumbers, enabled = true) {
  return setNumbers.map((n) => stylisticSet(n, enabled));
}
function characterVariant(variantNumber, enabled = true) {
  if (variantNumber < 1 || variantNumber > 99) {
    throw new Error(`Character variant number must be 1-99, got ${variantNumber}`);
  }
  const tagStr = `cv${variantNumber.toString().padStart(2, "0")}`;
  return { tag: tag(tagStr), enabled };
}
function characterVariants(variantNumbers, enabled = true) {
  return variantNumbers.map((n) => characterVariant(n, enabled));
}
function standardLigatures(enabled = true) {
  return { tag: tag("liga"), enabled };
}
function discretionaryLigatures(enabled = true) {
  return { tag: tag("dlig"), enabled };
}
function historicalLigatures(enabled = true) {
  return { tag: tag("hlig"), enabled };
}
function contextualAlternates(enabled = true) {
  return { tag: tag("calt"), enabled };
}
function stylisticAlternates(enabled = true) {
  return { tag: tag("salt"), enabled };
}
function swash(enabled = true) {
  return { tag: tag("swsh"), enabled };
}
function smallCaps(enabled = true) {
  return { tag: tag("smcp"), enabled };
}
function capsToSmallCaps(enabled = true) {
  return { tag: tag("c2sc"), enabled };
}
function petiteCaps(enabled = true) {
  return { tag: tag("pcap"), enabled };
}
function allSmallCaps(enabled = true) {
  return [smallCaps(enabled), capsToSmallCaps(enabled)];
}
function oldstyleFigures(enabled = true) {
  return { tag: tag("onum"), enabled };
}
function liningFigures(enabled = true) {
  return { tag: tag("lnum"), enabled };
}
function proportionalFigures(enabled = true) {
  return { tag: tag("pnum"), enabled };
}
function tabularFigures(enabled = true) {
  return { tag: tag("tnum"), enabled };
}
function fractions(enabled = true) {
  return { tag: tag("frac"), enabled };
}
function ordinals(enabled = true) {
  return { tag: tag("ordn"), enabled };
}
function slashedZero(enabled = true) {
  return { tag: tag("zero"), enabled };
}
function superscript(enabled = true) {
  return { tag: tag("sups"), enabled };
}
function subscript(enabled = true) {
  return { tag: tag("subs"), enabled };
}
function scientificInferiors(enabled = true) {
  return { tag: tag("sinf"), enabled };
}
function caseSensitiveForms(enabled = true) {
  return { tag: tag("case"), enabled };
}
function capitalSpacing(enabled = true) {
  return { tag: tag("cpsp"), enabled };
}
function kerning(enabled = true) {
  return { tag: tag("kern"), enabled };
}
function verticalForms(enabled = true) {
  return { tag: tag("vert"), enabled };
}
function verticalAlternatesRotation(enabled = true) {
  return { tag: tag("vrt2"), enabled };
}
function verticalKanaAlternates(enabled = true) {
  return { tag: tag("vkna"), enabled };
}
function verticalLayoutFeatures(enabled = true) {
  return [
    verticalForms(enabled),
    verticalAlternatesRotation(enabled),
    verticalKanaAlternates(enabled)
  ];
}
function ruby(enabled = true) {
  return { tag: tag("ruby"), enabled };
}
function halfWidthForms(enabled = true) {
  return { tag: tag("hwid"), enabled };
}
function fullWidthForms(enabled = true) {
  return { tag: tag("fwid"), enabled };
}
function proportionalWidthForms(enabled = true) {
  return { tag: tag("pwid"), enabled };
}
function quarterWidthForms(enabled = true) {
  return { tag: tag("qwid"), enabled };
}
function thirdWidthForms(enabled = true) {
  return { tag: tag("twid"), enabled };
}
function jis78Forms(enabled = true) {
  return { tag: tag("jp78"), enabled };
}
function jis83Forms(enabled = true) {
  return { tag: tag("jp83"), enabled };
}
function jis90Forms(enabled = true) {
  return { tag: tag("jp90"), enabled };
}
function jis2004Forms(enabled = true) {
  return { tag: tag("jp04"), enabled };
}
function simplifiedForms(enabled = true) {
  return { tag: tag("smpl"), enabled };
}
function traditionalForms(enabled = true) {
  return { tag: tag("trad"), enabled };
}
function feature(tagStr, enabled = true) {
  return { tag: tag(tagStr), enabled };
}
function features(tagStrs, enabled = true) {
  return tagStrs.map((t) => feature(t, enabled));
}
function combineFeatures(...featureSets) {
  const result = [];
  for (let i = 0;i < featureSets.length; i++) {
    const set = featureSets[i];
    if (Array.isArray(set)) {
      result.push(...set);
    } else {
      result.push(set);
    }
  }
  return result;
}
// reference/text-shaper/src/shaper/complex/arabic.ts
var JOINING_TYPE_ARABIC_BLOCK = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  2,
  5,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  2,
  2,
  2,
  1,
  1,
  0,
  2,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  2,
  2,
  0,
  0,
  2
]);
var JT_NON_JOINING = 0;
var JT_RIGHT_JOINING = 1;
var JT_DUAL_JOINING = 2;
var JT_JOIN_CAUSING = 3;
var JT_LEFT_JOINING = 4;
var JT_TRANSPARENT = 5;
function getJoiningTypeNumeric(cp) {
  if (cp >= 1536 && cp <= 1791) {
    return JOINING_TYPE_ARABIC_BLOCK[cp - 1536];
  }
  if (cp < 1536)
    return JT_NON_JOINING;
  if (cp >= 1808 && cp <= 1810)
    return JT_LEFT_JOINING;
  if (cp >= 2259 && cp <= 2303)
    return JT_TRANSPARENT;
  return JT_NON_JOINING;
}
function getArabicFeatures() {
  return [
    "ccmp",
    "locl",
    "isol",
    "init",
    "medi",
    "fina",
    "rlig",
    "rclt",
    "calt",
    "liga"
  ];
}
function setupArabicMasks(infos) {
  const n = infos.length;
  for (let i = 0;i < n; i++) {
    const info = infos[i];
    const cp = info.codepoint ?? 0;
    const type = getJoiningTypeNumeric(cp);
    if (type === JT_NON_JOINING || type === JT_TRANSPARENT) {
      continue;
    }
    let prevType = JT_NON_JOINING;
    for (let j = i - 1;j >= 0; j--) {
      const prevInfo = infos[j];
      const prevCp = prevInfo.codepoint ?? 0;
      const jType = getJoiningTypeNumeric(prevCp);
      if (jType !== JT_TRANSPARENT) {
        prevType = jType;
        break;
      }
    }
    let nextType = JT_NON_JOINING;
    for (let j = i + 1;j < n; j++) {
      const nextInfo = infos[j];
      const nextCp = nextInfo.codepoint ?? 0;
      const jType = getJoiningTypeNumeric(nextCp);
      if (jType !== JT_TRANSPARENT) {
        nextType = jType;
        break;
      }
    }
    const joinsLeft = prevType === JT_DUAL_JOINING || prevType === JT_LEFT_JOINING || prevType === JT_JOIN_CAUSING;
    const joinsRight = nextType === JT_DUAL_JOINING || nextType === JT_RIGHT_JOINING || nextType === JT_JOIN_CAUSING;
    let mask = 0;
    if (type === JT_DUAL_JOINING) {
      if (joinsLeft && joinsRight) {
        mask = 4;
      } else if (joinsLeft) {
        mask = 2;
      } else if (joinsRight) {
        mask = 8;
      } else {
        mask = 1;
      }
    } else if (type === JT_RIGHT_JOINING) {
      if (joinsLeft) {
        mask = 2;
      } else {
        mask = 1;
      }
    } else if (type === JT_LEFT_JOINING) {
      if (joinsRight) {
        mask = 8;
      } else {
        mask = 1;
      }
    }
    if (mask !== 0) {
      info.mask = info.mask & 4294967280 | mask;
    }
  }
}

// reference/text-shaper/src/shaper/complex/ethiopic.ts
function getEthiopicFeatures() {
  return [
    "ccmp",
    "locl",
    "calt",
    "liga"
  ];
}
function usesEthiopic(script) {
  return script === "ethi" || script === "Ethi";
}

// reference/text-shaper/src/shaper/complex/georgian.ts
function getGeorgianFeatures() {
  return [
    "ccmp",
    "locl",
    "calt",
    "liga"
  ];
}
function usesGeorgian(script) {
  return script === "geor" || script === "Geor" || script === "geok" || script === "Geok";
}

// reference/text-shaper/src/shaper/complex/mongolian.ts
function getMongolianFeatures() {
  return [
    "ccmp",
    "locl",
    "isol",
    "init",
    "medi",
    "fina",
    "rlig",
    "calt",
    "liga",
    "vert"
  ];
}
function usesMongolian(script) {
  const mongolianScripts = [
    "mong",
    "Mong",
    "phag",
    "Phag"
  ];
  return mongolianScripts.includes(script);
}

// reference/text-shaper/src/shaper/complex/syriac.ts
function getSyriacFeatures() {
  return [
    "ccmp",
    "locl",
    "stch",
    "isol",
    "init",
    "medi",
    "fina",
    "rlig",
    "calt",
    "liga"
  ];
}
function usesSyriac(script) {
  return script === "syrc" || script === "Syrc";
}

// reference/text-shaper/src/shaper/complex/tibetan.ts
function getTibetanFeatures() {
  return [
    "ccmp",
    "locl",
    "abvs",
    "blws",
    "calt",
    "liga"
  ];
}
function usesTibetan(script) {
  return script === "tibt" || script === "Tibt";
}

// reference/text-shaper/src/shaper/shape-plan.ts
var shapePlanCache = new WeakMap;
var MAX_CACHE_SIZE = 64;
var DEFAULT_GSUB_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "rclt",
  "calt",
  "liga"
];
var DEFAULT_GPOS_FEATURES = [
  "kern",
  "mark",
  "mkmk"
];
function getDefaultGsubFeatures(script) {
  const features2 = new Set(DEFAULT_GSUB_FEATURES);
  const scriptTag = script.padEnd(4, " ");
  const scriptLower = scriptTag.toLowerCase();
  if (usesSyriac(scriptTag)) {
    for (const feature2 of getSyriacFeatures()) {
      features2.add(feature2);
    }
  } else if (scriptLower === "arab" || scriptLower === "mand" || scriptLower === "nko " || scriptLower === "nkoo") {
    for (const feature2 of getArabicFeatures()) {
      features2.add(feature2);
    }
  } else if (usesMongolian(scriptTag)) {
    for (const feature2 of getMongolianFeatures()) {
      features2.add(feature2);
    }
  } else if (usesTibetan(scriptTag)) {
    for (const feature2 of getTibetanFeatures()) {
      features2.add(feature2);
    }
  } else if (usesEthiopic(scriptTag)) {
    for (const feature2 of getEthiopicFeatures()) {
      features2.add(feature2);
    }
  } else if (usesGeorgian(scriptTag)) {
    for (const feature2 of getGeorgianFeatures()) {
      features2.add(feature2);
    }
  }
  return [...features2];
}
function getCacheKey(script, language, direction, userFeatures, axisCoords) {
  if (userFeatures.length === 0 && axisCoords === null) {
    return language === null ? `${script}||${direction}||` : `${script}|${language}|${direction}||`;
  }
  const featuresKey = userFeatures.map((f) => `${tagToString(f.tag)}:${f.enabled ? "1" : "0"}`).sort().join(",");
  const coordsKey = axisCoords ? axisCoords.map((c) => c.toFixed(4)).join(",") : "";
  return `${script}|${language || ""}|${direction}|${featuresKey}|${coordsKey}`;
}
function getOrCreateShapePlan(font, script, language, direction, userFeatures = [], axisCoords = null) {
  const cacheKey = getCacheKey(script, language, direction, userFeatures, axisCoords);
  let fontCache = shapePlanCache.get(font);
  if (!fontCache) {
    fontCache = new Map;
    shapePlanCache.set(font, fontCache);
  }
  const cached = fontCache.get(cacheKey);
  if (cached) {
    return cached;
  }
  const plan = createShapePlanInternal(font, script, language, direction, userFeatures, axisCoords);
  if (fontCache.size >= MAX_CACHE_SIZE) {
    const firstKey = fontCache.keys().next().value;
    if (firstKey !== undefined) {
      fontCache.delete(firstKey);
    }
  }
  fontCache.set(cacheKey, plan);
  return plan;
}
function createShapePlan(font, script, language, direction, userFeatures = [], axisCoords = null) {
  return getOrCreateShapePlan(font, script, language, direction, userFeatures, axisCoords);
}
function createShapePlanInternal(font, script, language, direction, userFeatures = [], axisCoords = null) {
  const scriptTag = tag(script.padEnd(4, " "));
  const languageTag = language ? tag(language.padEnd(4, " ")) : null;
  const enabledFeatures = new Set;
  const gsubDefaults = getDefaultGsubFeatures(script);
  for (let i = 0;i < gsubDefaults.length; i++) {
    enabledFeatures.add(tag(gsubDefaults[i]));
  }
  for (let i = 0;i < DEFAULT_GPOS_FEATURES.length; i++) {
    enabledFeatures.add(tag(DEFAULT_GPOS_FEATURES[i]));
  }
  for (let i = 0;i < userFeatures.length; i++) {
    const feat = userFeatures[i];
    if (feat.enabled) {
      enabledFeatures.add(feat.tag);
    } else {
      enabledFeatures.delete(feat.tag);
    }
  }
  const gsubLookups = collectLookups(font.gsub, scriptTag, languageTag, enabledFeatures, axisCoords);
  const gposLookups = collectLookups(font.gpos, scriptTag, languageTag, enabledFeatures, axisCoords);
  const gsubLookupMap = new Map;
  for (let i = 0;i < gsubLookups.length; i++) {
    const entry = gsubLookups[i];
    gsubLookupMap.set(entry.index, entry);
  }
  const gposLookupMap = new Map;
  for (let i = 0;i < gposLookups.length; i++) {
    const entry = gposLookups[i];
    gposLookupMap.set(entry.index, entry);
  }
  return {
    script: scriptTag,
    language: languageTag,
    direction,
    gsubLookups,
    gposLookups,
    gsubLookupMap,
    gposLookupMap
  };
}
function collectLookups(table, scriptTag, languageTag, enabledFeatures, axisCoords) {
  if (!table)
    return [];
  const gsub = table;
  const lookupIndices = new Set;
  let script = findScript(gsub.scriptList, scriptTag);
  if (!script) {
    script = findScript(gsub.scriptList, tag("DFLT"));
  }
  if (!script) {
    script = findScript(gsub.scriptList, tag("latn"));
  }
  if (!script)
    return [];
  const langSys = findLangSys(script, languageTag);
  if (!langSys)
    return [];
  const featureVariations = gsub.featureVariations;
  const matchingVariation = featureVariations && axisCoords ? findMatchingFeatureVariation(featureVariations, axisCoords) : null;
  const featureSubstitutions = new Map;
  if (matchingVariation) {
    const subs = matchingVariation.featureTableSubstitution.substitutions;
    for (let i = 0;i < subs.length; i++) {
      const subst = subs[i];
      featureSubstitutions.set(subst.featureIndex, subst.alternateFeature.lookupListIndices);
    }
  }
  if (langSys.requiredFeatureIndex !== 65535) {
    const feature2 = getFeature2(gsub.featureList, langSys.requiredFeatureIndex);
    if (feature2) {
      const substitutedLookups = featureSubstitutions.get(langSys.requiredFeatureIndex);
      const lookups = substitutedLookups ?? feature2.feature.lookupListIndices;
      for (let i = 0;i < lookups.length; i++) {
        lookupIndices.add(lookups[i]);
      }
    }
  }
  const featureIndices = langSys.featureIndices;
  for (let f = 0;f < featureIndices.length; f++) {
    const featureIndex = featureIndices[f];
    const featureRecord = getFeature2(gsub.featureList, featureIndex);
    if (!featureRecord)
      continue;
    if (enabledFeatures.has(featureRecord.featureTag)) {
      const substitutedLookups = featureSubstitutions.get(featureIndex);
      const lookups = substitutedLookups ?? featureRecord.feature.lookupListIndices;
      for (let i = 0;i < lookups.length; i++) {
        lookupIndices.add(lookups[i]);
      }
    }
  }
  const result = [];
  const sortedIndices = [...lookupIndices].sort((a, b) => a - b);
  for (let i = 0;i < sortedIndices.length; i++) {
    const index = sortedIndices[i];
    const lookup = gsub.lookups[index];
    if (lookup) {
      result.push({ index, lookup });
    }
  }
  return result;
}
// reference/text-shaper/src/shaper/complex/hangul.ts
var HANGUL_BASE = 44032;
var HANGUL_END = 55203;
var JAMO_L_BASE = 4352;
var JAMO_V_BASE = 4449;
var JAMO_T_BASE = 4519;
var JAMO_L_COUNT = 19;
var JAMO_V_COUNT = 21;
var JAMO_T_COUNT = 28;
var JAMO_VT_COUNT = JAMO_V_COUNT * JAMO_T_COUNT;
var _JAMO_LVT_COUNT = JAMO_L_COUNT * JAMO_VT_COUNT;
var COMPAT_JAMO_START = 12593;
var COMPAT_JAMO_END = 12686;
var JAMO_EXT_A_START = 43360;
var JAMO_EXT_A_END = 43388;
var JAMO_EXT_B_START = 55216;
var JAMO_EXT_B_END = 55291;
function isHangulSyllable(cp) {
  return cp >= HANGUL_BASE && cp <= HANGUL_END;
}
function isHangulJamo(cp) {
  return cp >= JAMO_L_BASE && cp <= 4607 || cp >= JAMO_EXT_A_START && cp <= JAMO_EXT_A_END || cp >= JAMO_EXT_B_START && cp <= JAMO_EXT_B_END;
}
function isJamoL(cp) {
  return cp >= JAMO_L_BASE && cp < JAMO_L_BASE + JAMO_L_COUNT || cp >= JAMO_EXT_A_START && cp <= JAMO_EXT_A_END;
}
function isJamoV(cp) {
  return cp >= JAMO_V_BASE && cp < JAMO_V_BASE + JAMO_V_COUNT || cp >= 55216 && cp <= 55238;
}
function isJamoT(cp) {
  return cp > JAMO_T_BASE && cp <= JAMO_T_BASE + JAMO_T_COUNT - 1 || cp >= 55243 && cp <= 55291;
}
function decomposeHangul(cp) {
  if (!isHangulSyllable(cp))
    return [cp];
  const syllableIndex = cp - HANGUL_BASE;
  const l = Math.floor(syllableIndex / JAMO_VT_COUNT);
  const v = Math.floor(syllableIndex % JAMO_VT_COUNT / JAMO_T_COUNT);
  const t = syllableIndex % JAMO_T_COUNT;
  const result = [JAMO_L_BASE + l, JAMO_V_BASE + v];
  if (t > 0) {
    result.push(JAMO_T_BASE + t);
  }
  return result;
}
function composeHangul(l, v, t = 0) {
  const lIndex = l - JAMO_L_BASE;
  const vIndex = v - JAMO_V_BASE;
  const tIndex = t === 0 ? 0 : t - JAMO_T_BASE;
  if (lIndex < 0 || lIndex >= JAMO_L_COUNT)
    return null;
  if (vIndex < 0 || vIndex >= JAMO_V_COUNT)
    return null;
  if (tIndex < 0 || tIndex >= JAMO_T_COUNT)
    return null;
  return HANGUL_BASE + lIndex * JAMO_VT_COUNT + vIndex * JAMO_T_COUNT + tIndex;
}
function getHangulSyllableType(cp) {
  if (isJamoL(cp))
    return 1 /* LeadingJamo */;
  if (isJamoV(cp))
    return 2 /* VowelJamo */;
  if (isJamoT(cp))
    return 3 /* TrailingJamo */;
  if (isHangulSyllable(cp)) {
    const syllableIndex = cp - HANGUL_BASE;
    const t = syllableIndex % JAMO_T_COUNT;
    return t === 0 ? 4 /* LVSyllable */ : 5 /* LVTSyllable */;
  }
  return 0 /* NotApplicable */;
}
var HangulFeatureMask = {
  ljmo: 1,
  vjmo: 2,
  tjmo: 4
};
function setupHangulMasks(infos) {
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    const type = getHangulSyllableType(info.codepoint);
    switch (type) {
      case 1 /* LeadingJamo */:
        info.mask |= HangulFeatureMask.ljmo;
        break;
      case 2 /* VowelJamo */:
        info.mask |= HangulFeatureMask.vjmo;
        break;
      case 3 /* TrailingJamo */:
        info.mask |= HangulFeatureMask.tjmo;
        break;
      case 4 /* LVSyllable */:
      case 5 /* LVTSyllable */:
        break;
    }
  }
}
function normalizeHangul(infos) {
  const result = [];
  let i = 0;
  while (i < infos.length) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const type = getHangulSyllableType(info.codepoint);
    if (type === 1 /* LeadingJamo */ && i + 1 < infos.length) {
      const nextInfo = infos[i + 1];
      if (!nextInfo) {
        result.push(info);
        i++;
        continue;
      }
      const nextType = getHangulSyllableType(nextInfo.codepoint);
      if (nextType === 2 /* VowelJamo */) {
        let t = 0;
        let consumed = 2;
        if (i + 2 < infos.length) {
          const thirdInfo = infos[i + 2];
          if (thirdInfo) {
            const thirdType = getHangulSyllableType(thirdInfo.codepoint);
            if (thirdType === 3 /* TrailingJamo */) {
              t = thirdInfo.codepoint;
              consumed = 3;
            }
          }
        }
        const composed = composeHangul(info.codepoint, nextInfo.codepoint, t);
        if (composed !== null) {
          result.push({
            glyphId: info.glyphId,
            cluster: info.cluster,
            mask: info.mask,
            codepoint: composed
          });
          i += consumed;
          continue;
        }
      }
    }
    if (type === 4 /* LVSyllable */ && i + 1 < infos.length) {
      const nextInfo = infos[i + 1];
      if (!nextInfo) {
        result.push(info);
        i++;
        continue;
      }
      const nextType = getHangulSyllableType(nextInfo.codepoint);
      if (nextType === 3 /* TrailingJamo */) {
        const decomposed = decomposeHangul(info.codepoint);
        const [firstJamo, secondJamo] = decomposed;
        if (decomposed.length === 2 && firstJamo !== undefined && secondJamo !== undefined) {
          const composed = composeHangul(firstJamo, secondJamo, nextInfo.codepoint);
          if (composed !== null) {
            result.push({
              glyphId: info.glyphId,
              cluster: info.cluster,
              mask: info.mask,
              codepoint: composed
            });
            i += 2;
            continue;
          }
        }
      }
    }
    result.push(info);
    i++;
  }
  return result;
}
function isKorean(cp) {
  return isHangulSyllable(cp) || isHangulJamo(cp) || cp >= COMPAT_JAMO_START && cp <= COMPAT_JAMO_END;
}

// reference/text-shaper/src/shaper/complex/hebrew.ts
var HEBREW_START = 1424;
var HEBREW_END = 1535;
var HEBREW_EXTENDED_START = 64285;
var HEBREW_EXTENDED_END = 64335;
function isHebrew(cp) {
  return cp >= HEBREW_START && cp <= HEBREW_END || cp >= HEBREW_EXTENDED_START && cp <= HEBREW_EXTENDED_END;
}
function getHebrewCategory(cp) {
  if (cp >= 1425 && cp <= 1455)
    return 6 /* Accent */;
  if (cp >= 1456 && cp <= 1469)
    return 2 /* Point */;
  if (cp === 1470)
    return 7 /* Maqaf */;
  if (cp === 1471)
    return 5 /* Rafe */;
  if (cp === 1472 || cp === 1475)
    return 8 /* Punctuation */;
  if (cp === 1473 || cp === 1474)
    return 4 /* Shin */;
  if (cp === 1468)
    return 3 /* Dagesh */;
  if (cp === 1469)
    return 2 /* Point */;
  if (cp >= 1488 && cp <= 1514)
    return 1 /* Letter */;
  if (cp >= 1520 && cp <= 1524)
    return 1 /* Letter */;
  if (cp >= 64285 && cp <= 64335)
    return 1 /* Letter */;
  if (isHebrew(cp))
    return 0 /* Other */;
  return 0 /* Other */;
}
function setupHebrewMasks(infos) {
  let baseIndex = 0;
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    if (!info)
      continue;
    const cat = getHebrewCategory(info.codepoint);
    if (cat === 1 /* Letter */) {
      baseIndex = i;
    }
    info.mask = info.mask & 4294901760 | baseIndex & 65535;
  }
}

// reference/text-shaper/src/shaper/complex/indic.ts
function isDevanagari(cp) {
  return cp >= 2304 && cp <= 2431;
}
function isBengali(cp) {
  return cp >= 2432 && cp <= 2559;
}
function isGurmukhi(cp) {
  return cp >= 2560 && cp <= 2687;
}
function isGujarati(cp) {
  return cp >= 2688 && cp <= 2815;
}
function isOriya(cp) {
  return cp >= 2816 && cp <= 2943;
}
function isTamil(cp) {
  return cp >= 2944 && cp <= 3071;
}
function isTelugu(cp) {
  return cp >= 3072 && cp <= 3199;
}
function isKannada(cp) {
  return cp >= 3200 && cp <= 3327;
}
function isMalayalam(cp) {
  return cp >= 3328 && cp <= 3455;
}
function isIndic(cp) {
  return isDevanagari(cp) || isBengali(cp) || isGurmukhi(cp) || isGujarati(cp) || isOriya(cp) || isTamil(cp) || isTelugu(cp) || isKannada(cp) || isMalayalam(cp);
}
function getIndicCategory(cp) {
  if (cp === 8204)
    return 5 /* ZWNJ */;
  if (cp === 8205)
    return 6 /* ZWJ */;
  if (cp === 9676)
    return 12 /* Dotted_Circle */;
  if (isDevanagari(cp)) {
    if (cp >= 2362 && cp <= 2363 || cp >= 2366 && cp <= 2380 || cp >= 2382 && cp <= 2383 || cp >= 2389 && cp <= 2391) {
      return 7 /* M */;
    }
    if (cp === 2381)
      return 4 /* H */;
    if (cp === 2364)
      return 3 /* N */;
    if (cp >= 2305 && cp <= 2307)
      return 8 /* SM */;
    if (cp >= 2385 && cp <= 2388)
      return 9 /* A */;
    if (cp >= 2308 && cp <= 2324 || cp === 2400 || cp === 2401 || cp === 2418 || cp >= 2422 && cp <= 2423) {
      return 2 /* V */;
    }
    if (cp >= 2325 && cp <= 2361 || cp >= 2392 && cp <= 2399 || cp === 2424 || cp === 2425 || cp === 2426 || cp >= 2427 && cp <= 2428 || cp >= 2430 && cp <= 2431) {
      if (cp === 2352)
        return 15 /* Ra */;
      return 1 /* C */;
    }
    if (cp >= 2406 && cp <= 2415)
      return 17 /* Symbol */;
    return 0 /* X */;
  }
  if (isBengali(cp)) {
    if (cp >= 2494 && cp <= 2500 || cp >= 2503 && cp <= 2504 || cp >= 2507 && cp <= 2508 || cp === 2519) {
      return 7 /* M */;
    }
    if (cp === 2509)
      return 4 /* H */;
    if (cp === 2492)
      return 3 /* N */;
    if (cp >= 2433 && cp <= 2435)
      return 8 /* SM */;
    if (cp >= 2437 && cp <= 2444 || cp >= 2447 && cp <= 2448 || cp >= 2451 && cp <= 2452 || cp === 2528 || cp === 2529) {
      return 2 /* V */;
    }
    if (cp >= 2453 && cp <= 2472 || cp >= 2474 && cp <= 2480 || cp === 2482 || cp >= 2486 && cp <= 2489 || cp >= 2524 && cp <= 2525 || cp >= 2527 && cp <= 2529) {
      if (cp === 2480)
        return 15 /* Ra */;
      return 1 /* C */;
    }
    return 0 /* X */;
  }
  if (isGurmukhi(cp) || isGujarati(cp) || isOriya(cp) || isTamil(cp) || isTelugu(cp) || isKannada(cp) || isMalayalam(cp)) {
    const offset = cp & 127;
    if (offset >= 1 && offset <= 3)
      return 8 /* SM */;
    if (offset >= 5 && offset <= 20)
      return 2 /* V */;
    if (offset >= 21 && offset <= 57)
      return 1 /* C */;
    if (offset === 60)
      return 3 /* N */;
    if (offset >= 62 && offset <= 76)
      return 7 /* M */;
    if (offset === 77)
      return 4 /* H */;
    return 0 /* X */;
  }
  return 0 /* X */;
}
function findSyllables(infos) {
  const syllables = [];
  const n = infos.length;
  if (n === 0)
    return syllables;
  let start = 0;
  while (start < n) {
    const syllable = parseSyllable(infos, start);
    syllables.push(syllable);
    start = syllable.end;
  }
  return syllables;
}
function parseSyllable(infos, start) {
  const n = infos.length;
  let pos = start;
  let baseConsonant = -1;
  let hasReph = false;
  if (pos + 1 < n) {
    const info1 = infos[pos];
    const info2 = infos[pos + 1];
    if (info1 && info2) {
      const cat1 = getIndicCategory(info1.codepoint ?? 0);
      const cat2 = getIndicCategory(info2.codepoint ?? 0);
      if (cat1 === 15 /* Ra */ && cat2 === 4 /* H */) {
        hasReph = true;
        pos += 2;
      }
    }
  }
  let lastConsonant = -1;
  while (pos < n) {
    const info = infos[pos];
    if (!info) {
      pos++;
      continue;
    }
    const cp = info.codepoint ?? 0;
    const cat = getIndicCategory(cp);
    if (cat === 1 /* C */ || cat === 15 /* Ra */) {
      lastConsonant = pos;
      pos++;
      if (pos < n) {
        const nextInfo = infos[pos];
        if (nextInfo && getIndicCategory(nextInfo.codepoint ?? 0) === 3 /* N */) {
          pos++;
        }
      }
      if (pos < n) {
        const hInfo = infos[pos];
        if (hInfo && getIndicCategory(hInfo.codepoint ?? 0) === 4 /* H */) {
          pos++;
          if (pos < n) {
            const afterH = infos[pos];
            if (afterH) {
              const nextCat = getIndicCategory(afterH.codepoint ?? 0);
              if (nextCat === 6 /* ZWJ */ || nextCat === 5 /* ZWNJ */) {
                pos++;
              }
            }
          }
          continue;
        }
      }
      break;
    } else if (cat === 2 /* V */) {
      pos++;
      break;
    } else if (cat === 3 /* N */) {
      pos++;
    } else {
      if (lastConsonant === -1) {
        pos++;
      }
      break;
    }
  }
  baseConsonant = lastConsonant >= 0 ? lastConsonant : start;
  while (pos < n) {
    const info = infos[pos];
    if (!info) {
      pos++;
      continue;
    }
    const cp = info.codepoint ?? 0;
    const cat = getIndicCategory(cp);
    if (cat === 7 /* M */ || cat === 8 /* SM */ || cat === 9 /* A */ || cat === 3 /* N */) {
      pos++;
    } else if (cat === 4 /* H */) {
      pos++;
      break;
    } else {
      break;
    }
  }
  if (pos === start) {
    pos = start + 1;
  }
  return {
    start,
    end: pos,
    hasReph,
    baseConsonant
  };
}
var IndicFeatureMask = {
  nukt: 1,
  akhn: 2,
  rphf: 4,
  rkrf: 8,
  pref: 16,
  blwf: 32,
  abvf: 64,
  half: 128,
  pstf: 256,
  vatu: 512,
  cjct: 1024,
  init: 2048,
  pres: 4096,
  abvs: 8192,
  blws: 16384,
  psts: 32768
};
function getMatraPosition(cp) {
  if (cp >= 2304 && cp <= 2431) {
    if (cp === 2367)
      return 0 /* PreBase */;
    if (cp >= 2373 && cp <= 2376)
      return 1 /* AboveBase */;
    if (cp >= 2369 && cp <= 2372)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 2432 && cp <= 2559) {
    if (cp === 2495)
      return 0 /* PreBase */;
    if (cp === 2503 || cp === 2504)
      return 0 /* PreBase */;
    if (cp >= 2497 && cp <= 2500)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 2944 && cp <= 3071) {
    if (cp >= 3014 && cp <= 3016)
      return 0 /* PreBase */;
    if (cp === 3009 || cp === 3010)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 3072 && cp <= 3199) {
    if (cp >= 3134 && cp <= 3136 || cp >= 3142 && cp <= 3144) {
      return 1 /* AboveBase */;
    }
    if (cp >= 3137 && cp <= 3140)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 3200 && cp <= 3327) {
    if (cp >= 3262 && cp <= 3264 || cp >= 3270 && cp <= 3272) {
      return 1 /* AboveBase */;
    }
    if (cp >= 3265 && cp <= 3268)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 3328 && cp <= 3455) {
    if (cp >= 3398 && cp <= 3400)
      return 0 /* PreBase */;
    if (cp >= 3393 && cp <= 3395)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 2560 && cp <= 2687) {
    if (cp === 2623)
      return 0 /* PreBase */;
    if (cp === 2625 || cp === 2626)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 2688 && cp <= 2815) {
    if (cp === 2751)
      return 0 /* PreBase */;
    if (cp >= 2753 && cp <= 2756)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  if (cp >= 2816 && cp <= 2943) {
    if (cp === 2879)
      return 0 /* PreBase */;
    if (cp >= 2881 && cp <= 2883)
      return 2 /* BelowBase */;
    return 3 /* PostBase */;
  }
  return 3 /* PostBase */;
}
function setupIndicMasks(infos) {
  const syllables = findSyllables(infos);
  for (let i = 0;i < syllables.length; i++) {
    const syllable = syllables[i];
    for (let j = syllable.start;j < syllable.end; j++) {
      const info = infos[j];
      if (info) {
        info.mask = info.mask & 65535 | (i & 65535) << 16;
        const cat = getIndicCategory(info.codepoint);
        if (cat === 3 /* N */) {
          info.mask |= IndicFeatureMask.nukt;
        }
        if (cat === 4 /* H */) {
          if (j < syllable.baseConsonant) {
            info.mask |= IndicFeatureMask.half;
          } else if (j > syllable.baseConsonant) {
            info.mask |= IndicFeatureMask.blwf | IndicFeatureMask.pstf;
          }
        }
        if (cat === 1 /* C */ || cat === 15 /* Ra */) {
          if (j < syllable.baseConsonant) {
            info.mask |= IndicFeatureMask.half | IndicFeatureMask.cjct;
          } else if (j > syllable.baseConsonant) {
            info.mask |= IndicFeatureMask.blwf | IndicFeatureMask.pstf | IndicFeatureMask.vatu;
          }
        }
        if (syllable.hasReph && j < syllable.start + 2) {
          info.mask |= IndicFeatureMask.rphf;
        }
        if (cat === 7 /* M */) {
          const matraPos = getMatraPosition(info.codepoint);
          switch (matraPos) {
            case 0 /* PreBase */:
              info.mask |= IndicFeatureMask.pref | IndicFeatureMask.pres;
              break;
            case 1 /* AboveBase */:
              info.mask |= IndicFeatureMask.abvf | IndicFeatureMask.abvs;
              break;
            case 2 /* BelowBase */:
              info.mask |= IndicFeatureMask.blwf | IndicFeatureMask.blws;
              break;
            case 3 /* PostBase */:
              info.mask |= IndicFeatureMask.pstf | IndicFeatureMask.psts;
              break;
          }
        }
        if (cat === 8 /* SM */) {
          info.mask |= IndicFeatureMask.abvs | IndicFeatureMask.psts;
        }
      }
    }
  }
}
function reorderIndic(infos) {
  const syllables = findSyllables(infos);
  for (let i = 0;i < syllables.length; i++) {
    const syllable = syllables[i];
    reorderSyllable(infos, syllable);
  }
}
function reorderSyllable(infos, syllable) {
  const { start, end, baseConsonant, hasReph } = syllable;
  const preBaseMatras = [];
  for (let i = baseConsonant + 1;i < end; i++) {
    const info = infos[i];
    if (!info)
      continue;
    const cat = getIndicCategory(info.codepoint);
    if (cat === 7 /* M */) {
      const matraPos = getMatraPosition(info.codepoint);
      if (matraPos === 0 /* PreBase */) {
        preBaseMatras.push({ index: i, info });
      }
    }
  }
  if (preBaseMatras.length > 0) {
    preBaseMatras.sort((a, b) => b.index - a.index);
    for (let i = 0;i < preBaseMatras.length; i++) {
      const { index, info } = preBaseMatras[i];
      infos.splice(index, 1);
      const insertPos = hasReph ? start + 2 : start;
      infos.splice(insertPos, 0, info);
    }
  }
  if (hasReph && end > start + 2) {
    const rephRa = infos[start];
    const rephH = infos[start + 1];
    if (rephRa && rephH) {
      let rephTarget = end - 1;
      while (rephTarget > baseConsonant) {
        const targetInfo = infos[rephTarget];
        if (!targetInfo)
          break;
        const cat = getIndicCategory(targetInfo.codepoint);
        if (cat === 8 /* SM */ || cat === 9 /* A */) {
          rephTarget--;
        } else {
          break;
        }
      }
      if (rephTarget > start + 1) {
        infos.splice(start, 2);
        const adjustedTarget = rephTarget - 2;
        infos.splice(adjustedTarget + 1, 0, rephRa, rephH);
      }
    }
  }
}

// reference/text-shaper/src/shaper/complex/khmer.ts
var KHMER_START = 6016;
var KHMER_END = 6143;
var KHMER_SYMBOLS_START = 6624;
var KHMER_SYMBOLS_END = 6655;
function getKhmerCategory(cp) {
  if (cp < KHMER_START || cp > KHMER_END)
    return 0 /* Other */;
  if (cp >= 6016 && cp <= 6050)
    return 1 /* Consonant */;
  if (cp === 6051 || cp === 6052)
    return 2 /* IndependentVowel */;
  if (cp >= 6053 && cp <= 6067)
    return 2 /* IndependentVowel */;
  if (cp >= 6070 && cp <= 6085)
    return 3 /* DependentVowel */;
  if (cp === 6086)
    return 8 /* Anusvara */;
  if (cp === 6087)
    return 9 /* Visarga */;
  if (cp === 6088)
    return 7 /* Sign */;
  if (cp === 6089 || cp === 6090)
    return 5 /* Register */;
  if (cp === 6098)
    return 4 /* Coeng */;
  if (cp === 6092)
    return 6 /* Robat */;
  if (cp >= 6091 && cp <= 6097)
    return 7 /* Sign */;
  if (cp >= 6099 && cp <= 6109)
    return 7 /* Sign */;
  return 0 /* Other */;
}
var KhmerFeatureMask = {
  pref: 1,
  blwf: 2,
  abvf: 4,
  pstf: 8,
  cfar: 16,
  pres: 32,
  abvs: 64,
  blws: 128,
  psts: 256,
  clig: 512
};
function isKhmer(cp) {
  return cp >= KHMER_START && cp <= KHMER_END || cp >= KHMER_SYMBOLS_START && cp <= KHMER_SYMBOLS_END;
}
function setupKhmerMasks(infos) {
  let i = 0;
  while (i < infos.length) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const cat = getKhmerCategory(info.codepoint);
    if (cat === 0 /* Other */) {
      i++;
      continue;
    }
    const _syllableStart = i;
    let _base = -1;
    if (cat === 1 /* Consonant */) {
      _base = i;
    }
    let j = i + 1;
    while (j < infos.length) {
      const nextInfo = infos[j];
      if (!nextInfo) {
        j++;
        continue;
      }
      const nextCat = getKhmerCategory(nextInfo.codepoint);
      if (nextCat === 0 /* Other */)
        break;
      if (nextCat === 1 /* Consonant */) {
        const prevInfo = infos[j - 1];
        if (prevInfo && getKhmerCategory(prevInfo.codepoint) !== 4 /* Coeng */) {
          break;
        }
      }
      if (nextCat === 4 /* Coeng */ && j + 1 < infos.length) {
        const afterCoeng = infos[j + 1];
        if (afterCoeng && getKhmerCategory(afterCoeng.codepoint) === 1 /* Consonant */) {
          nextInfo.mask |= KhmerFeatureMask.blwf;
          afterCoeng.mask |= KhmerFeatureMask.blwf;
          j += 2;
          continue;
        }
      }
      if (nextCat === 3 /* DependentVowel */) {
        if (nextInfo.codepoint >= 6081 && nextInfo.codepoint <= 6083) {
          nextInfo.mask |= KhmerFeatureMask.pref;
        } else if (nextInfo.codepoint >= 6071 && nextInfo.codepoint <= 6074) {
          nextInfo.mask |= KhmerFeatureMask.abvf;
        } else if (nextInfo.codepoint === 6075 || nextInfo.codepoint === 6076 || nextInfo.codepoint === 6077) {
          nextInfo.mask |= KhmerFeatureMask.blwf;
        } else {
          nextInfo.mask |= KhmerFeatureMask.pstf;
        }
      }
      if (nextCat === 5 /* Register */) {
        nextInfo.mask |= KhmerFeatureMask.abvs;
      }
      if (nextCat === 6 /* Robat */) {
        nextInfo.mask |= KhmerFeatureMask.abvs;
      }
      j++;
    }
    i = j;
  }
}
function reorderKhmer(infos) {
  let i = 0;
  while (i < infos.length) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const cat = getKhmerCategory(info.codepoint);
    if (cat !== 1 /* Consonant */) {
      i++;
      continue;
    }
    const base = i;
    let j = i + 1;
    while (j < infos.length) {
      const jInfo = infos[j];
      if (!jInfo)
        break;
      const jCat = getKhmerCategory(jInfo.codepoint);
      if (jCat === 4 /* Coeng */ && j + 1 < infos.length) {
        j += 2;
      } else {
        break;
      }
    }
    if (j < infos.length) {
      const jInfo = infos[j];
      if (jInfo) {
        const cp = jInfo.codepoint;
        if (cp >= 6081 && cp <= 6083) {
          const vowel = jInfo;
          for (let k = j;k > base; k--) {
            const prevInfo = infos[k - 1];
            if (prevInfo) {
              infos[k] = prevInfo;
            }
          }
          infos[base] = vowel;
        }
      }
    }
    i = j + 1;
  }
}

// reference/text-shaper/src/shaper/complex/myanmar.ts
var MYANMAR_START = 4096;
var MYANMAR_END = 4255;
var MYANMAR_EXT_A_START = 43616;
var MYANMAR_EXT_A_END = 43647;
var MYANMAR_EXT_B_START = 43488;
var MYANMAR_EXT_B_END = 43519;
function getMyanmarCategory(cp) {
  if (cp >= MYANMAR_START && cp <= MYANMAR_END) {
    if (cp >= 4096 && cp <= 4129)
      return 1 /* Consonant */;
    if (cp >= 4131 && cp <= 4135)
      return 2 /* IndependentVowel */;
    if (cp >= 4137 && cp <= 4138)
      return 2 /* IndependentVowel */;
    if (cp >= 4139 && cp <= 4149)
      return 3 /* DependentVowel */;
    if (cp === 4150)
      return 6 /* Anusvara */;
    if (cp === 4151)
      return 8 /* Sign */;
    if (cp === 4152)
      return 7 /* Visarga */;
    if (cp === 4153)
      return 5 /* Asat */;
    if (cp === 4154)
      return 5 /* Asat */;
    if (cp >= 4155 && cp <= 4158)
      return 4 /* Medial */;
    if (cp >= 4159 && cp <= 4169) {
      if (cp === 4159)
        return 1 /* Consonant */;
      return 9 /* Number */;
    }
    if (cp >= 4170 && cp <= 4175)
      return 8 /* Sign */;
    if (cp >= 4176 && cp <= 4185)
      return 1 /* Consonant */;
    if (cp >= 4186 && cp <= 4189)
      return 1 /* Consonant */;
    if (cp >= 4192 && cp <= 4193)
      return 1 /* Consonant */;
    if (cp >= 4194 && cp <= 4196)
      return 3 /* DependentVowel */;
    if (cp >= 4197 && cp <= 4198)
      return 1 /* Consonant */;
    if (cp >= 4199 && cp <= 4205)
      return 3 /* DependentVowel */;
    if (cp >= 4206 && cp <= 4208)
      return 1 /* Consonant */;
    if (cp >= 4209 && cp <= 4212)
      return 3 /* DependentVowel */;
    if (cp >= 4213 && cp <= 4225)
      return 1 /* Consonant */;
    if (cp >= 4226 && cp <= 4226)
      return 4 /* Medial */;
    if (cp >= 4227 && cp <= 4236)
      return 3 /* DependentVowel */;
    if (cp === 4237)
      return 8 /* Sign */;
    if (cp === 4238)
      return 1 /* Consonant */;
    if (cp === 4239)
      return 8 /* Sign */;
    if (cp >= 4240 && cp <= 4249)
      return 9 /* Number */;
  }
  if (cp >= MYANMAR_EXT_A_START && cp <= MYANMAR_EXT_A_END) {
    if (cp >= 43616 && cp <= 43638)
      return 1 /* Consonant */;
    if (cp >= 43639 && cp <= 43641)
      return 8 /* Sign */;
    if (cp === 43642)
      return 1 /* Consonant */;
    if (cp === 43643)
      return 8 /* Sign */;
    if (cp === 43644)
      return 8 /* Sign */;
    if (cp === 43645)
      return 8 /* Sign */;
    if (cp >= 43646 && cp <= 43647)
      return 1 /* Consonant */;
  }
  if (cp >= MYANMAR_EXT_B_START && cp <= MYANMAR_EXT_B_END) {
    if (cp >= 43488 && cp <= 43492)
      return 1 /* Consonant */;
    if (cp === 43493)
      return 3 /* DependentVowel */;
    if (cp >= 43494 && cp <= 43503)
      return 1 /* Consonant */;
    if (cp >= 43504 && cp <= 43513)
      return 9 /* Number */;
    if (cp >= 43514 && cp <= 43518)
      return 1 /* Consonant */;
  }
  return 0 /* Other */;
}
var MyanmarFeatureMask = {
  rphf: 1,
  pref: 2,
  blwf: 4,
  pstf: 8,
  pres: 16,
  abvs: 32,
  blws: 64,
  psts: 128
};
function isMyanmar(cp) {
  return cp >= MYANMAR_START && cp <= MYANMAR_END || cp >= MYANMAR_EXT_A_START && cp <= MYANMAR_EXT_A_END || cp >= MYANMAR_EXT_B_START && cp <= MYANMAR_EXT_B_END;
}
function setupMyanmarMasks(infos) {
  let i = 0;
  while (i < infos.length) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const cat = getMyanmarCategory(info.codepoint);
    if (cat === 0 /* Other */) {
      i++;
      continue;
    }
    let _base = -1;
    let hasAsat = false;
    if (cat === 1 /* Consonant */) {
      _base = i;
    }
    let j = i + 1;
    while (j < infos.length) {
      const nextInfo = infos[j];
      if (!nextInfo) {
        j++;
        continue;
      }
      const nextCat = getMyanmarCategory(nextInfo.codepoint);
      if (nextCat === 0 /* Other */)
        break;
      if (nextCat === 5 /* Asat */) {
        hasAsat = true;
        nextInfo.mask |= MyanmarFeatureMask.blwf;
        if (j + 1 < infos.length) {
          const afterAsat = infos[j + 1];
          if (afterAsat && getMyanmarCategory(afterAsat.codepoint) === 1 /* Consonant */) {
            afterAsat.mask |= MyanmarFeatureMask.blwf;
            j += 2;
            continue;
          }
        }
      }
      if (nextCat === 4 /* Medial */) {
        const cp = nextInfo.codepoint;
        if (cp === 4155) {
          nextInfo.mask |= MyanmarFeatureMask.pref;
        } else if (cp === 4156) {
          nextInfo.mask |= MyanmarFeatureMask.pref;
        } else if (cp === 4157) {
          nextInfo.mask |= MyanmarFeatureMask.blwf;
        } else if (cp === 4158) {
          nextInfo.mask |= MyanmarFeatureMask.blwf;
        }
      }
      if (nextCat === 3 /* DependentVowel */) {
        const cp = nextInfo.codepoint;
        if (cp === 4145) {
          nextInfo.mask |= MyanmarFeatureMask.pref;
        } else if (cp === 4141 || cp === 4142 || cp === 4146) {
          nextInfo.mask |= MyanmarFeatureMask.abvs;
        } else if (cp === 4143 || cp === 4144) {
          nextInfo.mask |= MyanmarFeatureMask.blws;
        } else {
          nextInfo.mask |= MyanmarFeatureMask.psts;
        }
      }
      if (nextCat === 6 /* Anusvara */ || nextCat === 8 /* Sign */) {
        nextInfo.mask |= MyanmarFeatureMask.abvs;
      }
      if (nextCat === 1 /* Consonant */ && !hasAsat) {
        if (j > 0) {
          const prevInfo = infos[j - 1];
          if (prevInfo) {
            const prevCat = getMyanmarCategory(prevInfo.codepoint);
            if (prevCat !== 5 /* Asat */) {
              break;
            }
          }
        }
      }
      hasAsat = false;
      j++;
    }
    i = j;
  }
}
function reorderMyanmar(infos) {
  let i = 0;
  while (i < infos.length) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const cat = getMyanmarCategory(info.codepoint);
    if (cat !== 1 /* Consonant */) {
      i++;
      continue;
    }
    const base = i;
    const preBase = [];
    let j = i + 1;
    while (j < infos.length) {
      const jInfo = infos[j];
      if (!jInfo) {
        j++;
        continue;
      }
      const jCat = getMyanmarCategory(jInfo.codepoint);
      if (jInfo.codepoint === 4145) {
        preBase.push(jInfo);
        infos.splice(j, 1);
        continue;
      }
      if (jInfo.codepoint === 4156) {
        preBase.push(jInfo);
        infos.splice(j, 1);
        continue;
      }
      if (jCat === 1 /* Consonant */ || jCat === 0 /* Other */) {
        break;
      }
      j++;
    }
    if (preBase.length > 0) {
      infos.splice(base, 0, ...preBase);
      i += preBase.length;
    }
    i++;
  }
}

// reference/text-shaper/src/shaper/complex/thai-lao.ts
function isThai(cp) {
  return cp >= 3584 && cp <= 3711;
}
function isLao(cp) {
  return cp >= 3712 && cp <= 3839;
}
function getThaiLaoCategory(cp) {
  if (isThai(cp)) {
    if (cp >= 3585 && cp <= 3630)
      return 1 /* Consonant */;
    if (cp === 3631)
      return 1 /* Consonant */;
    if (cp >= 3648 && cp <= 3652)
      return 2 /* LeadingVowel */;
    if (cp === 3633)
      return 3 /* AboveVowel */;
    if (cp >= 3636 && cp <= 3639)
      return 3 /* AboveVowel */;
    if (cp === 3655)
      return 3 /* AboveVowel */;
    if (cp >= 3640 && cp <= 3642)
      return 4 /* BelowVowel */;
    if (cp === 3632)
      return 5 /* FollowingVowel */;
    if (cp === 3634 || cp === 3635)
      return 5 /* FollowingVowel */;
    if (cp === 3653)
      return 5 /* FollowingVowel */;
    if (cp === 3635)
      return 8 /* SaraAm */;
    if (cp >= 3656 && cp <= 3659)
      return 6 /* Tone */;
    if (cp === 3660)
      return 6 /* Tone */;
    if (cp === 3661)
      return 7 /* NikhahitMaiEk */;
    if (cp === 3662)
      return 7 /* NikhahitMaiEk */;
    if (cp >= 3664 && cp <= 3675)
      return 9 /* Symbol */;
    return 0 /* Other */;
  }
  if (isLao(cp)) {
    if (cp >= 3713 && cp <= 3758)
      return 1 /* Consonant */;
    if (cp >= 3776 && cp <= 3780)
      return 2 /* LeadingVowel */;
    if (cp === 3761)
      return 3 /* AboveVowel */;
    if (cp >= 3764 && cp <= 3767)
      return 3 /* AboveVowel */;
    if (cp === 3771)
      return 3 /* AboveVowel */;
    if (cp >= 3768 && cp <= 3769)
      return 4 /* BelowVowel */;
    if (cp === 3772)
      return 4 /* BelowVowel */;
    if (cp === 3760)
      return 5 /* FollowingVowel */;
    if (cp === 3762 || cp === 3763)
      return 5 /* FollowingVowel */;
    if (cp >= 3784 && cp <= 3789)
      return 6 /* Tone */;
    if (cp >= 3792 && cp <= 3801)
      return 9 /* Symbol */;
    return 0 /* Other */;
  }
  return 0 /* Other */;
}
function setupThaiLaoMasks(infos) {
  let clusterIndex = 0;
  let _consonantIndex = -1;
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    if (!info)
      continue;
    const cat = getThaiLaoCategory(info.codepoint);
    if (cat === 1 /* Consonant */) {
      clusterIndex++;
      _consonantIndex = i;
    }
    info.mask = info.mask & 4294967040 | cat & 255;
    info.mask = info.mask & 65535 | (clusterIndex & 65535) << 16;
    if (cat === 2 /* LeadingVowel */) {
      info.mask |= 256;
    }
  }
}
function reorderThaiLao(infos) {
  let i = 0;
  while (i < infos.length) {
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    const cat = getThaiLaoCategory(info.codepoint);
    if (cat === 2 /* LeadingVowel */) {
      let j = i + 1;
      while (j < infos.length) {
        const nextInfo = infos[j];
        if (!nextInfo) {
          j++;
          continue;
        }
        const nextCat = getThaiLaoCategory(nextInfo.codepoint ?? 0);
        if (nextCat === 1 /* Consonant */) {
          const temp = info;
          infos[i] = nextInfo;
          infos[j] = temp;
          break;
        }
        if (nextCat !== 2 /* LeadingVowel */) {
          break;
        }
        j++;
      }
    }
    i++;
  }
}

// reference/text-shaper/src/shaper/complex/use.ts
function usesUSE(script) {
  const useScripts = [
    "bali",
    "batk",
    "brah",
    "bugi",
    "buhd",
    "cakm",
    "cham",
    "dupl",
    "egyp",
    "gran",
    "hano",
    "java",
    "kthi",
    "khar",
    "khmr",
    "khoj",
    "lana",
    "lepc",
    "limb",
    "mahj",
    "modi",
    "mtei",
    "mymr",
    "newa",
    "phlp",
    "rjng",
    "saur",
    "shrd",
    "sidd",
    "sind",
    "sinh",
    "sund",
    "sylo",
    "tagb",
    "takr",
    "tale",
    "talu",
    "tavt",
    "tibt",
    "tirh"
  ];
  return useScripts.includes(script);
}
function getUseCategory(cp) {
  if (cp === 8204)
    return 21 /* ZWNJ */;
  if (cp === 8205)
    return 20 /* ZWJ */;
  if (cp === 847)
    return 2 /* CGJ */;
  if (cp === 8288)
    return 19 /* WJ */;
  if (cp >= 65024 && cp <= 65039)
    return 18 /* VS */;
  if (cp >= 917760 && cp <= 917999)
    return 18 /* VS */;
  if (cp >= 4096 && cp <= 4255) {
    if (cp >= 4096 && cp <= 4128)
      return 1 /* B */;
    if (cp >= 4129 && cp <= 4138)
      return 10 /* IND */;
    if (cp >= 4139 && cp <= 4146)
      return 31 /* VPst */;
    if (cp >= 4150 && cp <= 4151)
      return 32 /* SMAbv */;
    if (cp === 4153)
      return 8 /* H */;
    if (cp === 4154)
      return 8 /* H */;
    if (cp >= 4155 && cp <= 4158)
      return 38 /* MBlw */;
    if (cp >= 4160 && cp <= 4169)
      return 7 /* GB */;
    return 0 /* O */;
  }
  if (cp >= 6016 && cp <= 6143) {
    if (cp >= 6016 && cp <= 6050)
      return 1 /* B */;
    if (cp >= 6051 && cp <= 6067)
      return 10 /* IND */;
    if (cp >= 6070 && cp <= 6085)
      return 31 /* VPst */;
    if (cp === 6098)
      return 8 /* H */;
    if (cp >= 6086 && cp <= 6088)
      return 32 /* SMAbv */;
    return 0 /* O */;
  }
  if (cp >= 3840 && cp <= 4095) {
    if (cp >= 3840 && cp <= 3863)
      return 14 /* S */;
    if (cp >= 3953 && cp <= 3965)
      return 28 /* VAbv */;
    if (cp >= 3984 && cp <= 4028)
      return 17 /* SUB */;
    if (cp >= 3904 && cp <= 3948)
      return 1 /* B */;
    return 0 /* O */;
  }
  if (cp >= 3584 && cp <= 3711) {
    if (cp >= 3585 && cp <= 3630)
      return 1 /* B */;
    if (cp >= 3632 && cp <= 3642)
      return 31 /* VPst */;
    if (cp >= 3648 && cp <= 3652)
      return 30 /* VPre */;
    if (cp >= 3656 && cp <= 3659)
      return 32 /* SMAbv */;
    return 0 /* O */;
  }
  if (cp >= 3712 && cp <= 3839) {
    if (cp >= 3713 && cp <= 3747)
      return 1 /* B */;
    if (cp >= 3760 && cp <= 3772)
      return 31 /* VPst */;
    if (cp >= 3776 && cp <= 3780)
      return 30 /* VPre */;
    if (cp >= 3784 && cp <= 3789)
      return 32 /* SMAbv */;
    return 0 /* O */;
  }
  if (cp >= 57344 && cp <= 57599) {
    if (cp === 57344)
      return 13 /* R */;
    if (cp === 57345)
      return 24 /* VMAbv */;
    if (cp === 57346)
      return 25 /* VMBlw */;
    if (cp === 57347)
      return 26 /* VMPre */;
    if (cp === 57348)
      return 27 /* VMPst */;
    if (cp === 57349)
      return 4 /* CS */;
    if (cp === 57350)
      return 12 /* N */;
    if (cp === 57351)
      return 9 /* HN */;
    if (cp === 57352)
      return 23 /* VD */;
    if (cp === 57353)
      return 29 /* VBlw */;
    if (cp === 57354)
      return 37 /* MAbv */;
    if (cp === 57355)
      return 39 /* MPre */;
    if (cp === 57356)
      return 40 /* MPst */;
    if (cp === 57357)
      return 33 /* SMBlw */;
    if (cp === 57358)
      return 34 /* FAbv */;
    if (cp === 57359)
      return 35 /* FBlw */;
    if (cp === 57360)
      return 36 /* FPst */;
    if (cp === 57361)
      return 5 /* F */;
    if (cp === 57362)
      return 6 /* FM */;
  }
  return 0 /* O */;
}
var UseFeatureMask = {
  rphf: 1,
  pref: 2,
  blwf: 4,
  abvf: 8,
  pstf: 16,
  half: 32,
  cjct: 64,
  vatu: 128,
  pres: 256,
  abvs: 512,
  blws: 1024,
  psts: 2048,
  haln: 4096
};
function findUseSyllables(infos) {
  const syllables = [];
  const n = infos.length;
  if (n === 0)
    return syllables;
  let start = 0;
  while (start < n) {
    const syllable = parseUseSyllable(infos, start);
    syllables.push(syllable);
    start = syllable.end;
  }
  return syllables;
}
function parseUseSyllable(infos, start) {
  const n = infos.length;
  let pos = start;
  let base = -1;
  let hasReph = false;
  if (pos + 1 < n) {
    const info1 = infos[pos];
    const info2 = infos[pos + 1];
    if (info1 && info2) {
      const cat1 = getUseCategory(info1.codepoint ?? 0);
      const cat2 = getUseCategory(info2.codepoint ?? 0);
      if (cat1 === 13 /* R */ && cat2 === 8 /* H */) {
        hasReph = true;
        pos += 2;
      }
    }
  }
  while (pos < n) {
    const info = infos[pos];
    if (!info) {
      pos++;
      continue;
    }
    const cat = getUseCategory(info.codepoint ?? 0);
    if (cat === 1 /* B */ || cat === 10 /* IND */ || cat === 7 /* GB */ || cat === 22 /* V */) {
      base = pos;
      pos++;
      break;
    }
    if (cat === 26 /* VMPre */ || cat === 30 /* VPre */ || cat === 39 /* MPre */) {
      pos++;
      continue;
    }
    if (base === -1) {
      pos++;
    }
    break;
  }
  if (base === -1)
    base = start;
  while (pos < n) {
    const posInfo = infos[pos];
    if (!posInfo) {
      pos++;
      continue;
    }
    const cat = getUseCategory(posInfo.codepoint ?? 0);
    if (cat === 8 /* H */) {
      pos++;
      if (pos < n) {
        const nextInfo = infos[pos];
        if (nextInfo) {
          const nextCat = getUseCategory(nextInfo.codepoint ?? 0);
          if (nextCat === 1 /* B */ || nextCat === 4 /* CS */ || nextCat === 17 /* SUB */) {
            pos++;
            continue;
          }
          if (nextCat === 20 /* ZWJ */ || nextCat === 21 /* ZWNJ */) {
            pos++;
          }
        }
      }
      continue;
    }
    if (cat === 17 /* SUB */ || cat === 4 /* CS */) {
      pos++;
      continue;
    }
    if (cat === 12 /* N */ || cat === 9 /* HN */) {
      pos++;
      continue;
    }
    break;
  }
  while (pos < n) {
    const posInfo = infos[pos];
    if (!posInfo) {
      pos++;
      continue;
    }
    const cat = getUseCategory(posInfo.codepoint ?? 0);
    if (cat === 28 /* VAbv */ || cat === 29 /* VBlw */ || cat === 30 /* VPre */ || cat === 31 /* VPst */ || cat === 23 /* VD */) {
      pos++;
      continue;
    }
    if (cat === 37 /* MAbv */ || cat === 38 /* MBlw */ || cat === 39 /* MPre */ || cat === 40 /* MPst */) {
      pos++;
      continue;
    }
    if (cat === 24 /* VMAbv */ || cat === 25 /* VMBlw */ || cat === 26 /* VMPre */ || cat === 27 /* VMPst */) {
      pos++;
      continue;
    }
    if (cat === 32 /* SMAbv */ || cat === 33 /* SMBlw */) {
      pos++;
      continue;
    }
    if (cat === 34 /* FAbv */ || cat === 35 /* FBlw */ || cat === 36 /* FPst */ || cat === 5 /* F */ || cat === 6 /* FM */) {
      pos++;
      continue;
    }
    if (cat === 2 /* CGJ */ || cat === 18 /* VS */) {
      pos++;
      continue;
    }
    break;
  }
  if (pos === start) {
    pos = start + 1;
  }
  return { start, end: pos, base, hasReph };
}
function setupUseMasks(infos) {
  const syllables = findUseSyllables(infos);
  for (let i = 0;i < syllables.length; i++) {
    const syllable = syllables[i];
    for (let j = syllable.start;j < syllable.end; j++) {
      const info = infos[j];
      if (!info)
        continue;
      info.mask = info.mask & 65535 | (i & 65535) << 16;
      const cat = getUseCategory(info.codepoint);
      if (syllable.hasReph && j < syllable.start + 2) {
        info.mask |= UseFeatureMask.rphf;
      }
      if (j < syllable.base) {
        if (cat === 1 /* B */ || cat === 4 /* CS */ || cat === 17 /* SUB */) {
          info.mask |= UseFeatureMask.half | UseFeatureMask.cjct;
        }
      }
      if (j > syllable.base) {
        if (cat === 1 /* B */ || cat === 4 /* CS */ || cat === 17 /* SUB */) {
          info.mask |= UseFeatureMask.blwf | UseFeatureMask.pstf | UseFeatureMask.vatu;
        }
      }
      if (cat === 8 /* H */ || cat === 9 /* HN */) {
        if (j < syllable.base) {
          info.mask |= UseFeatureMask.half;
        } else {
          info.mask |= UseFeatureMask.haln;
        }
      }
      if (cat === 30 /* VPre */) {
        info.mask |= UseFeatureMask.pref | UseFeatureMask.pres;
      } else if (cat === 28 /* VAbv */) {
        info.mask |= UseFeatureMask.abvf | UseFeatureMask.abvs;
      } else if (cat === 29 /* VBlw */) {
        info.mask |= UseFeatureMask.blwf | UseFeatureMask.blws;
      } else if (cat === 31 /* VPst */ || cat === 23 /* VD */) {
        info.mask |= UseFeatureMask.pstf | UseFeatureMask.psts;
      }
      if (cat === 37 /* MAbv */) {
        info.mask |= UseFeatureMask.abvs;
      } else if (cat === 38 /* MBlw */) {
        info.mask |= UseFeatureMask.blws;
      } else if (cat === 39 /* MPre */) {
        info.mask |= UseFeatureMask.pres;
      } else if (cat === 40 /* MPst */) {
        info.mask |= UseFeatureMask.psts;
      }
      if (cat === 32 /* SMAbv */) {
        info.mask |= UseFeatureMask.abvs;
      } else if (cat === 33 /* SMBlw */) {
        info.mask |= UseFeatureMask.blws;
      }
      if (cat === 34 /* FAbv */) {
        info.mask |= UseFeatureMask.abvs;
      } else if (cat === 35 /* FBlw */) {
        info.mask |= UseFeatureMask.blws;
      } else if (cat === 36 /* FPst */ || cat === 5 /* F */ || cat === 6 /* FM */) {
        info.mask |= UseFeatureMask.psts;
      }
    }
  }
}
function reorderUSE(infos) {
  const syllables = findUseSyllables(infos);
  for (let i = 0;i < syllables.length; i++) {
    const syllable = syllables[i];
    reorderUseSyllable(infos, syllable);
  }
}
function reorderUseSyllable(infos, syllable) {
  const { start, end, base, hasReph } = syllable;
  const preBaseVowels = [];
  for (let i = base + 1;i < end; i++) {
    const info = infos[i];
    if (!info)
      continue;
    const cat = getUseCategory(info.codepoint);
    if (cat === 30 /* VPre */ || cat === 39 /* MPre */) {
      preBaseVowels.push({ index: i, info });
    }
  }
  if (preBaseVowels.length > 0) {
    preBaseVowels.sort((a, b) => b.index - a.index);
    for (let i = 0;i < preBaseVowels.length; i++) {
      const { index, info } = preBaseVowels[i];
      infos.splice(index, 1);
      const insertPos = hasReph ? start + 2 : start;
      infos.splice(insertPos, 0, info);
    }
  }
  if (hasReph && end > start + 2) {
    const rephStart = infos[start];
    const rephH = infos[start + 1];
    if (rephStart && rephH) {
      let rephTarget = end - 1;
      while (rephTarget > base) {
        const targetInfo = infos[rephTarget];
        if (!targetInfo)
          break;
        const cat = getUseCategory(targetInfo.codepoint);
        if (cat === 32 /* SMAbv */ || cat === 33 /* SMBlw */ || cat === 34 /* FAbv */ || cat === 35 /* FBlw */ || cat === 36 /* FPst */ || cat === 5 /* F */ || cat === 6 /* FM */) {
          rephTarget--;
        } else {
          break;
        }
      }
      if (rephTarget > start + 1) {
        infos.splice(start, 2);
        const adjustedTarget = rephTarget - 2;
        infos.splice(adjustedTarget + 1, 0, rephStart, rephH);
      }
    }
  }
}

// reference/text-shaper/src/shaper/shaper.ts
var _ligMatchIndices = new Uint16Array(16);
var _ligMatchGlyphs = new Uint16Array(16);
function getFont(fontLike) {
  return fontLike instanceof Face ? fontLike.font : fontLike;
}
var _faceCache = new WeakMap;
function getFace(fontLike) {
  if (fontLike instanceof Face)
    return fontLike;
  let face = _faceCache.get(fontLike);
  if (!face) {
    face = new Face(fontLike);
    _faceCache.set(fontLike, face);
  }
  return face;
}
function precomputeSkipMarkers(font, buffer, lookupFlag) {
  const markers = new Uint8Array(buffer.infos.length);
  const gdef = font.gdef;
  if (!gdef || lookupFlag === 0) {
    return markers;
  }
  const ignoreBase = lookupFlag & LookupFlag.IgnoreBaseGlyphs;
  const ignoreLig = lookupFlag & LookupFlag.IgnoreLigatures;
  const ignoreMark = lookupFlag & LookupFlag.IgnoreMarks;
  const markAttachmentType = getMarkAttachmentType(lookupFlag);
  for (let i = 0;i < buffer.infos.length; i++) {
    const info = buffer.infos[i];
    if (!info)
      continue;
    const glyphClass = getGlyphClass2(gdef, info.glyphId);
    if (ignoreBase && glyphClass === 1 /* Base */) {
      markers[i] = 1;
    } else if (ignoreLig && glyphClass === 2 /* Ligature */) {
      markers[i] = 1;
    } else if (ignoreMark && glyphClass === 3 /* Mark */) {
      markers[i] = 1;
    } else if (markAttachmentType !== 0 && glyphClass === 3 /* Mark */) {
      const glyphMarkClass = gdef.markAttachClassDef.get(info.glyphId);
      if (glyphMarkClass !== markAttachmentType) {
        markers[i] = 1;
      }
    }
  }
  return markers;
}
function buildNextNonSkipArray(skip, length) {
  const next = new Int16Array(length);
  let lastNonSkip = -1;
  for (let i = length - 1;i >= 0; i--) {
    next[i] = lastNonSkip;
    if (!skip[i]) {
      lastNonSkip = i;
    }
  }
  return next;
}
function hasAnyMarks2(buffer, font) {
  if (!font.gdef)
    return false;
  const infos = buffer.infos;
  const len = buffer.length;
  for (let i = 0;i < len; i++) {
    const info = infos[i];
    if (!info)
      continue;
    const cls = getGlyphClass2(font.gdef, info.glyphId);
    if (cls === 3 /* Mark */)
      return true;
  }
  return false;
}
function buildBaseIndexArray(buffer, glyphClassCache, font) {
  const baseIndex = new Int16Array(buffer.infos.length);
  baseIndex.fill(-1);
  let lastBaseIndex = -1;
  for (let i = 0;i < buffer.infos.length; i++) {
    const info = buffer.infos[i];
    if (!info)
      continue;
    const cls = getCachedGlyphClass(font, info.glyphId, glyphClassCache);
    if (cls === 1 /* Base */ || cls === 0 || cls === 2 /* Ligature */) {
      lastBaseIndex = i;
    } else if (cls === 3 /* Mark */) {
      baseIndex[i] = lastBaseIndex;
    }
  }
  return baseIndex;
}
var _glyphBufferPool = [];
function shape(fontLike, buffer, options = {}) {
  let glyphBuffer = _glyphBufferPool.pop();
  if (!glyphBuffer) {
    glyphBuffer = GlyphBuffer.withCapacity(64);
  }
  shapeInto(fontLike, buffer, glyphBuffer, options);
  return glyphBuffer;
}
function shapeInto(fontLike, buffer, glyphBuffer, options = {}) {
  const font = getFont(fontLike);
  const face = getFace(fontLike);
  const script = options.script ?? buffer.script ?? "latn";
  const language = options.language ?? buffer.language ?? null;
  const direction = options.direction ?? "ltr";
  const features2 = options.features ?? [];
  let kernEnabled = true;
  if (features2.length) {
    const kernTag = tag("kern");
    for (let i = 0;i < features2.length; i++) {
      const feat = features2[i];
      if (feat.tag === kernTag) {
        kernEnabled = feat.enabled;
        break;
      }
    }
  }
  const axisCoords = face.normalizedCoords.length > 0 ? face.normalizedCoords : null;
  const plan = getOrCreateShapePlan(font, script, language, direction, features2, axisCoords);
  glyphBuffer.reset();
  glyphBuffer.direction = buffer.direction;
  glyphBuffer.script = script;
  glyphBuffer.language = language;
  glyphBuffer.initFromCodepointsWithFont(buffer.codepoints, buffer.clusters, font);
  preShape(glyphBuffer, script);
  applyGsub(font, glyphBuffer, plan);
  initializePositions(face, glyphBuffer);
  const hasGpos = font.gpos !== null && plan.gposLookups.length > 0;
  if (hasGpos) {
    applyGpos(font, glyphBuffer, plan);
  } else {
    if (kernEnabled) {
      applyFallbackKerning(font, glyphBuffer.infos, glyphBuffer.positions);
    }
    applyFallbackMarkPositioning(font, glyphBuffer.infos, glyphBuffer.positions);
  }
  if (!font.gsub && font.morx) {
    applyMorx(font, glyphBuffer);
  }
  if (direction === "rtl") {
    glyphBuffer.reverse();
  }
}
function preShape(buffer, script) {
  if (script === "arab" || script === "syrc" || script === "mand" || script === "nko ") {
    setupArabicMasks(buffer.infos);
    return;
  }
  if (script === "hebr") {
    setupHebrewMasks(buffer.infos);
    return;
  }
  if (script === "hang" || script === "kore") {
    const normalized = normalizeHangul(buffer.infos);
    if (normalized.length !== buffer.infos.length) {
      buffer.initFromInfos(normalized);
    }
    setupHangulMasks(buffer.infos);
    return;
  }
  if (script === "deva" || script === "beng" || script === "guru" || script === "gujr" || script === "orya" || script === "taml" || script === "telu" || script === "knda" || script === "mlym") {
    setupIndicMasks(buffer.infos);
    reorderIndic(buffer.infos);
    return;
  }
  if (script === "thai" || script === "lao ") {
    setupThaiLaoMasks(buffer.infos);
    reorderThaiLao(buffer.infos);
    return;
  }
  if (script === "khmr") {
    setupKhmerMasks(buffer.infos);
    reorderKhmer(buffer.infos);
    return;
  }
  if (script === "mymr") {
    setupMyanmarMasks(buffer.infos);
    reorderMyanmar(buffer.infos);
    return;
  }
  if (usesUSE(script)) {
    setupUseMasks(buffer.infos);
    reorderUSE(buffer.infos);
    return;
  }
  if (script === "Zyyy" || script === "Zinh" || script === "Zzzz") {
    detectAndApplyComplexShaping(buffer.infos);
  }
}
function detectAndApplyComplexShaping(infos) {
  if (infos.length === 0)
    return;
  const sampleLen = Math.min(10, infos.length);
  for (let s = 0;s < sampleLen; s++) {
    const info = infos[s];
    const cp = info.codepoint;
    if (cp >= 1536 && cp <= 1791 || cp >= 1872 && cp <= 1919 || cp >= 2208 && cp <= 2303) {
      setupArabicMasks(infos);
      return;
    }
    if (cp >= 1424 && cp <= 1535) {
      setupHebrewMasks(infos);
      return;
    }
    if (isKorean(cp)) {
      const normalized = normalizeHangul(infos);
      if (normalized.length !== infos.length) {
        infos.length = 0;
        infos.push(...normalized);
      }
      setupHangulMasks(infos);
      return;
    }
    if (isIndic(cp)) {
      setupIndicMasks(infos);
      reorderIndic(infos);
      return;
    }
    if (isThai(cp)) {
      setupThaiLaoMasks(infos);
      reorderThaiLao(infos);
      return;
    }
    if (isLao(cp)) {
      setupThaiLaoMasks(infos);
      reorderThaiLao(infos);
      return;
    }
    if (isKhmer(cp)) {
      setupKhmerMasks(infos);
      reorderKhmer(infos);
      return;
    }
    if (isMyanmar(cp)) {
      setupMyanmarMasks(infos);
      reorderMyanmar(infos);
      return;
    }
  }
}
function applyGsub(font, buffer, plan) {
  const lookups = plan.gsubLookups;
  let bufferDigest = new SetDigest;
  const infos = buffer.infos;
  for (let i = 0;i < buffer.length; i++) {
    bufferDigest.add(infos[i].glyphId);
  }
  for (let i = 0;i < lookups.length; i++) {
    const entry = lookups[i];
    if (!bufferDigest.mayIntersect(entry.lookup.digest))
      continue;
    const prevLength = buffer.length;
    applyGsubLookup(font, buffer, entry.lookup, plan);
    if (buffer.length !== prevLength) {
      bufferDigest = new SetDigest;
      for (let j = 0;j < buffer.length; j++) {
        bufferDigest.add(infos[j].glyphId);
      }
    }
  }
  buffer.compact();
}
function applyGsubLookup(font, buffer, lookup, plan) {
  switch (lookup.type) {
    case 1 /* Single */:
      applySingleSubstLookup(font, buffer, lookup);
      break;
    case 2 /* Multiple */:
      applyMultipleSubstLookup(font, buffer, lookup);
      break;
    case 3 /* Alternate */:
      applyAlternateSubstLookup(font, buffer, lookup);
      break;
    case 4 /* Ligature */:
      applyLigatureSubstLookup(font, buffer, lookup);
      break;
    case 5 /* Context */:
      applyContextSubstLookup(font, buffer, lookup, plan);
      break;
    case 6 /* ChainingContext */:
      applyChainingContextSubstLookup(font, buffer, lookup, plan);
      break;
    case 8 /* ReverseChainingSingle */:
      applyReverseChainingSingleSubstLookup(font, buffer, lookup);
      break;
  }
}
function applySingleSubstLookup(font, buffer, lookup) {
  const infos = buffer.infos;
  const len = infos.length;
  const digest = lookup.digest;
  if (lookup.flag === 0 || !font.gdef) {
    if (lookup.subtables.length === 1) {
      const subtable = lookup.subtables[0];
      if (subtable.format === 1 && subtable.deltaGlyphId !== undefined) {
        const delta = subtable.deltaGlyphId;
        for (let i = 0;i < len; i++) {
          const info = infos[i];
          if (!digest.mayHave(info.glyphId))
            continue;
          if (subtable.coverage.get(info.glyphId) !== null) {
            info.glyphId = info.glyphId + delta & 65535;
          }
        }
      } else if (subtable.format === 2 && subtable.substituteGlyphIds) {
        const subs = subtable.substituteGlyphIds;
        for (let i = 0;i < len; i++) {
          const info = infos[i];
          if (!digest.mayHave(info.glyphId))
            continue;
          const idx = subtable.coverage.get(info.glyphId);
          if (idx !== null) {
            const rep = subs[idx];
            if (rep !== undefined)
              info.glyphId = rep;
          }
        }
      }
      return;
    }
    for (let i = 0;i < len; i++) {
      const info = infos[i];
      if (!digest.mayHave(info.glyphId))
        continue;
      const replacement = applySingleSubst(lookup, info.glyphId);
      if (replacement !== null) {
        info.glyphId = replacement;
      }
    }
    return;
  }
  const skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  for (let i = 0;i < len; i++) {
    if (skip[i])
      continue;
    const info = infos[i];
    if (!digest.mayHave(info.glyphId))
      continue;
    const replacement = applySingleSubst(lookup, info.glyphId);
    if (replacement !== null) {
      info.glyphId = replacement;
    }
  }
}
function applyMultipleSubstLookup(font, buffer, lookup) {
  const digest = lookup.digest;
  let i = 0;
  while (i < buffer.infos.length) {
    const info = buffer.infos[i];
    if (!info) {
      i++;
      continue;
    }
    if (shouldSkipGlyph(font, info.glyphId, lookup.flag)) {
      i++;
      continue;
    }
    if (!digest.mayHave(info.glyphId)) {
      i++;
      continue;
    }
    let applied = false;
    const subtables = lookup.subtables;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const coverageIndex = subtable.coverage.get(info.glyphId);
      if (coverageIndex === null)
        continue;
      const sequence = subtable.sequences[coverageIndex];
      if (!sequence || sequence.length === 0)
        continue;
      const firstGlyph = sequence[0];
      if (firstGlyph === undefined)
        continue;
      info.glyphId = firstGlyph;
      for (let j = 1;j < sequence.length; j++) {
        const glyphId = sequence[j];
        const newInfo = {
          glyphId,
          cluster: info.cluster,
          mask: info.mask,
          codepoint: info.codepoint
        };
        const newPos = {
          xAdvance: 0,
          yAdvance: 0,
          xOffset: 0,
          yOffset: 0
        };
        buffer.insertGlyph(i + j, newInfo, newPos);
      }
      i += sequence.length;
      applied = true;
      break;
    }
    if (!applied)
      i++;
  }
}
function applyAlternateSubstLookup(font, buffer, lookup) {
  const infos = buffer.infos;
  const subtables = lookup.subtables;
  const digest = lookup.digest;
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    if (shouldSkipGlyph(font, info.glyphId, lookup.flag))
      continue;
    if (!digest.mayHave(info.glyphId))
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const coverageIndex = subtable.coverage.get(info.glyphId);
      if (coverageIndex === null)
        continue;
      const alternateSet = subtable.alternateSets[coverageIndex];
      if (!alternateSet || alternateSet.length === 0)
        continue;
      const firstAlternate = alternateSet[0];
      if (firstAlternate === undefined)
        continue;
      info.glyphId = firstAlternate;
      break;
    }
  }
}
function applyLigatureSubstLookup(font, buffer, lookup) {
  const infos = buffer.infos;
  const len = infos.length;
  const needsSkipCheck = lookup.flag !== 0 && font.gdef !== null;
  const digest = lookup.digest;
  let skip = null;
  if (needsSkipCheck) {
    skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  }
  let i = 0;
  while (i < len) {
    if (buffer.isDeleted(i)) {
      i++;
      continue;
    }
    const info = infos[i];
    if (!info) {
      i++;
      continue;
    }
    if (skip?.[i]) {
      i++;
      continue;
    }
    if (!digest.mayHave(info.glyphId)) {
      i++;
      continue;
    }
    let matchLen = 1;
    _ligMatchIndices[0] = i;
    _ligMatchGlyphs[0] = info.glyphId;
    for (let j = i + 1;j < len && matchLen < 16; j++) {
      if (buffer.isDeleted(j))
        continue;
      const nextInfo = infos[j];
      if (!nextInfo)
        continue;
      if (skip?.[j])
        continue;
      _ligMatchIndices[matchLen] = j;
      _ligMatchGlyphs[matchLen] = nextInfo.glyphId;
      matchLen++;
    }
    const result = applyLigatureSubstDirect(lookup, _ligMatchGlyphs, matchLen, 0);
    if (result) {
      info.glyphId = result.ligatureGlyph;
      for (let k = 1;k < result.consumed; k++) {
        const idx = _ligMatchIndices[k];
        if (idx !== undefined) {
          const targetInfo = infos[idx];
          if (targetInfo) {
            info.cluster = Math.min(info.cluster, targetInfo.cluster);
          }
          buffer.markDeleted(idx);
        }
      }
    }
    i++;
  }
}
function applyContextSubstLookup(font, buffer, lookup, plan) {
  const infos = buffer.infos;
  const len = infos.length;
  const digest = lookup.digest;
  let skip = null;
  if (lookup.flag !== 0 && font.gdef !== null) {
    skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  }
  const subtables = lookup.subtables;
  for (let i = 0;i < len; i++) {
    const info = infos[i];
    if (!info)
      continue;
    if (skip?.[i])
      continue;
    if (!digest.mayHave(info.glyphId))
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      let matched = false;
      let lookupRecords = [];
      if (subtable.format === 1) {
        const result = matchContextFormat1(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 2) {
        const result = matchContextFormat2(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 3) {
        if (matchContextFormat3(font, buffer, i, subtable, lookup.flag)) {
          matched = true;
          lookupRecords = subtable.lookupRecords;
        }
      }
      if (matched) {
        applyNestedLookups(font, buffer, i, lookupRecords, plan);
        break;
      }
    }
  }
}
function applyChainingContextSubstLookup(font, buffer, lookup, plan) {
  const infos = buffer.infos;
  const len = infos.length;
  const digest = lookup.digest;
  let skip = null;
  if (lookup.flag !== 0 && font.gdef !== null) {
    skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  }
  const subtables = lookup.subtables;
  for (let i = 0;i < len; i++) {
    const info = infos[i];
    if (!info)
      continue;
    if (skip?.[i])
      continue;
    if (!digest.mayHave(info.glyphId))
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      let matched = false;
      let lookupRecords = [];
      if (subtable.format === 1) {
        const result = matchChainingFormat1(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 2) {
        const result = matchChainingFormat2(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 3) {
        if (matchChainingFormat3(font, buffer, i, subtable, lookup.flag)) {
          matched = true;
          lookupRecords = subtable.lookupRecords;
        }
      }
      if (matched) {
        applyNestedLookups(font, buffer, i, lookupRecords, plan);
        break;
      }
    }
  }
}
function applyReverseChainingSingleSubstLookup(font, buffer, lookup) {
  const infos = buffer.infos;
  const subtables = lookup.subtables;
  const digest = lookup.digest;
  for (let i = infos.length - 1;i >= 0; i--) {
    const info = infos[i];
    if (!info)
      continue;
    if (shouldSkipGlyph(font, info.glyphId, lookup.flag))
      continue;
    if (!digest.mayHave(info.glyphId))
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const coverageIndex = subtable.coverage.get(info.glyphId);
      if (coverageIndex === null)
        continue;
      let backtrackMatch = true;
      let backtrackPos = i + 1;
      const backtrackCoverages = subtable.backtrackCoverages;
      for (let b = 0;b < backtrackCoverages.length; b++) {
        const backCov = backtrackCoverages[b];
        while (backtrackPos < infos.length && shouldSkipGlyph(font, infos[backtrackPos]?.glyphId, lookup.flag)) {
          backtrackPos++;
        }
        if (backtrackPos >= infos.length || backCov.get(infos[backtrackPos]?.glyphId) === null) {
          backtrackMatch = false;
          break;
        }
        backtrackPos++;
      }
      if (!backtrackMatch)
        continue;
      let lookaheadMatch = true;
      let lookaheadPos = i - 1;
      const lookaheadCoverages = subtable.lookaheadCoverages;
      for (let l = 0;l < lookaheadCoverages.length; l++) {
        const lookCov = lookaheadCoverages[l];
        while (lookaheadPos >= 0 && shouldSkipGlyph(font, infos[lookaheadPos]?.glyphId, lookup.flag)) {
          lookaheadPos--;
        }
        if (lookaheadPos < 0 || lookCov.get(infos[lookaheadPos]?.glyphId) === null) {
          lookaheadMatch = false;
          break;
        }
        lookaheadPos--;
      }
      if (!lookaheadMatch)
        continue;
      const substitute = subtable.substituteGlyphIds[coverageIndex];
      if (substitute !== undefined) {
        info.glyphId = substitute;
      }
      break;
    }
  }
}
function matchContextFormat1(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const ruleSet = subtable.ruleSets[coverageIndex];
  if (!ruleSet)
    return null;
  for (let r = 0;r < ruleSet.length; r++) {
    const rule = ruleSet[r];
    if (matchGlyphSequence(font, buffer, startIndex + 1, rule.inputSequence, lookupFlag)) {
      return rule.lookupRecords;
    }
  }
  return null;
}
function matchContextFormat2(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const firstClass = subtable.classDef.get(firstGlyph);
  const classRuleSet = subtable.classRuleSets[firstClass];
  if (!classRuleSet)
    return null;
  for (let r = 0;r < classRuleSet.length; r++) {
    const rule = classRuleSet[r];
    if (matchClassSequence(font, buffer, startIndex + 1, rule.inputClasses, subtable.classDef, lookupFlag)) {
      return rule.lookupRecords;
    }
  }
  return null;
}
function matchContextFormat3(font, buffer, startIndex, subtable, lookupFlag) {
  const infos = buffer.infos;
  const coverages = subtable.coverages;
  let pos = startIndex;
  for (let c = 0;c < coverages.length; c++) {
    const coverage = coverages[c];
    while (pos < infos.length && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {
      pos++;
    }
    if (pos >= infos.length)
      return false;
    if (coverage.get(infos[pos]?.glyphId) === null)
      return false;
    pos++;
  }
  return true;
}
function matchChainingFormat1(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const chainRuleSet = subtable.chainRuleSets[coverageIndex];
  if (!chainRuleSet)
    return null;
  for (let r = 0;r < chainRuleSet.length; r++) {
    const rule = chainRuleSet[r];
    if (!matchGlyphSequenceBackward(font, buffer, startIndex - 1, rule.backtrackSequence, lookupFlag)) {
      continue;
    }
    if (!matchGlyphSequence(font, buffer, startIndex + 1, rule.inputSequence, lookupFlag)) {
      continue;
    }
    let inputEnd = startIndex + 1;
    for (let i = 0;i < rule.inputSequence.length; i++) {
      while (inputEnd < buffer.infos.length && shouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)) {
        inputEnd++;
      }
      inputEnd++;
    }
    if (!matchGlyphSequence(font, buffer, inputEnd, rule.lookaheadSequence, lookupFlag)) {
      continue;
    }
    return rule.lookupRecords;
  }
  return null;
}
function matchChainingFormat2(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const firstClass = subtable.inputClassDef.get(firstGlyph);
  const chainClassRuleSet = subtable.chainClassRuleSets[firstClass];
  if (!chainClassRuleSet)
    return null;
  for (let r = 0;r < chainClassRuleSet.length; r++) {
    const rule = chainClassRuleSet[r];
    if (!matchClassSequenceBackward(font, buffer, startIndex - 1, rule.backtrackClasses, subtable.backtrackClassDef, lookupFlag)) {
      continue;
    }
    if (!matchClassSequence(font, buffer, startIndex + 1, rule.inputClasses, subtable.inputClassDef, lookupFlag)) {
      continue;
    }
    const infos = buffer.infos;
    let inputEnd = startIndex + 1;
    for (let i = 0;i < rule.inputClasses.length; i++) {
      while (inputEnd < infos.length && shouldSkipGlyph(font, infos[inputEnd]?.glyphId, lookupFlag)) {
        inputEnd++;
      }
      inputEnd++;
    }
    if (!matchClassSequence(font, buffer, inputEnd, rule.lookaheadClasses, subtable.lookaheadClassDef, lookupFlag)) {
      continue;
    }
    return rule.lookupRecords;
  }
  return null;
}
function matchChainingFormat3(font, buffer, startIndex, subtable, lookupFlag) {
  const infos = buffer.infos;
  let backtrackPos = startIndex - 1;
  const backtrackCoverages = subtable.backtrackCoverages;
  for (let b = 0;b < backtrackCoverages.length; b++) {
    const coverage = backtrackCoverages[b];
    while (backtrackPos >= 0 && shouldSkipGlyph(font, infos[backtrackPos]?.glyphId, lookupFlag)) {
      backtrackPos--;
    }
    if (backtrackPos < 0)
      return false;
    if (coverage.get(infos[backtrackPos]?.glyphId) === null)
      return false;
    backtrackPos--;
  }
  let inputPos = startIndex;
  const inputCoverages = subtable.inputCoverages;
  for (let i = 0;i < inputCoverages.length; i++) {
    const coverage = inputCoverages[i];
    while (inputPos < infos.length && shouldSkipGlyph(font, infos[inputPos]?.glyphId, lookupFlag)) {
      inputPos++;
    }
    if (inputPos >= infos.length)
      return false;
    if (coverage.get(infos[inputPos]?.glyphId) === null)
      return false;
    inputPos++;
  }
  let lookaheadPos = inputPos;
  const lookaheadCoverages = subtable.lookaheadCoverages;
  for (let l = 0;l < lookaheadCoverages.length; l++) {
    const coverage = lookaheadCoverages[l];
    while (lookaheadPos < infos.length && shouldSkipGlyph(font, infos[lookaheadPos]?.glyphId, lookupFlag)) {
      lookaheadPos++;
    }
    if (lookaheadPos >= infos.length)
      return false;
    if (coverage.get(infos[lookaheadPos]?.glyphId) === null)
      return false;
    lookaheadPos++;
  }
  return true;
}
function applyNestedLookups(_font, buffer, startIndex, lookupRecords, plan) {
  const len = lookupRecords.length;
  if (len === 0)
    return;
  if (len === 1) {
    const record = lookupRecords[0];
    const lookupEntry = plan.gsubLookupMap.get(record.lookupListIndex);
    if (!lookupEntry)
      return;
    const pos = startIndex + record.sequenceIndex;
    if (pos >= buffer.infos.length)
      return;
    const targetInfo = buffer.infos[pos];
    if (!targetInfo)
      return;
    if (lookupEntry.lookup.type === 1 /* Single */) {
      const replacement = applySingleSubst(lookupEntry.lookup, targetInfo.glyphId);
      if (replacement !== null) {
        targetInfo.glyphId = replacement;
      }
    }
    return;
  }
  const applied = new Uint8Array(len);
  for (let round2 = 0;round2 < len; round2++) {
    let maxIdx = -1;
    let maxSeq = -1;
    for (let i = 0;i < len; i++) {
      if (applied[i])
        continue;
      const seq = lookupRecords[i]?.sequenceIndex;
      if (seq > maxSeq) {
        maxSeq = seq;
        maxIdx = i;
      }
    }
    if (maxIdx < 0)
      break;
    applied[maxIdx] = 1;
    const record = lookupRecords[maxIdx];
    const lookupEntry = plan.gsubLookupMap.get(record.lookupListIndex);
    if (!lookupEntry)
      continue;
    const pos = startIndex + record.sequenceIndex;
    if (pos >= buffer.infos.length)
      continue;
    const targetInfo = buffer.infos[pos];
    if (!targetInfo)
      continue;
    if (lookupEntry.lookup.type === 1 /* Single */) {
      const replacement = applySingleSubst(lookupEntry.lookup, targetInfo.glyphId);
      if (replacement !== null) {
        targetInfo.glyphId = replacement;
      }
    }
  }
}
function initializePositions(face, buffer) {
  const infos = buffer.infos;
  const positions = buffer.positions;
  const len = infos.length;
  const hmtx = face.font.hmtx;
  const hMetrics = hmtx.hMetrics;
  const hMetricsLen = hMetrics.length;
  const lastAdvance = hMetrics[hMetricsLen - 1]?.advanceWidth ?? 0;
  const isVariable = face.normalizedCoords.length > 0;
  if (!isVariable) {
    for (let i = 0;i < len; i++) {
      const gid = infos[i].glyphId;
      positions[i].xAdvance = gid < hMetricsLen ? hMetrics[gid]?.advanceWidth ?? 0 : lastAdvance;
    }
    return;
  }
  for (let i = 0;i < len; i++) {
    const info = infos[i];
    positions[i].xAdvance = face.advanceWidth(info.glyphId);
  }
}
function getCachedGlyphClass(font, glyphId, cache) {
  let cls = cache.get(glyphId);
  if (cls === undefined) {
    cls = getGlyphClass2(font.gdef, glyphId);
    cache.set(glyphId, cls);
  }
  return cls;
}
function applyGpos(font, buffer, plan) {
  const bufferDigest = new SetDigest;
  const infos = buffer.infos;
  const len = buffer.length;
  for (let i = 0;i < len; i++) {
    bufferDigest.add(infos[i].glyphId);
  }
  const hasMarks = hasAnyMarks2(buffer, font);
  let baseIndexArray;
  let glyphClassCache;
  if (hasMarks) {
    glyphClassCache = new Map;
    baseIndexArray = buildBaseIndexArray(buffer, glyphClassCache, font);
  } else {
    baseIndexArray = _emptyBaseIndex;
    glyphClassCache = _emptyGlyphClassCache;
  }
  const lookups = plan.gposLookups;
  for (let i = 0;i < lookups.length; i++) {
    const entry = lookups[i];
    if (!bufferDigest.mayIntersect(entry.lookup.digest))
      continue;
    applyGposLookup(font, buffer, entry.lookup, plan, glyphClassCache, baseIndexArray, hasMarks);
  }
}
var _emptyBaseIndex = new Int16Array(0);
var _emptyGlyphClassCache = new Map;
function applyGposLookup(font, buffer, lookup, plan, glyphClassCache, baseIndexArray, hasMarks) {
  switch (lookup.type) {
    case 1 /* Single */:
      applySinglePosLookup(font, buffer, lookup, hasMarks);
      break;
    case 2 /* Pair */:
      applyPairPosLookup(font, buffer, lookup, hasMarks);
      break;
    case 3 /* Cursive */:
      applyCursivePosLookup(font, buffer, lookup, hasMarks);
      break;
    case 4 /* MarkToBase */:
      if (!hasMarks)
        break;
      applyMarkBasePosLookup(font, buffer, lookup, glyphClassCache, baseIndexArray);
      break;
    case 5 /* MarkToLigature */:
      if (!hasMarks)
        break;
      applyMarkLigaturePosLookup(font, buffer, lookup, glyphClassCache, baseIndexArray);
      break;
    case 6 /* MarkToMark */:
      if (!hasMarks)
        break;
      applyMarkMarkPosLookup(font, buffer, lookup, glyphClassCache);
      break;
    case 7 /* Context */:
      applyContextPosLookup(font, buffer, lookup, plan, glyphClassCache, baseIndexArray, hasMarks);
      break;
    case 8 /* ChainingContext */:
      applyChainingContextPosLookup(font, buffer, lookup, plan, glyphClassCache, baseIndexArray, hasMarks);
      break;
  }
}
function applySinglePosLookup(font, buffer, lookup, hasMarks) {
  const infos = buffer.infos;
  const positions = buffer.positions;
  const len = infos.length;
  const digest = lookup.digest;
  const subtables = lookup.subtables;
  const needsSkip = hasMarks && lookup.flag !== 0 && font.gdef !== null;
  if (subtables.length === 1 && !needsSkip) {
    const subtable = subtables[0];
    if (subtable.format === 1 && subtable.value) {
      const value = subtable.value;
      const hasX = value.xPlacement !== undefined && value.xPlacement !== 0;
      const hasY = value.yPlacement !== undefined && value.yPlacement !== 0;
      const hasXAdv = value.xAdvance !== undefined && value.xAdvance !== 0;
      const hasYAdv = value.yAdvance !== undefined && value.yAdvance !== 0;
      if (!hasX && !hasY && !hasXAdv && !hasYAdv)
        return;
      for (let i = 0;i < len; i++) {
        const info = infos[i];
        if (!digest.mayHave(info.glyphId))
          continue;
        if (subtable.coverage.get(info.glyphId) === null)
          continue;
        const pos = positions[i];
        if (hasX)
          pos.xOffset += value.xPlacement;
        if (hasY)
          pos.yOffset += value.yPlacement;
        if (hasXAdv)
          pos.xAdvance += value.xAdvance;
        if (hasYAdv)
          pos.yAdvance += value.yAdvance;
      }
      return;
    }
  }
  const applySingle = (i) => {
    const info = infos[i];
    if (!digest.mayHave(info.glyphId))
      return;
    const pos = positions[i];
    if (!pos)
      return;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const coverageIndex = subtable.coverage.get(info.glyphId);
      if (coverageIndex === null)
        continue;
      const value = subtable.format === 1 ? subtable.value : subtable.values?.[coverageIndex];
      if (value) {
        if (value.xPlacement)
          pos.xOffset += value.xPlacement;
        if (value.yPlacement)
          pos.yOffset += value.yPlacement;
        if (value.xAdvance)
          pos.xAdvance += value.xAdvance;
        if (value.yAdvance)
          pos.yAdvance += value.yAdvance;
      }
      break;
    }
  };
  if (!needsSkip) {
    for (let i = 0;i < len; i++) {
      applySingle(i);
    }
    return;
  }
  const skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  for (let i = 0;i < len; i++) {
    if (skip[i])
      continue;
    applySingle(i);
  }
}
function applyPairPosLookup(font, buffer, lookup, hasMarks) {
  const infos = buffer.infos;
  const positions = buffer.positions;
  const len = infos.length;
  const digest = lookup.digest;
  const subtables = lookup.subtables;
  const subtableCount = subtables.length;
  const needsSkip = hasMarks && lookup.flag !== 0 && font.gdef !== null;
  if (!needsSkip) {
    if (subtableCount === 1) {
      const subtable = subtables[0];
      const coverage = subtable.coverage;
      if (subtable.format === 1) {
        const pairSets = subtable.pairSets;
        for (let i = 0;i < len - 1; i++) {
          const gid1 = infos[i].glyphId;
          if (!digest.mayHave(gid1))
            continue;
          const coverageIndex = coverage.get(gid1);
          if (coverageIndex === null)
            continue;
          const pairSet = pairSets[coverageIndex];
          if (!pairSet)
            continue;
          const gid2 = infos[i + 1].glyphId;
          const records = pairSet.pairValueRecords;
          let low = 0;
          let high = records.length - 1;
          while (low <= high) {
            const mid = low + high >>> 1;
            const record = records[mid];
            const sg = record.secondGlyph;
            if (sg < gid2) {
              low = mid + 1;
            } else if (sg > gid2) {
              high = mid - 1;
            } else {
              const xAdv1 = record.value1.xAdvance;
              if (xAdv1)
                positions[i].xAdvance += xAdv1;
              break;
            }
          }
        }
      } else {
        const classDef1 = subtable.classDef1;
        const classDef2 = subtable.classDef2;
        const class1Records = subtable.class1Records;
        const class1Count = class1Records.length;
        for (let i = 0;i < len - 1; i++) {
          const gid1 = infos[i].glyphId;
          if (!digest.mayHave(gid1))
            continue;
          if (coverage.get(gid1) === null)
            continue;
          const class1 = classDef1.get(gid1);
          if (class1 >= class1Count)
            continue;
          const class1Record = class1Records[class1];
          const gid2 = infos[i + 1].glyphId;
          const class2 = classDef2.get(gid2);
          const class2Records = class1Record.class2Records;
          if (class2 >= class2Records.length)
            continue;
          const xAdv1 = class2Records[class2].value1.xAdvance;
          if (xAdv1)
            positions[i].xAdvance += xAdv1;
        }
      }
      return;
    }
    if (subtableCount === 2) {
      const st0 = subtables[0];
      const st1 = subtables[1];
      if (st0.format === 1 && st1.format === 2) {
        const cov0 = st0.coverage;
        const pairSets = st0.pairSets;
        const cov1 = st1.coverage;
        const classDef1 = st1.classDef1;
        const classDef2 = st1.classDef2;
        const class1Records = st1.class1Records;
        const class1Count = class1Records.length;
        for (let i = 0;i < len - 1; i++) {
          const gid1 = infos[i].glyphId;
          if (!digest.mayHave(gid1))
            continue;
          const gid2 = infos[i + 1].glyphId;
          const covIdx0 = cov0.get(gid1);
          if (covIdx0 !== null) {
            const pairSet = pairSets[covIdx0];
            if (pairSet) {
              const records = pairSet.pairValueRecords;
              let low = 0;
              let high = records.length - 1;
              let found = false;
              while (low <= high) {
                const mid = low + high >>> 1;
                const record = records[mid];
                const sg = record.secondGlyph;
                if (sg < gid2) {
                  low = mid + 1;
                } else if (sg > gid2) {
                  high = mid - 1;
                } else {
                  const xAdv1 = record.value1.xAdvance;
                  if (xAdv1)
                    positions[i].xAdvance += xAdv1;
                  found = true;
                  break;
                }
              }
              if (found)
                continue;
            }
          }
          if (cov1.get(gid1) !== null) {
            const class1 = classDef1.get(gid1);
            if (class1 < class1Count) {
              const class1Record = class1Records[class1];
              const class2 = classDef2.get(gid2);
              const class2Records = class1Record.class2Records;
              if (class2 < class2Records.length) {
                const xAdv1 = class2Records[class2].value1.xAdvance;
                if (xAdv1)
                  positions[i].xAdvance += xAdv1;
              }
            }
          }
        }
        return;
      }
    }
    for (let i = 0;i < len - 1; i++) {
      const info1 = infos[i];
      if (!digest.mayHave(info1.glyphId))
        continue;
      const info2 = infos[i + 1];
      const pos1 = positions[i];
      const pos2 = positions[i + 1];
      applyKerningDirect(lookup, info1.glyphId, info2.glyphId, pos1, pos2);
    }
    return;
  }
  const skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  const nextNonSkip = buildNextNonSkipArray(skip, len);
  for (let i = 0;i < len - 1; i++) {
    if (skip[i])
      continue;
    const j = nextNonSkip[i];
    if (j < 0)
      break;
    const info1 = infos[i];
    if (!digest.mayHave(info1.glyphId))
      continue;
    const info2 = infos[j];
    const pos1 = positions[i];
    const pos2 = positions[j];
    applyKerningDirect(lookup, info1.glyphId, info2.glyphId, pos1, pos2);
  }
}
function applyCursivePosLookup(font, buffer, lookup, hasMarks) {
  const infos = buffer.infos;
  const positions = buffer.positions;
  const len = infos.length;
  const digest = lookup.digest;
  const subtables = lookup.subtables;
  const applyCursive = (i, j) => {
    const info1 = infos[i];
    const info2 = infos[j];
    if (!digest.mayHave(info1.glyphId) && !digest.mayHave(info2.glyphId))
      return;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const exitIndex = subtable.coverage.get(info1.glyphId);
      const entryIndex = subtable.coverage.get(info2.glyphId);
      if (exitIndex === null || entryIndex === null)
        continue;
      const exitRecord = subtable.entryExitRecords[exitIndex];
      const entryRecord = subtable.entryExitRecords[entryIndex];
      if (!exitRecord?.exitAnchor || !entryRecord?.entryAnchor)
        continue;
      const exitAnchor = exitRecord.exitAnchor;
      const entryAnchor = entryRecord.entryAnchor;
      const pos2 = positions[j];
      if (pos2) {
        pos2.yOffset = exitAnchor.yCoordinate - entryAnchor.yCoordinate;
      }
      break;
    }
  };
  const needsSkip = hasMarks && lookup.flag !== 0 && font.gdef !== null;
  if (!needsSkip) {
    for (let i = 0;i < len - 1; i++) {
      applyCursive(i, i + 1);
    }
    return;
  }
  const skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  const nextNonSkip = buildNextNonSkipArray(skip, len);
  for (let i = 0;i < len - 1; i++) {
    if (skip[i])
      continue;
    const j = nextNonSkip[i];
    if (j < 0)
      break;
    applyCursive(i, j);
  }
}
function applyMarkBasePosLookup(font, buffer, lookup, glyphClassCache, baseIndexArray) {
  const digest = lookup.digest;
  const infos = buffer.infos;
  const positions = buffer.positions;
  const subtables = lookup.subtables;
  for (let i = 0;i < infos.length; i++) {
    const markInfo = infos[i];
    if (!markInfo)
      continue;
    if (!digest.mayHave(markInfo.glyphId))
      continue;
    if (getCachedGlyphClass(font, markInfo.glyphId, glyphClassCache) !== 3 /* Mark */)
      continue;
    const baseIndex = baseIndexArray[i];
    if (baseIndex < 0)
      continue;
    const baseInfo = infos[baseIndex];
    if (!baseInfo)
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const markCoverageIndex = subtable.markCoverage.get(markInfo.glyphId);
      const baseCoverageIndex = subtable.baseCoverage.get(baseInfo.glyphId);
      if (markCoverageIndex === null || baseCoverageIndex === null)
        continue;
      const markRecord = subtable.markArray.markRecords[markCoverageIndex];
      const baseRecord = subtable.baseArray[baseCoverageIndex];
      if (!markRecord || !baseRecord)
        continue;
      const baseAnchor = baseRecord.baseAnchors[markRecord.markClass];
      if (!baseAnchor)
        continue;
      const markAnchor = markRecord.markAnchor;
      const markPos = positions[i];
      const basePos = positions[baseIndex];
      if (!markPos || !basePos)
        continue;
      markPos.xOffset = baseAnchor.xCoordinate - markAnchor.xCoordinate + basePos.xOffset;
      markPos.yOffset = baseAnchor.yCoordinate - markAnchor.yCoordinate + basePos.yOffset;
      markPos.xAdvance = 0;
      markPos.yAdvance = 0;
      break;
    }
  }
}
function applyMarkLigaturePosLookup(font, buffer, lookup, glyphClassCache, baseIndexArray) {
  const digest = lookup.digest;
  const infos = buffer.infos;
  const positions = buffer.positions;
  const subtables = lookup.subtables;
  for (let i = 0;i < infos.length; i++) {
    const markInfo = infos[i];
    if (!markInfo)
      continue;
    if (!digest.mayHave(markInfo.glyphId))
      continue;
    if (getCachedGlyphClass(font, markInfo.glyphId, glyphClassCache) !== 3 /* Mark */)
      continue;
    const ligIndex = baseIndexArray[i];
    if (ligIndex < 0)
      continue;
    const ligInfo = infos[ligIndex];
    if (!ligInfo)
      continue;
    if (getCachedGlyphClass(font, ligInfo.glyphId, glyphClassCache) !== 2 /* Ligature */)
      continue;
    let componentIndex = 0;
    for (let j = ligIndex + 1;j < i; j++) {
      const midInfo = infos[j];
      if (midInfo && getCachedGlyphClass(font, midInfo.glyphId, glyphClassCache) === 3 /* Mark */) {
        componentIndex++;
      }
    }
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const markCoverageIndex = subtable.markCoverage.get(markInfo.glyphId);
      const ligCoverageIndex = subtable.ligatureCoverage.get(ligInfo.glyphId);
      if (markCoverageIndex === null || ligCoverageIndex === null)
        continue;
      const markRecord = subtable.markArray.markRecords[markCoverageIndex];
      const ligAttach = subtable.ligatureArray[ligCoverageIndex];
      if (!markRecord || !ligAttach)
        continue;
      const compIdx = Math.min(componentIndex, ligAttach.componentRecords.length - 1);
      const component = ligAttach.componentRecords[compIdx];
      if (!component)
        continue;
      const ligAnchor = component.ligatureAnchors[markRecord.markClass];
      if (!ligAnchor)
        continue;
      const markAnchor = markRecord.markAnchor;
      const markPos = positions[i];
      const ligPos = positions[ligIndex];
      if (!markPos || !ligPos)
        continue;
      markPos.xOffset = ligAnchor.xCoordinate - markAnchor.xCoordinate + ligPos.xOffset;
      markPos.yOffset = ligAnchor.yCoordinate - markAnchor.yCoordinate + ligPos.yOffset;
      markPos.xAdvance = 0;
      markPos.yAdvance = 0;
      break;
    }
  }
}
function applyMarkMarkPosLookup(font, buffer, lookup, glyphClassCache) {
  const digest = lookup.digest;
  const infos = buffer.infos;
  const positions = buffer.positions;
  const subtables = lookup.subtables;
  for (let i = 0;i < infos.length; i++) {
    const mark1Info = infos[i];
    if (!mark1Info)
      continue;
    if (!digest.mayHave(mark1Info.glyphId))
      continue;
    if (getCachedGlyphClass(font, mark1Info.glyphId, glyphClassCache) !== 3 /* Mark */)
      continue;
    let mark2Index = -1;
    if (i > 0) {
      const prevInfo = infos[i - 1];
      if (prevInfo) {
        const prevClass = getCachedGlyphClass(font, prevInfo.glyphId, glyphClassCache);
        if (prevClass === 3 /* Mark */) {
          mark2Index = i - 1;
        }
      }
    }
    if (mark2Index < 0)
      continue;
    const mark2Info = infos[mark2Index];
    if (!mark2Info)
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      const mark1CoverageIndex = subtable.mark1Coverage.get(mark1Info.glyphId);
      const mark2CoverageIndex = subtable.mark2Coverage.get(mark2Info.glyphId);
      if (mark1CoverageIndex === null || mark2CoverageIndex === null)
        continue;
      const mark1Record = subtable.mark1Array.markRecords[mark1CoverageIndex];
      const mark2Record = subtable.mark2Array[mark2CoverageIndex];
      if (!mark1Record || !mark2Record)
        continue;
      const mark2Anchor = mark2Record.mark2Anchors[mark1Record.markClass];
      if (!mark2Anchor)
        continue;
      const mark1Anchor = mark1Record.markAnchor;
      const mark1Pos = positions[i];
      const mark2Pos = positions[mark2Index];
      if (!mark1Pos || !mark2Pos)
        continue;
      mark1Pos.xOffset = mark2Anchor.xCoordinate - mark1Anchor.xCoordinate + mark2Pos.xOffset;
      mark1Pos.yOffset = mark2Anchor.yCoordinate - mark1Anchor.yCoordinate + mark2Pos.yOffset;
      break;
    }
  }
}
function applyContextPosLookup(font, buffer, lookup, plan, glyphClassCache, baseIndexArray, hasMarks) {
  const infos = buffer.infos;
  const len = infos.length;
  const digest = lookup.digest;
  const subtables = lookup.subtables;
  let skip = null;
  if (lookup.flag !== 0 && font.gdef !== null) {
    skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  }
  for (let i = 0;i < len; i++) {
    const info = infos[i];
    if (!info)
      continue;
    if (skip?.[i])
      continue;
    if (!digest.mayHave(info.glyphId))
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      let matched = false;
      let lookupRecords = [];
      if (subtable.format === 1) {
        const result = matchContextPosFormat1(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 2) {
        const result = matchContextPosFormat2(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 3) {
        if (matchContextPosFormat3(font, buffer, i, subtable, lookup.flag)) {
          matched = true;
          lookupRecords = subtable.lookupRecords;
        }
      }
      if (matched) {
        applyNestedPosLookups(font, buffer, i, lookupRecords, plan, glyphClassCache, baseIndexArray, hasMarks);
        break;
      }
    }
  }
}
function applyChainingContextPosLookup(font, buffer, lookup, plan, glyphClassCache, baseIndexArray, hasMarks) {
  const infos = buffer.infos;
  const len = infos.length;
  const digest = lookup.digest;
  const subtables = lookup.subtables;
  let skip = null;
  if (lookup.flag !== 0 && font.gdef !== null) {
    skip = precomputeSkipMarkers(font, buffer, lookup.flag);
  }
  for (let i = 0;i < len; i++) {
    const info = infos[i];
    if (!info)
      continue;
    if (skip?.[i])
      continue;
    if (!digest.mayHave(info.glyphId))
      continue;
    for (let s = 0;s < subtables.length; s++) {
      const subtable = subtables[s];
      let matched = false;
      let lookupRecords = [];
      if (subtable.format === 1) {
        const result = matchChainingContextPosFormat1(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 2) {
        const result = matchChainingContextPosFormat2(font, buffer, i, subtable, lookup.flag);
        if (result) {
          matched = true;
          lookupRecords = result;
        }
      } else if (subtable.format === 3) {
        if (matchChainingContextPosFormat3(font, buffer, i, subtable, lookup.flag)) {
          matched = true;
          lookupRecords = subtable.lookupRecords;
        }
      }
      if (matched) {
        applyNestedPosLookups(font, buffer, i, lookupRecords, plan, glyphClassCache, baseIndexArray, hasMarks);
        break;
      }
    }
  }
}
function matchContextPosFormat1(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const ruleSet = subtable.ruleSets[coverageIndex];
  if (!ruleSet)
    return null;
  for (let r = 0;r < ruleSet.length; r++) {
    const rule = ruleSet[r];
    if (matchGlyphSequence(font, buffer, startIndex + 1, rule.inputSequence, lookupFlag)) {
      return rule.lookupRecords;
    }
  }
  return null;
}
function matchContextPosFormat2(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const firstClass = subtable.classDef.get(firstGlyph);
  const classRuleSet = subtable.classRuleSets[firstClass];
  if (!classRuleSet)
    return null;
  for (let r = 0;r < classRuleSet.length; r++) {
    const rule = classRuleSet[r];
    if (matchClassSequence(font, buffer, startIndex + 1, rule.inputClasses, subtable.classDef, lookupFlag)) {
      return rule.lookupRecords;
    }
  }
  return null;
}
function matchContextPosFormat3(font, buffer, startIndex, subtable, lookupFlag) {
  const infos = buffer.infos;
  const coverages = subtable.coverages;
  let pos = startIndex;
  for (let c = 0;c < coverages.length; c++) {
    const coverage = coverages[c];
    while (pos < infos.length && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {
      pos++;
    }
    if (pos >= infos.length)
      return false;
    if (coverage.get(infos[pos]?.glyphId) === null)
      return false;
    pos++;
  }
  return true;
}
function matchChainingContextPosFormat1(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const chainRuleSet = subtable.chainRuleSets[coverageIndex];
  if (!chainRuleSet)
    return null;
  for (let r = 0;r < chainRuleSet.length; r++) {
    const rule = chainRuleSet[r];
    if (!matchGlyphSequenceBackward(font, buffer, startIndex - 1, rule.backtrackSequence, lookupFlag)) {
      continue;
    }
    if (!matchGlyphSequence(font, buffer, startIndex + 1, rule.inputSequence, lookupFlag)) {
      continue;
    }
    let inputEnd = startIndex + 1;
    for (let i = 0;i < rule.inputSequence.length; i++) {
      while (inputEnd < buffer.infos.length && shouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)) {
        inputEnd++;
      }
      inputEnd++;
    }
    if (!matchGlyphSequence(font, buffer, inputEnd, rule.lookaheadSequence, lookupFlag)) {
      continue;
    }
    return rule.lookupRecords;
  }
  return null;
}
function matchChainingContextPosFormat2(font, buffer, startIndex, subtable, lookupFlag) {
  const firstGlyph = buffer.infos[startIndex]?.glyphId;
  const coverageIndex = subtable.coverage.get(firstGlyph);
  if (coverageIndex === null)
    return null;
  const firstClass = subtable.inputClassDef.get(firstGlyph);
  const chainClassRuleSet = subtable.chainClassRuleSets[firstClass];
  if (!chainClassRuleSet)
    return null;
  for (let r = 0;r < chainClassRuleSet.length; r++) {
    const rule = chainClassRuleSet[r];
    if (!matchClassSequenceBackward(font, buffer, startIndex - 1, rule.backtrackClasses, subtable.backtrackClassDef, lookupFlag)) {
      continue;
    }
    if (!matchClassSequence(font, buffer, startIndex + 1, rule.inputClasses, subtable.inputClassDef, lookupFlag)) {
      continue;
    }
    const infos = buffer.infos;
    let inputEnd = startIndex + 1;
    for (let i = 0;i < rule.inputClasses.length; i++) {
      while (inputEnd < infos.length && shouldSkipGlyph(font, infos[inputEnd]?.glyphId, lookupFlag)) {
        inputEnd++;
      }
      inputEnd++;
    }
    if (!matchClassSequence(font, buffer, inputEnd, rule.lookaheadClasses, subtable.lookaheadClassDef, lookupFlag)) {
      continue;
    }
    return rule.lookupRecords;
  }
  return null;
}
function matchChainingContextPosFormat3(font, buffer, startIndex, subtable, lookupFlag) {
  const infos = buffer.infos;
  let backtrackPos = startIndex - 1;
  const backtrackCoverages = subtable.backtrackCoverages;
  for (let b = 0;b < backtrackCoverages.length; b++) {
    const coverage = backtrackCoverages[b];
    while (backtrackPos >= 0 && shouldSkipGlyph(font, infos[backtrackPos]?.glyphId, lookupFlag)) {
      backtrackPos--;
    }
    if (backtrackPos < 0)
      return false;
    if (coverage.get(infos[backtrackPos]?.glyphId) === null)
      return false;
    backtrackPos--;
  }
  let inputPos = startIndex;
  const inputCoverages = subtable.inputCoverages;
  for (let i = 0;i < inputCoverages.length; i++) {
    const coverage = inputCoverages[i];
    while (inputPos < infos.length && shouldSkipGlyph(font, infos[inputPos]?.glyphId, lookupFlag)) {
      inputPos++;
    }
    if (inputPos >= infos.length)
      return false;
    if (coverage.get(infos[inputPos]?.glyphId) === null)
      return false;
    inputPos++;
  }
  let lookaheadPos = inputPos;
  const lookaheadCoverages = subtable.lookaheadCoverages;
  for (let l = 0;l < lookaheadCoverages.length; l++) {
    const coverage = lookaheadCoverages[l];
    while (lookaheadPos < infos.length && shouldSkipGlyph(font, infos[lookaheadPos]?.glyphId, lookupFlag)) {
      lookaheadPos++;
    }
    if (lookaheadPos >= infos.length)
      return false;
    if (coverage.get(infos[lookaheadPos]?.glyphId) === null)
      return false;
    lookaheadPos++;
  }
  return true;
}
function applyNestedPosLookups(font, buffer, startIndex, lookupRecords, plan, glyphClassCache, baseIndexArray, hasMarks) {
  const len = lookupRecords.length;
  if (len === 0)
    return;
  if (len === 1) {
    const record = lookupRecords[0];
    const lookupEntry = plan.gposLookupMap.get(record.lookupListIndex);
    if (!lookupEntry)
      return;
    const pos = startIndex + record.sequenceIndex;
    if (pos >= buffer.infos.length)
      return;
    applyGposLookup(font, buffer, lookupEntry.lookup, plan, glyphClassCache, baseIndexArray, hasMarks);
    return;
  }
  const applied = new Uint8Array(len);
  for (let round2 = 0;round2 < len; round2++) {
    let maxIdx = -1;
    let maxSeq = -1;
    for (let i = 0;i < len; i++) {
      if (applied[i])
        continue;
      const seq = lookupRecords[i].sequenceIndex;
      if (seq > maxSeq) {
        maxSeq = seq;
        maxIdx = i;
      }
    }
    if (maxIdx < 0)
      break;
    applied[maxIdx] = 1;
    const record = lookupRecords[maxIdx];
    const lookupEntry = plan.gposLookupMap.get(record.lookupListIndex);
    if (!lookupEntry)
      continue;
    const pos = startIndex + record.sequenceIndex;
    if (pos >= buffer.infos.length)
      continue;
    applyGposLookup(font, buffer, lookupEntry.lookup, plan, glyphClassCache, baseIndexArray, hasMarks);
  }
}
function matchGlyphSequence(font, buffer, startPos, glyphs, lookupFlag) {
  let pos = startPos;
  for (let g = 0;g < glyphs.length; g++) {
    const glyph2 = glyphs[g];
    while (pos < buffer.infos.length && shouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)) {
      pos++;
    }
    if (pos >= buffer.infos.length)
      return false;
    if (buffer.infos[pos]?.glyphId !== glyph2)
      return false;
    pos++;
  }
  return true;
}
function matchGlyphSequenceBackward(font, buffer, startPos, glyphs, lookupFlag) {
  const infos = buffer.infos;
  let pos = startPos;
  for (let g = 0;g < glyphs.length; g++) {
    const glyph2 = glyphs[g];
    while (pos >= 0 && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {
      pos--;
    }
    if (pos < 0)
      return false;
    if (infos[pos]?.glyphId !== glyph2)
      return false;
    pos--;
  }
  return true;
}
function matchClassSequence(font, buffer, startPos, classes, classDef, lookupFlag) {
  const infos = buffer.infos;
  let pos = startPos;
  for (let c = 0;c < classes.length; c++) {
    const cls = classes[c];
    while (pos < infos.length && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {
      pos++;
    }
    if (pos >= infos.length)
      return false;
    if (classDef.get(infos[pos]?.glyphId) !== cls)
      return false;
    pos++;
  }
  return true;
}
function matchClassSequenceBackward(font, buffer, startPos, classes, classDef, lookupFlag) {
  const infos = buffer.infos;
  let pos = startPos;
  for (let c = 0;c < classes.length; c++) {
    const cls = classes[c];
    while (pos >= 0 && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {
      pos--;
    }
    if (pos < 0)
      return false;
    if (classDef.get(infos[pos]?.glyphId) !== cls)
      return false;
    pos--;
  }
  return true;
}
function shouldSkipGlyph(font, glyphId, lookupFlag) {
  if ((lookupFlag & 14) === 0 && (lookupFlag & 65280) === 0)
    return false;
  const gdef = font.gdef;
  if (!gdef)
    return false;
  const glyphClass = getGlyphClass2(gdef, glyphId);
  if (lookupFlag & LookupFlag.IgnoreBaseGlyphs && glyphClass === 1 /* Base */)
    return true;
  if (lookupFlag & LookupFlag.IgnoreLigatures && glyphClass === 2 /* Ligature */)
    return true;
  if (lookupFlag & LookupFlag.IgnoreMarks && glyphClass === 3 /* Mark */)
    return true;
  const markAttachmentType = getMarkAttachmentType(lookupFlag);
  if (markAttachmentType !== 0 && glyphClass === 3 /* Mark */) {
    const glyphMarkClass = gdef.markAttachClassDef.get(glyphId);
    if (glyphMarkClass !== markAttachmentType)
      return true;
  }
  return false;
}
function applyMorx(font, buffer) {
  const morx = font.morx;
  if (!morx)
    return;
  const chains = morx.chains;
  for (let c = 0;c < chains.length; c++) {
    const chain = chains[c];
    const chainSubtables = chain.subtables;
    for (let s = 0;s < chainSubtables.length; s++) {
      const subtable = chainSubtables[s];
      if ((chain.defaultFlags & subtable.subFeatureFlags) === 0)
        continue;
      switch (subtable.type) {
        case 4 /* NonContextual */: {
          const infos = buffer.infos;
          for (let i = 0;i < infos.length; i++) {
            const info = infos[i];
            const replacement = applyNonContextual(subtable, info.glyphId);
            if (replacement !== null) {
              info.glyphId = replacement;
            }
          }
          break;
        }
        case 0 /* Rearrangement */:
          processRearrangement(subtable, buffer.infos);
          break;
        case 1 /* Contextual */:
          processContextual(subtable, buffer.infos);
          break;
        case 2 /* Ligature */: {
          const newInfos = processLigature(subtable, buffer.infos);
          if (newInfos.length !== buffer.infos.length) {
            buffer.initFromInfos(newInfos);
          }
          break;
        }
        case 5 /* Insertion */: {
          const newInfos = processInsertion(subtable, buffer.infos);
          if (newInfos.length !== buffer.infos.length) {
            buffer.initFromInfos(newInfos);
          }
          break;
        }
      }
    }
  }
}
// reference/text-shaper/src/unicode/bidi/brackets.gen.ts
var brackets_gen_default = {
  pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
  canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
};

// reference/text-shaper/src/unicode/bidi/parse-character-map.ts
function parseCharacterMap(encodedString, includeReverse) {
  const radix = 36;
  let lastCode = 0;
  const map = new Map;
  const reverseMap = includeReverse ? new Map : null;
  let prevPair = "";
  function visit(entry) {
    if (entry.indexOf("+") !== -1) {
      for (let i = +entry;i--; ) {
        visit(prevPair);
      }
    } else {
      prevPair = entry;
      const parts = entry.split(">");
      const aStr = parts[0] ?? "";
      const bStr = parts[1] ?? "";
      lastCode += parseInt(aStr, radix);
      const a = String.fromCodePoint(lastCode);
      lastCode += parseInt(bStr, radix);
      const b = String.fromCodePoint(lastCode);
      map.set(a, b);
      if (reverseMap) {
        reverseMap.set(b, a);
      }
    }
  }
  encodedString.split(",").forEach(visit);
  return { map, reverseMap };
}

// reference/text-shaper/src/unicode/bidi/brackets.ts
var openToClose = null;
var closeToOpen = null;
var canonical = null;
function parse() {
  if (!openToClose) {
    const { map, reverseMap } = parseCharacterMap(brackets_gen_default.pairs, true);
    openToClose = map;
    closeToOpen = reverseMap;
    canonical = parseCharacterMap(brackets_gen_default.canonical, false).map;
  }
}
function openingToClosingBracket(char2) {
  parse();
  return openToClose?.get(char2) || null;
}
function closingToOpeningBracket(char2) {
  parse();
  return closeToOpen?.get(char2) || null;
}
function getCanonicalBracket(char2) {
  parse();
  return canonical?.get(char2) || null;
}
// reference/text-shaper/src/unicode/bidi/char-types.gen.ts
var char_types_gen_default = {
  R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
  EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
  ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
  ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
  AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
  CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
  B: "a,3,f+2,2v,690",
  S: "9,2,k",
  WS: "c,k,4f4,1vk+a,u,1j,335",
  ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
  BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
  NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
  AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
  LRO: "6ct",
  RLO: "6cu",
  LRE: "6cq",
  RLE: "6cr",
  PDF: "6cs",
  LRI: "6ee",
  RLI: "6ef",
  FSI: "6eg",
  PDI: "6eh"
};

// reference/text-shaper/src/unicode/bidi/char-types.ts
var TYPES = {};
var TYPES_TO_NAMES = {};
TYPES.L = 1;
TYPES_TO_NAMES[1] = "L";
Object.keys(char_types_gen_default).forEach((type, i) => {
  TYPES[type] = 1 << i + 1;
  const typeVal = TYPES[type];
  if (typeVal !== undefined) {
    TYPES_TO_NAMES[typeVal] = type;
  }
});
Object.freeze(TYPES);
function getType(name) {
  return TYPES[name] ?? 0;
}
var ISOLATE_INIT_TYPES = getType("LRI") | getType("RLI") | getType("FSI");
var STRONG_TYPES = getType("L") | getType("R") | getType("AL");
var NEUTRAL_ISOLATE_TYPES = getType("B") | getType("S") | getType("WS") | getType("ON") | getType("FSI") | getType("LRI") | getType("RLI") | getType("PDI");
var BN_LIKE_TYPES = getType("BN") | getType("RLE") | getType("LRE") | getType("RLO") | getType("LRO") | getType("PDF");
var TRAILING_TYPES = getType("S") | getType("WS") | getType("B") | ISOLATE_INIT_TYPES | getType("PDI") | BN_LIKE_TYPES;
var map = null;
function parseData() {
  if (!map) {
    map = new Map;
    let start = 0;
    for (const type in char_types_gen_default) {
      if (Object.hasOwn(char_types_gen_default, type)) {
        const segments = char_types_gen_default[type];
        let temp = "";
        let end = 0;
        let state = false;
        let lastCode = 0;
        for (let i = 0;i <= segments.length + 1; i += 1) {
          const char2 = segments[i];
          if (char2 !== "," && i !== segments.length) {
            if (char2 === "+") {
              state = true;
              lastCode = start = lastCode + parseInt(temp, 36);
              temp = "";
            } else {
              temp += char2;
            }
          } else {
            if (!state) {
              lastCode = start = lastCode + parseInt(temp, 36);
              end = start;
            } else {
              end = start + parseInt(temp, 36);
            }
            state = false;
            temp = "";
            lastCode = end;
            const typeVal = getType(type);
            for (let j = start;j < end + 1; j += 1) {
              map.set(j, typeVal);
            }
          }
        }
      }
    }
  }
}
function getBidiCharType(char2) {
  parseData();
  const codepoint = char2.codePointAt(0);
  if (codepoint === undefined)
    return getType("L");
  return map?.get(codepoint) ?? getType("L");
}
// reference/text-shaper/src/unicode/bidi/embedding-levels.ts
var TYPE_L = TYPES.L ?? 1;
var TYPE_R = TYPES.R ?? 2;
var TYPE_EN = TYPES.EN ?? 4;
var TYPE_ES = TYPES.ES ?? 8;
var TYPE_ET = TYPES.ET ?? 16;
var TYPE_AN = TYPES.AN ?? 32;
var TYPE_CS = TYPES.CS ?? 64;
var TYPE_B = TYPES.B ?? 128;
var TYPE_S = TYPES.S ?? 256;
var TYPE_ON = TYPES.ON ?? 512;
var TYPE_BN = TYPES.BN ?? 1024;
var TYPE_NSM = TYPES.NSM ?? 2048;
var TYPE_AL = TYPES.AL ?? 4096;
var TYPE_LRO = TYPES.LRO ?? 8192;
var TYPE_RLO = TYPES.RLO ?? 16384;
var TYPE_LRE = TYPES.LRE ?? 32768;
var TYPE_RLE = TYPES.RLE ?? 65536;
var TYPE_PDF = TYPES.PDF ?? 131072;
var TYPE_LRI = TYPES.LRI ?? 262144;
var TYPE_RLI = TYPES.RLI ?? 524288;
var TYPE_FSI = TYPES.FSI ?? 1048576;
var TYPE_PDI = TYPES.PDI ?? 2097152;
function getCharType(charTypes, i) {
  return charTypes[i] ?? 0;
}
function getSeqIndex(seqIndices, i) {
  return seqIndices[i] ?? 0;
}
function getCharAt(s, i) {
  return s[i] ?? "";
}
function getEmbeddingLevels(string, baseDirection) {
  const MAX_DEPTH = 125;
  const charTypes = new Uint32Array(string.length);
  for (let i = 0;i < string.length; i++) {
    charTypes[i] = getBidiCharType(getCharAt(string, i));
  }
  const charTypeCounts = new Map;
  function changeCharType(i, type) {
    const oldType = getCharType(charTypes, i);
    charTypes[i] = type;
    charTypeCounts.set(oldType, (charTypeCounts.get(oldType) ?? 0) - 1);
    if (oldType & NEUTRAL_ISOLATE_TYPES) {
      charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) - 1);
    }
    charTypeCounts.set(type, (charTypeCounts.get(type) ?? 0) + 1);
    if (type & NEUTRAL_ISOLATE_TYPES) {
      charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) + 1);
    }
  }
  const embedLevels = new Uint8Array(string.length);
  const isolationPairs = new Map;
  const paragraphs = [];
  let paragraph = null;
  function determineAutoEmbedLevel(start, isFSI) {
    for (let i = start;i < string.length; i++) {
      const charType = getCharType(charTypes, i);
      if (charType & (TYPE_R | TYPE_AL)) {
        return 1;
      }
      if (charType & (TYPE_B | TYPE_L) || isFSI && charType === TYPE_PDI) {
        return 0;
      }
      if (charType & ISOLATE_INIT_TYPES) {
        const pdi = indexOfMatchingPDI(i);
        i = pdi === -1 ? string.length : pdi;
      }
    }
    return 0;
  }
  function indexOfMatchingPDI(isolateStart) {
    let isolationLevel = 1;
    for (let i = isolateStart + 1;i < string.length; i++) {
      const charType = getCharType(charTypes, i);
      if (charType & TYPE_B) {
        break;
      }
      if (charType & TYPE_PDI) {
        if (--isolationLevel === 0) {
          return i;
        }
      } else if (charType & ISOLATE_INIT_TYPES) {
        isolationLevel++;
      }
    }
    return -1;
  }
  for (let i = 0;i < string.length; i++) {
    if (!paragraph) {
      paragraph = {
        start: i,
        end: string.length - 1,
        level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i, false)
      };
      paragraphs.push(paragraph);
    }
    if (getCharType(charTypes, i) & TYPE_B) {
      paragraph.end = i;
      paragraph = null;
    }
  }
  const FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
  const nextEven = (n) => n + (n & 1 ? 1 : 2);
  const nextOdd = (n) => n + (n & 1 ? 2 : 1);
  for (let paraIdx = 0;paraIdx < paragraphs.length; paraIdx++) {
    const para = paragraphs[paraIdx];
    if (!para)
      continue;
    paragraph = para;
    const statusStack = [
      {
        _level: paragraph.level,
        _override: 0,
        _isolate: 0
      }
    ];
    let overflowIsolateCount = 0;
    let overflowEmbeddingCount = 0;
    let validIsolateCount = 0;
    charTypeCounts.clear();
    for (let i = paragraph.start;i <= paragraph.end; i++) {
      let charType = getCharType(charTypes, i);
      let stackTop = statusStack[statusStack.length - 1];
      if (!stackTop)
        continue;
      charTypeCounts.set(charType, (charTypeCounts.get(charType) ?? 0) + 1);
      if (charType & NEUTRAL_ISOLATE_TYPES) {
        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) + 1);
      }
      if (charType & FORMATTING_TYPES) {
        if (charType & (TYPE_RLE | TYPE_LRE)) {
          embedLevels[i] = stackTop._level;
          const level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
          if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
            statusStack.push({
              _level: level,
              _override: 0,
              _isolate: 0
            });
          } else if (!overflowIsolateCount) {
            overflowEmbeddingCount++;
          }
        } else if (charType & (TYPE_RLO | TYPE_LRO)) {
          embedLevels[i] = stackTop._level;
          const level = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
          if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
            statusStack.push({
              _level: level,
              _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
              _isolate: 0
            });
          } else if (!overflowIsolateCount) {
            overflowEmbeddingCount++;
          }
        } else if (charType & ISOLATE_INIT_TYPES) {
          if (charType & TYPE_FSI) {
            charType = determineAutoEmbedLevel(i + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
          }
          embedLevels[i] = stackTop._level;
          if (stackTop._override) {
            changeCharType(i, stackTop._override);
          }
          const level = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
          if (level <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
            validIsolateCount++;
            statusStack.push({
              _level: level,
              _override: 0,
              _isolate: 1,
              _isolInitIndex: i
            });
          } else {
            overflowIsolateCount++;
          }
        } else if (charType & TYPE_PDI) {
          if (overflowIsolateCount > 0) {
            overflowIsolateCount--;
          } else if (validIsolateCount > 0) {
            overflowEmbeddingCount = 0;
            while (statusStack.length > 0) {
              const top2 = statusStack[statusStack.length - 1];
              if (top2?._isolate)
                break;
              statusStack.pop();
            }
            const top = statusStack[statusStack.length - 1];
            const isolInitIndex = top?._isolInitIndex;
            if (isolInitIndex != null) {
              isolationPairs.set(isolInitIndex, i);
              isolationPairs.set(i, isolInitIndex);
            }
            statusStack.pop();
            validIsolateCount--;
          }
          stackTop = statusStack[statusStack.length - 1];
          if (!stackTop)
            continue;
          embedLevels[i] = stackTop._level;
          if (stackTop._override) {
            changeCharType(i, stackTop._override);
          }
        } else if (charType & TYPE_PDF) {
          if (overflowIsolateCount === 0) {
            if (overflowEmbeddingCount > 0) {
              overflowEmbeddingCount--;
            } else if (!stackTop._isolate && statusStack.length > 1) {
              statusStack.pop();
              stackTop = statusStack[statusStack.length - 1];
              if (!stackTop)
                continue;
            }
          }
          embedLevels[i] = stackTop._level;
        } else if (charType & TYPE_B) {
          embedLevels[i] = paragraph.level;
        }
      } else {
        embedLevels[i] = stackTop._level;
        if (stackTop._override && charType !== TYPE_BN) {
          changeCharType(i, stackTop._override);
        }
      }
    }
    const levelRuns = [];
    let currentRun = null;
    for (let i = paragraph.start;i <= paragraph.end; i++) {
      const charType = getCharType(charTypes, i);
      if (!(charType & BN_LIKE_TYPES)) {
        const lvl = embedLevels[i] ?? 0;
        const isIsolInit = !!(charType & ISOLATE_INIT_TYPES);
        const isPDI = charType === TYPE_PDI;
        if (currentRun && lvl === currentRun._level) {
          currentRun._end = i;
          currentRun._endsWithIsolInit = isIsolInit;
        } else {
          currentRun = {
            _start: i,
            _end: i,
            _level: lvl,
            _startsWithPDI: isPDI,
            _endsWithIsolInit: isIsolInit
          };
          levelRuns.push(currentRun);
        }
      }
    }
    const isolatingRunSeqs = [];
    for (let runIdx = 0;runIdx < levelRuns.length; runIdx++) {
      const run = levelRuns[runIdx];
      if (!run)
        continue;
      if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
        currentRun = run;
        const seqRuns = [run];
        while (currentRun?._endsWithIsolInit) {
          const pdiIndex = isolationPairs.get(currentRun._end);
          if (pdiIndex == null)
            break;
          let found = false;
          for (let i = runIdx + 1;i < levelRuns.length; i++) {
            const nextRun = levelRuns[i];
            if (nextRun?._start === pdiIndex) {
              currentRun = nextRun;
              seqRuns.push(nextRun);
              found = true;
              break;
            }
          }
          if (!found)
            break;
        }
        const seqIndices = [];
        for (let i = 0;i < seqRuns.length; i++) {
          const seqRun = seqRuns[i];
          for (let j = seqRun._start;j <= seqRun._end; j++) {
            seqIndices.push(j);
          }
        }
        const firstIdx = seqIndices[0] ?? 0;
        const firstLevel = embedLevels[firstIdx] ?? 0;
        let prevLevel = paragraph.level;
        for (let i = firstIdx - 1;i >= 0; i--) {
          if (!(getCharType(charTypes, i) & BN_LIKE_TYPES)) {
            prevLevel = embedLevels[i] ?? 0;
            break;
          }
        }
        const lastIndex = seqIndices[seqIndices.length - 1] ?? 0;
        const lastLevel = embedLevels[lastIndex] ?? 0;
        let nextLevel = paragraph.level;
        if (!(getCharType(charTypes, lastIndex) & ISOLATE_INIT_TYPES)) {
          for (let i = lastIndex + 1;i <= paragraph.end; i++) {
            if (!(getCharType(charTypes, i) & BN_LIKE_TYPES)) {
              nextLevel = embedLevels[i] ?? 0;
              break;
            }
          }
        }
        isolatingRunSeqs.push({
          _seqIndices: seqIndices,
          _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
          _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
        });
      }
    }
    for (let seqIdx = 0;seqIdx < isolatingRunSeqs.length; seqIdx++) {
      const seq = isolatingRunSeqs[seqIdx];
      const {
        _seqIndices: seqIndices,
        _sosType: sosType,
        _eosType: eosType
      } = seq;
      const firstSeqIdx = seqIndices[0] ?? 0;
      const embedDirection = (embedLevels[firstSeqIdx] ?? 0) & 1 ? TYPE_R : TYPE_L;
      if (charTypeCounts.get(TYPE_NSM)) {
        for (let si = 0;si < seqIndices.length; si++) {
          const i = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, i) & TYPE_NSM) {
            let prevType = sosType;
            for (let sj = si - 1;sj >= 0; sj--) {
              const sjIdx = getSeqIndex(seqIndices, sj);
              if (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) {
                prevType = getCharType(charTypes, sjIdx);
                break;
              }
            }
            changeCharType(i, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
          }
        }
      }
      if (charTypeCounts.get(TYPE_EN)) {
        for (let si = 0;si < seqIndices.length; si++) {
          const i = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, i) & TYPE_EN) {
            for (let sj = si - 1;sj >= -1; sj--) {
              const prevCharType = sj === -1 ? sosType : getCharType(charTypes, getSeqIndex(seqIndices, sj));
              if (prevCharType & STRONG_TYPES) {
                if (prevCharType === TYPE_AL) {
                  changeCharType(i, TYPE_AN);
                }
                break;
              }
            }
          }
        }
      }
      if (charTypeCounts.get(TYPE_AL)) {
        for (let si = 0;si < seqIndices.length; si++) {
          const i = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, i) & TYPE_AL) {
            changeCharType(i, TYPE_R);
          }
        }
      }
      if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
        for (let si = 1;si < seqIndices.length - 1; si++) {
          const i = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, i) & (TYPE_ES | TYPE_CS)) {
            let prevType = 0;
            let nextType = 0;
            for (let sj = si - 1;sj >= 0; sj--) {
              prevType = getCharType(charTypes, getSeqIndex(seqIndices, sj));
              if (!(prevType & BN_LIKE_TYPES))
                break;
            }
            for (let sj = si + 1;sj < seqIndices.length; sj++) {
              nextType = getCharType(charTypes, getSeqIndex(seqIndices, sj));
              if (!(nextType & BN_LIKE_TYPES))
                break;
            }
            if (prevType === nextType && (getCharType(charTypes, i) === TYPE_ES ? prevType === TYPE_EN : prevType & (TYPE_EN | TYPE_AN))) {
              changeCharType(i, prevType);
            }
          }
        }
      }
      if (charTypeCounts.get(TYPE_EN)) {
        for (let si = 0;si < seqIndices.length; si++) {
          const i = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, i) & TYPE_EN) {
            for (let sj = si - 1;sj >= 0; sj--) {
              const sjIdx = getSeqIndex(seqIndices, sj);
              if (!(getCharType(charTypes, sjIdx) & (TYPE_ET | BN_LIKE_TYPES)))
                break;
              changeCharType(sjIdx, TYPE_EN);
            }
            for (si++;si < seqIndices.length; si++) {
              const siIdx = getSeqIndex(seqIndices, si);
              if (!(getCharType(charTypes, siIdx) & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)))
                break;
              if (getCharType(charTypes, siIdx) !== TYPE_EN) {
                changeCharType(siIdx, TYPE_EN);
              }
            }
          }
        }
      }
      if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
        for (let si = 0;si < seqIndices.length; si++) {
          const i = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, i) & (TYPE_ET | TYPE_ES | TYPE_CS)) {
            changeCharType(i, TYPE_ON);
            for (let sj = si - 1;sj >= 0; sj--) {
              const sjIdx = getSeqIndex(seqIndices, sj);
              if (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES))
                break;
              changeCharType(sjIdx, TYPE_ON);
            }
            for (let sj = si + 1;sj < seqIndices.length; sj++) {
              const sjIdx = getSeqIndex(seqIndices, sj);
              if (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES))
                break;
              changeCharType(sjIdx, TYPE_ON);
            }
          }
        }
      }
      if (charTypeCounts.get(TYPE_EN)) {
        let prevStrongType = sosType;
        for (let si = 0;si < seqIndices.length; si++) {
          const i = getSeqIndex(seqIndices, si);
          const type = getCharType(charTypes, i);
          if (type & TYPE_EN) {
            if (prevStrongType === TYPE_L) {
              changeCharType(i, TYPE_L);
            }
          } else if (type & STRONG_TYPES) {
            prevStrongType = type;
          }
        }
      }
      if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
        const R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
        const STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
        const bracketPairs = [];
        const openerStack = [];
        for (let si = 0;si < seqIndices.length; si++) {
          const siIdx = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, siIdx) & NEUTRAL_ISOLATE_TYPES) {
            const char2 = getCharAt(string, siIdx);
            const closingBracket = openingToClosingBracket(char2);
            if (closingBracket !== null) {
              if (openerStack.length < 63) {
                openerStack.push({ char: char2, seqIndex: si });
              } else {
                break;
              }
            } else {
              const oppositeBracket = closingToOpeningBracket(char2);
              if (oppositeBracket !== null) {
                for (let stackIdx = openerStack.length - 1;stackIdx >= 0; stackIdx--) {
                  const opener = openerStack[stackIdx];
                  if (!opener)
                    continue;
                  const stackChar = opener.char;
                  const canonicalChar = getCanonicalBracket(char2);
                  const canonicalStack = getCanonicalBracket(stackChar);
                  if (stackChar === oppositeBracket || canonicalChar && stackChar === closingToOpeningBracket(canonicalChar) || canonicalStack && openingToClosingBracket(canonicalStack) === char2) {
                    bracketPairs.push([opener.seqIndex, si]);
                    openerStack.length = stackIdx;
                    break;
                  }
                }
              }
            }
          }
        }
        bracketPairs.sort((a, b) => a[0] - b[0]);
        for (let pairIdx = 0;pairIdx < bracketPairs.length; pairIdx++) {
          const pair = bracketPairs[pairIdx];
          const [openSeqIdx, closeSeqIdx] = pair;
          let foundStrongType = false;
          let useStrongType = 0;
          for (let si = openSeqIdx + 1;si < closeSeqIdx; si++) {
            const i = getSeqIndex(seqIndices, si);
            const ct = getCharType(charTypes, i);
            if (ct & STRONG_TYPES_FOR_N_STEPS) {
              foundStrongType = true;
              const lr = ct & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
              if (lr === embedDirection) {
                useStrongType = lr;
                break;
              }
            }
          }
          if (foundStrongType && !useStrongType) {
            useStrongType = sosType;
            for (let si = openSeqIdx - 1;si >= 0; si--) {
              const i = getSeqIndex(seqIndices, si);
              const ct = getCharType(charTypes, i);
              if (ct & STRONG_TYPES_FOR_N_STEPS) {
                const lr = ct & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                useStrongType = lr !== embedDirection ? lr : embedDirection;
                break;
              }
            }
          }
          if (useStrongType) {
            charTypes[getSeqIndex(seqIndices, openSeqIdx)] = useStrongType;
            charTypes[getSeqIndex(seqIndices, closeSeqIdx)] = useStrongType;
            if (useStrongType !== embedDirection) {
              for (let si = openSeqIdx + 1;si < seqIndices.length; si++) {
                const siIdx = getSeqIndex(seqIndices, si);
                if (!(getCharType(charTypes, siIdx) & BN_LIKE_TYPES)) {
                  if (getBidiCharType(getCharAt(string, siIdx)) & TYPE_NSM) {
                    charTypes[siIdx] = useStrongType;
                  }
                  break;
                }
              }
              for (let si = closeSeqIdx + 1;si < seqIndices.length; si++) {
                const siIdx = getSeqIndex(seqIndices, si);
                if (!(getCharType(charTypes, siIdx) & BN_LIKE_TYPES)) {
                  if (getBidiCharType(getCharAt(string, siIdx)) & TYPE_NSM) {
                    charTypes[siIdx] = useStrongType;
                  }
                  break;
                }
              }
            }
          }
        }
        for (let si = 0;si < seqIndices.length; si++) {
          const siIdx = getSeqIndex(seqIndices, si);
          if (getCharType(charTypes, siIdx) & NEUTRAL_ISOLATE_TYPES) {
            let niRunStart = si;
            let niRunEnd = si;
            let prevType = sosType;
            for (let si2 = si - 1;si2 >= 0; si2--) {
              const si2Idx = getSeqIndex(seqIndices, si2);
              if (getCharType(charTypes, si2Idx) & BN_LIKE_TYPES) {
                niRunStart = si2;
              } else {
                prevType = getCharType(charTypes, si2Idx) & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                break;
              }
            }
            let nextType = eosType;
            for (let si2 = si + 1;si2 < seqIndices.length; si2++) {
              const si2Idx = getSeqIndex(seqIndices, si2);
              if (getCharType(charTypes, si2Idx) & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                niRunEnd = si2;
              } else {
                nextType = getCharType(charTypes, si2Idx) & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                break;
              }
            }
            for (let sj = niRunStart;sj <= niRunEnd; sj++) {
              charTypes[getSeqIndex(seqIndices, sj)] = prevType === nextType ? prevType : embedDirection;
            }
            si = niRunEnd;
          }
        }
      }
    }
    for (let i = paragraph.start;i <= paragraph.end; i++) {
      const level = embedLevels[i] ?? 0;
      const type = getCharType(charTypes, i);
      if (level & 1) {
        if (type & (TYPE_L | TYPE_EN | TYPE_AN)) {
          embedLevels[i]++;
        }
      } else {
        if (type & TYPE_R) {
          embedLevels[i]++;
        } else if (type & (TYPE_AN | TYPE_EN)) {
          embedLevels[i] += 2;
        }
      }
      if (type & BN_LIKE_TYPES) {
        embedLevels[i] = i === 0 ? paragraph.level : embedLevels[i - 1] ?? paragraph.level;
      }
      if (i === paragraph.end || getBidiCharType(getCharAt(string, i)) & (TYPE_S | TYPE_B)) {
        for (let j = i;j >= 0 && getBidiCharType(getCharAt(string, j)) & TRAILING_TYPES; j--) {
          embedLevels[j] = paragraph.level;
        }
      }
    }
  }
  return {
    levels: embedLevels,
    paragraphs
  };
}
// reference/text-shaper/src/unicode/bidi/mirroring.gen.ts
var mirroring_gen_default = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";

// reference/text-shaper/src/unicode/bidi/mirroring.ts
var mirrorMap = null;
function parse2() {
  if (!mirrorMap) {
    const { map: map2, reverseMap } = parseCharacterMap(mirroring_gen_default, true);
    if (reverseMap) {
      reverseMap.forEach((value, key) => {
        map2.set(key, value);
      });
    }
    mirrorMap = map2;
  }
}
function getMirroredCharacter(char2) {
  parse2();
  return mirrorMap?.get(char2) || null;
}
// reference/text-shaper/src/unicode/bidi/reordering.ts
function getReorderSegments(string, embeddingLevelsResult, start, end) {
  const strLen = string.length;
  const startPos = Math.max(0, start == null ? 0 : +start);
  const endPos = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
  const segments = [];
  for (let i = 0;i < embeddingLevelsResult.paragraphs.length; i++) {
    const paragraph = embeddingLevelsResult.paragraphs[i];
    const lineStart = Math.max(startPos, paragraph.start);
    const lineEnd = Math.min(endPos, paragraph.end);
    if (lineStart < lineEnd) {
      const lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
      for (let i2 = lineEnd;i2 >= lineStart; i2--) {
        const char2 = string[i2];
        if (char2 === undefined)
          break;
        if (!(getBidiCharType(char2) & TRAILING_TYPES))
          break;
        lineLevels[i2 - lineStart] = paragraph.level;
      }
      let maxLevel = paragraph.level;
      let minOddLevel = Infinity;
      for (let i2 = 0;i2 < lineLevels.length; i2++) {
        const level = lineLevels[i2] ?? 0;
        if (level > maxLevel)
          maxLevel = level;
        if (level < minOddLevel)
          minOddLevel = level | 1;
      }
      for (let lvl = maxLevel;lvl >= minOddLevel; lvl--) {
        for (let i2 = 0;i2 < lineLevels.length; i2++) {
          const level = lineLevels[i2] ?? 0;
          if (level >= lvl) {
            const segStart = i2;
            while (i2 + 1 < lineLevels.length) {
              const nextLevel = lineLevels[i2 + 1] ?? 0;
              if (nextLevel < lvl)
                break;
              i2++;
            }
            if (i2 > segStart) {
              segments.push([segStart + lineStart, i2 + lineStart]);
            }
          }
        }
      }
    }
  }
  return segments;
}
function getReorderedIndices(string, embedLevelsResult, start, end) {
  const segments = getReorderSegments(string, embedLevelsResult, start, end);
  const indices = [];
  for (let i = 0;i < string.length; i++) {
    indices[i] = i;
  }
  for (let i = 0;i < segments.length; i++) {
    const segment = segments[i];
    const segStart = segment[0];
    const segEnd = segment[1];
    const slice = indices.slice(segStart, segEnd + 1);
    for (let j = slice.length;j--; ) {
      const val = slice[j];
      if (val !== undefined) {
        indices[segEnd - j] = val;
      }
    }
  }
  return indices;
}
// reference/text-shaper/src/unicode/bidi.ts
function getEmbeddings(text, baseDirection = 4 /* LTR */) {
  const dir = baseDirection === 5 /* RTL */ ? "rtl" : baseDirection === 4 /* LTR */ ? "ltr" : "auto";
  const result = getEmbeddingLevels(text, dir);
  return {
    levels: result.levels,
    paragraphs: result.paragraphs
  };
}
function getVisualOrder(text, result, start = 0, end = text.length) {
  return [...getReorderedIndices(text, result, start, end)];
}
function reorderGlyphs(infos, result) {
  if (infos.length === 0)
    return infos;
  const dummyString = "x".repeat(infos.length);
  const indices = getReorderedIndices(dummyString, result, 0, infos.length);
  const reordered = [];
  for (let i = 0;i < indices.length; i++) {
    const idx = indices[i];
    if (idx < infos.length) {
      const info = infos[idx];
      if (info) {
        reordered.push(info);
      }
    }
  }
  return reordered;
}
function getMirror(codepoint) {
  const char2 = String.fromCodePoint(codepoint);
  const mirrored = getMirroredCharacter(char2);
  return mirrored ? mirrored.codePointAt(0) ?? codepoint : codepoint;
}
function applyMirroring(infos, levels) {
  for (let i = 0;i < infos.length; i++) {
    const info = infos[i];
    const level = levels[i];
    if (level === undefined)
      continue;
    if (level & 1) {
      const mirrored = getMirror(info.codepoint);
      if (mirrored !== info.codepoint) {
        info.codepoint = mirrored;
      }
    }
  }
}
var BidiType = {
  L: 1,
  R: 2,
  EN: 4,
  ES: 8,
  ET: 16,
  AN: 32,
  CS: 64,
  B: 128,
  S: 256,
  WS: 512,
  ON: 1024,
  BN: 2048,
  NSM: 4096,
  AL: 8192,
  LRO: 16384,
  RLO: 32768,
  LRE: 65536,
  RLE: 131072,
  PDF: 262144,
  LRI: 524288,
  RLI: 1048576,
  FSI: 2097152,
  PDI: 4194304
};
function getCharType2(char2) {
  return getBidiCharType(char2);
}
function isRTL(codepoint) {
  const char2 = String.fromCodePoint(codepoint);
  const type = getBidiCharType(char2);
  return (type & (BidiType.R | BidiType.AL)) !== 0;
}
function isLTR(codepoint) {
  const char2 = String.fromCodePoint(codepoint);
  const type = getBidiCharType(char2);
  return (type & BidiType.L) !== 0;
}
function detectDirection(text) {
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    const type = getBidiCharType(char2);
    if (type & BidiType.L)
      return 4 /* LTR */;
    if (type & (BidiType.R | BidiType.AL))
      return 5 /* RTL */;
  }
  return 4 /* LTR */;
}
function processBidi(infos, baseDirection = 4 /* LTR */) {
  if (infos.length === 0) {
    return { infos, levels: new Uint8Array(0) };
  }
  const text = infos.map((i) => String.fromCodePoint(i.codepoint)).join("");
  const result = getEmbeddings(text, baseDirection);
  applyMirroring(infos, result.levels);
  const reordered = reorderGlyphs(infos, result);
  return { infos: reordered, levels: result.levels };
}
// reference/text-shaper/src/unicode/line-break.ts
var LineBreakClass;
((LineBreakClass2) => {
  LineBreakClass2[LineBreakClass2["BK"] = 0] = "BK";
  LineBreakClass2[LineBreakClass2["CR"] = 1] = "CR";
  LineBreakClass2[LineBreakClass2["LF"] = 2] = "LF";
  LineBreakClass2[LineBreakClass2["CM"] = 3] = "CM";
  LineBreakClass2[LineBreakClass2["NL"] = 4] = "NL";
  LineBreakClass2[LineBreakClass2["SG"] = 5] = "SG";
  LineBreakClass2[LineBreakClass2["WJ"] = 6] = "WJ";
  LineBreakClass2[LineBreakClass2["ZW"] = 7] = "ZW";
  LineBreakClass2[LineBreakClass2["GL"] = 8] = "GL";
  LineBreakClass2[LineBreakClass2["SP"] = 9] = "SP";
  LineBreakClass2[LineBreakClass2["ZWJ"] = 10] = "ZWJ";
  LineBreakClass2[LineBreakClass2["B2"] = 11] = "B2";
  LineBreakClass2[LineBreakClass2["BA"] = 12] = "BA";
  LineBreakClass2[LineBreakClass2["BB"] = 13] = "BB";
  LineBreakClass2[LineBreakClass2["HY"] = 14] = "HY";
  LineBreakClass2[LineBreakClass2["CB"] = 15] = "CB";
  LineBreakClass2[LineBreakClass2["CL"] = 16] = "CL";
  LineBreakClass2[LineBreakClass2["CP"] = 17] = "CP";
  LineBreakClass2[LineBreakClass2["EX"] = 18] = "EX";
  LineBreakClass2[LineBreakClass2["IN"] = 19] = "IN";
  LineBreakClass2[LineBreakClass2["NS"] = 20] = "NS";
  LineBreakClass2[LineBreakClass2["OP"] = 21] = "OP";
  LineBreakClass2[LineBreakClass2["QU"] = 22] = "QU";
  LineBreakClass2[LineBreakClass2["IS"] = 23] = "IS";
  LineBreakClass2[LineBreakClass2["NU"] = 24] = "NU";
  LineBreakClass2[LineBreakClass2["PO"] = 25] = "PO";
  LineBreakClass2[LineBreakClass2["PR"] = 26] = "PR";
  LineBreakClass2[LineBreakClass2["SY"] = 27] = "SY";
  LineBreakClass2[LineBreakClass2["AI"] = 28] = "AI";
  LineBreakClass2[LineBreakClass2["AL"] = 29] = "AL";
  LineBreakClass2[LineBreakClass2["CJ"] = 30] = "CJ";
  LineBreakClass2[LineBreakClass2["EB"] = 31] = "EB";
  LineBreakClass2[LineBreakClass2["EM"] = 32] = "EM";
  LineBreakClass2[LineBreakClass2["H2"] = 33] = "H2";
  LineBreakClass2[LineBreakClass2["H3"] = 34] = "H3";
  LineBreakClass2[LineBreakClass2["HL"] = 35] = "HL";
  LineBreakClass2[LineBreakClass2["ID"] = 36] = "ID";
  LineBreakClass2[LineBreakClass2["JL"] = 37] = "JL";
  LineBreakClass2[LineBreakClass2["JV"] = 38] = "JV";
  LineBreakClass2[LineBreakClass2["JT"] = 39] = "JT";
  LineBreakClass2[LineBreakClass2["RI"] = 40] = "RI";
  LineBreakClass2[LineBreakClass2["SA"] = 41] = "SA";
  LineBreakClass2[LineBreakClass2["XX"] = 42] = "XX";
})(LineBreakClass ||= {});
var BreakAction;
((BreakAction2) => {
  BreakAction2[BreakAction2["Direct"] = 0] = "Direct";
  BreakAction2[BreakAction2["Indirect"] = 1] = "Indirect";
  BreakAction2[BreakAction2["CombiningIndirect"] = 2] = "CombiningIndirect";
  BreakAction2[BreakAction2["CombiningProhibited"] = 3] = "CombiningProhibited";
  BreakAction2[BreakAction2["Prohibited"] = 4] = "Prohibited";
  BreakAction2[BreakAction2["Explicit"] = 5] = "Explicit";
})(BreakAction ||= {});
var BreakOpportunity;
((BreakOpportunity2) => {
  BreakOpportunity2[BreakOpportunity2["NoBreak"] = 0] = "NoBreak";
  BreakOpportunity2[BreakOpportunity2["Optional"] = 1] = "Optional";
  BreakOpportunity2[BreakOpportunity2["Mandatory"] = 2] = "Mandatory";
})(BreakOpportunity ||= {});
function getLineBreakClass(cp) {
  if (cp === 10)
    return 2 /* LF */;
  if (cp === 13)
    return 1 /* CR */;
  if (cp === 133)
    return 4 /* NL */;
  if (cp === 11 || cp === 12)
    return 0 /* BK */;
  if (cp === 8232)
    return 0 /* BK */;
  if (cp === 8233)
    return 0 /* BK */;
  if (cp === 8203)
    return 7 /* ZW */;
  if (cp === 8205)
    return 10 /* ZWJ */;
  if (cp === 8288)
    return 6 /* WJ */;
  if (cp === 65279)
    return 6 /* WJ */;
  if (cp === 32)
    return 9 /* SP */;
  if (cp === 160)
    return 8 /* GL */;
  if (cp === 8239)
    return 8 /* GL */;
  if (cp === 8199)
    return 8 /* GL */;
  if (cp === 8209)
    return 8 /* GL */;
  if (cp === 9)
    return 12 /* BA */;
  if (cp >= 8192 && cp <= 8202)
    return 12 /* BA */;
  if (cp >= 768 && cp <= 879)
    return 3 /* CM */;
  if (cp >= 1155 && cp <= 1161)
    return 3 /* CM */;
  if (cp >= 1425 && cp <= 1469)
    return 3 /* CM */;
  if (cp >= 1471 && cp <= 1479)
    return 3 /* CM */;
  if (cp >= 1552 && cp <= 1562)
    return 3 /* CM */;
  if (cp >= 1611 && cp <= 1631)
    return 3 /* CM */;
  if (cp >= 1648 && cp <= 1648)
    return 3 /* CM */;
  if (cp >= 1750 && cp <= 1773)
    return 3 /* CM */;
  if (cp >= 1809 && cp <= 1809)
    return 3 /* CM */;
  if (cp >= 1840 && cp <= 1866)
    return 3 /* CM */;
  if (cp >= 1958 && cp <= 1968)
    return 3 /* CM */;
  if (cp >= 2070 && cp <= 2083)
    return 3 /* CM */;
  if (cp >= 2085 && cp <= 2093)
    return 3 /* CM */;
  if (cp >= 2137 && cp <= 2139)
    return 3 /* CM */;
  if (cp >= 2259 && cp <= 2273)
    return 3 /* CM */;
  if (cp >= 2275 && cp <= 2307)
    return 3 /* CM */;
  if (cp >= 2362 && cp <= 2364)
    return 3 /* CM */;
  if (cp >= 2366 && cp <= 2383)
    return 3 /* CM */;
  if (cp >= 2385 && cp <= 2391)
    return 3 /* CM */;
  if (cp >= 2402 && cp <= 2403)
    return 3 /* CM */;
  if (cp >= 2433 && cp <= 2435)
    return 3 /* CM */;
  if (cp === 2492)
    return 3 /* CM */;
  if (cp >= 2494 && cp <= 2509)
    return 3 /* CM */;
  if (cp >= 2519 && cp <= 2519)
    return 3 /* CM */;
  if (cp >= 2530 && cp <= 2531)
    return 3 /* CM */;
  if (cp >= 2558 && cp <= 2558)
    return 3 /* CM */;
  if (cp >= 2561 && cp <= 2563)
    return 3 /* CM */;
  if (cp >= 2620 && cp <= 2641)
    return 3 /* CM */;
  if (cp >= 2672 && cp <= 2673)
    return 3 /* CM */;
  if (cp >= 2677 && cp <= 2677)
    return 3 /* CM */;
  if (cp >= 2689 && cp <= 2691)
    return 3 /* CM */;
  if (cp >= 2748 && cp <= 2765)
    return 3 /* CM */;
  if (cp >= 2786 && cp <= 2787)
    return 3 /* CM */;
  if (cp >= 2810 && cp <= 2815)
    return 3 /* CM */;
  if (cp >= 2817 && cp <= 2819)
    return 3 /* CM */;
  if (cp >= 2876 && cp <= 2903)
    return 3 /* CM */;
  if (cp >= 2914 && cp <= 2915)
    return 3 /* CM */;
  if (cp >= 2946 && cp <= 2946)
    return 3 /* CM */;
  if (cp >= 3006 && cp <= 3021)
    return 3 /* CM */;
  if (cp >= 3031 && cp <= 3031)
    return 3 /* CM */;
  if (cp >= 3072 && cp <= 3076)
    return 3 /* CM */;
  if (cp >= 3134 && cp <= 3158)
    return 3 /* CM */;
  if (cp >= 3170 && cp <= 3171)
    return 3 /* CM */;
  if (cp >= 3201 && cp <= 3203)
    return 3 /* CM */;
  if (cp >= 3260 && cp <= 3286)
    return 3 /* CM */;
  if (cp >= 3298 && cp <= 3299)
    return 3 /* CM */;
  if (cp >= 3328 && cp <= 3331)
    return 3 /* CM */;
  if (cp >= 3387 && cp <= 3405)
    return 3 /* CM */;
  if (cp >= 3415 && cp <= 3415)
    return 3 /* CM */;
  if (cp >= 3426 && cp <= 3427)
    return 3 /* CM */;
  if (cp >= 3457 && cp <= 3459)
    return 3 /* CM */;
  if (cp >= 3530 && cp <= 3571)
    return 3 /* CM */;
  if (cp >= 3864 && cp <= 3865)
    return 3 /* CM */;
  if (cp >= 3893 && cp <= 3897)
    return 3 /* CM */;
  if (cp >= 3902 && cp <= 3903)
    return 3 /* CM */;
  if (cp >= 3953 && cp <= 3972)
    return 3 /* CM */;
  if (cp >= 3974 && cp <= 3975)
    return 3 /* CM */;
  if (cp >= 3981 && cp <= 4028)
    return 3 /* CM */;
  if (cp === 4038)
    return 3 /* CM */;
  if (cp >= 5906 && cp <= 5908)
    return 3 /* CM */;
  if (cp >= 5938 && cp <= 5940)
    return 3 /* CM */;
  if (cp >= 5970 && cp <= 5971)
    return 3 /* CM */;
  if (cp >= 6002 && cp <= 6003)
    return 3 /* CM */;
  if (cp >= 6068 && cp <= 6099)
    return 3 /* CM */;
  if (cp === 6109)
    return 3 /* CM */;
  if (cp >= 6155 && cp <= 6157)
    return 3 /* CM */;
  if (cp === 6159)
    return 3 /* CM */;
  if (cp >= 6277 && cp <= 6278)
    return 3 /* CM */;
  if (cp === 6313)
    return 3 /* CM */;
  if (cp >= 6432 && cp <= 6459)
    return 3 /* CM */;
  if (cp >= 6679 && cp <= 6683)
    return 3 /* CM */;
  if (cp >= 6741 && cp <= 6783)
    return 3 /* CM */;
  if (cp >= 6832 && cp <= 6862)
    return 3 /* CM */;
  if (cp >= 6912 && cp <= 6916)
    return 3 /* CM */;
  if (cp >= 6964 && cp <= 6980)
    return 3 /* CM */;
  if (cp >= 7019 && cp <= 7027)
    return 3 /* CM */;
  if (cp >= 7040 && cp <= 7042)
    return 3 /* CM */;
  if (cp >= 7073 && cp <= 7085)
    return 3 /* CM */;
  if (cp >= 7142 && cp <= 7155)
    return 3 /* CM */;
  if (cp >= 7204 && cp <= 7223)
    return 3 /* CM */;
  if (cp >= 7376 && cp <= 7417)
    return 3 /* CM */;
  if (cp >= 7616 && cp <= 7679)
    return 3 /* CM */;
  if (cp >= 8400 && cp <= 8432)
    return 3 /* CM */;
  if (cp >= 11503 && cp <= 11505)
    return 3 /* CM */;
  if (cp === 11647)
    return 3 /* CM */;
  if (cp >= 11744 && cp <= 11775)
    return 3 /* CM */;
  if (cp >= 12330 && cp <= 12335)
    return 3 /* CM */;
  if (cp >= 12441 && cp <= 12442)
    return 3 /* CM */;
  if (cp >= 42607 && cp <= 42610)
    return 3 /* CM */;
  if (cp >= 42612 && cp <= 42621)
    return 3 /* CM */;
  if (cp >= 42654 && cp <= 42655)
    return 3 /* CM */;
  if (cp >= 42736 && cp <= 42737)
    return 3 /* CM */;
  if (cp >= 43010 && cp <= 43047)
    return 3 /* CM */;
  if (cp >= 43052 && cp <= 43052)
    return 3 /* CM */;
  if (cp >= 43136 && cp <= 43137)
    return 3 /* CM */;
  if (cp >= 43188 && cp <= 43205)
    return 3 /* CM */;
  if (cp >= 43232 && cp <= 43249)
    return 3 /* CM */;
  if (cp === 43263)
    return 3 /* CM */;
  if (cp >= 43302 && cp <= 43309)
    return 3 /* CM */;
  if (cp >= 43335 && cp <= 43347)
    return 3 /* CM */;
  if (cp >= 43392 && cp <= 43395)
    return 3 /* CM */;
  if (cp >= 43443 && cp <= 43469)
    return 3 /* CM */;
  if (cp === 43493)
    return 3 /* CM */;
  if (cp >= 43561 && cp <= 43574)
    return 3 /* CM */;
  if (cp >= 43587 && cp <= 43587)
    return 3 /* CM */;
  if (cp >= 43596 && cp <= 43597)
    return 3 /* CM */;
  if (cp >= 43643 && cp <= 43645)
    return 3 /* CM */;
  if (cp >= 43696 && cp <= 43714)
    return 3 /* CM */;
  if (cp >= 43755 && cp <= 43759)
    return 3 /* CM */;
  if (cp >= 43765 && cp <= 43766)
    return 3 /* CM */;
  if (cp >= 44003 && cp <= 44010)
    return 3 /* CM */;
  if (cp >= 44012 && cp <= 44013)
    return 3 /* CM */;
  if (cp === 64286)
    return 3 /* CM */;
  if (cp >= 65024 && cp <= 65039)
    return 3 /* CM */;
  if (cp >= 65056 && cp <= 65071)
    return 3 /* CM */;
  if (cp >= 66045 && cp <= 66045)
    return 3 /* CM */;
  if (cp >= 66272 && cp <= 66272)
    return 3 /* CM */;
  if (cp >= 66422 && cp <= 66426)
    return 3 /* CM */;
  if (cp >= 68097 && cp <= 68111)
    return 3 /* CM */;
  if (cp >= 68152 && cp <= 68159)
    return 3 /* CM */;
  if (cp >= 68325 && cp <= 68326)
    return 3 /* CM */;
  if (cp >= 68900 && cp <= 68903)
    return 3 /* CM */;
  if (cp >= 69291 && cp <= 69292)
    return 3 /* CM */;
  if (cp >= 69446 && cp <= 69456)
    return 3 /* CM */;
  if (cp >= 69506 && cp <= 69509)
    return 3 /* CM */;
  if (cp >= 69632 && cp <= 69634)
    return 3 /* CM */;
  if (cp >= 69688 && cp <= 69702)
    return 3 /* CM */;
  if (cp >= 69744 && cp <= 69744)
    return 3 /* CM */;
  if (cp >= 69747 && cp <= 69748)
    return 3 /* CM */;
  if (cp >= 69759 && cp <= 69762)
    return 3 /* CM */;
  if (cp >= 69808 && cp <= 69826)
    return 3 /* CM */;
  if (cp >= 69888 && cp <= 69890)
    return 3 /* CM */;
  if (cp >= 69927 && cp <= 69940)
    return 3 /* CM */;
  if (cp === 69957)
    return 3 /* CM */;
  if (cp === 69958)
    return 3 /* CM */;
  if (cp >= 70003 && cp <= 70003)
    return 3 /* CM */;
  if (cp >= 70016 && cp <= 70018)
    return 3 /* CM */;
  if (cp >= 70067 && cp <= 70080)
    return 3 /* CM */;
  if (cp >= 70089 && cp <= 70092)
    return 3 /* CM */;
  if (cp === 70094)
    return 3 /* CM */;
  if (cp === 70095)
    return 3 /* CM */;
  if (cp >= 70188 && cp <= 70199)
    return 3 /* CM */;
  if (cp === 70206)
    return 3 /* CM */;
  if (cp >= 70367 && cp <= 70378)
    return 3 /* CM */;
  if (cp >= 70400 && cp <= 70403)
    return 3 /* CM */;
  if (cp >= 70459 && cp <= 70460)
    return 3 /* CM */;
  if (cp >= 70462 && cp <= 70477)
    return 3 /* CM */;
  if (cp >= 70487 && cp <= 70487)
    return 3 /* CM */;
  if (cp >= 70498 && cp <= 70516)
    return 3 /* CM */;
  if (cp >= 70709 && cp <= 70726)
    return 3 /* CM */;
  if (cp === 70750)
    return 3 /* CM */;
  if (cp >= 70832 && cp <= 70851)
    return 3 /* CM */;
  if (cp >= 71087 && cp <= 71104)
    return 3 /* CM */;
  if (cp >= 71132 && cp <= 71133)
    return 3 /* CM */;
  if (cp >= 71216 && cp <= 71232)
    return 3 /* CM */;
  if (cp >= 71339 && cp <= 71351)
    return 3 /* CM */;
  if (cp >= 71453 && cp <= 71467)
    return 3 /* CM */;
  if (cp >= 71724 && cp <= 71738)
    return 3 /* CM */;
  if (cp >= 71984 && cp <= 71989)
    return 3 /* CM */;
  if (cp >= 71991 && cp <= 71992)
    return 3 /* CM */;
  if (cp >= 71995 && cp <= 71998)
    return 3 /* CM */;
  if (cp === 72000)
    return 3 /* CM */;
  if (cp >= 72002 && cp <= 72003)
    return 3 /* CM */;
  if (cp >= 72145 && cp <= 72151)
    return 3 /* CM */;
  if (cp >= 72154 && cp <= 72160)
    return 3 /* CM */;
  if (cp === 72164)
    return 3 /* CM */;
  if (cp >= 72193 && cp <= 72202)
    return 3 /* CM */;
  if (cp >= 72243 && cp <= 72249)
    return 3 /* CM */;
  if (cp >= 72251 && cp <= 72254)
    return 3 /* CM */;
  if (cp === 72263)
    return 3 /* CM */;
  if (cp >= 72273 && cp <= 72283)
    return 3 /* CM */;
  if (cp >= 72330 && cp <= 72345)
    return 3 /* CM */;
  if (cp >= 72751 && cp <= 72758)
    return 3 /* CM */;
  if (cp >= 72760 && cp <= 72767)
    return 3 /* CM */;
  if (cp >= 72850 && cp <= 72871)
    return 3 /* CM */;
  if (cp >= 72873 && cp <= 72886)
    return 3 /* CM */;
  if (cp >= 73009 && cp <= 73029)
    return 3 /* CM */;
  if (cp === 73031)
    return 3 /* CM */;
  if (cp >= 73098 && cp <= 73111)
    return 3 /* CM */;
  if (cp >= 73459 && cp <= 73462)
    return 3 /* CM */;
  if (cp >= 92912 && cp <= 92916)
    return 3 /* CM */;
  if (cp >= 92976 && cp <= 92982)
    return 3 /* CM */;
  if (cp === 94031)
    return 3 /* CM */;
  if (cp >= 94033 && cp <= 94087)
    return 3 /* CM */;
  if (cp >= 94095 && cp <= 94098)
    return 3 /* CM */;
  if (cp >= 94180 && cp <= 94180)
    return 3 /* CM */;
  if (cp >= 94192 && cp <= 94193)
    return 3 /* CM */;
  if (cp >= 113821 && cp <= 113822)
    return 3 /* CM */;
  if (cp >= 118528 && cp <= 118598)
    return 3 /* CM */;
  if (cp >= 119141 && cp <= 119145)
    return 3 /* CM */;
  if (cp >= 119149 && cp <= 119154)
    return 3 /* CM */;
  if (cp >= 119163 && cp <= 119170)
    return 3 /* CM */;
  if (cp >= 119173 && cp <= 119179)
    return 3 /* CM */;
  if (cp >= 119210 && cp <= 119213)
    return 3 /* CM */;
  if (cp >= 119362 && cp <= 119364)
    return 3 /* CM */;
  if (cp >= 121344 && cp <= 121398)
    return 3 /* CM */;
  if (cp >= 121403 && cp <= 121452)
    return 3 /* CM */;
  if (cp === 121461)
    return 3 /* CM */;
  if (cp === 121476)
    return 3 /* CM */;
  if (cp >= 121499 && cp <= 121519)
    return 3 /* CM */;
  if (cp >= 122880 && cp <= 122922)
    return 3 /* CM */;
  if (cp >= 123184 && cp <= 123190)
    return 3 /* CM */;
  if (cp >= 123566 && cp <= 123566)
    return 3 /* CM */;
  if (cp >= 123628 && cp <= 123631)
    return 3 /* CM */;
  if (cp >= 125136 && cp <= 125142)
    return 3 /* CM */;
  if (cp >= 125252 && cp <= 125258)
    return 3 /* CM */;
  if (cp >= 917760 && cp <= 917999)
    return 3 /* CM */;
  if (cp === 33)
    return 18 /* EX */;
  if (cp === 63)
    return 18 /* EX */;
  if (cp === 34)
    return 22 /* QU */;
  if (cp === 39)
    return 22 /* QU */;
  if (cp === 40)
    return 21 /* OP */;
  if (cp === 41)
    return 17 /* CP */;
  if (cp === 91)
    return 21 /* OP */;
  if (cp === 93)
    return 17 /* CP */;
  if (cp === 123)
    return 21 /* OP */;
  if (cp === 125)
    return 16 /* CL */;
  if (cp === 44)
    return 23 /* IS */;
  if (cp === 46)
    return 23 /* IS */;
  if (cp === 58)
    return 23 /* IS */;
  if (cp === 59)
    return 23 /* IS */;
  if (cp === 45)
    return 14 /* HY */;
  if (cp === 8208)
    return 12 /* BA */;
  if (cp === 8211)
    return 12 /* BA */;
  if (cp === 8212)
    return 11 /* B2 */;
  if (cp === 8216 || cp === 8217)
    return 22 /* QU */;
  if (cp === 8220 || cp === 8221)
    return 22 /* QU */;
  if (cp === 8230)
    return 19 /* IN */;
  if (cp === 12289 || cp === 12290)
    return 16 /* CL */;
  if (cp === 12296)
    return 21 /* OP */;
  if (cp === 12297)
    return 16 /* CL */;
  if (cp === 12298)
    return 21 /* OP */;
  if (cp === 12299)
    return 16 /* CL */;
  if (cp === 12300)
    return 21 /* OP */;
  if (cp === 12301)
    return 16 /* CL */;
  if (cp === 12302)
    return 21 /* OP */;
  if (cp === 12303)
    return 16 /* CL */;
  if (cp === 12304)
    return 21 /* OP */;
  if (cp === 12305)
    return 16 /* CL */;
  if (cp === 12308)
    return 21 /* OP */;
  if (cp === 12309)
    return 16 /* CL */;
  if (cp === 12310)
    return 21 /* OP */;
  if (cp === 12311)
    return 16 /* CL */;
  if (cp >= 12312 && cp <= 12315)
    return cp % 2 === 0 ? 21 /* OP */ : 16 /* CL */;
  if (cp === 65288)
    return 21 /* OP */;
  if (cp === 65289)
    return 16 /* CL */;
  if (cp === 65292)
    return 16 /* CL */;
  if (cp === 65294)
    return 16 /* CL */;
  if (cp === 65306)
    return 20 /* NS */;
  if (cp === 65307)
    return 20 /* NS */;
  if (cp === 65311)
    return 18 /* EX */;
  if (cp === 65281)
    return 18 /* EX */;
  if (cp >= 12353 && cp <= 12438) {
    if (cp === 12353 || cp === 12355 || cp === 12357 || cp === 12359 || cp === 12361 || cp === 12387 || cp === 12419 || cp === 12421 || cp === 12423 || cp === 12430 || cp === 12437 || cp === 12438)
      return 30 /* CJ */;
    return 36 /* ID */;
  }
  if (cp >= 12449 && cp <= 12538) {
    if (cp === 12449 || cp === 12451 || cp === 12453 || cp === 12455 || cp === 12457 || cp === 12483 || cp === 12515 || cp === 12517 || cp === 12519 || cp === 12526 || cp === 12533 || cp === 12534)
      return 30 /* CJ */;
    return 36 /* ID */;
  }
  if (cp === 12540)
    return 30 /* CJ */;
  if (cp >= 4352 && cp <= 4447)
    return 37 /* JL */;
  if (cp >= 43360 && cp <= 43388)
    return 37 /* JL */;
  if (cp >= 4448 && cp <= 4519)
    return 38 /* JV */;
  if (cp >= 55216 && cp <= 55238)
    return 38 /* JV */;
  if (cp >= 4520 && cp <= 4607)
    return 39 /* JT */;
  if (cp >= 55243 && cp <= 55291)
    return 39 /* JT */;
  if (cp >= 44032 && cp <= 55203) {
    const sIndex = cp - 44032;
    if (sIndex % 28 === 0)
      return 33 /* H2 */;
    return 34 /* H3 */;
  }
  if (cp >= 48 && cp <= 57)
    return 24 /* NU */;
  if (cp >= 1632 && cp <= 1641)
    return 24 /* NU */;
  if (cp >= 1776 && cp <= 1785)
    return 24 /* NU */;
  if (cp >= 2406 && cp <= 2415)
    return 24 /* NU */;
  if (cp >= 65296 && cp <= 65305)
    return 24 /* NU */;
  if (cp === 36)
    return 26 /* PR */;
  if (cp === 163)
    return 26 /* PR */;
  if (cp === 165)
    return 26 /* PR */;
  if (cp === 8364)
    return 26 /* PR */;
  if (cp === 37)
    return 25 /* PO */;
  if (cp >= 1488 && cp <= 1514)
    return 35 /* HL */;
  if (cp >= 64285 && cp <= 64335)
    return 35 /* HL */;
  if (cp >= 19968 && cp <= 40959)
    return 36 /* ID */;
  if (cp >= 13312 && cp <= 19903)
    return 36 /* ID */;
  if (cp >= 131072 && cp <= 173791)
    return 36 /* ID */;
  if (cp >= 173824 && cp <= 177983)
    return 36 /* ID */;
  if (cp >= 177984 && cp <= 178207)
    return 36 /* ID */;
  if (cp >= 178208 && cp <= 183983)
    return 36 /* ID */;
  if (cp >= 183984 && cp <= 191471)
    return 36 /* ID */;
  if (cp >= 196608 && cp <= 201551)
    return 36 /* ID */;
  if (cp >= 63744 && cp <= 64255)
    return 36 /* ID */;
  if (cp >= 194560 && cp <= 195103)
    return 36 /* ID */;
  if (cp >= 127744 && cp <= 129535)
    return 36 /* ID */;
  if (cp >= 129536 && cp <= 129791)
    return 36 /* ID */;
  if (cp >= 9728 && cp <= 9983)
    return 36 /* ID */;
  if (cp >= 9984 && cp <= 10175)
    return 36 /* ID */;
  if (cp >= 127456 && cp <= 127487)
    return 40 /* RI */;
  if (cp >= 127995 && cp <= 127999)
    return 32 /* EM */;
  if (cp >= 3584 && cp <= 3711)
    return 41 /* SA */;
  if (cp >= 3712 && cp <= 3839)
    return 41 /* SA */;
  if (cp >= 4096 && cp <= 4255)
    return 41 /* SA */;
  if (cp >= 43488 && cp <= 43519)
    return 41 /* SA */;
  if (cp >= 43616 && cp <= 43647)
    return 41 /* SA */;
  if (cp >= 6016 && cp <= 6143)
    return 41 /* SA */;
  if (cp >= 6624 && cp <= 6655)
    return 41 /* SA */;
  if (cp >= 65 && cp <= 90)
    return 29 /* AL */;
  if (cp >= 97 && cp <= 122)
    return 29 /* AL */;
  if (cp >= 192 && cp <= 591)
    return 29 /* AL */;
  if (cp >= 1536 && cp <= 1791)
    return 29 /* AL */;
  if (cp >= 1872 && cp <= 1919)
    return 29 /* AL */;
  if (cp >= 2208 && cp <= 2303)
    return 29 /* AL */;
  if (cp >= 2304 && cp <= 2431)
    return 29 /* AL */;
  if (cp >= 2432 && cp <= 2559)
    return 29 /* AL */;
  if (cp >= 2560 && cp <= 2687)
    return 29 /* AL */;
  if (cp >= 2688 && cp <= 2815)
    return 29 /* AL */;
  if (cp >= 2816 && cp <= 2943)
    return 29 /* AL */;
  if (cp >= 2944 && cp <= 3071)
    return 29 /* AL */;
  if (cp >= 3072 && cp <= 3199)
    return 29 /* AL */;
  if (cp >= 3200 && cp <= 3327)
    return 29 /* AL */;
  if (cp >= 3328 && cp <= 3455)
    return 29 /* AL */;
  if (cp >= 1024 && cp <= 1279)
    return 29 /* AL */;
  if (cp >= 1280 && cp <= 1327)
    return 29 /* AL */;
  if (cp >= 880 && cp <= 1023)
    return 29 /* AL */;
  return 42 /* XX */;
}
function getPairAction(before, after) {
  if (before === 28 /* AI */)
    before = 29 /* AL */;
  if (before === 41 /* SA */)
    before = 29 /* AL */;
  if (before === 5 /* SG */)
    before = 29 /* AL */;
  if (before === 42 /* XX */)
    before = 29 /* AL */;
  if (before === 30 /* CJ */)
    before = 20 /* NS */;
  if (after === 28 /* AI */)
    after = 29 /* AL */;
  if (after === 41 /* SA */)
    after = 29 /* AL */;
  if (after === 5 /* SG */)
    after = 29 /* AL */;
  if (after === 42 /* XX */)
    after = 29 /* AL */;
  if (after === 30 /* CJ */)
    after = 20 /* NS */;
  if (before === 0 /* BK */)
    return 5 /* Explicit */;
  if (before === 1 /* CR */ && after === 2 /* LF */)
    return 4 /* Prohibited */;
  if (before === 1 /* CR */ || before === 2 /* LF */ || before === 4 /* NL */)
    return 5 /* Explicit */;
  if (after === 0 /* BK */ || after === 1 /* CR */ || after === 2 /* LF */ || after === 4 /* NL */)
    return 4 /* Prohibited */;
  if (after === 9 /* SP */ || after === 7 /* ZW */)
    return 4 /* Prohibited */;
  if (before === 7 /* ZW */)
    return 0 /* Direct */;
  if (before === 10 /* ZWJ */)
    return 4 /* Prohibited */;
  if (after === 3 /* CM */ || after === 10 /* ZWJ */) {
    if (before !== 9 /* SP */)
      return 4 /* Prohibited */;
  }
  let beforeResolved = before;
  let afterResolved = after;
  if (before === 3 /* CM */ || before === 10 /* ZWJ */)
    beforeResolved = 29 /* AL */;
  if (after === 3 /* CM */ || after === 10 /* ZWJ */)
    afterResolved = 29 /* AL */;
  before = beforeResolved;
  after = afterResolved;
  if (before === 6 /* WJ */ || after === 6 /* WJ */)
    return 4 /* Prohibited */;
  if (before === 8 /* GL */)
    return 4 /* Prohibited */;
  if (after === 8 /* GL */) {
    if (before !== 9 /* SP */ && before !== 12 /* BA */ && before !== 14 /* HY */)
      return 4 /* Prohibited */;
  }
  if (after === 16 /* CL */ || after === 17 /* CP */ || after === 18 /* EX */ || after === 23 /* IS */ || after === 27 /* SY */)
    return 4 /* Prohibited */;
  if (before === 21 /* OP */)
    return 4 /* Prohibited */;
  if (before === 22 /* QU */ && after === 21 /* OP */)
    return 4 /* Prohibited */;
  if ((before === 16 /* CL */ || before === 17 /* CP */) && after === 20 /* NS */)
    return 4 /* Prohibited */;
  if (before === 11 /* B2 */ && after === 11 /* B2 */)
    return 4 /* Prohibited */;
  if (before === 9 /* SP */)
    return 0 /* Direct */;
  if (before === 22 /* QU */ || after === 22 /* QU */)
    return 4 /* Prohibited */;
  if (before === 15 /* CB */ || after === 15 /* CB */)
    return 0 /* Direct */;
  if (after === 12 /* BA */ || after === 14 /* HY */ || after === 20 /* NS */)
    return 4 /* Prohibited */;
  if (before === 13 /* BB */)
    return 4 /* Prohibited */;
  if (before === 27 /* SY */ && after === 35 /* HL */)
    return 4 /* Prohibited */;
  if (after === 19 /* IN */)
    return 4 /* Prohibited */;
  if ((before === 29 /* AL */ || before === 35 /* HL */) && after === 24 /* NU */)
    return 4 /* Prohibited */;
  if (before === 24 /* NU */ && (after === 29 /* AL */ || after === 35 /* HL */))
    return 4 /* Prohibited */;
  if (before === 26 /* PR */ && after === 36 /* ID */)
    return 4 /* Prohibited */;
  if (before === 36 /* ID */ && after === 25 /* PO */)
    return 4 /* Prohibited */;
  if ((before === 26 /* PR */ || before === 25 /* PO */) && (after === 29 /* AL */ || after === 35 /* HL */))
    return 4 /* Prohibited */;
  if ((before === 29 /* AL */ || before === 35 /* HL */) && (after === 26 /* PR */ || after === 25 /* PO */))
    return 4 /* Prohibited */;
  if ((before === 16 /* CL */ || before === 17 /* CP */) && after === 24 /* NU */)
    return 4 /* Prohibited */;
  if (before === 24 /* NU */ && (after === 25 /* PO */ || after === 26 /* PR */))
    return 4 /* Prohibited */;
  if ((before === 25 /* PO */ || before === 26 /* PR */ || before === 14 /* HY */ || before === 23 /* IS */ || before === 24 /* NU */ || before === 27 /* SY */) && after === 24 /* NU */)
    return 4 /* Prohibited */;
  if (before === 37 /* JL */) {
    if (after === 37 /* JL */ || after === 38 /* JV */ || after === 33 /* H2 */ || after === 34 /* H3 */)
      return 4 /* Prohibited */;
  }
  if (before === 38 /* JV */ || before === 33 /* H2 */) {
    if (after === 38 /* JV */ || after === 39 /* JT */)
      return 4 /* Prohibited */;
  }
  if (before === 39 /* JT */ || before === 34 /* H3 */) {
    if (after === 39 /* JT */)
      return 4 /* Prohibited */;
  }
  if (before === 37 /* JL */ || before === 38 /* JV */ || before === 39 /* JT */ || before === 33 /* H2 */ || before === 34 /* H3 */) {
    if (after === 25 /* PO */)
      return 4 /* Prohibited */;
  }
  if (after === 37 /* JL */ || after === 38 /* JV */ || after === 39 /* JT */ || after === 33 /* H2 */ || after === 34 /* H3 */) {
    if (before === 26 /* PR */)
      return 4 /* Prohibited */;
  }
  if ((before === 29 /* AL */ || before === 35 /* HL */) && (after === 29 /* AL */ || after === 35 /* HL */))
    return 4 /* Prohibited */;
  if (before === 23 /* IS */ && (after === 29 /* AL */ || after === 35 /* HL */))
    return 4 /* Prohibited */;
  if ((before === 29 /* AL */ || before === 35 /* HL */ || before === 24 /* NU */) && after === 21 /* OP */)
    return 4 /* Prohibited */;
  if (before === 17 /* CP */ && (after === 29 /* AL */ || after === 35 /* HL */ || after === 24 /* NU */))
    return 4 /* Prohibited */;
  if (before === 40 /* RI */ && after === 40 /* RI */)
    return 4 /* Prohibited */;
  if (before === 31 /* EB */ && after === 32 /* EM */)
    return 4 /* Prohibited */;
  return 0 /* Direct */;
}
function analyzeLineBreaks(text) {
  const codepoints = [];
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    codepoints.push(char2.codePointAt(0) ?? 0);
  }
  return analyzeLineBreaksFromCodepoints(codepoints);
}
function analyzeLineBreaksFromCodepoints(codepoints) {
  const len = codepoints.length;
  const classes = [];
  const breaks = [];
  for (let i = 0;i < codepoints.length; i++) {
    const cp = codepoints[i];
    classes.push(getLineBreakClass(cp));
  }
  breaks.push(0 /* NoBreak */);
  for (let i = 1;i < len; i++) {
    const before = classes[i - 1];
    const after = classes[i];
    const action = getPairAction(before, after);
    switch (action) {
      case 5 /* Explicit */:
        breaks.push(2 /* Mandatory */);
        break;
      case 0 /* Direct */:
        breaks.push(1 /* Optional */);
        break;
      default:
        breaks.push(0 /* NoBreak */);
    }
  }
  breaks.push(2 /* Mandatory */);
  return { breaks, classes };
}
function analyzeLineBreaksForGlyphs(infos) {
  const codepoints = infos.map((info) => info.codepoint);
  return analyzeLineBreaksFromCodepoints(codepoints);
}
function findNextBreak(analysis, startIndex) {
  for (let i = startIndex + 1;i < analysis.breaks.length; i++) {
    if (analysis.breaks[i] !== 0 /* NoBreak */) {
      return i;
    }
  }
  return analysis.breaks.length - 1;
}
function canBreakAt(analysis, index) {
  if (index < 0 || index >= analysis.breaks.length)
    return false;
  return analysis.breaks[index] !== 0 /* NoBreak */;
}
function mustBreakAt(analysis, index) {
  if (index < 0 || index >= analysis.breaks.length)
    return false;
  return analysis.breaks[index] === 2 /* Mandatory */;
}
function getAllBreakOpportunities(analysis) {
  const opportunities = [];
  for (let i = 0;i < analysis.breaks.length; i++) {
    if (analysis.breaks[i] !== 0 /* NoBreak */) {
      opportunities.push(i);
    }
  }
  return opportunities;
}
// reference/text-shaper/src/unicode/script.ts
var Script;
((Script2) => {
  Script2["Common"] = "Zyyy";
  Script2["Inherited"] = "Zinh";
  Script2["Unknown"] = "Zzzz";
  Script2["Latin"] = "Latn";
  Script2["Greek"] = "Grek";
  Script2["Cyrillic"] = "Cyrl";
  Script2["Armenian"] = "Armn";
  Script2["Hebrew"] = "Hebr";
  Script2["Arabic"] = "Arab";
  Script2["Syriac"] = "Syrc";
  Script2["Thaana"] = "Thaa";
  Script2["Devanagari"] = "Deva";
  Script2["Bengali"] = "Beng";
  Script2["Gurmukhi"] = "Guru";
  Script2["Gujarati"] = "Gujr";
  Script2["Oriya"] = "Orya";
  Script2["Tamil"] = "Taml";
  Script2["Telugu"] = "Telu";
  Script2["Kannada"] = "Knda";
  Script2["Malayalam"] = "Mlym";
  Script2["Sinhala"] = "Sinh";
  Script2["Thai"] = "Thai";
  Script2["Lao"] = "Laoo";
  Script2["Tibetan"] = "Tibt";
  Script2["Myanmar"] = "Mymr";
  Script2["Georgian"] = "Geor";
  Script2["Hangul"] = "Hang";
  Script2["Ethiopic"] = "Ethi";
  Script2["Cherokee"] = "Cher";
  Script2["CanadianAboriginal"] = "Cans";
  Script2["Ogham"] = "Ogam";
  Script2["Runic"] = "Runr";
  Script2["Khmer"] = "Khmr";
  Script2["Mongolian"] = "Mong";
  Script2["Hiragana"] = "Hira";
  Script2["Katakana"] = "Kana";
  Script2["Bopomofo"] = "Bopo";
  Script2["Han"] = "Hani";
  Script2["Yi"] = "Yiii";
  Script2["OldItalic"] = "Ital";
  Script2["Gothic"] = "Goth";
  Script2["Deseret"] = "Dsrt";
  Script2["Tagalog"] = "Tglg";
  Script2["Hanunoo"] = "Hano";
  Script2["Buhid"] = "Buhd";
  Script2["Tagbanwa"] = "Tagb";
  Script2["Limbu"] = "Limb";
  Script2["TaiLe"] = "Tale";
  Script2["LinearB"] = "Linb";
  Script2["Ugaritic"] = "Ugar";
  Script2["Shavian"] = "Shaw";
  Script2["Osmanya"] = "Osma";
  Script2["Cypriot"] = "Cprt";
  Script2["Braille"] = "Brai";
  Script2["Buginese"] = "Bugi";
  Script2["Coptic"] = "Copt";
  Script2["NewTaiLue"] = "Talu";
  Script2["Glagolitic"] = "Glag";
  Script2["Tifinagh"] = "Tfng";
  Script2["SylotiNagri"] = "Sylo";
  Script2["OldPersian"] = "Xpeo";
  Script2["Kharoshthi"] = "Khar";
  Script2["Balinese"] = "Bali";
  Script2["Cuneiform"] = "Xsux";
  Script2["Phoenician"] = "Phnx";
  Script2["PhagsPa"] = "Phag";
  Script2["Nko"] = "Nkoo";
  Script2["Sundanese"] = "Sund";
  Script2["Lepcha"] = "Lepc";
  Script2["OlChiki"] = "Olck";
  Script2["Vai"] = "Vaii";
  Script2["Saurashtra"] = "Saur";
  Script2["KayahLi"] = "Kali";
  Script2["Rejang"] = "Rjng";
  Script2["Lycian"] = "Lyci";
  Script2["Carian"] = "Cari";
  Script2["Lydian"] = "Lydi";
  Script2["Cham"] = "Cham";
  Script2["TaiTham"] = "Lana";
  Script2["TaiViet"] = "Tavt";
  Script2["Avestan"] = "Avst";
  Script2["EgyptianHieroglyphs"] = "Egyp";
  Script2["Samaritan"] = "Samr";
  Script2["Lisu"] = "Lisu";
  Script2["Bamum"] = "Bamu";
  Script2["Javanese"] = "Java";
  Script2["MeeteiMayek"] = "Mtei";
  Script2["ImperialAramaic"] = "Armi";
  Script2["OldSouthArabian"] = "Sarb";
  Script2["InscriptionalParthian"] = "Prti";
  Script2["InscriptionalPahlavi"] = "Phli";
  Script2["OldTurkic"] = "Orkh";
  Script2["Kaithi"] = "Kthi";
  Script2["Batak"] = "Batk";
  Script2["Brahmi"] = "Brah";
  Script2["Mandaic"] = "Mand";
  Script2["Chakma"] = "Cakm";
  Script2["MeroiticCursive"] = "Merc";
  Script2["MeroiticHieroglyphs"] = "Mero";
  Script2["Miao"] = "Plrd";
  Script2["Sharada"] = "Shrd";
  Script2["SoraSompeng"] = "Sora";
  Script2["Takri"] = "Takr";
  Script2["CaucasianAlbanian"] = "Aghb";
  Script2["BassaVah"] = "Bass";
  Script2["Duployan"] = "Dupl";
  Script2["Elbasan"] = "Elba";
  Script2["Grantha"] = "Gran";
  Script2["PahawhHmong"] = "Hmng";
  Script2["Khojki"] = "Khoj";
  Script2["LinearA"] = "Lina";
  Script2["Mahajani"] = "Mahj";
  Script2["Manichaean"] = "Mani";
  Script2["MendeKikakui"] = "Mend";
  Script2["Modi"] = "Modi";
  Script2["Mro"] = "Mroo";
  Script2["OldNorthArabian"] = "Narb";
  Script2["Nabataean"] = "Nbat";
  Script2["Palmyrene"] = "Palm";
  Script2["PauCinHau"] = "Pauc";
  Script2["OldPermic"] = "Perm";
  Script2["PsalterPahlavi"] = "Phlp";
  Script2["Siddham"] = "Sidd";
  Script2["Khudawadi"] = "Sind";
  Script2["Tirhuta"] = "Tirh";
  Script2["WarangCiti"] = "Wara";
  Script2["Ahom"] = "Ahom";
  Script2["AnatolianHieroglyphs"] = "Hluw";
  Script2["Hatran"] = "Hatr";
  Script2["Multani"] = "Mult";
  Script2["OldHungarian"] = "Hung";
  Script2["SignWriting"] = "Sgnw";
  Script2["Adlam"] = "Adlm";
  Script2["Bhaiksuki"] = "Bhks";
  Script2["Marchen"] = "Marc";
  Script2["Newa"] = "Newa";
  Script2["Osage"] = "Osge";
  Script2["Tangut"] = "Tang";
  Script2["MasaramGondi"] = "Gonm";
  Script2["Nushu"] = "Nshu";
  Script2["Soyombo"] = "Soyo";
  Script2["ZanabazarSquare"] = "Zanb";
  Script2["Dogra"] = "Dogr";
  Script2["GunjalaGondi"] = "Gong";
  Script2["Makasar"] = "Maka";
  Script2["Medefaidrin"] = "Medf";
  Script2["HanifiRohingya"] = "Rohg";
  Script2["Sogdian"] = "Sogd";
  Script2["OldSogdian"] = "Sogo";
  Script2["Elymaic"] = "Elym";
  Script2["Nandinagari"] = "Nand";
  Script2["NyiakengPuachueHmong"] = "Hmnp";
  Script2["Wancho"] = "Wcho";
  Script2["Yezidi"] = "Yezi";
  Script2["Chorasmian"] = "Chrs";
  Script2["DivesAkuru"] = "Diak";
  Script2["KhitanSmallScript"] = "Kits";
  Script2["Vithkuqi"] = "Vith";
  Script2["OldUyghur"] = "Ougr";
  Script2["Cypro_Minoan"] = "Cpmn";
  Script2["Tangsa"] = "Tnsa";
  Script2["Toto"] = "Toto";
  Script2["Kawi"] = "Kawi";
  Script2["NagMundari"] = "Nagm";
})(Script ||= {});
var SCRIPT_RANGES = [
  { start: 0, end: 127, script: "Zyyy" /* Common */ },
  { start: 128, end: 255, script: "Latn" /* Latin */ },
  { start: 256, end: 383, script: "Latn" /* Latin */ },
  { start: 384, end: 591, script: "Latn" /* Latin */ },
  { start: 592, end: 687, script: "Latn" /* Latin */ },
  { start: 688, end: 767, script: "Zyyy" /* Common */ },
  { start: 768, end: 879, script: "Zinh" /* Inherited */ },
  { start: 880, end: 1023, script: "Grek" /* Greek */ },
  { start: 1024, end: 1279, script: "Cyrl" /* Cyrillic */ },
  { start: 1280, end: 1327, script: "Cyrl" /* Cyrillic */ },
  { start: 1328, end: 1423, script: "Armn" /* Armenian */ },
  { start: 1424, end: 1535, script: "Hebr" /* Hebrew */ },
  { start: 1536, end: 1791, script: "Arab" /* Arabic */ },
  { start: 1792, end: 1871, script: "Syrc" /* Syriac */ },
  { start: 1872, end: 1919, script: "Arab" /* Arabic */ },
  { start: 1920, end: 1983, script: "Thaa" /* Thaana */ },
  { start: 1984, end: 2047, script: "Nkoo" /* Nko */ },
  { start: 2048, end: 2111, script: "Samr" /* Samaritan */ },
  { start: 2112, end: 2143, script: "Mand" /* Mandaic */ },
  { start: 2144, end: 2159, script: "Syrc" /* Syriac */ },
  { start: 2160, end: 2207, script: "Arab" /* Arabic */ },
  { start: 2208, end: 2303, script: "Arab" /* Arabic */ },
  { start: 2304, end: 2431, script: "Deva" /* Devanagari */ },
  { start: 2432, end: 2559, script: "Beng" /* Bengali */ },
  { start: 2560, end: 2687, script: "Guru" /* Gurmukhi */ },
  { start: 2688, end: 2815, script: "Gujr" /* Gujarati */ },
  { start: 2816, end: 2943, script: "Orya" /* Oriya */ },
  { start: 2944, end: 3071, script: "Taml" /* Tamil */ },
  { start: 3072, end: 3199, script: "Telu" /* Telugu */ },
  { start: 3200, end: 3327, script: "Knda" /* Kannada */ },
  { start: 3328, end: 3455, script: "Mlym" /* Malayalam */ },
  { start: 3456, end: 3583, script: "Sinh" /* Sinhala */ },
  { start: 3584, end: 3711, script: "Thai" /* Thai */ },
  { start: 3712, end: 3839, script: "Laoo" /* Lao */ },
  { start: 3840, end: 4095, script: "Tibt" /* Tibetan */ },
  { start: 4096, end: 4255, script: "Mymr" /* Myanmar */ },
  { start: 4256, end: 4351, script: "Geor" /* Georgian */ },
  { start: 4352, end: 4607, script: "Hang" /* Hangul */ },
  { start: 4608, end: 4991, script: "Ethi" /* Ethiopic */ },
  { start: 4992, end: 5023, script: "Ethi" /* Ethiopic */ },
  { start: 5024, end: 5119, script: "Cher" /* Cherokee */ },
  { start: 5120, end: 5759, script: "Cans" /* CanadianAboriginal */ },
  { start: 5760, end: 5791, script: "Ogam" /* Ogham */ },
  { start: 5792, end: 5887, script: "Runr" /* Runic */ },
  { start: 5888, end: 5919, script: "Tglg" /* Tagalog */ },
  { start: 5920, end: 5951, script: "Hano" /* Hanunoo */ },
  { start: 5952, end: 5983, script: "Buhd" /* Buhid */ },
  { start: 5984, end: 6015, script: "Tagb" /* Tagbanwa */ },
  { start: 6016, end: 6143, script: "Khmr" /* Khmer */ },
  { start: 6144, end: 6319, script: "Mong" /* Mongolian */ },
  { start: 6320, end: 6399, script: "Cans" /* CanadianAboriginal */ },
  { start: 6400, end: 6479, script: "Limb" /* Limbu */ },
  { start: 6480, end: 6527, script: "Tale" /* TaiLe */ },
  { start: 6528, end: 6623, script: "Talu" /* NewTaiLue */ },
  { start: 6624, end: 6655, script: "Khmr" /* Khmer */ },
  { start: 6656, end: 6687, script: "Bugi" /* Buginese */ },
  { start: 6688, end: 6831, script: "Lana" /* TaiTham */ },
  { start: 6832, end: 6911, script: "Zinh" /* Inherited */ },
  { start: 6912, end: 7039, script: "Bali" /* Balinese */ },
  { start: 7040, end: 7103, script: "Sund" /* Sundanese */ },
  { start: 7104, end: 7167, script: "Batk" /* Batak */ },
  { start: 7168, end: 7247, script: "Lepc" /* Lepcha */ },
  { start: 7248, end: 7295, script: "Olck" /* OlChiki */ },
  { start: 7296, end: 7311, script: "Cyrl" /* Cyrillic */ },
  { start: 7312, end: 7359, script: "Geor" /* Georgian */ },
  { start: 7360, end: 7375, script: "Sund" /* Sundanese */ },
  { start: 7376, end: 7423, script: "Zinh" /* Inherited */ },
  { start: 7424, end: 7551, script: "Latn" /* Latin */ },
  { start: 7552, end: 7615, script: "Latn" /* Latin */ },
  { start: 7616, end: 7679, script: "Zinh" /* Inherited */ },
  { start: 7680, end: 7935, script: "Latn" /* Latin */ },
  { start: 7936, end: 8191, script: "Grek" /* Greek */ },
  { start: 8192, end: 8303, script: "Zyyy" /* Common */ },
  { start: 8304, end: 8351, script: "Zyyy" /* Common */ },
  { start: 8352, end: 8399, script: "Zyyy" /* Common */ },
  { start: 8400, end: 8447, script: "Zinh" /* Inherited */ },
  { start: 8448, end: 8527, script: "Zyyy" /* Common */ },
  { start: 8528, end: 8591, script: "Zyyy" /* Common */ },
  { start: 8592, end: 8703, script: "Zyyy" /* Common */ },
  { start: 8704, end: 8959, script: "Zyyy" /* Common */ },
  { start: 8960, end: 9215, script: "Zyyy" /* Common */ },
  { start: 9216, end: 9279, script: "Zyyy" /* Common */ },
  { start: 9280, end: 9311, script: "Zyyy" /* Common */ },
  { start: 9312, end: 9471, script: "Zyyy" /* Common */ },
  { start: 9472, end: 9599, script: "Zyyy" /* Common */ },
  { start: 9600, end: 9631, script: "Zyyy" /* Common */ },
  { start: 9632, end: 9727, script: "Zyyy" /* Common */ },
  { start: 9728, end: 9983, script: "Zyyy" /* Common */ },
  { start: 9984, end: 10175, script: "Zyyy" /* Common */ },
  { start: 10176, end: 10223, script: "Zyyy" /* Common */ },
  { start: 10224, end: 10239, script: "Zyyy" /* Common */ },
  { start: 10240, end: 10495, script: "Brai" /* Braille */ },
  { start: 10496, end: 10623, script: "Zyyy" /* Common */ },
  { start: 10624, end: 10751, script: "Zyyy" /* Common */ },
  { start: 10752, end: 11007, script: "Zyyy" /* Common */ },
  { start: 11008, end: 11263, script: "Zyyy" /* Common */ },
  { start: 11264, end: 11359, script: "Glag" /* Glagolitic */ },
  { start: 11360, end: 11391, script: "Latn" /* Latin */ },
  { start: 11392, end: 11519, script: "Copt" /* Coptic */ },
  { start: 11520, end: 11567, script: "Geor" /* Georgian */ },
  { start: 11568, end: 11647, script: "Tfng" /* Tifinagh */ },
  { start: 11648, end: 11743, script: "Ethi" /* Ethiopic */ },
  { start: 11744, end: 11775, script: "Cyrl" /* Cyrillic */ },
  { start: 11776, end: 11903, script: "Zyyy" /* Common */ },
  { start: 11904, end: 12031, script: "Hani" /* Han */ },
  { start: 12032, end: 12255, script: "Hani" /* Han */ },
  { start: 12272, end: 12287, script: "Zyyy" /* Common */ },
  { start: 12288, end: 12351, script: "Zyyy" /* Common */ },
  { start: 12352, end: 12447, script: "Hira" /* Hiragana */ },
  { start: 12448, end: 12543, script: "Kana" /* Katakana */ },
  { start: 12544, end: 12591, script: "Bopo" /* Bopomofo */ },
  { start: 12592, end: 12687, script: "Hang" /* Hangul */ },
  { start: 12688, end: 12703, script: "Zyyy" /* Common */ },
  { start: 12704, end: 12735, script: "Bopo" /* Bopomofo */ },
  { start: 12736, end: 12783, script: "Zyyy" /* Common */ },
  { start: 12784, end: 12799, script: "Kana" /* Katakana */ },
  { start: 12800, end: 13055, script: "Zyyy" /* Common */ },
  { start: 13056, end: 13311, script: "Zyyy" /* Common */ },
  { start: 13312, end: 19903, script: "Hani" /* Han */ },
  { start: 19904, end: 19967, script: "Zyyy" /* Common */ },
  { start: 19968, end: 40959, script: "Hani" /* Han */ },
  { start: 40960, end: 42127, script: "Yiii" /* Yi */ },
  { start: 42128, end: 42191, script: "Yiii" /* Yi */ },
  { start: 42192, end: 42239, script: "Lisu" /* Lisu */ },
  { start: 42240, end: 42559, script: "Vaii" /* Vai */ },
  { start: 42560, end: 42655, script: "Cyrl" /* Cyrillic */ },
  { start: 42656, end: 42751, script: "Bamu" /* Bamum */ },
  { start: 42752, end: 42783, script: "Zyyy" /* Common */ },
  { start: 42784, end: 43007, script: "Latn" /* Latin */ },
  { start: 43008, end: 43055, script: "Sylo" /* SylotiNagri */ },
  { start: 43056, end: 43071, script: "Zyyy" /* Common */ },
  { start: 43072, end: 43135, script: "Phag" /* PhagsPa */ },
  { start: 43136, end: 43231, script: "Saur" /* Saurashtra */ },
  { start: 43232, end: 43263, script: "Deva" /* Devanagari */ },
  { start: 43264, end: 43311, script: "Kali" /* KayahLi */ },
  { start: 43312, end: 43359, script: "Rjng" /* Rejang */ },
  { start: 43360, end: 43391, script: "Hang" /* Hangul */ },
  { start: 43392, end: 43487, script: "Java" /* Javanese */ },
  { start: 43488, end: 43519, script: "Mymr" /* Myanmar */ },
  { start: 43520, end: 43615, script: "Cham" /* Cham */ },
  { start: 43616, end: 43647, script: "Mymr" /* Myanmar */ },
  { start: 43648, end: 43743, script: "Tavt" /* TaiViet */ },
  { start: 43744, end: 43775, script: "Mtei" /* MeeteiMayek */ },
  { start: 43776, end: 43823, script: "Ethi" /* Ethiopic */ },
  { start: 43824, end: 43887, script: "Latn" /* Latin */ },
  { start: 43888, end: 43967, script: "Cher" /* Cherokee */ },
  { start: 43968, end: 44031, script: "Mtei" /* MeeteiMayek */ },
  { start: 44032, end: 55215, script: "Hang" /* Hangul */ },
  { start: 55216, end: 55295, script: "Hang" /* Hangul */ },
  { start: 55296, end: 57343, script: "Zzzz" /* Unknown */ },
  { start: 57344, end: 63743, script: "Zzzz" /* Unknown */ },
  { start: 63744, end: 64255, script: "Hani" /* Han */ },
  { start: 64256, end: 64335, script: "Latn" /* Latin */ },
  { start: 64336, end: 65023, script: "Arab" /* Arabic */ },
  { start: 65024, end: 65039, script: "Zinh" /* Inherited */ },
  { start: 65040, end: 65055, script: "Zyyy" /* Common */ },
  { start: 65056, end: 65071, script: "Zinh" /* Inherited */ },
  { start: 65072, end: 65103, script: "Zyyy" /* Common */ },
  { start: 65104, end: 65135, script: "Zyyy" /* Common */ },
  { start: 65136, end: 65279, script: "Arab" /* Arabic */ },
  { start: 65280, end: 65519, script: "Zyyy" /* Common */ },
  { start: 65520, end: 65535, script: "Zyyy" /* Common */ },
  { start: 65536, end: 65663, script: "Linb" /* LinearB */ },
  { start: 65664, end: 65791, script: "Linb" /* LinearB */ },
  { start: 65792, end: 65855, script: "Zyyy" /* Common */ },
  { start: 65856, end: 65935, script: "Grek" /* Greek */ },
  { start: 65936, end: 65999, script: "Zyyy" /* Common */ },
  { start: 66000, end: 66047, script: "Zyyy" /* Common */ },
  { start: 66176, end: 66207, script: "Lyci" /* Lycian */ },
  { start: 66208, end: 66271, script: "Cari" /* Carian */ },
  { start: 66272, end: 66303, script: "Zinh" /* Inherited */ },
  { start: 66304, end: 66351, script: "Ital" /* OldItalic */ },
  { start: 66352, end: 66383, script: "Goth" /* Gothic */ },
  { start: 66384, end: 66431, script: "Perm" /* OldPermic */ },
  { start: 66432, end: 66463, script: "Ugar" /* Ugaritic */ },
  { start: 66464, end: 66527, script: "Xpeo" /* OldPersian */ },
  { start: 66560, end: 66639, script: "Dsrt" /* Deseret */ },
  { start: 66640, end: 66687, script: "Shaw" /* Shavian */ },
  { start: 66688, end: 66735, script: "Osma" /* Osmanya */ },
  { start: 66736, end: 66815, script: "Osge" /* Osage */ },
  { start: 66816, end: 66863, script: "Elba" /* Elbasan */ },
  { start: 66864, end: 66927, script: "Aghb" /* CaucasianAlbanian */ },
  { start: 66928, end: 67007, script: "Vith" /* Vithkuqi */ },
  { start: 67072, end: 67455, script: "Lina" /* LinearA */ },
  { start: 67456, end: 67519, script: "Latn" /* Latin */ },
  { start: 67584, end: 67647, script: "Cprt" /* Cypriot */ },
  { start: 67648, end: 67679, script: "Armi" /* ImperialAramaic */ },
  { start: 67680, end: 67711, script: "Palm" /* Palmyrene */ },
  { start: 67712, end: 67759, script: "Nbat" /* Nabataean */ },
  { start: 67808, end: 67839, script: "Hatr" /* Hatran */ },
  { start: 67840, end: 67871, script: "Phnx" /* Phoenician */ },
  { start: 67872, end: 67903, script: "Lydi" /* Lydian */ },
  { start: 67968, end: 67999, script: "Mero" /* MeroiticHieroglyphs */ },
  { start: 68000, end: 68095, script: "Merc" /* MeroiticCursive */ },
  { start: 68096, end: 68191, script: "Khar" /* Kharoshthi */ },
  { start: 68192, end: 68223, script: "Sarb" /* OldSouthArabian */ },
  { start: 68224, end: 68255, script: "Narb" /* OldNorthArabian */ },
  { start: 68288, end: 68351, script: "Mani" /* Manichaean */ },
  { start: 68352, end: 68415, script: "Avst" /* Avestan */ },
  { start: 68416, end: 68447, script: "Prti" /* InscriptionalParthian */ },
  { start: 68448, end: 68479, script: "Phli" /* InscriptionalPahlavi */ },
  { start: 68480, end: 68527, script: "Phlp" /* PsalterPahlavi */ },
  { start: 68608, end: 68687, script: "Orkh" /* OldTurkic */ },
  { start: 68736, end: 68863, script: "Hung" /* OldHungarian */ },
  { start: 68864, end: 68927, script: "Rohg" /* HanifiRohingya */ },
  { start: 69248, end: 69311, script: "Yezi" /* Yezidi */ },
  { start: 69376, end: 69423, script: "Sogo" /* OldSogdian */ },
  { start: 69424, end: 69487, script: "Sogd" /* Sogdian */ },
  { start: 69488, end: 69551, script: "Ougr" /* OldUyghur */ },
  { start: 69552, end: 69599, script: "Chrs" /* Chorasmian */ },
  { start: 69600, end: 69631, script: "Elym" /* Elymaic */ },
  { start: 69632, end: 69759, script: "Brah" /* Brahmi */ },
  { start: 69760, end: 69839, script: "Kthi" /* Kaithi */ },
  { start: 69840, end: 69887, script: "Sora" /* SoraSompeng */ },
  { start: 69888, end: 69967, script: "Cakm" /* Chakma */ },
  { start: 69968, end: 70015, script: "Mahj" /* Mahajani */ },
  { start: 70016, end: 70111, script: "Shrd" /* Sharada */ },
  { start: 70112, end: 70143, script: "Sinh" /* Sinhala */ },
  { start: 70144, end: 70223, script: "Khoj" /* Khojki */ },
  { start: 70272, end: 70319, script: "Mult" /* Multani */ },
  { start: 70320, end: 70399, script: "Sind" /* Khudawadi */ },
  { start: 70400, end: 70527, script: "Gran" /* Grantha */ },
  { start: 70656, end: 70783, script: "Newa" /* Newa */ },
  { start: 70784, end: 70879, script: "Tirh" /* Tirhuta */ },
  { start: 71040, end: 71167, script: "Sidd" /* Siddham */ },
  { start: 71168, end: 71263, script: "Modi" /* Modi */ },
  { start: 71264, end: 71295, script: "Mong" /* Mongolian */ },
  { start: 71296, end: 71375, script: "Takr" /* Takri */ },
  { start: 71424, end: 71503, script: "Ahom" /* Ahom */ },
  { start: 71680, end: 71759, script: "Dogr" /* Dogra */ },
  { start: 71840, end: 71935, script: "Wara" /* WarangCiti */ },
  { start: 71936, end: 72031, script: "Diak" /* DivesAkuru */ },
  { start: 72096, end: 72191, script: "Nand" /* Nandinagari */ },
  { start: 72192, end: 72271, script: "Zanb" /* ZanabazarSquare */ },
  { start: 72272, end: 72367, script: "Soyo" /* Soyombo */ },
  { start: 72368, end: 72383, script: "Cans" /* CanadianAboriginal */ },
  { start: 72384, end: 72447, script: "Pauc" /* PauCinHau */ },
  { start: 72704, end: 72815, script: "Bhks" /* Bhaiksuki */ },
  { start: 72816, end: 72895, script: "Marc" /* Marchen */ },
  { start: 72960, end: 73055, script: "Gonm" /* MasaramGondi */ },
  { start: 73056, end: 73135, script: "Gong" /* GunjalaGondi */ },
  { start: 73440, end: 73471, script: "Maka" /* Makasar */ },
  { start: 73472, end: 73567, script: "Kawi" /* Kawi */ },
  { start: 73728, end: 74751, script: "Xsux" /* Cuneiform */ },
  { start: 74752, end: 74879, script: "Xsux" /* Cuneiform */ },
  { start: 74880, end: 75087, script: "Xsux" /* Cuneiform */ },
  { start: 77712, end: 77823, script: "Cpmn" /* Cypro_Minoan */ },
  { start: 77824, end: 78895, script: "Egyp" /* EgyptianHieroglyphs */ },
  { start: 78896, end: 78943, script: "Egyp" /* EgyptianHieroglyphs */ },
  { start: 82944, end: 83583, script: "Hluw" /* AnatolianHieroglyphs */ },
  { start: 92160, end: 92735, script: "Bamu" /* Bamum */ },
  { start: 92736, end: 92783, script: "Mroo" /* Mro */ },
  { start: 92784, end: 92879, script: "Tnsa" /* Tangsa */ },
  { start: 92880, end: 92927, script: "Bass" /* BassaVah */ },
  { start: 92928, end: 93071, script: "Hmng" /* PahawhHmong */ },
  { start: 93760, end: 93855, script: "Medf" /* Medefaidrin */ },
  { start: 93952, end: 94111, script: "Plrd" /* Miao */ },
  { start: 94176, end: 94207, script: "Zyyy" /* Common */ },
  { start: 94208, end: 100351, script: "Tang" /* Tangut */ },
  { start: 100352, end: 101119, script: "Tang" /* Tangut */ },
  { start: 101120, end: 101631, script: "Kits" /* KhitanSmallScript */ },
  { start: 101632, end: 101759, script: "Tang" /* Tangut */ },
  { start: 110576, end: 110591, script: "Kana" /* Katakana */ },
  { start: 110592, end: 110847, script: "Hira" /* Hiragana */ },
  { start: 110848, end: 110895, script: "Hira" /* Hiragana */ },
  { start: 110896, end: 110959, script: "Kana" /* Katakana */ },
  { start: 110960, end: 111359, script: "Nshu" /* Nushu */ },
  { start: 113664, end: 113823, script: "Dupl" /* Duployan */ },
  { start: 113824, end: 113839, script: "Zyyy" /* Common */ },
  { start: 118528, end: 118735, script: "Zyyy" /* Common */ },
  { start: 118784, end: 119039, script: "Zyyy" /* Common */ },
  { start: 119040, end: 119295, script: "Zyyy" /* Common */ },
  { start: 119296, end: 119375, script: "Grek" /* Greek */ },
  { start: 119488, end: 119519, script: "Zyyy" /* Common */ },
  { start: 119520, end: 119551, script: "Zyyy" /* Common */ },
  { start: 119552, end: 119647, script: "Zyyy" /* Common */ },
  { start: 119648, end: 119679, script: "Zyyy" /* Common */ },
  { start: 119808, end: 120831, script: "Zyyy" /* Common */ },
  { start: 120832, end: 121519, script: "Sgnw" /* SignWriting */ },
  { start: 122624, end: 122879, script: "Latn" /* Latin */ },
  { start: 122880, end: 122927, script: "Glag" /* Glagolitic */ },
  { start: 122928, end: 123023, script: "Cyrl" /* Cyrillic */ },
  { start: 123136, end: 123215, script: "Hmnp" /* NyiakengPuachueHmong */ },
  { start: 123536, end: 123583, script: "Toto" /* Toto */ },
  { start: 123584, end: 123647, script: "Wcho" /* Wancho */ },
  { start: 124112, end: 124159, script: "Nagm" /* NagMundari */ },
  { start: 124896, end: 124927, script: "Ethi" /* Ethiopic */ },
  { start: 124928, end: 125151, script: "Mend" /* MendeKikakui */ },
  { start: 125184, end: 125279, script: "Adlm" /* Adlam */ },
  { start: 126064, end: 126143, script: "Zyyy" /* Common */ },
  { start: 126208, end: 126287, script: "Zyyy" /* Common */ },
  { start: 126464, end: 126719, script: "Arab" /* Arabic */ },
  { start: 126976, end: 127023, script: "Zyyy" /* Common */ },
  { start: 127024, end: 127135, script: "Zyyy" /* Common */ },
  { start: 127136, end: 127231, script: "Zyyy" /* Common */ },
  { start: 127232, end: 127487, script: "Zyyy" /* Common */ },
  { start: 127488, end: 127743, script: "Zyyy" /* Common */ },
  { start: 127744, end: 128511, script: "Zyyy" /* Common */ },
  { start: 128512, end: 128591, script: "Zyyy" /* Common */ },
  { start: 128592, end: 128639, script: "Zyyy" /* Common */ },
  { start: 128640, end: 128767, script: "Zyyy" /* Common */ },
  { start: 128768, end: 128895, script: "Zyyy" /* Common */ },
  { start: 128896, end: 129023, script: "Zyyy" /* Common */ },
  { start: 129024, end: 129279, script: "Zyyy" /* Common */ },
  { start: 129280, end: 129535, script: "Zyyy" /* Common */ },
  { start: 129536, end: 129647, script: "Zyyy" /* Common */ },
  { start: 129648, end: 129791, script: "Zyyy" /* Common */ },
  { start: 129792, end: 130047, script: "Zyyy" /* Common */ },
  { start: 131072, end: 173791, script: "Hani" /* Han */ },
  { start: 173824, end: 177983, script: "Hani" /* Han */ },
  { start: 177984, end: 178207, script: "Hani" /* Han */ },
  { start: 178208, end: 183983, script: "Hani" /* Han */ },
  { start: 183984, end: 191471, script: "Hani" /* Han */ },
  { start: 194560, end: 195103, script: "Hani" /* Han */ },
  { start: 196608, end: 201551, script: "Hani" /* Han */ },
  { start: 201552, end: 205743, script: "Hani" /* Han */ },
  { start: 917504, end: 917631, script: "Zyyy" /* Common */ },
  { start: 917760, end: 917999, script: "Zinh" /* Inherited */ },
  { start: 983040, end: 1048575, script: "Zzzz" /* Unknown */ },
  { start: 1048576, end: 1114111, script: "Zzzz" /* Unknown */ }
];
function getScript(cp) {
  let left = 0;
  let right = SCRIPT_RANGES.length - 1;
  while (left <= right) {
    const mid = left + right >>> 1;
    const range = SCRIPT_RANGES[mid];
    if (cp < range.start) {
      right = mid - 1;
    } else if (cp > range.end) {
      left = mid + 1;
    } else {
      return range.script;
    }
  }
  return "Zzzz" /* Unknown */;
}
function detectScript(text) {
  const counts = new Map;
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    const cp = char2.codePointAt(0) ?? 0;
    const script = getScript(cp);
    if (script === "Zyyy" /* Common */ || script === "Zinh" /* Inherited */) {
      continue;
    }
    counts.set(script, (counts.get(script) ?? 0) + 1);
  }
  if (counts.size === 0) {
    return "Zyyy" /* Common */;
  }
  let maxScript = "Zyyy" /* Common */;
  let maxCount = 0;
  const entries = [...counts];
  for (let i = 0;i < entries.length; i++) {
    const [script, count] = entries[i];
    if (count > maxCount) {
      maxCount = count;
      maxScript = script;
    }
  }
  return maxScript;
}
function getScripts(text) {
  const scripts = new Set;
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    const cp = char2.codePointAt(0) ?? 0;
    const script = getScript(cp);
    scripts.add(script);
  }
  return [...scripts];
}
function isScript(text, script) {
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    const cp = char2.codePointAt(0) ?? 0;
    const charScript = getScript(cp);
    if (charScript !== script && charScript !== "Zyyy" /* Common */ && charScript !== "Zinh" /* Inherited */) {
      return false;
    }
  }
  return true;
}
function getScriptRuns(text) {
  const runs = [];
  if (text.length === 0)
    return runs;
  let currentScript = null;
  let runStart = 0;
  const _charIndex = 0;
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    const cp = char2.codePointAt(0) ?? 0;
    let script = getScript(cp);
    if (script === "Zyyy" /* Common */ || script === "Zinh" /* Inherited */) {
      if (currentScript !== null) {
        script = currentScript;
      }
    }
    if (currentScript === null) {
      currentScript = script;
      runStart = i;
    } else if (script !== currentScript && script !== "Zyyy" /* Common */ && script !== "Zinh" /* Inherited */) {
      runs.push({
        script: currentScript,
        start: runStart,
        end: i,
        text: chars.slice(runStart, i).join("")
      });
      currentScript = script;
      runStart = i;
    }
  }
  if (currentScript !== null) {
    runs.push({
      script: currentScript,
      start: runStart,
      end: chars.length,
      text: chars.slice(runStart).join("")
    });
  }
  return runs;
}
function getScriptTag(script) {
  const tagMap = {
    ["Zyyy" /* Common */]: "DFLT",
    ["Zinh" /* Inherited */]: "DFLT",
    ["Zzzz" /* Unknown */]: "DFLT",
    ["Latn" /* Latin */]: "latn",
    ["Grek" /* Greek */]: "grek",
    ["Cyrl" /* Cyrillic */]: "cyrl",
    ["Armn" /* Armenian */]: "armn",
    ["Hebr" /* Hebrew */]: "hebr",
    ["Arab" /* Arabic */]: "arab",
    ["Syrc" /* Syriac */]: "syrc",
    ["Thaa" /* Thaana */]: "thaa",
    ["Deva" /* Devanagari */]: "deva",
    ["Beng" /* Bengali */]: "beng",
    ["Guru" /* Gurmukhi */]: "guru",
    ["Gujr" /* Gujarati */]: "gujr",
    ["Orya" /* Oriya */]: "orya",
    ["Taml" /* Tamil */]: "taml",
    ["Telu" /* Telugu */]: "telu",
    ["Knda" /* Kannada */]: "knda",
    ["Mlym" /* Malayalam */]: "mlym",
    ["Sinh" /* Sinhala */]: "sinh",
    ["Thai" /* Thai */]: "thai",
    ["Laoo" /* Lao */]: "lao ",
    ["Tibt" /* Tibetan */]: "tibt",
    ["Mymr" /* Myanmar */]: "mymr",
    ["Geor" /* Georgian */]: "geor",
    ["Hang" /* Hangul */]: "hang",
    ["Ethi" /* Ethiopic */]: "ethi",
    ["Cher" /* Cherokee */]: "cher",
    ["Cans" /* CanadianAboriginal */]: "cans",
    ["Ogam" /* Ogham */]: "ogam",
    ["Runr" /* Runic */]: "runr",
    ["Khmr" /* Khmer */]: "khmr",
    ["Mong" /* Mongolian */]: "mong",
    ["Hira" /* Hiragana */]: "kana",
    ["Kana" /* Katakana */]: "kana",
    ["Bopo" /* Bopomofo */]: "bopo",
    ["Hani" /* Han */]: "hani",
    ["Yiii" /* Yi */]: "yi  ",
    ["Ital" /* OldItalic */]: "ital",
    ["Goth" /* Gothic */]: "goth",
    ["Dsrt" /* Deseret */]: "dsrt",
    ["Tglg" /* Tagalog */]: "tglg",
    ["Hano" /* Hanunoo */]: "hano",
    ["Buhd" /* Buhid */]: "buhd",
    ["Tagb" /* Tagbanwa */]: "tagb",
    ["Limb" /* Limbu */]: "limb",
    ["Tale" /* TaiLe */]: "tale",
    ["Linb" /* LinearB */]: "linb",
    ["Ugar" /* Ugaritic */]: "ugar",
    ["Shaw" /* Shavian */]: "shaw",
    ["Osma" /* Osmanya */]: "osma",
    ["Cprt" /* Cypriot */]: "cprt",
    ["Brai" /* Braille */]: "brai",
    ["Bugi" /* Buginese */]: "bugi",
    ["Copt" /* Coptic */]: "copt",
    ["Talu" /* NewTaiLue */]: "talu",
    ["Glag" /* Glagolitic */]: "glag",
    ["Tfng" /* Tifinagh */]: "tfng",
    ["Sylo" /* SylotiNagri */]: "sylo",
    ["Xpeo" /* OldPersian */]: "xpeo",
    ["Khar" /* Kharoshthi */]: "khar",
    ["Bali" /* Balinese */]: "bali",
    ["Xsux" /* Cuneiform */]: "xsux",
    ["Phnx" /* Phoenician */]: "phnx",
    ["Phag" /* PhagsPa */]: "phag",
    ["Nkoo" /* Nko */]: "nko ",
    ["Sund" /* Sundanese */]: "sund",
    ["Lepc" /* Lepcha */]: "lepc",
    ["Olck" /* OlChiki */]: "olck",
    ["Vaii" /* Vai */]: "vai ",
    ["Saur" /* Saurashtra */]: "saur",
    ["Kali" /* KayahLi */]: "kali",
    ["Rjng" /* Rejang */]: "rjng",
    ["Lyci" /* Lycian */]: "lyci",
    ["Cari" /* Carian */]: "cari",
    ["Lydi" /* Lydian */]: "lydi",
    ["Cham" /* Cham */]: "cham",
    ["Lana" /* TaiTham */]: "lana",
    ["Tavt" /* TaiViet */]: "tavt",
    ["Avst" /* Avestan */]: "avst",
    ["Egyp" /* EgyptianHieroglyphs */]: "egyp",
    ["Samr" /* Samaritan */]: "samr",
    ["Lisu" /* Lisu */]: "lisu",
    ["Bamu" /* Bamum */]: "bamu",
    ["Java" /* Javanese */]: "java",
    ["Mtei" /* MeeteiMayek */]: "mtei",
    ["Armi" /* ImperialAramaic */]: "armi",
    ["Sarb" /* OldSouthArabian */]: "sarb",
    ["Prti" /* InscriptionalParthian */]: "prti",
    ["Phli" /* InscriptionalPahlavi */]: "phli",
    ["Orkh" /* OldTurkic */]: "orkh",
    ["Kthi" /* Kaithi */]: "kthi",
    ["Batk" /* Batak */]: "batk",
    ["Brah" /* Brahmi */]: "brah",
    ["Mand" /* Mandaic */]: "mand",
    ["Cakm" /* Chakma */]: "cakm",
    ["Merc" /* MeroiticCursive */]: "merc",
    ["Mero" /* MeroiticHieroglyphs */]: "mero",
    ["Plrd" /* Miao */]: "plrd",
    ["Shrd" /* Sharada */]: "shrd",
    ["Sora" /* SoraSompeng */]: "sora",
    ["Takr" /* Takri */]: "takr",
    ["Aghb" /* CaucasianAlbanian */]: "aghb",
    ["Bass" /* BassaVah */]: "bass",
    ["Dupl" /* Duployan */]: "dupl",
    ["Elba" /* Elbasan */]: "elba",
    ["Gran" /* Grantha */]: "gran",
    ["Hmng" /* PahawhHmong */]: "hmng",
    ["Khoj" /* Khojki */]: "khoj",
    ["Lina" /* LinearA */]: "lina",
    ["Mahj" /* Mahajani */]: "mahj",
    ["Mani" /* Manichaean */]: "mani",
    ["Mend" /* MendeKikakui */]: "mend",
    ["Modi" /* Modi */]: "modi",
    ["Mroo" /* Mro */]: "mroo",
    ["Narb" /* OldNorthArabian */]: "narb",
    ["Nbat" /* Nabataean */]: "nbat",
    ["Palm" /* Palmyrene */]: "palm",
    ["Pauc" /* PauCinHau */]: "pauc",
    ["Perm" /* OldPermic */]: "perm",
    ["Phlp" /* PsalterPahlavi */]: "phlp",
    ["Sidd" /* Siddham */]: "sidd",
    ["Sind" /* Khudawadi */]: "sind",
    ["Tirh" /* Tirhuta */]: "tirh",
    ["Wara" /* WarangCiti */]: "wara",
    ["Ahom" /* Ahom */]: "ahom",
    ["Hluw" /* AnatolianHieroglyphs */]: "hluw",
    ["Hatr" /* Hatran */]: "hatr",
    ["Mult" /* Multani */]: "mult",
    ["Hung" /* OldHungarian */]: "hung",
    ["Sgnw" /* SignWriting */]: "sgnw",
    ["Adlm" /* Adlam */]: "adlm",
    ["Bhks" /* Bhaiksuki */]: "bhks",
    ["Marc" /* Marchen */]: "marc",
    ["Newa" /* Newa */]: "newa",
    ["Osge" /* Osage */]: "osge",
    ["Tang" /* Tangut */]: "tang",
    ["Gonm" /* MasaramGondi */]: "gonm",
    ["Nshu" /* Nushu */]: "nshu",
    ["Soyo" /* Soyombo */]: "soyo",
    ["Zanb" /* ZanabazarSquare */]: "zanb",
    ["Dogr" /* Dogra */]: "dogr",
    ["Gong" /* GunjalaGondi */]: "gong",
    ["Maka" /* Makasar */]: "maka",
    ["Medf" /* Medefaidrin */]: "medf",
    ["Rohg" /* HanifiRohingya */]: "rohg",
    ["Sogd" /* Sogdian */]: "sogd",
    ["Sogo" /* OldSogdian */]: "sogo",
    ["Elym" /* Elymaic */]: "elym",
    ["Nand" /* Nandinagari */]: "nand",
    ["Hmnp" /* NyiakengPuachueHmong */]: "hmnp",
    ["Wcho" /* Wancho */]: "wcho",
    ["Yezi" /* Yezidi */]: "yezi",
    ["Chrs" /* Chorasmian */]: "chrs",
    ["Diak" /* DivesAkuru */]: "diak",
    ["Kits" /* KhitanSmallScript */]: "kits",
    ["Vith" /* Vithkuqi */]: "vith",
    ["Ougr" /* OldUyghur */]: "ougr",
    ["Cpmn" /* Cypro_Minoan */]: "cpmn",
    ["Tnsa" /* Tangsa */]: "tnsa",
    ["Toto" /* Toto */]: "toto",
    ["Kawi" /* Kawi */]: "kawi",
    ["Nagm" /* NagMundari */]: "nagm"
  };
  return tagMap[script] ?? "DFLT";
}
var COMPLEX_SCRIPTS = new Set([
  "Arab" /* Arabic */,
  "Syrc" /* Syriac */,
  "Hebr" /* Hebrew */,
  "Thaa" /* Thaana */,
  "Nkoo" /* Nko */,
  "Deva" /* Devanagari */,
  "Beng" /* Bengali */,
  "Guru" /* Gurmukhi */,
  "Gujr" /* Gujarati */,
  "Orya" /* Oriya */,
  "Taml" /* Tamil */,
  "Telu" /* Telugu */,
  "Knda" /* Kannada */,
  "Mlym" /* Malayalam */,
  "Sinh" /* Sinhala */,
  "Thai" /* Thai */,
  "Laoo" /* Lao */,
  "Tibt" /* Tibetan */,
  "Mymr" /* Myanmar */,
  "Khmr" /* Khmer */,
  "Mong" /* Mongolian */,
  "Hang" /* Hangul */
]);
var RTL_SCRIPTS = new Set([
  "Arab" /* Arabic */,
  "Hebr" /* Hebrew */,
  "Syrc" /* Syriac */,
  "Thaa" /* Thaana */,
  "Nkoo" /* Nko */,
  "Samr" /* Samaritan */,
  "Mand" /* Mandaic */,
  "Armi" /* ImperialAramaic */,
  "Phnx" /* Phoenician */,
  "Sarb" /* OldSouthArabian */,
  "Narb" /* OldNorthArabian */,
  "Avst" /* Avestan */,
  "Prti" /* InscriptionalParthian */,
  "Phli" /* InscriptionalPahlavi */,
  "Phlp" /* PsalterPahlavi */,
  "Hatr" /* Hatran */,
  "Lydi" /* Lydian */,
  "Nbat" /* Nabataean */,
  "Palm" /* Palmyrene */,
  "Mani" /* Manichaean */,
  "Mend" /* MendeKikakui */,
  "Rohg" /* HanifiRohingya */,
  "Yezi" /* Yezidi */,
  "Sogo" /* OldSogdian */,
  "Sogd" /* Sogdian */,
  "Elym" /* Elymaic */,
  "Chrs" /* Chorasmian */,
  "Ougr" /* OldUyghur */,
  "Adlm" /* Adlam */
]);
function isComplexScript(script) {
  return COMPLEX_SCRIPTS.has(script);
}
function getScriptDirection(script) {
  return RTL_SCRIPTS.has(script) ? "rtl" : "ltr";
}
// reference/text-shaper/src/unicode/segmentation.ts
var GraphemeBreakProperty;
((GraphemeBreakProperty2) => {
  GraphemeBreakProperty2[GraphemeBreakProperty2["Other"] = 0] = "Other";
  GraphemeBreakProperty2[GraphemeBreakProperty2["CR"] = 1] = "CR";
  GraphemeBreakProperty2[GraphemeBreakProperty2["LF"] = 2] = "LF";
  GraphemeBreakProperty2[GraphemeBreakProperty2["Control"] = 3] = "Control";
  GraphemeBreakProperty2[GraphemeBreakProperty2["Extend"] = 4] = "Extend";
  GraphemeBreakProperty2[GraphemeBreakProperty2["ZWJ"] = 5] = "ZWJ";
  GraphemeBreakProperty2[GraphemeBreakProperty2["Regional_Indicator"] = 6] = "Regional_Indicator";
  GraphemeBreakProperty2[GraphemeBreakProperty2["Prepend"] = 7] = "Prepend";
  GraphemeBreakProperty2[GraphemeBreakProperty2["SpacingMark"] = 8] = "SpacingMark";
  GraphemeBreakProperty2[GraphemeBreakProperty2["L"] = 9] = "L";
  GraphemeBreakProperty2[GraphemeBreakProperty2["V"] = 10] = "V";
  GraphemeBreakProperty2[GraphemeBreakProperty2["T"] = 11] = "T";
  GraphemeBreakProperty2[GraphemeBreakProperty2["LV"] = 12] = "LV";
  GraphemeBreakProperty2[GraphemeBreakProperty2["LVT"] = 13] = "LVT";
  GraphemeBreakProperty2[GraphemeBreakProperty2["Extended_Pictographic"] = 14] = "Extended_Pictographic";
})(GraphemeBreakProperty ||= {});
var WordBreakProperty;
((WordBreakProperty2) => {
  WordBreakProperty2[WordBreakProperty2["Other"] = 0] = "Other";
  WordBreakProperty2[WordBreakProperty2["CR"] = 1] = "CR";
  WordBreakProperty2[WordBreakProperty2["LF"] = 2] = "LF";
  WordBreakProperty2[WordBreakProperty2["Newline"] = 3] = "Newline";
  WordBreakProperty2[WordBreakProperty2["Extend"] = 4] = "Extend";
  WordBreakProperty2[WordBreakProperty2["ZWJ"] = 5] = "ZWJ";
  WordBreakProperty2[WordBreakProperty2["Regional_Indicator"] = 6] = "Regional_Indicator";
  WordBreakProperty2[WordBreakProperty2["Format"] = 7] = "Format";
  WordBreakProperty2[WordBreakProperty2["Katakana"] = 8] = "Katakana";
  WordBreakProperty2[WordBreakProperty2["Hebrew_Letter"] = 9] = "Hebrew_Letter";
  WordBreakProperty2[WordBreakProperty2["ALetter"] = 10] = "ALetter";
  WordBreakProperty2[WordBreakProperty2["Single_Quote"] = 11] = "Single_Quote";
  WordBreakProperty2[WordBreakProperty2["Double_Quote"] = 12] = "Double_Quote";
  WordBreakProperty2[WordBreakProperty2["MidNumLet"] = 13] = "MidNumLet";
  WordBreakProperty2[WordBreakProperty2["MidLetter"] = 14] = "MidLetter";
  WordBreakProperty2[WordBreakProperty2["MidNum"] = 15] = "MidNum";
  WordBreakProperty2[WordBreakProperty2["Numeric"] = 16] = "Numeric";
  WordBreakProperty2[WordBreakProperty2["ExtendNumLet"] = 17] = "ExtendNumLet";
  WordBreakProperty2[WordBreakProperty2["WSegSpace"] = 18] = "WSegSpace";
  WordBreakProperty2[WordBreakProperty2["Extended_Pictographic"] = 19] = "Extended_Pictographic";
})(WordBreakProperty ||= {});
function getGraphemeBreakProperty(cp) {
  if (cp === 13)
    return 1 /* CR */;
  if (cp === 10)
    return 2 /* LF */;
  if (cp >= 0 && cp <= 31 && cp !== 10 && cp !== 13)
    return 3 /* Control */;
  if (cp >= 127 && cp <= 159)
    return 3 /* Control */;
  if (cp === 173)
    return 3 /* Control */;
  if (cp === 1564)
    return 3 /* Control */;
  if (cp === 6158)
    return 3 /* Control */;
  if (cp === 8203)
    return 3 /* Control */;
  if (cp >= 8206 && cp <= 8207)
    return 3 /* Control */;
  if (cp >= 8232 && cp <= 8238)
    return 3 /* Control */;
  if (cp >= 8288 && cp <= 8303)
    return 3 /* Control */;
  if (cp === 65279)
    return 3 /* Control */;
  if (cp >= 65520 && cp <= 65531)
    return 3 /* Control */;
  if (cp === 8205)
    return 5 /* ZWJ */;
  if (cp >= 127456 && cp <= 127487)
    return 6 /* Regional_Indicator */;
  if (cp === 1536 || cp === 1537 || cp === 1538 || cp === 1539 || cp === 1540 || cp === 1541 || cp === 1757 || cp === 1807 || cp === 2192 || cp === 2193 || cp === 2274 || cp === 69821 || cp === 69837)
    return 7 /* Prepend */;
  if (cp >= 4352 && cp <= 4447)
    return 9 /* L */;
  if (cp >= 43360 && cp <= 43388)
    return 9 /* L */;
  if (cp >= 4448 && cp <= 4519)
    return 10 /* V */;
  if (cp >= 55216 && cp <= 55238)
    return 10 /* V */;
  if (cp >= 4520 && cp <= 4607)
    return 11 /* T */;
  if (cp >= 55243 && cp <= 55291)
    return 11 /* T */;
  if (cp >= 44032 && cp <= 55203) {
    const sIndex = cp - 44032;
    if (sIndex % 28 === 0)
      return 12 /* LV */;
    return 13 /* LVT */;
  }
  if (cp >= 127744 && cp <= 129535)
    return 14 /* Extended_Pictographic */;
  if (cp >= 129536 && cp <= 129791)
    return 14 /* Extended_Pictographic */;
  if (cp >= 9728 && cp <= 9983)
    return 14 /* Extended_Pictographic */;
  if (cp >= 9984 && cp <= 10175)
    return 14 /* Extended_Pictographic */;
  if (cp === 169 || cp === 174)
    return 14 /* Extended_Pictographic */;
  if (cp >= 8960 && cp <= 9215)
    return 14 /* Extended_Pictographic */;
  if (cp >= 126976 && cp <= 127023)
    return 14 /* Extended_Pictographic */;
  if (cp >= 127136 && cp <= 127231)
    return 14 /* Extended_Pictographic */;
  if (cp >= 127232 && cp <= 127487)
    return 14 /* Extended_Pictographic */;
  if (cp >= 127488 && cp <= 127743)
    return 14 /* Extended_Pictographic */;
  if (cp >= 2307 && cp <= 2307)
    return 8 /* SpacingMark */;
  if (cp >= 2363 && cp <= 2363)
    return 8 /* SpacingMark */;
  if (cp >= 2366 && cp <= 2368)
    return 8 /* SpacingMark */;
  if (cp >= 2377 && cp <= 2380)
    return 8 /* SpacingMark */;
  if (cp >= 2382 && cp <= 2383)
    return 8 /* SpacingMark */;
  if (cp >= 2434 && cp <= 2435)
    return 8 /* SpacingMark */;
  if (cp >= 2494 && cp <= 2496)
    return 8 /* SpacingMark */;
  if (cp >= 2503 && cp <= 2508)
    return 8 /* SpacingMark */;
  if (cp === 2519)
    return 8 /* SpacingMark */;
  if (cp >= 2563 && cp <= 2563)
    return 8 /* SpacingMark */;
  if (cp >= 2622 && cp <= 2624)
    return 8 /* SpacingMark */;
  if (cp >= 2691 && cp <= 2691)
    return 8 /* SpacingMark */;
  if (cp >= 2750 && cp <= 2752)
    return 8 /* SpacingMark */;
  if (cp === 2761)
    return 8 /* SpacingMark */;
  if (cp >= 2763 && cp <= 2764)
    return 8 /* SpacingMark */;
  if (cp >= 2818 && cp <= 2819)
    return 8 /* SpacingMark */;
  if (cp === 2878)
    return 8 /* SpacingMark */;
  if (cp === 2880)
    return 8 /* SpacingMark */;
  if (cp >= 2887 && cp <= 2892)
    return 8 /* SpacingMark */;
  if (cp === 2903)
    return 8 /* SpacingMark */;
  if (cp >= 3006 && cp <= 3007)
    return 8 /* SpacingMark */;
  if (cp >= 3009 && cp <= 3020)
    return 8 /* SpacingMark */;
  if (cp === 3031)
    return 8 /* SpacingMark */;
  if (cp >= 3073 && cp <= 3075)
    return 8 /* SpacingMark */;
  if (cp >= 3137 && cp <= 3140)
    return 8 /* SpacingMark */;
  if (cp >= 3202 && cp <= 3203)
    return 8 /* SpacingMark */;
  if (cp === 3262)
    return 8 /* SpacingMark */;
  if (cp >= 3264 && cp <= 3268)
    return 8 /* SpacingMark */;
  if (cp >= 3271 && cp <= 3275)
    return 8 /* SpacingMark */;
  if (cp >= 3285 && cp <= 3286)
    return 8 /* SpacingMark */;
  if (cp >= 3330 && cp <= 3331)
    return 8 /* SpacingMark */;
  if (cp >= 3390 && cp <= 3392)
    return 8 /* SpacingMark */;
  if (cp >= 3398 && cp <= 3404)
    return 8 /* SpacingMark */;
  if (cp === 3415)
    return 8 /* SpacingMark */;
  if (cp >= 3458 && cp <= 3459)
    return 8 /* SpacingMark */;
  if (cp >= 3535 && cp <= 3537)
    return 8 /* SpacingMark */;
  if (cp >= 3544 && cp <= 3551)
    return 8 /* SpacingMark */;
  if (cp >= 3570 && cp <= 3571)
    return 8 /* SpacingMark */;
  if (cp === 3902 || cp === 3903)
    return 8 /* SpacingMark */;
  if (cp === 3967)
    return 8 /* SpacingMark */;
  if (cp >= 4139 && cp <= 4140)
    return 8 /* SpacingMark */;
  if (cp === 4145)
    return 8 /* SpacingMark */;
  if (cp === 4152)
    return 8 /* SpacingMark */;
  if (cp >= 4155 && cp <= 4156)
    return 8 /* SpacingMark */;
  if (cp >= 4182 && cp <= 4183)
    return 8 /* SpacingMark */;
  if (cp === 4194)
    return 8 /* SpacingMark */;
  if (cp >= 4199 && cp <= 4200)
    return 8 /* SpacingMark */;
  if (cp >= 4227 && cp <= 4228)
    return 8 /* SpacingMark */;
  if (cp >= 4231 && cp <= 4236)
    return 8 /* SpacingMark */;
  if (cp === 4239)
    return 8 /* SpacingMark */;
  if (cp >= 4250 && cp <= 4252)
    return 8 /* SpacingMark */;
  if (cp >= 6070 && cp <= 6070)
    return 8 /* SpacingMark */;
  if (cp >= 6078 && cp <= 6085)
    return 8 /* SpacingMark */;
  if (cp >= 6087 && cp <= 6088)
    return 8 /* SpacingMark */;
  if (cp >= 6435 && cp <= 6438)
    return 8 /* SpacingMark */;
  if (cp >= 6441 && cp <= 6443)
    return 8 /* SpacingMark */;
  if (cp >= 6448 && cp <= 6449)
    return 8 /* SpacingMark */;
  if (cp >= 6451 && cp <= 6456)
    return 8 /* SpacingMark */;
  if (cp >= 768 && cp <= 879)
    return 4 /* Extend */;
  if (cp >= 1155 && cp <= 1161)
    return 4 /* Extend */;
  if (cp >= 1425 && cp <= 1469)
    return 4 /* Extend */;
  if (cp === 1471)
    return 4 /* Extend */;
  if (cp >= 1473 && cp <= 1474)
    return 4 /* Extend */;
  if (cp >= 1476 && cp <= 1477)
    return 4 /* Extend */;
  if (cp === 1479)
    return 4 /* Extend */;
  if (cp >= 1552 && cp <= 1562)
    return 4 /* Extend */;
  if (cp >= 1611 && cp <= 1631)
    return 4 /* Extend */;
  if (cp === 1648)
    return 4 /* Extend */;
  if (cp >= 1750 && cp <= 1756)
    return 4 /* Extend */;
  if (cp >= 1759 && cp <= 1764)
    return 4 /* Extend */;
  if (cp >= 1767 && cp <= 1768)
    return 4 /* Extend */;
  if (cp >= 1770 && cp <= 1773)
    return 4 /* Extend */;
  if (cp === 1809)
    return 4 /* Extend */;
  if (cp >= 1840 && cp <= 1866)
    return 4 /* Extend */;
  if (cp >= 1958 && cp <= 1968)
    return 4 /* Extend */;
  if (cp >= 2027 && cp <= 2035)
    return 4 /* Extend */;
  if (cp === 2045)
    return 4 /* Extend */;
  if (cp >= 2070 && cp <= 2073)
    return 4 /* Extend */;
  if (cp >= 2075 && cp <= 2083)
    return 4 /* Extend */;
  if (cp >= 2085 && cp <= 2087)
    return 4 /* Extend */;
  if (cp >= 2089 && cp <= 2093)
    return 4 /* Extend */;
  if (cp >= 2137 && cp <= 2139)
    return 4 /* Extend */;
  if (cp >= 2259 && cp <= 2273)
    return 4 /* Extend */;
  if (cp >= 2275 && cp <= 2306)
    return 4 /* Extend */;
  if (cp === 2362)
    return 4 /* Extend */;
  if (cp === 2364)
    return 4 /* Extend */;
  if (cp >= 2369 && cp <= 2376)
    return 4 /* Extend */;
  if (cp === 2381)
    return 4 /* Extend */;
  if (cp >= 2385 && cp <= 2391)
    return 4 /* Extend */;
  if (cp >= 2402 && cp <= 2403)
    return 4 /* Extend */;
  if (cp === 2433)
    return 4 /* Extend */;
  if (cp === 2492)
    return 4 /* Extend */;
  if (cp >= 2497 && cp <= 2500)
    return 4 /* Extend */;
  if (cp === 2509)
    return 4 /* Extend */;
  if (cp >= 2530 && cp <= 2531)
    return 4 /* Extend */;
  if (cp === 2558)
    return 4 /* Extend */;
  if (cp >= 2561 && cp <= 2562)
    return 4 /* Extend */;
  if (cp === 2620)
    return 4 /* Extend */;
  if (cp >= 2625 && cp <= 2626)
    return 4 /* Extend */;
  if (cp >= 2631 && cp <= 2632)
    return 4 /* Extend */;
  if (cp >= 2635 && cp <= 2637)
    return 4 /* Extend */;
  if (cp === 2641)
    return 4 /* Extend */;
  if (cp >= 2672 && cp <= 2673)
    return 4 /* Extend */;
  if (cp === 2677)
    return 4 /* Extend */;
  if (cp >= 2689 && cp <= 2690)
    return 4 /* Extend */;
  if (cp === 2748)
    return 4 /* Extend */;
  if (cp >= 2753 && cp <= 2757)
    return 4 /* Extend */;
  if (cp >= 2759 && cp <= 2760)
    return 4 /* Extend */;
  if (cp === 2765)
    return 4 /* Extend */;
  if (cp >= 2786 && cp <= 2787)
    return 4 /* Extend */;
  if (cp >= 2810 && cp <= 2815)
    return 4 /* Extend */;
  if (cp === 2817)
    return 4 /* Extend */;
  if (cp === 2876)
    return 4 /* Extend */;
  if (cp === 2879)
    return 4 /* Extend */;
  if (cp >= 2881 && cp <= 2884)
    return 4 /* Extend */;
  if (cp === 2893)
    return 4 /* Extend */;
  if (cp >= 2901 && cp <= 2902)
    return 4 /* Extend */;
  if (cp >= 2914 && cp <= 2915)
    return 4 /* Extend */;
  if (cp === 2946)
    return 4 /* Extend */;
  if (cp === 3008)
    return 4 /* Extend */;
  if (cp === 3021)
    return 4 /* Extend */;
  if (cp === 3072)
    return 4 /* Extend */;
  if (cp === 3076)
    return 4 /* Extend */;
  if (cp >= 3134 && cp <= 3136)
    return 4 /* Extend */;
  if (cp >= 3142 && cp <= 3144)
    return 4 /* Extend */;
  if (cp >= 3146 && cp <= 3149)
    return 4 /* Extend */;
  if (cp >= 3157 && cp <= 3158)
    return 4 /* Extend */;
  if (cp >= 3170 && cp <= 3171)
    return 4 /* Extend */;
  if (cp === 3201)
    return 4 /* Extend */;
  if (cp === 3260)
    return 4 /* Extend */;
  if (cp === 3263)
    return 4 /* Extend */;
  if (cp === 3270)
    return 4 /* Extend */;
  if (cp >= 3276 && cp <= 3277)
    return 4 /* Extend */;
  if (cp >= 3298 && cp <= 3299)
    return 4 /* Extend */;
  if (cp >= 3328 && cp <= 3329)
    return 4 /* Extend */;
  if (cp >= 3387 && cp <= 3388)
    return 4 /* Extend */;
  if (cp >= 3393 && cp <= 3396)
    return 4 /* Extend */;
  if (cp === 3405)
    return 4 /* Extend */;
  if (cp >= 3426 && cp <= 3427)
    return 4 /* Extend */;
  if (cp === 3457)
    return 4 /* Extend */;
  if (cp === 3530)
    return 4 /* Extend */;
  if (cp >= 3538 && cp <= 3540)
    return 4 /* Extend */;
  if (cp === 3542)
    return 4 /* Extend */;
  if (cp === 3633)
    return 4 /* Extend */;
  if (cp >= 3636 && cp <= 3642)
    return 4 /* Extend */;
  if (cp >= 3655 && cp <= 3662)
    return 4 /* Extend */;
  if (cp === 3761)
    return 4 /* Extend */;
  if (cp >= 3764 && cp <= 3772)
    return 4 /* Extend */;
  if (cp >= 3784 && cp <= 3789)
    return 4 /* Extend */;
  if (cp >= 3864 && cp <= 3865)
    return 4 /* Extend */;
  if (cp === 3893)
    return 4 /* Extend */;
  if (cp === 3895)
    return 4 /* Extend */;
  if (cp === 3897)
    return 4 /* Extend */;
  if (cp >= 3953 && cp <= 3966)
    return 4 /* Extend */;
  if (cp >= 3968 && cp <= 3972)
    return 4 /* Extend */;
  if (cp >= 3974 && cp <= 3975)
    return 4 /* Extend */;
  if (cp >= 3981 && cp <= 3991)
    return 4 /* Extend */;
  if (cp >= 3993 && cp <= 4028)
    return 4 /* Extend */;
  if (cp === 4038)
    return 4 /* Extend */;
  if (cp >= 4141 && cp <= 4144)
    return 4 /* Extend */;
  if (cp >= 4146 && cp <= 4151)
    return 4 /* Extend */;
  if (cp >= 4153 && cp <= 4154)
    return 4 /* Extend */;
  if (cp >= 4157 && cp <= 4158)
    return 4 /* Extend */;
  if (cp >= 4184 && cp <= 4185)
    return 4 /* Extend */;
  if (cp >= 4190 && cp <= 4192)
    return 4 /* Extend */;
  if (cp >= 4209 && cp <= 4212)
    return 4 /* Extend */;
  if (cp === 4226)
    return 4 /* Extend */;
  if (cp >= 4229 && cp <= 4230)
    return 4 /* Extend */;
  if (cp === 4237)
    return 4 /* Extend */;
  if (cp === 4253)
    return 4 /* Extend */;
  if (cp >= 4957 && cp <= 4959)
    return 4 /* Extend */;
  if (cp >= 5906 && cp <= 5908)
    return 4 /* Extend */;
  if (cp >= 5938 && cp <= 5940)
    return 4 /* Extend */;
  if (cp >= 5970 && cp <= 5971)
    return 4 /* Extend */;
  if (cp >= 6002 && cp <= 6003)
    return 4 /* Extend */;
  if (cp >= 6068 && cp <= 6069)
    return 4 /* Extend */;
  if (cp >= 6071 && cp <= 6077)
    return 4 /* Extend */;
  if (cp === 6086)
    return 4 /* Extend */;
  if (cp >= 6089 && cp <= 6099)
    return 4 /* Extend */;
  if (cp === 6109)
    return 4 /* Extend */;
  if (cp >= 6155 && cp <= 6157)
    return 4 /* Extend */;
  if (cp === 6159)
    return 4 /* Extend */;
  if (cp >= 6277 && cp <= 6278)
    return 4 /* Extend */;
  if (cp === 6313)
    return 4 /* Extend */;
  if (cp >= 6432 && cp <= 6434)
    return 4 /* Extend */;
  if (cp >= 6439 && cp <= 6440)
    return 4 /* Extend */;
  if (cp === 6450)
    return 4 /* Extend */;
  if (cp >= 6457 && cp <= 6459)
    return 4 /* Extend */;
  if (cp >= 6679 && cp <= 6680)
    return 4 /* Extend */;
  if (cp === 6683)
    return 4 /* Extend */;
  if (cp === 6742)
    return 4 /* Extend */;
  if (cp >= 6744 && cp <= 6750)
    return 4 /* Extend */;
  if (cp === 6752)
    return 4 /* Extend */;
  if (cp === 6754)
    return 4 /* Extend */;
  if (cp >= 6757 && cp <= 6764)
    return 4 /* Extend */;
  if (cp >= 6771 && cp <= 6780)
    return 4 /* Extend */;
  if (cp === 6783)
    return 4 /* Extend */;
  if (cp >= 6832 && cp <= 6862)
    return 4 /* Extend */;
  if (cp >= 6912 && cp <= 6915)
    return 4 /* Extend */;
  if (cp === 6964)
    return 4 /* Extend */;
  if (cp >= 6966 && cp <= 6970)
    return 4 /* Extend */;
  if (cp === 6972)
    return 4 /* Extend */;
  if (cp === 6978)
    return 4 /* Extend */;
  if (cp >= 7019 && cp <= 7027)
    return 4 /* Extend */;
  if (cp >= 7040 && cp <= 7041)
    return 4 /* Extend */;
  if (cp >= 7074 && cp <= 7077)
    return 4 /* Extend */;
  if (cp >= 7080 && cp <= 7081)
    return 4 /* Extend */;
  if (cp >= 7083 && cp <= 7085)
    return 4 /* Extend */;
  if (cp === 7142)
    return 4 /* Extend */;
  if (cp >= 7144 && cp <= 7145)
    return 4 /* Extend */;
  if (cp === 7149)
    return 4 /* Extend */;
  if (cp >= 7151 && cp <= 7153)
    return 4 /* Extend */;
  if (cp >= 7212 && cp <= 7219)
    return 4 /* Extend */;
  if (cp >= 7222 && cp <= 7223)
    return 4 /* Extend */;
  if (cp >= 7376 && cp <= 7378)
    return 4 /* Extend */;
  if (cp >= 7380 && cp <= 7392)
    return 4 /* Extend */;
  if (cp >= 7394 && cp <= 7400)
    return 4 /* Extend */;
  if (cp === 7405)
    return 4 /* Extend */;
  if (cp === 7412)
    return 4 /* Extend */;
  if (cp >= 7416 && cp <= 7417)
    return 4 /* Extend */;
  if (cp >= 7616 && cp <= 7679)
    return 4 /* Extend */;
  if (cp >= 8400 && cp <= 8432)
    return 4 /* Extend */;
  if (cp >= 11503 && cp <= 11505)
    return 4 /* Extend */;
  if (cp === 11647)
    return 4 /* Extend */;
  if (cp >= 11744 && cp <= 11775)
    return 4 /* Extend */;
  if (cp >= 12330 && cp <= 12335)
    return 4 /* Extend */;
  if (cp >= 12441 && cp <= 12442)
    return 4 /* Extend */;
  if (cp >= 42607 && cp <= 42610)
    return 4 /* Extend */;
  if (cp >= 42612 && cp <= 42621)
    return 4 /* Extend */;
  if (cp >= 42654 && cp <= 42655)
    return 4 /* Extend */;
  if (cp >= 42736 && cp <= 42737)
    return 4 /* Extend */;
  if (cp === 43010)
    return 4 /* Extend */;
  if (cp === 43014)
    return 4 /* Extend */;
  if (cp === 43019)
    return 4 /* Extend */;
  if (cp >= 43045 && cp <= 43046)
    return 4 /* Extend */;
  if (cp === 43052)
    return 4 /* Extend */;
  if (cp >= 43204 && cp <= 43205)
    return 4 /* Extend */;
  if (cp >= 43232 && cp <= 43249)
    return 4 /* Extend */;
  if (cp === 43263)
    return 4 /* Extend */;
  if (cp >= 43302 && cp <= 43309)
    return 4 /* Extend */;
  if (cp >= 43335 && cp <= 43345)
    return 4 /* Extend */;
  if (cp >= 43392 && cp <= 43394)
    return 4 /* Extend */;
  if (cp === 43443)
    return 4 /* Extend */;
  if (cp >= 43446 && cp <= 43449)
    return 4 /* Extend */;
  if (cp >= 43452 && cp <= 43453)
    return 4 /* Extend */;
  if (cp === 43493)
    return 4 /* Extend */;
  if (cp >= 43561 && cp <= 43566)
    return 4 /* Extend */;
  if (cp >= 43569 && cp <= 43570)
    return 4 /* Extend */;
  if (cp >= 43573 && cp <= 43574)
    return 4 /* Extend */;
  if (cp === 43587)
    return 4 /* Extend */;
  if (cp === 43596)
    return 4 /* Extend */;
  if (cp === 43644)
    return 4 /* Extend */;
  if (cp === 43696)
    return 4 /* Extend */;
  if (cp >= 43698 && cp <= 43700)
    return 4 /* Extend */;
  if (cp >= 43703 && cp <= 43704)
    return 4 /* Extend */;
  if (cp >= 43710 && cp <= 43711)
    return 4 /* Extend */;
  if (cp === 43713)
    return 4 /* Extend */;
  if (cp >= 43756 && cp <= 43757)
    return 4 /* Extend */;
  if (cp === 43766)
    return 4 /* Extend */;
  if (cp === 44005)
    return 4 /* Extend */;
  if (cp === 44008)
    return 4 /* Extend */;
  if (cp === 44013)
    return 4 /* Extend */;
  if (cp === 64286)
    return 4 /* Extend */;
  if (cp >= 65024 && cp <= 65039)
    return 4 /* Extend */;
  if (cp >= 65056 && cp <= 65071)
    return 4 /* Extend */;
  if (cp >= 127995 && cp <= 127999)
    return 4 /* Extend */;
  if (cp >= 917760 && cp <= 917999)
    return 4 /* Extend */;
  return 0 /* Other */;
}
function getWordBreakProperty(cp) {
  if (cp === 13)
    return 1 /* CR */;
  if (cp === 10)
    return 2 /* LF */;
  if (cp === 11 || cp === 12 || cp === 133 || cp === 8232 || cp === 8233)
    return 3 /* Newline */;
  if (cp === 8205)
    return 5 /* ZWJ */;
  if (cp === 173)
    return 7 /* Format */;
  if (cp === 1564)
    return 7 /* Format */;
  if (cp === 8203)
    return 7 /* Format */;
  if (cp >= 8206 && cp <= 8207)
    return 7 /* Format */;
  if (cp >= 8288 && cp <= 8303)
    return 7 /* Format */;
  if (cp === 65279)
    return 7 /* Format */;
  if (cp >= 127456 && cp <= 127487)
    return 6 /* Regional_Indicator */;
  if (cp >= 127744 && cp <= 129535)
    return 19 /* Extended_Pictographic */;
  if (cp >= 129536 && cp <= 129791)
    return 19 /* Extended_Pictographic */;
  if (cp >= 9728 && cp <= 9983)
    return 19 /* Extended_Pictographic */;
  if (cp >= 9984 && cp <= 10175)
    return 19 /* Extended_Pictographic */;
  if (cp >= 1488 && cp <= 1514)
    return 9 /* Hebrew_Letter */;
  if (cp >= 64285 && cp <= 64335)
    return 9 /* Hebrew_Letter */;
  if (cp >= 12448 && cp <= 12543)
    return 8 /* Katakana */;
  if (cp === 12337 || cp === 12338 || cp === 12339 || cp === 12340 || cp === 12341)
    return 8 /* Katakana */;
  if (cp === 12443 || cp === 12444)
    return 8 /* Katakana */;
  if (cp >= 12784 && cp <= 12799)
    return 8 /* Katakana */;
  if (cp >= 13008 && cp <= 13054)
    return 8 /* Katakana */;
  if (cp >= 13056 && cp <= 13143)
    return 8 /* Katakana */;
  if (cp >= 65382 && cp <= 65437)
    return 8 /* Katakana */;
  if (cp === 39)
    return 11 /* Single_Quote */;
  if (cp === 34)
    return 12 /* Double_Quote */;
  if (cp === 46)
    return 13 /* MidNumLet */;
  if (cp === 8216 || cp === 8217)
    return 13 /* MidNumLet */;
  if (cp === 8228)
    return 13 /* MidNumLet */;
  if (cp === 65106)
    return 13 /* MidNumLet */;
  if (cp === 65287)
    return 13 /* MidNumLet */;
  if (cp === 65294)
    return 13 /* MidNumLet */;
  if (cp === 58)
    return 14 /* MidLetter */;
  if (cp === 183)
    return 14 /* MidLetter */;
  if (cp === 903)
    return 14 /* MidLetter */;
  if (cp === 1524)
    return 14 /* MidLetter */;
  if (cp === 8231)
    return 14 /* MidLetter */;
  if (cp === 65043)
    return 14 /* MidLetter */;
  if (cp === 65109)
    return 14 /* MidLetter */;
  if (cp === 65306)
    return 14 /* MidLetter */;
  if (cp === 44)
    return 15 /* MidNum */;
  if (cp === 59)
    return 15 /* MidNum */;
  if (cp === 894)
    return 15 /* MidNum */;
  if (cp === 1417)
    return 15 /* MidNum */;
  if (cp === 1548 || cp === 1549)
    return 15 /* MidNum */;
  if (cp === 1644)
    return 15 /* MidNum */;
  if (cp === 2040)
    return 15 /* MidNum */;
  if (cp === 8260)
    return 15 /* MidNum */;
  if (cp === 65040)
    return 15 /* MidNum */;
  if (cp === 65044)
    return 15 /* MidNum */;
  if (cp === 65104)
    return 15 /* MidNum */;
  if (cp === 65108)
    return 15 /* MidNum */;
  if (cp === 65292)
    return 15 /* MidNum */;
  if (cp === 65307)
    return 15 /* MidNum */;
  if (cp >= 48 && cp <= 57)
    return 16 /* Numeric */;
  if (cp >= 1632 && cp <= 1641)
    return 16 /* Numeric */;
  if (cp >= 1776 && cp <= 1785)
    return 16 /* Numeric */;
  if (cp >= 1984 && cp <= 1993)
    return 16 /* Numeric */;
  if (cp >= 2406 && cp <= 2415)
    return 16 /* Numeric */;
  if (cp >= 2534 && cp <= 2543)
    return 16 /* Numeric */;
  if (cp >= 2662 && cp <= 2671)
    return 16 /* Numeric */;
  if (cp >= 2790 && cp <= 2799)
    return 16 /* Numeric */;
  if (cp >= 2918 && cp <= 2927)
    return 16 /* Numeric */;
  if (cp >= 3046 && cp <= 3055)
    return 16 /* Numeric */;
  if (cp >= 3174 && cp <= 3183)
    return 16 /* Numeric */;
  if (cp >= 3302 && cp <= 3311)
    return 16 /* Numeric */;
  if (cp >= 3430 && cp <= 3439)
    return 16 /* Numeric */;
  if (cp >= 3558 && cp <= 3567)
    return 16 /* Numeric */;
  if (cp >= 3664 && cp <= 3673)
    return 16 /* Numeric */;
  if (cp >= 3792 && cp <= 3801)
    return 16 /* Numeric */;
  if (cp >= 3872 && cp <= 3881)
    return 16 /* Numeric */;
  if (cp >= 4160 && cp <= 4169)
    return 16 /* Numeric */;
  if (cp >= 4240 && cp <= 4249)
    return 16 /* Numeric */;
  if (cp >= 6112 && cp <= 6121)
    return 16 /* Numeric */;
  if (cp >= 6160 && cp <= 6169)
    return 16 /* Numeric */;
  if (cp >= 6470 && cp <= 6479)
    return 16 /* Numeric */;
  if (cp >= 6608 && cp <= 6617)
    return 16 /* Numeric */;
  if (cp >= 6784 && cp <= 6793)
    return 16 /* Numeric */;
  if (cp >= 6800 && cp <= 6809)
    return 16 /* Numeric */;
  if (cp >= 6992 && cp <= 7001)
    return 16 /* Numeric */;
  if (cp >= 7088 && cp <= 7097)
    return 16 /* Numeric */;
  if (cp >= 7232 && cp <= 7241)
    return 16 /* Numeric */;
  if (cp >= 7248 && cp <= 7257)
    return 16 /* Numeric */;
  if (cp >= 42528 && cp <= 42537)
    return 16 /* Numeric */;
  if (cp >= 43216 && cp <= 43225)
    return 16 /* Numeric */;
  if (cp >= 43264 && cp <= 43273)
    return 16 /* Numeric */;
  if (cp >= 43472 && cp <= 43481)
    return 16 /* Numeric */;
  if (cp >= 43504 && cp <= 43513)
    return 16 /* Numeric */;
  if (cp >= 43600 && cp <= 43609)
    return 16 /* Numeric */;
  if (cp >= 44016 && cp <= 44025)
    return 16 /* Numeric */;
  if (cp >= 65296 && cp <= 65305)
    return 16 /* Numeric */;
  if (cp === 95)
    return 17 /* ExtendNumLet */;
  if (cp === 8239)
    return 17 /* ExtendNumLet */;
  if (cp === 8256)
    return 17 /* ExtendNumLet */;
  if (cp === 8276)
    return 17 /* ExtendNumLet */;
  if (cp === 65075 || cp === 65076)
    return 17 /* ExtendNumLet */;
  if (cp >= 65101 && cp <= 65103)
    return 17 /* ExtendNumLet */;
  if (cp === 65343)
    return 17 /* ExtendNumLet */;
  if (cp === 32)
    return 18 /* WSegSpace */;
  if (cp === 5760)
    return 18 /* WSegSpace */;
  if (cp >= 8192 && cp <= 8202 && cp !== 8199)
    return 18 /* WSegSpace */;
  if (cp === 8287)
    return 18 /* WSegSpace */;
  if (cp === 12288)
    return 18 /* WSegSpace */;
  const gbp = getGraphemeBreakProperty(cp);
  if (gbp === 4 /* Extend */)
    return 4 /* Extend */;
  if (cp >= 65 && cp <= 90)
    return 10 /* ALetter */;
  if (cp >= 97 && cp <= 122)
    return 10 /* ALetter */;
  if (cp >= 192 && cp <= 214)
    return 10 /* ALetter */;
  if (cp >= 216 && cp <= 246)
    return 10 /* ALetter */;
  if (cp >= 248 && cp <= 591)
    return 10 /* ALetter */;
  if (cp >= 592 && cp <= 687)
    return 10 /* ALetter */;
  if (cp >= 880 && cp <= 1023)
    return 10 /* ALetter */;
  if (cp >= 1024 && cp <= 1279)
    return 10 /* ALetter */;
  if (cp >= 1280 && cp <= 1327)
    return 10 /* ALetter */;
  if (cp >= 1329 && cp <= 1366)
    return 10 /* ALetter */;
  if (cp >= 1376 && cp <= 1416)
    return 10 /* ALetter */;
  if (cp >= 1536 && cp <= 1791)
    return 10 /* ALetter */;
  if (cp >= 2304 && cp <= 2431)
    return 10 /* ALetter */;
  if (cp >= 2432 && cp <= 2559)
    return 10 /* ALetter */;
  if (cp >= 2560 && cp <= 2687)
    return 10 /* ALetter */;
  if (cp >= 2688 && cp <= 2815)
    return 10 /* ALetter */;
  if (cp >= 2816 && cp <= 2943)
    return 10 /* ALetter */;
  if (cp >= 2944 && cp <= 3071)
    return 10 /* ALetter */;
  if (cp >= 3072 && cp <= 3199)
    return 10 /* ALetter */;
  if (cp >= 3200 && cp <= 3327)
    return 10 /* ALetter */;
  if (cp >= 3328 && cp <= 3455)
    return 10 /* ALetter */;
  if (cp >= 3584 && cp <= 3711)
    return 10 /* ALetter */;
  if (cp >= 3712 && cp <= 3839)
    return 10 /* ALetter */;
  if (cp >= 4096 && cp <= 4255)
    return 10 /* ALetter */;
  if (cp >= 4256 && cp <= 4351)
    return 10 /* ALetter */;
  if (cp >= 4352 && cp <= 4607)
    return 10 /* ALetter */;
  if (cp >= 6016 && cp <= 6143)
    return 10 /* ALetter */;
  if (cp >= 12352 && cp <= 12447)
    return 10 /* ALetter */;
  if (cp >= 7936 && cp <= 8191)
    return 10 /* ALetter */;
  if (cp >= 11264 && cp <= 11359)
    return 10 /* ALetter */;
  if (cp >= 40960 && cp <= 42127)
    return 10 /* ALetter */;
  if (cp >= 42192 && cp <= 42239)
    return 10 /* ALetter */;
  if (cp >= 42240 && cp <= 42559)
    return 10 /* ALetter */;
  if (cp >= 42560 && cp <= 42655)
    return 10 /* ALetter */;
  if (cp >= 42784 && cp <= 43007)
    return 10 /* ALetter */;
  if (cp >= 43776 && cp <= 43887)
    return 10 /* ALetter */;
  if (cp >= 44032 && cp <= 55215)
    return 10 /* ALetter */;
  if (cp >= 64256 && cp <= 64262)
    return 10 /* ALetter */;
  if (cp >= 65313 && cp <= 65338)
    return 10 /* ALetter */;
  if (cp >= 65345 && cp <= 65370)
    return 10 /* ALetter */;
  return 0 /* Other */;
}
function findGraphemeBoundaries(codepoints) {
  const len = codepoints.length;
  const properties = [];
  const boundaries = [];
  for (let i = 0;i < codepoints.length; i++) {
    const cp = codepoints[i];
    properties.push(getGraphemeBreakProperty(cp));
  }
  if (len === 0)
    return { boundaries, properties };
  let riCount = 0;
  let inExtendedPictographicSequence = false;
  for (let i = 1;i < len; i++) {
    const prev = properties[i - 1];
    const curr = properties[i];
    let shouldBreak = true;
    if (prev === 1 /* CR */ && curr === 2 /* LF */) {
      shouldBreak = false;
    } else if (prev === 3 /* Control */ || prev === 1 /* CR */ || prev === 2 /* LF */) {
      shouldBreak = true;
    } else if (curr === 3 /* Control */ || curr === 1 /* CR */ || curr === 2 /* LF */) {
      shouldBreak = true;
    } else if (prev === 9 /* L */ && (curr === 9 /* L */ || curr === 10 /* V */ || curr === 12 /* LV */ || curr === 13 /* LVT */)) {
      shouldBreak = false;
    } else if ((prev === 12 /* LV */ || prev === 10 /* V */) && (curr === 10 /* V */ || curr === 11 /* T */)) {
      shouldBreak = false;
    } else if ((prev === 13 /* LVT */ || prev === 11 /* T */) && curr === 11 /* T */) {
      shouldBreak = false;
    } else if (curr === 4 /* Extend */ || curr === 5 /* ZWJ */) {
      shouldBreak = false;
    } else if (curr === 8 /* SpacingMark */) {
      shouldBreak = false;
    } else if (prev === 7 /* Prepend */) {
      shouldBreak = false;
    } else if (inExtendedPictographicSequence && prev === 5 /* ZWJ */ && curr === 14 /* Extended_Pictographic */) {
      shouldBreak = false;
    } else if (prev === 6 /* Regional_Indicator */ && curr === 6 /* Regional_Indicator */) {
      if (riCount % 2 === 1) {
        shouldBreak = false;
      }
    }
    if (curr === 14 /* Extended_Pictographic */) {
      inExtendedPictographicSequence = true;
    } else if (curr !== 4 /* Extend */ && curr !== 5 /* ZWJ */) {
      inExtendedPictographicSequence = false;
    }
    if (curr === 6 /* Regional_Indicator */) {
      riCount++;
    } else {
      riCount = 0;
    }
    if (shouldBreak) {
      boundaries.push(i);
    }
  }
  boundaries.push(len);
  return { boundaries, properties };
}
function findWordBoundaries(codepoints) {
  const len = codepoints.length;
  const properties = [];
  const boundaries = [];
  for (let i = 0;i < codepoints.length; i++) {
    const cp = codepoints[i];
    properties.push(getWordBreakProperty(cp));
  }
  if (len === 0)
    return { boundaries, properties };
  boundaries.push(0);
  let riCount = 0;
  for (let i = 1;i < len; i++) {
    const prev = properties[i - 1];
    const curr = properties[i];
    let shouldBreak = true;
    if (prev === 1 /* CR */ && curr === 2 /* LF */) {
      shouldBreak = false;
    } else if (prev === 3 /* Newline */ || prev === 1 /* CR */ || prev === 2 /* LF */) {
      shouldBreak = true;
    } else if (curr === 3 /* Newline */ || curr === 1 /* CR */ || curr === 2 /* LF */) {
      shouldBreak = true;
    } else if (prev === 5 /* ZWJ */ && curr === 19 /* Extended_Pictographic */) {
      shouldBreak = false;
    } else if (prev === 18 /* WSegSpace */ && curr === 18 /* WSegSpace */) {
      shouldBreak = false;
    } else if (curr === 7 /* Format */ || curr === 4 /* Extend */ || curr === 5 /* ZWJ */) {
      shouldBreak = false;
    } else if ((prev === 10 /* ALetter */ || prev === 9 /* Hebrew_Letter */) && (curr === 10 /* ALetter */ || curr === 9 /* Hebrew_Letter */)) {
      shouldBreak = false;
    } else if ((prev === 10 /* ALetter */ || prev === 9 /* Hebrew_Letter */) && (curr === 14 /* MidLetter */ || curr === 13 /* MidNumLet */ || curr === 11 /* Single_Quote */)) {
      if (i + 1 < len) {
        const next = properties[i + 1];
        if (next === 10 /* ALetter */ || next === 9 /* Hebrew_Letter */) {
          shouldBreak = false;
        }
      }
    } else if (prev === 16 /* Numeric */ && curr === 16 /* Numeric */) {
      shouldBreak = false;
    } else if ((prev === 10 /* ALetter */ || prev === 9 /* Hebrew_Letter */) && curr === 16 /* Numeric */) {
      shouldBreak = false;
    } else if (prev === 16 /* Numeric */ && (curr === 10 /* ALetter */ || curr === 9 /* Hebrew_Letter */)) {
      shouldBreak = false;
    } else if (prev === 16 /* Numeric */ && (curr === 15 /* MidNum */ || curr === 13 /* MidNumLet */ || curr === 11 /* Single_Quote */)) {
      if (i + 1 < len && properties[i + 1] === 16 /* Numeric */) {
        shouldBreak = false;
      }
    } else if (prev === 8 /* Katakana */ && curr === 8 /* Katakana */) {
      shouldBreak = false;
    } else if ((prev === 10 /* ALetter */ || prev === 9 /* Hebrew_Letter */ || prev === 16 /* Numeric */ || prev === 8 /* Katakana */ || prev === 17 /* ExtendNumLet */) && curr === 17 /* ExtendNumLet */) {
      shouldBreak = false;
    } else if (prev === 17 /* ExtendNumLet */ && (curr === 10 /* ALetter */ || curr === 9 /* Hebrew_Letter */ || curr === 16 /* Numeric */ || curr === 8 /* Katakana */)) {
      shouldBreak = false;
    } else if (prev === 6 /* Regional_Indicator */ && curr === 6 /* Regional_Indicator */) {
      if (riCount % 2 === 1) {
        shouldBreak = false;
      }
    }
    if (curr === 6 /* Regional_Indicator */) {
      riCount++;
    } else {
      riCount = 0;
    }
    if (shouldBreak) {
      boundaries.push(i);
    }
  }
  boundaries.push(len);
  return { boundaries, properties };
}
function splitGraphemes(text) {
  const codepoints = [];
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    codepoints.push(char2.codePointAt(0) ?? 0);
  }
  const { boundaries } = findGraphemeBoundaries(codepoints);
  const graphemes = [];
  let start = 0;
  for (let i = 0;i < boundaries.length; i++) {
    const end = boundaries[i];
    if (end > start) {
      graphemes.push(chars.slice(start, end).join(""));
    }
    start = end;
  }
  return graphemes;
}
function splitWords(text) {
  const codepoints = [];
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    codepoints.push(char2.codePointAt(0) ?? 0);
  }
  const { boundaries, properties } = findWordBoundaries(codepoints);
  const words = [];
  for (let i = 0;i < boundaries.length - 1; i++) {
    const start = boundaries[i];
    const end = boundaries[i + 1];
    let hasContent = false;
    for (let j = start;j < end; j++) {
      const prop = properties[j];
      if (prop !== 18 /* WSegSpace */ && prop !== 1 /* CR */ && prop !== 2 /* LF */ && prop !== 3 /* Newline */) {
        hasContent = true;
        break;
      }
    }
    if (hasContent) {
      words.push(chars.slice(start, end).join(""));
    }
  }
  return words;
}
function countGraphemes(text) {
  const codepoints = [];
  const chars = [...text];
  for (let i = 0;i < chars.length; i++) {
    const char2 = chars[i];
    codepoints.push(char2.codePointAt(0) ?? 0);
  }
  const { boundaries } = findGraphemeBoundaries(codepoints);
  return boundaries.length;
}
export {
  verticalLayoutFeatures,
  verticalKanaAlternates,
  verticalForms,
  verticalAlternatesRotation,
  vectorLength,
  validateOutline,
  useTypoMetrics,
  upscale,
  updateMinTransformedX,
  truncPixel,
  translateOutline,
  translate2D,
  transformPoint3x3,
  transformPoint2D,
  transformOutline3D,
  transformOutline2D,
  transformBitmap3D,
  transformBitmap2D,
  traditionalForms,
  thirdWidthForms,
  tagToString,
  tag,
  tabularFigures,
  swash,
  superscript,
  subtractBitmap,
  subscript,
  subBitmaps,
  stylisticSets,
  stylisticSet,
  stylisticAlternates,
  strokeUniform,
  strokePath,
  strokeAsymmetricCombined,
  strokeAsymmetric,
  standardLigatures,
  splitWords,
  splitGraphemes,
  smallCaps,
  slashedZero,
  simplifiedForms,
  signedDistanceToQuadratic,
  signedDistanceToLine,
  signedDistanceToCubic,
  sign,
  shouldGridFit,
  shouldDoGray,
  shiftBitmap,
  shearBitmapY,
  shearBitmapX,
  shear2D,
  shapedTextToSVGWithVariation,
  shapedTextToSVG,
  shapeInto,
  shape,
  setSize,
  setCodeRange,
  scientificInferiors,
  scaleOutlinePow2,
  scaleOutline,
  scale2D,
  runProgram,
  runGlyphProgram,
  runFontProgram,
  runCVTProgram,
  ruby,
  roundUpToGrid,
  roundToHalfGrid,
  roundToGrid,
  roundToDoubleGrid,
  roundSuper45,
  roundSuper,
  roundPixel,
  roundOff,
  roundDownToGrid,
  round,
  rotateOutline90,
  rotateOutline,
  rotate2D,
  resolveDupeGlyph,
  resizeBitmapBilinear,
  resizeBitmap,
  reorderMarks,
  reorderGlyphs,
  renderShapedTextWithVariation,
  renderShapedText,
  renderSdf,
  renderMsdf,
  rasterizeText,
  rasterizePathWithGradient,
  rasterizePath,
  rasterizeLcd,
  rasterizeGlyphWithTransform,
  rasterizeGlyph,
  quarterWidthForms,
  proportionalWidthForms,
  proportionalFigures,
  processRearrangement,
  processLigature,
  processInsertion,
  processContextual,
  processBidi,
  pipe,
  petiteCaps,
  perspectiveMatrix,
  pathToSVGWithMatrix3D,
  pathToSVGWithMatrix,
  pathToSVG,
  pathToCanvasWithMatrix3D,
  pathToCanvasWithMatrix,
  pathToCanvas,
  path,
  parseSuperRound,
  parseScriptList,
  parsePrep,
  parsePost,
  parseOs2,
  parseName,
  parseMath,
  parseLookupHeaders,
  parseJstf,
  parseGasp,
  parseFpgm,
  parseFontDirectory,
  parseFeatureList,
  parseFeat,
  parseCvt,
  parseCpal,
  parseCoverageAt,
  parseCoverage,
  parseColr,
  parseClassDefAt,
  parseClassDef,
  parseCff2,
  parseCff,
  parseBase,
  padBitmap,
  ordinals,
  openTypeTagToAat,
  oldstyleFigures,
  obliquePath,
  normalizeVector,
  normalizeAxisValue,
  normalize3 as normalize,
  mustBreakAt,
  multiply3x3,
  multiply2D,
  mulFix2 as mulFix,
  mulDiv3 as mulDiv,
  mulBitmaps,
  msdfAtlasToRGBA,
  msdfAtlasToRGB,
  median,
  measureRasterGlyph,
  maxBitmaps,
  matrixToSVGTransform,
  matchAxisValue,
  loadFontProgram,
  loadCVTProgram,
  liningFigures,
  lcdToRGBA,
  kerning,
  justifyParagraph,
  justify,
  jis90Forms,
  jis83Forms,
  jis78Forms,
  jis2004Forms,
  italicizeOutline,
  isVariationIndexTable,
  isTrueType,
  isScript,
  isRTL,
  isOlderSiblingFont,
  isMonospaced,
  isLTR,
  isItalic,
  isExtendedShape,
  isExclusiveFeature,
  isElidableAxisValue,
  isComplexScript,
  isColrV1,
  isCFF,
  isBold,
  interpolateGradient,
  identity3x3,
  identity2D,
  hypot,
  historicalLigatures,
  hintedToPixels,
  hintGlyph,
  hasVertOriginY,
  hasSvgGlyph,
  hasSettingValue,
  hasGlyphOutline,
  hasGlyphBitmap,
  hasColorGlyph,
  hasColorBitmap,
  halfWidthForms,
  glyphVar,
  glyphToSVG,
  glyphBufferToShapedGlyphs,
  glyph,
  getXHeightDelta,
  getWordBreakProperty,
  getVorgDelta,
  getVisualOrder,
  getVerticalVariants,
  getVerticalMetrics,
  getVerticalAssembly,
  getVertOriginY,
  getVersion,
  getTsbDelta,
  getTrackingValue,
  getTopAccentAttachment,
  getTextWidth,
  getSvgGlyphIds,
  getSvgDocument,
  getSubstitutedLookups,
  getStrikeForPpem,
  getShrinkageMods,
  getSettingByValue,
  getScripts,
  getScriptTag,
  getScriptRuns,
  getScriptDirection,
  getScript,
  getGlyphBitmap as getSbixGlyphBitmap,
  getPostScriptName,
  getPathBounds,
  getOrCreateShapePlan,
  getNameById,
  getMirror,
  getMinMaxExtent,
  getMetricDelta,
  getMarkAttachmentType,
  getLineBreakClass,
  getLayerPaint,
  getKerxValue,
  getKernValue,
  getJstfPriorities,
  getItalicsCorrection,
  getHorizontalVariants,
  getHorizontalAssembly,
  getHDescenderDelta,
  getHAscenderDelta,
  getGraphemeBreakProperty,
  getGlyphUV,
  getGlyphPathWithVariation,
  getGlyphPath,
  getGlyphName,
  getGlyphLocation,
  getGlyphDelta,
  getGaspBehavior,
  getFullName,
  getFontSubfamily,
  getFontFamily,
  getFillRuleFromFlags,
  getFeature2 as getFeature,
  getExtensionMods,
  getExtenderGlyphs,
  getExactBounds,
  getEmbeddings,
  getEmbeddingPermission,
  getDeviceDelta,
  getDefaultSetting,
  getDefaultBaseline,
  getCombiningClass,
  getColorVariationDelta,
  getColorPaint,
  getColorLayers,
  getColorBitmapSizes,
  getColor,
  getClipBox,
  getCharType2 as getCharType,
  getCffString,
  getCffGlyphWidth,
  getCapHeightDelta,
  getBsbDelta,
  getBitmapGlyph,
  getBaselineForScript,
  getAxisValuesForAxis,
  getAxisValueNumber,
  getAxisRecord,
  getAxisIndex,
  getAvailablePpemSizes,
  getAllFeatures,
  getAllBreakOpportunities,
  getAdvanceWidthDelta,
  getAdvanceHeightDelta,
  getFeature as getAatFeature,
  gaussianBlur,
  fullWidthForms,
  fractions,
  fracPixel,
  floorPixel,
  floatToPixel,
  floatToF26Dot6,
  fixOutlineBitmap,
  fixOutline,
  findWordBoundaries,
  findScript,
  findNextBreak,
  findMatchingFeatureVariation,
  findLangSys,
  findGraphemeBoundaries,
  findAxisValueByNameId,
  features,
  feature,
  fastGaussianBlur,
  f26Dot6ToFloat,
  expandToFit,
  expandRasterMetrics,
  executeFontProgram,
  executeCffCharString,
  executeCff2CharString,
  execute,
  evaluateConditionSet,
  emboldenPath,
  emboldenBitmapWithBearing,
  emboldenBitmap,
  downscale,
  divFix2 as divFix,
  discretionaryLigatures,
  detectScript,
  detectDirection,
  decomposePath,
  decompose,
  createShapePlan,
  createPath2D,
  createLookupDigest,
  createHintingEngine,
  createGradientBitmap,
  createGlyphZone,
  createGaussianKernel,
  createFace,
  createExecContext,
  createDefaultGraphicsState,
  createBitmap,
  countGraphemes,
  copyBitmap,
  convertBitmap,
  contourToPath,
  contextualAlternates,
  condensePath,
  computeTightBounds,
  computeControlBox,
  compositeBitmaps,
  compensate,
  combinePaths,
  combineFeatures,
  combine,
  colorToRgba,
  colorToHex,
  clonePath,
  clearBitmap,
  clamp,
  characterVariants,
  characterVariant,
  char,
  ceilPixel,
  caseSensitiveForms,
  cascadeBlur,
  capsToSmallCaps,
  capitalSpacing,
  canBreakAt,
  calculateVariationDelta,
  calculateTupleScalar,
  calculateLineWidth,
  buildStringAtlas,
  buildMsdfStringAtlas,
  buildMsdfAtlas,
  buildMsdfAsciiAtlas,
  buildAtlas,
  buildAsciiAtlas,
  breakIntoLines,
  boxBlur,
  blurBitmap,
  blendBitmap,
  bitmapToRGBA,
  bitmapToGray,
  bitmap,
  atlasToRGBA,
  atlasToAlpha,
  assignEdgeColors,
  applyTracking,
  applyNonContextual,
  applyMirroring,
  applyMatrixToContext,
  applyFeatureVariations,
  applyFallbackMarkPositioning,
  applyFallbackKerning,
  applyDeviceAdjustment,
  applyAvarMapping,
  applyAvar,
  analyzeLineBreaksFromCodepoints,
  analyzeLineBreaksForGlyphs,
  analyzeLineBreaks,
  allSmallCaps,
  addBitmaps,
  adaptiveBlur,
  abs,
  aatToOpenTypeTag,
  WordBreakProperty,
  WindowsEncodingId,
  WidthClass,
  WeightClass,
  VerticalPositionSetting,
  UpperCaseSetting,
  UnicodeBuffer,
  TouchFlag,
  Tags,
  StylisticAlternativesSetting,
  SmartSwashSetting,
  SetDigest,
  Script,
  SbixGraphicType,
  RoundMode,
  Reader,
  PlatformId,
  PixelMode,
  PathBuilder,
  PaletteType,
  PaintFormat,
  PIXEL_MASK,
  PIXEL_BITS,
  OutlineError,
  Opcode,
  ONE_PIXEL,
  NumberSpacingSetting,
  NumberCaseSetting,
  NormalizationMode,
  NameId,
  MvarTags,
  MorxSubtableType,
  LowerCaseSetting,
  LookupFlag,
  LineBreakClass,
  LigatureSetting,
  LcdMode,
  LCD_FILTER_LIGHT,
  LCD_FILTER_LEGACY,
  LCD_FILTER_DEFAULT,
  JustifyMode,
  JstfPriority,
  GraphemeBreakProperty,
  GlyphClass,
  GlyphBuffer,
  GaspFlag,
  FsType,
  FsSelection,
  FractionsSetting,
  FontCollection,
  Font,
  FillRule,
  FeatureType,
  FeatureTags,
  FeatureFlags,
  Face,
  F26DOT6_SHIFT,
  F26DOT6_ONE,
  F16DOT16_SHIFT,
  F16DOT16_ONE,
  Extend,
  EMPTY_CLASS_DEF,
  Direction,
  DiacriticsSetting,
  Coverage,
  ContextualAlternativesSetting,
  CompositeMode,
  CodeRange,
  ClusterLevel,
  ClassDef,
  CharacterShapeSetting,
  CbdtImageFormat,
  CaseSensitiveLayoutSetting,
  BufferFlags,
  BreakOpportunity,
  BreakAction,
  BitmapBuilder,
  BidiType,
  BaselineTag,
  AxisValueFlags,
  translate as $translate,
  transformGlyph3D as $transformGlyph3D,
  transformGlyph2D as $transformGlyph2D,
  transformBitmap3D2 as $transformBitmap3D,
  transformBitmap2D2 as $transformBitmap2D,
  toSVG as $toSVG,
  toRGBA as $toRGBA,
  toGray as $toGray,
  strokePath2 as $strokePath,
  strokeAsymmetricCombined2 as $strokeAsymmetricCombined,
  strokeAsymmetric2 as $strokeAsymmetric,
  shift as $shift,
  shearGlyphY as $shearGlyphY,
  shearGlyphX as $shearGlyphX,
  shearBitmapY2 as $shearBitmapY,
  shearBitmapX2 as $shearBitmapX,
  shear as $shear,
  scale as $scale,
  rotateDeg as $rotateDeg,
  rotate as $rotate,
  resizeBilinear as $resizeBilinear,
  resize as $resize,
  renderSdf2 as $renderSdf,
  renderMsdf2 as $renderMsdf,
  rasterizeWithGradient as $rasterizeWithGradient,
  rasterizeAuto as $rasterizeAuto,
  rasterize as $rasterize,
  perspective as $perspective,
  pad as $pad,
  obliquePath2 as $obliquePath,
  matrix as $matrix,
  italic as $italic,
  fromGlyph as $fromGlyph,
  fastBlur as $fastBlur,
  emboldenPath2 as $emboldenPath,
  emboldenGlyph as $emboldenGlyph,
  embolden as $embolden,
  copy as $copy,
  convert as $convert,
  condensePath2 as $condensePath,
  combinePaths2 as $combinePaths,
  clone as $clone,
  cascadeBlur2 as $cascadeBlur,
  boxBlur2 as $boxBlur,
  blur as $blur,
  adaptiveBlur2 as $adaptiveBlur
};

//# debugId=7AB40BE30542535E64756E2164756E21
//# sourceMappingURL=index.js.map
