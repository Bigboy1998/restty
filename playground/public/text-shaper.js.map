{
  "version": 3,
  "sources": ["../../reference/text-shaper/src/raster/types.ts", "../../reference/text-shaper/src/font/brotli/context.ts", "../../reference/text-shaper/src/font/brotli/dictionary.ts", "../../reference/text-shaper/src/font/brotli/transform.ts", "../../reference/text-shaper/src/font/brotli/decode.ts", "../../reference/text-shaper/src/aat/state-machine.ts", "../../reference/text-shaper/src/hinting/instructions/arithmetic.ts", "../../reference/text-shaper/src/hinting/instructions/control-flow.ts", "../../reference/text-shaper/src/hinting/types.ts", "../../reference/text-shaper/src/hinting/rounding.ts", "../../reference/text-shaper/src/hinting/scale.ts", "../../reference/text-shaper/src/hinting/instructions/points.ts", "../../reference/text-shaper/src/hinting/instructions/delta.ts", "../../reference/text-shaper/src/hinting/instructions/graphics-state.ts", "../../reference/text-shaper/src/hinting/instructions/interpolate.ts", "../../reference/text-shaper/src/hinting/instructions/stack.ts", "../../reference/text-shaper/src/hinting/interpreter.ts", "../../reference/text-shaper/src/hinting/programs.ts", "../../reference/text-shaper/src/types.ts", "../../reference/text-shaper/src/buffer/glyph-buffer.ts", "../../reference/text-shaper/src/buffer/unicode-buffer.ts", "../../reference/text-shaper/src/font/tables/gvar.ts", "../../reference/text-shaper/src/font/tables/loca.ts", "../../reference/text-shaper/src/font/tables/glyf.ts", "../../reference/text-shaper/src/render/outline-transform.ts", "../../reference/text-shaper/src/render/path.ts", "../../reference/text-shaper/src/raster/fixed-point.ts", "../../reference/text-shaper/src/raster/cell.ts", "../../reference/text-shaper/src/raster/gray-raster.ts", "../../reference/text-shaper/src/raster/outline-decompose.ts", "../../reference/text-shaper/src/raster/rasterize.ts", "../../reference/text-shaper/src/raster/bitmap-utils.ts", "../../reference/text-shaper/src/raster/size.ts", "../../reference/text-shaper/src/raster/bbox.ts", "../../reference/text-shaper/src/raster/blur.ts", "../../reference/text-shaper/src/raster/gradient.ts", "../../reference/text-shaper/src/raster/sdf.ts", "../../reference/text-shaper/src/raster/stroker.ts", "../../reference/text-shaper/src/raster/asymmetric-stroke.ts", "../../reference/text-shaper/src/raster/synth.ts", "../../reference/text-shaper/src/raster/atlas.ts", "../../reference/text-shaper/src/raster/msdf.ts", "../../reference/text-shaper/src/raster/cascade-blur.ts", "../../reference/text-shaper/src/fluent/bitmap-builder.ts", "../../reference/text-shaper/src/fluent/path-builder.ts", "../../reference/text-shaper/src/fluent/pipe.ts", "../../reference/text-shaper/src/fluent/index.ts", "../../reference/text-shaper/src/font/binary/reader.ts", "../../reference/text-shaper/src/font/tables/avar.ts", "../../reference/text-shaper/src/font/tables/fvar.ts", "../../reference/text-shaper/src/font/tables/hvar.ts", "../../reference/text-shaper/src/font/face.ts", "../../reference/text-shaper/src/font/ttc.ts", "../../reference/text-shaper/src/font/woff2.ts", "../../reference/text-shaper/src/font/tables/base.ts", "../../reference/text-shaper/src/font/tables/cbdt.ts", "../../reference/text-shaper/src/font/tables/cff.ts", "../../reference/text-shaper/src/font/tables/cff-charstring.ts", "../../reference/text-shaper/src/font/tables/cff2.ts", "../../reference/text-shaper/src/font/tables/cmap.ts", "../../reference/text-shaper/src/font/tables/colr.ts", "../../reference/text-shaper/src/font/tables/cpal.ts", "../../reference/text-shaper/src/font/tables/feat.ts", "../../reference/text-shaper/src/font/tables/gasp.ts", "../../reference/text-shaper/src/layout/structures/class-def.ts", "../../reference/text-shaper/src/font/tables/gdef.ts", "../../reference/text-shaper/src/layout/structures/coverage.ts", "../../reference/text-shaper/src/layout/structures/device.ts", "../../reference/text-shaper/src/layout/structures/layout-common.ts", "../../reference/text-shaper/src/layout/structures/set-digest.ts", "../../reference/text-shaper/src/font/tables/gpos-contextual.ts", "../../reference/text-shaper/src/font/tables/gpos-mark.ts", "../../reference/text-shaper/src/font/tables/gpos.ts", "../../reference/text-shaper/src/font/tables/gsub-contextual.ts", "../../reference/text-shaper/src/font/tables/gsub.ts", "../../reference/text-shaper/src/font/tables/head.ts", "../../reference/text-shaper/src/font/tables/hhea.ts", "../../reference/text-shaper/src/font/tables/hinting.ts", "../../reference/text-shaper/src/font/tables/hmtx.ts", "../../reference/text-shaper/src/font/tables/jstf.ts", "../../reference/text-shaper/src/font/tables/kern.ts", "../../reference/text-shaper/src/font/tables/kerx.ts", "../../reference/text-shaper/src/font/tables/math.ts", "../../reference/text-shaper/src/font/tables/maxp.ts", "../../reference/text-shaper/src/font/tables/morx.ts", "../../reference/text-shaper/src/font/tables/mvar.ts", "../../reference/text-shaper/src/font/tables/name.ts", "../../reference/text-shaper/src/font/tables/os2.ts", "../../reference/text-shaper/src/font/tables/post.ts", "../../reference/text-shaper/src/font/tables/sbix.ts", "../../reference/text-shaper/src/font/tables/sfnt.ts", "../../reference/text-shaper/src/font/tables/stat.ts", "../../reference/text-shaper/src/font/tables/svg.ts", "../../reference/text-shaper/src/font/tables/trak.ts", "../../reference/text-shaper/src/font/tables/vhea.ts", "../../reference/text-shaper/src/font/tables/vmtx.ts", "../../reference/text-shaper/src/font/tables/vorg.ts", "../../reference/text-shaper/src/font/tables/vvar.ts", "../../reference/text-shaper/src/font/font.ts", "../../reference/text-shaper/src/layout/justify.ts", "../../reference/text-shaper/src/layout/structures/feature-variations.ts", "../../reference/text-shaper/src/raster/lcd-filter.ts", "../../reference/text-shaper/src/index.ts", "../../reference/text-shaper/src/unicode/normalize.ts", "../../reference/text-shaper/src/shaper/fallback.ts", "../../reference/text-shaper/src/shaper/features.ts", "../../reference/text-shaper/src/shaper/complex/arabic.ts", "../../reference/text-shaper/src/shaper/complex/ethiopic.ts", "../../reference/text-shaper/src/shaper/complex/georgian.ts", "../../reference/text-shaper/src/shaper/complex/mongolian.ts", "../../reference/text-shaper/src/shaper/complex/syriac.ts", "../../reference/text-shaper/src/shaper/complex/tibetan.ts", "../../reference/text-shaper/src/shaper/shape-plan.ts", "../../reference/text-shaper/src/shaper/complex/hangul.ts", "../../reference/text-shaper/src/shaper/complex/hebrew.ts", "../../reference/text-shaper/src/shaper/complex/indic.ts", "../../reference/text-shaper/src/shaper/complex/khmer.ts", "../../reference/text-shaper/src/shaper/complex/myanmar.ts", "../../reference/text-shaper/src/shaper/complex/thai-lao.ts", "../../reference/text-shaper/src/shaper/complex/use.ts", "../../reference/text-shaper/src/shaper/shaper.ts", "../../reference/text-shaper/src/unicode/bidi/brackets.gen.ts", "../../reference/text-shaper/src/unicode/bidi/parse-character-map.ts", "../../reference/text-shaper/src/unicode/bidi/brackets.ts", "../../reference/text-shaper/src/unicode/bidi/char-types.gen.ts", "../../reference/text-shaper/src/unicode/bidi/char-types.ts", "../../reference/text-shaper/src/unicode/bidi/embedding-levels.ts", "../../reference/text-shaper/src/unicode/bidi/mirroring.gen.ts", "../../reference/text-shaper/src/unicode/bidi/mirroring.ts", "../../reference/text-shaper/src/unicode/bidi/reordering.ts", "../../reference/text-shaper/src/unicode/bidi.ts", "../../reference/text-shaper/src/unicode/line-break.ts", "../../reference/text-shaper/src/unicode/script.ts", "../../reference/text-shaper/src/unicode/segmentation.ts"],
  "sourcesContent": [
    "/**\n * Rasterizer types - FreeType-style bitmap rendering\n */\n\nimport type { GlyphPath } from \"../render/path.ts\";\n\n/**\n * Pixel modes for bitmap output\n */\nexport enum PixelMode {\n\t/** 1-bit per pixel, 8 pixels per byte */\n\tMono = 0,\n\t/** 8-bit grayscale, 1 byte per pixel */\n\tGray = 1,\n\t/** 24-bit LCD subpixel RGB, 3 bytes per pixel */\n\tLCD = 2,\n\t/** 24-bit LCD subpixel vertical RGB */\n\tLCD_V = 3,\n\t/** 32-bit RGBA, 4 bytes per pixel */\n\tRGBA = 4,\n}\n\n/**\n * Font size interpretation mode\n * - \"em\": fontSize is treated as em size (CSS-like)\n * - \"height\": fontSize is treated as ascender-descender-lineGap height\n */\nexport type FontSizeMode = \"em\" | \"height\";\n\n/**\n * Options for rasterizing a glyph from a font\n */\nexport interface GlyphRasterizeOptions {\n\t/** Pixel mode */\n\tpixelMode?: PixelMode;\n\t/** Padding in pixels around glyph */\n\tpadding?: number;\n\t/** Use TrueType hinting if available */\n\thinting?: boolean;\n\t/** Interpret fontSize as em or full height */\n\tsizeMode?: FontSizeMode;\n}\n\n/**\n * Options for rasterizing text from a font\n */\nexport interface TextRasterizeOptions {\n\t/** Pixel mode */\n\tpixelMode?: PixelMode;\n\t/** Padding in pixels around glyphs */\n\tpadding?: number;\n\t/** Interpret fontSize as em or full height */\n\tsizeMode?: FontSizeMode;\n}\n/**\n * Fill rule for outline rendering\n */\nexport enum FillRule {\n\t/** Non-zero winding rule (default) */\n\tNonZero = 0,\n\t/** Even-odd (alternating) fill rule */\n\tEvenOdd = 1,\n}\n\n/**\n * Bitmap buffer for rasterized glyphs\n */\nexport interface Bitmap {\n\t/** Pixel buffer */\n\tbuffer: Uint8Array;\n\t/** Width in pixels */\n\twidth: number;\n\t/** Height in pixels */\n\trows: number;\n\t/** Bytes per row (may include padding) */\n\tpitch: number;\n\t/** Pixel format */\n\tpixelMode: PixelMode;\n\t/** Number of gray levels (256 for 8-bit) */\n\tnumGrays: number;\n}\n\n/**\n * A single horizontal span of pixels (for direct rendering)\n */\nexport interface Span {\n\t/** X position of span start */\n\tx: number;\n\t/** Length in pixels */\n\tlen: number;\n\t/** Coverage value 0-255 */\n\tcoverage: number;\n}\n\n/**\n * Callback for span-based rendering\n * @template T User data type passed through from render call\n */\nexport type SpanFunc<T = void> = (\n\ty: number,\n\tspans: Span[],\n\tuserData: T,\n) => void;\n\n/**\n * Rasterization parameters\n */\nexport interface RasterParams {\n\t/** Target bitmap (null for span callback mode) */\n\ttarget?: Bitmap;\n\t/** Source outline path */\n\tsource: GlyphPath;\n\t/** Fill rule */\n\tfillRule?: FillRule;\n\t/** Span callback for direct rendering */\n\tspanFunc?: SpanFunc;\n\t/** Clip box (in pixels) */\n\tclipBox?: {\n\t\txMin: number;\n\t\tyMin: number;\n\t\txMax: number;\n\t\tyMax: number;\n\t};\n}\n\n/**\n * Options for rasterizing a glyph\n */\nexport interface RasterizeOptions {\n\t/** Width in pixels */\n\twidth: number;\n\t/** Height in pixels */\n\theight: number;\n\t/** Scale factor (font units to pixels) */\n\tscale: number;\n\t/** X offset in pixels */\n\toffsetX?: number;\n\t/** Y offset in pixels */\n\toffsetY?: number;\n\t/** Pixel mode */\n\tpixelMode?: PixelMode;\n\t/** Fill rule */\n\tfillRule?: FillRule;\n\t/** Flip Y axis (font coords are Y-up, bitmap is Y-down) */\n\tflipY?: boolean;\n}\n\n/**\n * Result of glyph rasterization\n */\nexport interface RasterizedGlyph {\n\t/** Pixel data */\n\tbitmap: Bitmap;\n\t/** Bearing X (offset from origin to left edge) */\n\tbearingX: number;\n\t/** Bearing Y (offset from origin to top edge) */\n\tbearingY: number;\n}\n\n/**\n * Glyph metrics for atlas building\n */\nexport interface GlyphMetrics {\n\t/** Glyph ID */\n\tglyphId: number;\n\t/** X position in atlas */\n\tatlasX: number;\n\t/** Y position in atlas */\n\tatlasY: number;\n\t/** Width in atlas */\n\twidth: number;\n\t/** Height in atlas */\n\theight: number;\n\t/** Bearing X */\n\tbearingX: number;\n\t/** Bearing Y */\n\tbearingY: number;\n\t/** Horizontal advance */\n\tadvance: number;\n}\n\n/**\n * Texture atlas containing multiple glyphs\n */\nexport interface GlyphAtlas {\n\t/** Atlas bitmap */\n\tbitmap: Bitmap;\n\t/** Glyph metrics indexed by glyph ID */\n\tglyphs: Map<number, GlyphMetrics>;\n\t/** Font size used for rendering */\n\tfontSize: number;\n}\n\n/**\n * Options for building a glyph atlas\n */\nexport interface AtlasOptions {\n\t/** Font size in pixels */\n\tfontSize: number;\n\t/** Interpret fontSize as em or full height */\n\tsizeMode?: FontSizeMode;\n\t/** Padding between glyphs */\n\tpadding?: number;\n\t/** Maximum atlas width */\n\tmaxWidth?: number;\n\t/** Maximum atlas height */\n\tmaxHeight?: number;\n\t/** Pixel mode */\n\tpixelMode?: PixelMode;\n\t/** Enable hinting */\n\thinting?: boolean;\n}\n\n/**\n * Options for building an MSDF atlas\n */\nexport interface MsdfAtlasOptions {\n\t/** Font size in pixels (size of each glyph cell in the atlas) */\n\tfontSize: number;\n\t/** Interpret fontSize as em or full height */\n\tsizeMode?: FontSizeMode;\n\t/** Padding between glyphs */\n\tpadding?: number;\n\t/** Maximum atlas width */\n\tmaxWidth?: number;\n\t/** Maximum atlas height */\n\tmaxHeight?: number;\n\t/** SDF spread/radius in pixels (default: 4) */\n\tspread?: number;\n}\n\n/**\n * Create an empty bitmap\n * @param width Width in pixels\n * @param height Height in pixels\n * @param pixelMode Pixel format (default: Gray)\n * @returns Empty bitmap with the specified dimensions and format\n */\nexport function createBitmap(\n\twidth: number,\n\theight: number,\n\tpixelMode: PixelMode = PixelMode.Gray,\n): Bitmap {\n\tlet bytesPerPixel: number;\n\tswitch (pixelMode) {\n\t\tcase PixelMode.Mono:\n\t\t\tbytesPerPixel = 1 / 8; // 8 pixels per byte\n\t\t\tbreak;\n\t\tcase PixelMode.Gray:\n\t\t\tbytesPerPixel = 1;\n\t\t\tbreak;\n\t\tcase PixelMode.LCD:\n\t\tcase PixelMode.LCD_V:\n\t\t\tbytesPerPixel = 3;\n\t\t\tbreak;\n\t\tcase PixelMode.RGBA:\n\t\t\tbytesPerPixel = 4;\n\t\t\tbreak;\n\t}\n\n\tconst pitch =\n\t\tpixelMode === PixelMode.Mono ? Math.ceil(width / 8) : width * bytesPerPixel;\n\n\treturn {\n\t\tbuffer: new Uint8Array(pitch * height),\n\t\twidth,\n\t\trows: height,\n\t\tpitch,\n\t\tpixelMode,\n\t\tnumGrays: pixelMode === PixelMode.Mono ? 2 : 256,\n\t};\n}\n\n/**\n * Clear a bitmap to zero\n * @param bitmap Bitmap to clear\n */\nexport function clearBitmap(bitmap: Bitmap): void {\n\tbitmap.buffer.fill(0);\n}\n\n/**\n * Create a bottom-up bitmap (negative pitch)\n * Bottom-up bitmaps have row 0 at the bottom of the image,\n * which matches some graphics APIs (e.g., Windows DIB, OpenGL textures)\n * @param width Width in pixels\n * @param height Height in pixels\n * @param pixelMode Pixel format (default: Gray)\n * @returns Bottom-up bitmap with row 0 at the bottom\n */\nexport function createBottomUpBitmap(\n\twidth: number,\n\theight: number,\n\tpixelMode: PixelMode = PixelMode.Gray,\n): Bitmap {\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\t// Negative pitch indicates bottom-up storage\n\tbitmap.pitch = -bitmap.pitch;\n\treturn bitmap;\n}\n",
    "/**\n * Context lookup tables for Brotli decompression\n * Based on brotli.js reference implementation (Apache 2.0 License)\n */\n\n// Context lookup table combining all context modes\nexport const CONTEXT_LOOKUP = new Uint8Array([\n\t// CONTEXT_UTF8, last byte (0-255)\n\t// ASCII range\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36,\n\t12, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12, 12, 48,\n\t52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52,\n\t48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60,\n\t60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60,\n\t24, 12, 28, 12, 0,\n\t// UTF8 continuation byte range\n\t0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n\t0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n\t0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n\t// UTF8 lead byte range\n\t2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n\t2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n\t2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n\t// CONTEXT_UTF8 second last byte (256-511)\n\t// ASCII range\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0,\n\t// UTF8 continuation byte range\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0,\n\t// UTF8 lead byte range\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t// CONTEXT_SIGNED, second last byte (512-767)\n\t0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4,\n\t4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n\t5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,\n\t// CONTEXT_SIGNED, last byte (768-1023)\n\t0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16,\n\t16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n\t16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n\t16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 40, 40,\n\t40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n\t40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n\t40, 40, 40, 40, 40, 40, 40, 40, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n\t48, 48, 48, 48, 56,\n\t// CONTEXT_LSB6, last byte (1024-1279)\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n\t22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n\t60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\n\t18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n\t37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n\t56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n\t14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n\t33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n\t10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n\t29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n\t48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n\t// CONTEXT_MSB6, last byte (1280-1535)\n\t0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6,\n\t6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12,\n\t12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n\t17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21,\n\t21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26,\n\t26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31,\n\t31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,\n\t36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40,\n\t40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45,\n\t45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50,\n\t50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54,\n\t55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59,\n\t59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63,\n\t// CONTEXT_{M,L}SB6, second last byte (1536-1791)\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n]);\n\n// Lookup offsets for different context modes\nexport const CONTEXT_LOOKUP_OFFSETS = new Uint16Array([\n\t// CONTEXT_LSB6\n\t1024, 1536,\n\t// CONTEXT_MSB6\n\t1280, 1536,\n\t// CONTEXT_UTF8\n\t0, 256,\n\t// CONTEXT_SIGNED\n\t768, 512,\n]);\n",
    "/**\n * Brotli static dictionary\n * Based on brotli.js reference implementation (Apache 2.0 License)\n *\n * The dictionary is loaded lazily to avoid bloating the initial bundle.\n */\n\n// Offsets into the dictionary by word length (4-24)\nexport const DICTIONARY_OFFSETS_BY_LENGTH = new Uint32Array([\n\t0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040,\n\t93696, 100864, 104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280,\n\t122016,\n]);\n\n// Size bits by word length\nexport const DICTIONARY_SIZE_BITS_BY_LENGTH = new Uint8Array([\n\t0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6,\n\t5, 5,\n]);\n\nexport const MIN_DICTIONARY_WORD_LENGTH = 4;\nexport const MAX_DICTIONARY_WORD_LENGTH = 24;\n\n// The Brotli dictionary is ~122KB of static data\n// For WOFF2 fonts, dictionary references are relatively rare in font data\n// since fonts are mostly binary glyph data, not text.\n// We initialize an empty dictionary - if dictionary references are needed,\n// the full dictionary can be loaded separately.\nexport const DICTIONARY = new Uint8Array(122784);\n",
    "/**\n * Dictionary word transformations for Brotli decompression\n * Based on brotli.js reference implementation (Apache 2.0 License)\n */\n\nconst IDENTITY = 0;\nconst OMIT_LAST_1 = 1;\nconst OMIT_LAST_2 = 2;\nconst OMIT_LAST_3 = 3;\nconst OMIT_LAST_4 = 4;\nconst OMIT_LAST_5 = 5;\nconst OMIT_LAST_6 = 6;\nconst OMIT_LAST_7 = 7;\nconst OMIT_LAST_8 = 8;\nconst OMIT_LAST_9 = 9;\nconst UPPERCASE_FIRST = 10;\nconst UPPERCASE_ALL = 11;\nconst OMIT_FIRST_1 = 12;\nconst OMIT_FIRST_2 = 13;\nconst OMIT_FIRST_3 = 14;\nconst OMIT_FIRST_4 = 15;\nconst OMIT_FIRST_5 = 16;\nconst OMIT_FIRST_6 = 17;\nconst OMIT_FIRST_7 = 18;\nconst _OMIT_FIRST_8 = 19;\nconst OMIT_FIRST_9 = 20;\n\ninterface Transform {\n\tprefix: Uint8Array;\n\ttransform: number;\n\tsuffix: Uint8Array;\n}\n\nfunction makeTransform(\n\tprefix: string,\n\ttransform: number,\n\tsuffix: string,\n): Transform {\n\tconst prefixBytes = new Uint8Array(prefix.length);\n\tconst suffixBytes = new Uint8Array(suffix.length);\n\tfor (let i = 0; i < prefix.length; i++) prefixBytes[i] = prefix.charCodeAt(i);\n\tfor (let i = 0; i < suffix.length; i++) suffixBytes[i] = suffix.charCodeAt(i);\n\treturn { prefix: prefixBytes, transform, suffix: suffixBytes };\n}\n\nexport const TRANSFORMS: Transform[] = [\n\tmakeTransform(\"\", IDENTITY, \"\"),\n\tmakeTransform(\"\", IDENTITY, \" \"),\n\tmakeTransform(\" \", IDENTITY, \" \"),\n\tmakeTransform(\"\", OMIT_FIRST_1, \"\"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \" \"),\n\tmakeTransform(\"\", IDENTITY, \" the \"),\n\tmakeTransform(\" \", IDENTITY, \"\"),\n\tmakeTransform(\"s \", IDENTITY, \" \"),\n\tmakeTransform(\"\", IDENTITY, \" of \"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \"\"),\n\tmakeTransform(\"\", IDENTITY, \" and \"),\n\tmakeTransform(\"\", OMIT_FIRST_2, \"\"),\n\tmakeTransform(\"\", OMIT_LAST_1, \"\"),\n\tmakeTransform(\", \", IDENTITY, \" \"),\n\tmakeTransform(\"\", IDENTITY, \", \"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \" \"),\n\tmakeTransform(\"\", IDENTITY, \" in \"),\n\tmakeTransform(\"\", IDENTITY, \" to \"),\n\tmakeTransform(\"e \", IDENTITY, \" \"),\n\tmakeTransform(\"\", IDENTITY, '\"'),\n\tmakeTransform(\"\", IDENTITY, \".\"),\n\tmakeTransform(\"\", IDENTITY, '\">'),\n\tmakeTransform(\"\", IDENTITY, \"\\n\"),\n\tmakeTransform(\"\", OMIT_LAST_3, \"\"),\n\tmakeTransform(\"\", IDENTITY, \"]\"),\n\tmakeTransform(\"\", IDENTITY, \" for \"),\n\tmakeTransform(\"\", OMIT_FIRST_3, \"\"),\n\tmakeTransform(\"\", OMIT_LAST_2, \"\"),\n\tmakeTransform(\"\", IDENTITY, \" a \"),\n\tmakeTransform(\"\", IDENTITY, \" that \"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \"\"),\n\tmakeTransform(\"\", IDENTITY, \". \"),\n\tmakeTransform(\".\", IDENTITY, \"\"),\n\tmakeTransform(\" \", IDENTITY, \", \"),\n\tmakeTransform(\"\", OMIT_FIRST_4, \"\"),\n\tmakeTransform(\"\", IDENTITY, \" with \"),\n\tmakeTransform(\"\", IDENTITY, \"'\"),\n\tmakeTransform(\"\", IDENTITY, \" from \"),\n\tmakeTransform(\"\", IDENTITY, \" by \"),\n\tmakeTransform(\"\", OMIT_FIRST_5, \"\"),\n\tmakeTransform(\"\", OMIT_FIRST_6, \"\"),\n\tmakeTransform(\" the \", IDENTITY, \"\"),\n\tmakeTransform(\"\", OMIT_LAST_4, \"\"),\n\tmakeTransform(\"\", IDENTITY, \". The \"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \"\"),\n\tmakeTransform(\"\", IDENTITY, \" on \"),\n\tmakeTransform(\"\", IDENTITY, \" as \"),\n\tmakeTransform(\"\", IDENTITY, \" is \"),\n\tmakeTransform(\"\", OMIT_LAST_7, \"\"),\n\tmakeTransform(\"\", OMIT_LAST_1, \"ing \"),\n\tmakeTransform(\"\", IDENTITY, \"\\n\\t\"),\n\tmakeTransform(\"\", IDENTITY, \":\"),\n\tmakeTransform(\" \", IDENTITY, \". \"),\n\tmakeTransform(\"\", IDENTITY, \"ed \"),\n\tmakeTransform(\"\", OMIT_FIRST_9, \"\"),\n\tmakeTransform(\"\", OMIT_FIRST_7, \"\"),\n\tmakeTransform(\"\", OMIT_LAST_6, \"\"),\n\tmakeTransform(\"\", IDENTITY, \"(\"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \", \"),\n\tmakeTransform(\"\", OMIT_LAST_8, \"\"),\n\tmakeTransform(\"\", IDENTITY, \" at \"),\n\tmakeTransform(\"\", IDENTITY, \"ly \"),\n\tmakeTransform(\" the \", IDENTITY, \" of \"),\n\tmakeTransform(\"\", OMIT_LAST_5, \"\"),\n\tmakeTransform(\"\", OMIT_LAST_9, \"\"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \", \"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, '\"'),\n\tmakeTransform(\".\", IDENTITY, \"(\"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \" \"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, '\">'),\n\tmakeTransform(\"\", IDENTITY, '=\"'),\n\tmakeTransform(\" \", IDENTITY, \".\"),\n\tmakeTransform(\".com/\", IDENTITY, \"\"),\n\tmakeTransform(\" the \", IDENTITY, \" of the \"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \"'\"),\n\tmakeTransform(\"\", IDENTITY, \". This \"),\n\tmakeTransform(\"\", IDENTITY, \",\"),\n\tmakeTransform(\".\", IDENTITY, \" \"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \"(\"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \".\"),\n\tmakeTransform(\"\", IDENTITY, \" not \"),\n\tmakeTransform(\" \", IDENTITY, '=\"'),\n\tmakeTransform(\"\", IDENTITY, \"er \"),\n\tmakeTransform(\" \", UPPERCASE_ALL, \" \"),\n\tmakeTransform(\"\", IDENTITY, \"al \"),\n\tmakeTransform(\" \", UPPERCASE_ALL, \"\"),\n\tmakeTransform(\"\", IDENTITY, \"='\"),\n\tmakeTransform(\"\", UPPERCASE_ALL, '\"'),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \". \"),\n\tmakeTransform(\" \", IDENTITY, \"(\"),\n\tmakeTransform(\"\", IDENTITY, \"ful \"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \". \"),\n\tmakeTransform(\"\", IDENTITY, \"ive \"),\n\tmakeTransform(\"\", IDENTITY, \"less \"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \"'\"),\n\tmakeTransform(\"\", IDENTITY, \"est \"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \".\"),\n\tmakeTransform(\"\", UPPERCASE_ALL, '\">'),\n\tmakeTransform(\" \", IDENTITY, \"='\"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \",\"),\n\tmakeTransform(\"\", IDENTITY, \"ize \"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \".\"),\n\tmakeTransform(\"\\xc2\\xa0\", IDENTITY, \"\"),\n\tmakeTransform(\" \", IDENTITY, \",\"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, '=\"'),\n\tmakeTransform(\"\", UPPERCASE_ALL, '=\"'),\n\tmakeTransform(\"\", IDENTITY, \"ous \"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \", \"),\n\tmakeTransform(\"\", UPPERCASE_FIRST, \"='\"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \",\"),\n\tmakeTransform(\" \", UPPERCASE_ALL, '=\"'),\n\tmakeTransform(\" \", UPPERCASE_ALL, \", \"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \",\"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \"(\"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \". \"),\n\tmakeTransform(\" \", UPPERCASE_ALL, \".\"),\n\tmakeTransform(\"\", UPPERCASE_ALL, \"='\"),\n\tmakeTransform(\" \", UPPERCASE_ALL, \". \"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, '=\"'),\n\tmakeTransform(\" \", UPPERCASE_ALL, \"='\"),\n\tmakeTransform(\" \", UPPERCASE_FIRST, \"='\"),\n];\n\nfunction toUpperCase(p: Uint8Array, i: number): number {\n\tif (p[i] < 0xc0) {\n\t\tif (p[i] >= 97 && p[i] <= 122) {\n\t\t\tp[i] ^= 32;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t// UTF-8 multi-byte\n\tif (p[i] < 0xe0) {\n\t\tp[i + 1] ^= 32;\n\t\treturn 2;\n\t}\n\n\t// Three-byte characters\n\tp[i + 2] ^= 5;\n\treturn 3;\n}\n\nexport function transformDictionaryWord(\n\tdst: Uint8Array,\n\tidx: number,\n\twordOffset: number,\n\tlen: number,\n\ttransformIdx: number,\n\tdictionary: Uint8Array,\n): number {\n\tconst transform = TRANSFORMS[transformIdx];\n\tconst t = transform.transform;\n\tlet skip = t < OMIT_FIRST_1 ? 0 : t - (OMIT_FIRST_1 - 1);\n\tconst startIdx = idx;\n\n\tif (skip > len) skip = len;\n\n\t// Write prefix\n\tfor (let i = 0; i < transform.prefix.length; i++) {\n\t\tdst[idx++] = transform.prefix[i];\n\t}\n\n\tconst word = wordOffset + skip;\n\tlet wordLen = len - skip;\n\n\tif (t <= OMIT_LAST_9) {\n\t\twordLen -= t;\n\t}\n\n\t// Copy dictionary word\n\tfor (let i = 0; i < wordLen; i++) {\n\t\tdst[idx++] = dictionary[word + i];\n\t}\n\n\tlet uppercase = idx - wordLen;\n\n\tif (t === UPPERCASE_FIRST) {\n\t\ttoUpperCase(dst, uppercase);\n\t} else if (t === UPPERCASE_ALL) {\n\t\twhile (wordLen > 0) {\n\t\t\tconst step = toUpperCase(dst, uppercase);\n\t\t\tuppercase += step;\n\t\t\twordLen -= step;\n\t\t}\n\t}\n\n\t// Write suffix\n\tfor (let i = 0; i < transform.suffix.length; i++) {\n\t\tdst[idx++] = transform.suffix[i];\n\t}\n\n\treturn idx - startIdx;\n}\n",
    "/**\n * Pure TypeScript Brotli Decompressor\n * Based on the brotli.js reference implementation (MIT License)\n * https://github.com/devongovett/brotli.js\n */\n\nimport { CONTEXT_LOOKUP, CONTEXT_LOOKUP_OFFSETS } from \"./context.ts\";\nimport {\n\tDICTIONARY,\n\tDICTIONARY_OFFSETS_BY_LENGTH,\n\tDICTIONARY_SIZE_BITS_BY_LENGTH,\n} from \"./dictionary.ts\";\nimport { TRANSFORMS, transformDictionaryWord } from \"./transform.ts\";\n\n// Constants\nconst MAX_HUFFMAN_TABLE_SIZE = 1080;\nconst CODE_LENGTH_CODES = 18;\nconst NUM_LITERAL_CODES = 256;\nconst NUM_INSERT_AND_COPY_CODES = 704;\nconst NUM_BLOCK_LENGTH_CODES = 26;\nconst NUM_DISTANCE_SHORT_CODES = 16;\nconst HUFFMAN_TABLE_BITS = 8;\nconst HUFFMAN_TABLE_MASK = 0xff;\n\nconst CODE_LENGTH_CODE_ORDER = new Uint8Array([\n\t1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n]);\n\nconst DISTANCE_SHORT_CODE_INDEX_OFFSET = new Uint8Array([\n\t3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n]);\n\nconst DISTANCE_SHORT_CODE_VALUE_OFFSET = new Int8Array([\n\t0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3,\n]);\n\n// Prefix code tables\nconst BLOCK_LENGTH_PREFIX = [\n\t{ offset: 1, nbits: 2 },\n\t{ offset: 5, nbits: 2 },\n\t{ offset: 9, nbits: 2 },\n\t{ offset: 13, nbits: 2 },\n\t{ offset: 17, nbits: 3 },\n\t{ offset: 25, nbits: 3 },\n\t{ offset: 33, nbits: 3 },\n\t{ offset: 41, nbits: 3 },\n\t{ offset: 49, nbits: 4 },\n\t{ offset: 65, nbits: 4 },\n\t{ offset: 81, nbits: 4 },\n\t{ offset: 97, nbits: 4 },\n\t{ offset: 113, nbits: 5 },\n\t{ offset: 145, nbits: 5 },\n\t{ offset: 177, nbits: 5 },\n\t{ offset: 209, nbits: 5 },\n\t{ offset: 241, nbits: 6 },\n\t{ offset: 305, nbits: 6 },\n\t{ offset: 369, nbits: 7 },\n\t{ offset: 497, nbits: 8 },\n\t{ offset: 753, nbits: 9 },\n\t{ offset: 1265, nbits: 10 },\n\t{ offset: 2289, nbits: 11 },\n\t{ offset: 4337, nbits: 12 },\n\t{ offset: 8433, nbits: 13 },\n\t{ offset: 16625, nbits: 24 },\n];\n\nconst INSERT_LENGTH_PREFIX = [\n\t{ offset: 0, nbits: 0 },\n\t{ offset: 1, nbits: 0 },\n\t{ offset: 2, nbits: 0 },\n\t{ offset: 3, nbits: 0 },\n\t{ offset: 4, nbits: 0 },\n\t{ offset: 5, nbits: 0 },\n\t{ offset: 6, nbits: 1 },\n\t{ offset: 8, nbits: 1 },\n\t{ offset: 10, nbits: 2 },\n\t{ offset: 14, nbits: 2 },\n\t{ offset: 18, nbits: 3 },\n\t{ offset: 26, nbits: 3 },\n\t{ offset: 34, nbits: 4 },\n\t{ offset: 50, nbits: 4 },\n\t{ offset: 66, nbits: 5 },\n\t{ offset: 98, nbits: 5 },\n\t{ offset: 130, nbits: 6 },\n\t{ offset: 194, nbits: 7 },\n\t{ offset: 322, nbits: 8 },\n\t{ offset: 578, nbits: 9 },\n\t{ offset: 1090, nbits: 10 },\n\t{ offset: 2114, nbits: 12 },\n\t{ offset: 6210, nbits: 14 },\n\t{ offset: 22594, nbits: 24 },\n];\n\nconst COPY_LENGTH_PREFIX = [\n\t{ offset: 2, nbits: 0 },\n\t{ offset: 3, nbits: 0 },\n\t{ offset: 4, nbits: 0 },\n\t{ offset: 5, nbits: 0 },\n\t{ offset: 6, nbits: 0 },\n\t{ offset: 7, nbits: 0 },\n\t{ offset: 8, nbits: 0 },\n\t{ offset: 9, nbits: 0 },\n\t{ offset: 10, nbits: 1 },\n\t{ offset: 12, nbits: 1 },\n\t{ offset: 14, nbits: 2 },\n\t{ offset: 18, nbits: 2 },\n\t{ offset: 22, nbits: 3 },\n\t{ offset: 30, nbits: 3 },\n\t{ offset: 38, nbits: 4 },\n\t{ offset: 54, nbits: 4 },\n\t{ offset: 70, nbits: 5 },\n\t{ offset: 102, nbits: 5 },\n\t{ offset: 134, nbits: 6 },\n\t{ offset: 198, nbits: 7 },\n\t{ offset: 326, nbits: 8 },\n\t{ offset: 582, nbits: 9 },\n\t{ offset: 1094, nbits: 10 },\n\t{ offset: 2118, nbits: 24 },\n];\n\nconst INSERT_RANGE_LUT = [0, 0, 8, 8, 0, 16, 8, 16, 16];\nconst COPY_RANGE_LUT = [0, 8, 0, 8, 16, 0, 16, 8, 16];\n\n// Huffman code structure\ninterface HuffmanCode {\n\tbits: number;\n\tvalue: number;\n}\n\n// Bit reader class\nclass BitReader {\n\tprivate buf: Uint8Array;\n\tprivate pos = 0;\n\tprivate val = 0;\n\tprivate bitPos = 0;\n\tprivate bitEndPos = 0;\n\tprivate eos = false;\n\n\tconstructor(private data: Uint8Array) {\n\t\tthis.buf = new Uint8Array(8224); // 2 * 4096 + 32\n\t\tthis.fillBuffer();\n\t\t// Pre-fetch initial bits\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis.val |= this.buf[this.pos] << (8 * i);\n\t\t\tthis.pos++;\n\t\t}\n\t}\n\n\tprivate fillBuffer(): void {\n\t\tif (this.bitEndPos > 256) return;\n\t\tif (this.eos) {\n\t\t\tif (this.bitPos > this.bitEndPos) {\n\t\t\t\tthrow new Error(\"Unexpected end of input\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst remaining = this.data.length - this.pos;\n\t\tconst toRead = Math.min(4096, remaining);\n\n\t\tif (toRead > 0) {\n\t\t\tthis.buf.set(this.data.subarray(this.pos, this.pos + toRead), 0);\n\t\t\tthis.pos = 0;\n\t\t}\n\n\t\tif (toRead < 4096) {\n\t\t\tthis.eos = true;\n\t\t\t// Pad with zeros\n\t\t\tfor (let i = 0; i < 32; i++) {\n\t\t\t\tthis.buf[toRead + i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tthis.bitEndPos += toRead << 3;\n\t}\n\n\treadMoreInput(): void {\n\t\tif (this.bitEndPos > 256) return;\n\t\tif (this.eos) {\n\t\t\tif (this.bitPos > this.bitEndPos) {\n\t\t\t\tthrow new Error(\"Unexpected end of input\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst dst = this.pos & 4095;\n\t\tconst bytesRemaining = Math.min(\n\t\t\t4096,\n\t\t\tthis.data.length - (this.pos & ~4095),\n\t\t);\n\n\t\tif (bytesRemaining > 0) {\n\t\t\tconst srcStart = this.pos & ~4095;\n\t\t\tthis.buf.set(\n\t\t\t\tthis.data.subarray(srcStart, srcStart + bytesRemaining),\n\t\t\t\tdst === 0 ? 0 : 4096,\n\t\t\t);\n\t\t}\n\n\t\tif (bytesRemaining < 4096) {\n\t\t\tthis.eos = true;\n\t\t\tfor (let i = 0; i < 32; i++) {\n\t\t\t\tthis.buf[dst + bytesRemaining + i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tthis.bitEndPos += bytesRemaining << 3;\n\t}\n\n\tfillBitWindow(): void {\n\t\twhile (this.bitPos >= 8) {\n\t\t\tthis.val >>>= 8;\n\t\t\tthis.val |= this.buf[this.pos & 8191] << 24;\n\t\t\tthis.pos++;\n\t\t\tthis.bitPos -= 8;\n\t\t\tthis.bitEndPos -= 8;\n\t\t}\n\t}\n\n\treadBits(n: number): number {\n\t\tif (32 - this.bitPos < n) {\n\t\t\tthis.fillBitWindow();\n\t\t}\n\t\tconst val = (this.val >>> this.bitPos) & ((1 << n) - 1);\n\t\tthis.bitPos += n;\n\t\treturn val;\n\t}\n\n\tget currentBitPos(): number {\n\t\treturn this.bitPos;\n\t}\n\n\tset currentBitPos(v: number) {\n\t\tthis.bitPos = v;\n\t}\n\n\tget currentVal(): number {\n\t\treturn this.val;\n\t}\n}\n\n// Build Huffman table\nfunction buildHuffmanTable(\n\trootTable: HuffmanCode[],\n\ttableOffset: number,\n\trootBits: number,\n\tcodeLengths: Uint8Array,\n\tcodeLengthsSize: number,\n): number {\n\tconst MAX_LENGTH = 15;\n\tconst count = new Int32Array(MAX_LENGTH + 1);\n\tconst offset = new Int32Array(MAX_LENGTH + 1);\n\tconst sorted = new Int32Array(codeLengthsSize);\n\n\t// Build histogram\n\tfor (let i = 0; i < codeLengthsSize; i++) {\n\t\tcount[codeLengths[i]]++;\n\t}\n\n\t// Generate offsets\n\toffset[1] = 0;\n\tfor (let len = 1; len < MAX_LENGTH; len++) {\n\t\toffset[len + 1] = offset[len] + count[len];\n\t}\n\n\t// Sort symbols\n\tfor (let i = 0; i < codeLengthsSize; i++) {\n\t\tif (codeLengths[i] !== 0) {\n\t\t\tsorted[offset[codeLengths[i]]++] = i;\n\t\t}\n\t}\n\n\tlet tableBits = rootBits;\n\tlet tableSize = 1 << tableBits;\n\tlet totalSize = tableSize;\n\n\t// Special case: single value\n\tif (offset[MAX_LENGTH] === 1) {\n\t\tfor (let i = 0; i < totalSize; i++) {\n\t\t\trootTable[tableOffset + i] = { bits: 0, value: sorted[0] & 0xffff };\n\t\t}\n\t\treturn totalSize;\n\t}\n\n\t// Fill root table\n\tlet key = 0;\n\tlet symbol = 0;\n\tfor (let len = 1, step = 2; len <= rootBits; len++, step <<= 1) {\n\t\tfor (; count[len] > 0; count[len]--) {\n\t\t\tconst code: HuffmanCode = {\n\t\t\t\tbits: len & 0xff,\n\t\t\t\tvalue: sorted[symbol++] & 0xffff,\n\t\t\t};\n\t\t\treplicateValue(rootTable, tableOffset + key, step, tableSize, code);\n\t\t\tkey = getNextKey(key, len);\n\t\t}\n\t}\n\n\t// Fill 2nd level tables\n\tconst mask = totalSize - 1;\n\tlet low = -1;\n\tlet table = tableOffset;\n\n\tfor (let len = rootBits + 1, step = 2; len <= MAX_LENGTH; len++, step <<= 1) {\n\t\tfor (; count[len] > 0; count[len]--) {\n\t\t\tif ((key & mask) !== low) {\n\t\t\t\ttable += tableSize;\n\t\t\t\ttableBits = nextTableBitSize(count, len, rootBits);\n\t\t\t\ttableSize = 1 << tableBits;\n\t\t\t\ttotalSize += tableSize;\n\t\t\t\tlow = key & mask;\n\t\t\t\trootTable[tableOffset + low] = {\n\t\t\t\t\tbits: (tableBits + rootBits) & 0xff,\n\t\t\t\t\tvalue: (table - tableOffset - low) & 0xffff,\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst code: HuffmanCode = {\n\t\t\t\tbits: (len - rootBits) & 0xff,\n\t\t\t\tvalue: sorted[symbol++] & 0xffff,\n\t\t\t};\n\t\t\treplicateValue(\n\t\t\t\trootTable,\n\t\t\t\ttable + (key >> rootBits),\n\t\t\t\tstep,\n\t\t\t\ttableSize,\n\t\t\t\tcode,\n\t\t\t);\n\t\t\tkey = getNextKey(key, len);\n\t\t}\n\t}\n\n\treturn totalSize;\n}\n\nfunction getNextKey(key: number, len: number): number {\n\tlet step = 1 << (len - 1);\n\twhile (key & step) {\n\t\tstep >>= 1;\n\t}\n\treturn (key & (step - 1)) + step;\n}\n\nfunction replicateValue(\n\ttable: HuffmanCode[],\n\toffset: number,\n\tstep: number,\n\tend: number,\n\tcode: HuffmanCode,\n): void {\n\tdo {\n\t\tend -= step;\n\t\ttable[offset + end] = { bits: code.bits, value: code.value };\n\t} while (end > 0);\n}\n\nfunction nextTableBitSize(\n\tcount: Int32Array,\n\tlen: number,\n\trootBits: number,\n): number {\n\tlet left = 1 << (len - rootBits);\n\twhile (len < 15) {\n\t\tleft -= count[len];\n\t\tif (left <= 0) break;\n\t\tlen++;\n\t\tleft <<= 1;\n\t}\n\treturn len - rootBits;\n}\n\n// Read symbol from Huffman table\nfunction readSymbol(\n\ttable: HuffmanCode[],\n\ttableOffset: number,\n\tbr: BitReader,\n): number {\n\tbr.fillBitWindow();\n\tlet index =\n\t\ttableOffset + ((br.currentVal >>> br.currentBitPos) & HUFFMAN_TABLE_MASK);\n\tconst nbits = table[index].bits - HUFFMAN_TABLE_BITS;\n\tif (nbits > 0) {\n\t\tbr.currentBitPos += HUFFMAN_TABLE_BITS;\n\t\tindex += table[index].value;\n\t\tindex += (br.currentVal >>> br.currentBitPos) & ((1 << nbits) - 1);\n\t}\n\tbr.currentBitPos += table[index].bits;\n\treturn table[index].value;\n}\n\n// Decode variable-length uint8\nfunction decodeVarLenUint8(br: BitReader): number {\n\tif (br.readBits(1)) {\n\t\tconst nbits = br.readBits(3);\n\t\tif (nbits === 0) return 1;\n\t\treturn br.readBits(nbits) + (1 << nbits);\n\t}\n\treturn 0;\n}\n\n// Decode window bits\nfunction decodeWindowBits(br: BitReader): number {\n\tif (br.readBits(1) === 0) return 16;\n\tlet n = br.readBits(3);\n\tif (n > 0) return 17 + n;\n\tn = br.readBits(3);\n\tif (n > 0) return 8 + n;\n\treturn 17;\n}\n\n// Decode meta block length\nfunction decodeMetaBlockLength(br: BitReader): {\n\tlength: number;\n\tisLast: boolean;\n\tisUncompressed: boolean;\n\tisMetadata: boolean;\n} {\n\tconst isLast = br.readBits(1) === 1;\n\tif (isLast && br.readBits(1)) {\n\t\treturn {\n\t\t\tlength: 0,\n\t\t\tisLast: true,\n\t\t\tisUncompressed: false,\n\t\t\tisMetadata: false,\n\t\t};\n\t}\n\n\tconst sizeNibbles = br.readBits(2) + 4;\n\tif (sizeNibbles === 7) {\n\t\t// Metadata block\n\t\tif (br.readBits(1) !== 0) throw new Error(\"Invalid reserved bit\");\n\t\tconst sizeBytes = br.readBits(2);\n\t\tif (sizeBytes === 0)\n\t\t\treturn { length: 0, isLast, isUncompressed: false, isMetadata: true };\n\n\t\tlet length = 0;\n\t\tfor (let i = 0; i < sizeBytes; i++) {\n\t\t\tconst nextByte = br.readBits(8);\n\t\t\tif (i + 1 === sizeBytes && sizeBytes > 1 && nextByte === 0) {\n\t\t\t\tthrow new Error(\"Invalid size byte\");\n\t\t\t}\n\t\t\tlength |= nextByte << (i * 8);\n\t\t}\n\t\treturn {\n\t\t\tlength: length + 1,\n\t\t\tisLast,\n\t\t\tisUncompressed: false,\n\t\t\tisMetadata: true,\n\t\t};\n\t}\n\n\tlet length = 0;\n\tfor (let i = 0; i < sizeNibbles; i++) {\n\t\tconst nextNibble = br.readBits(4);\n\t\tif (i + 1 === sizeNibbles && sizeNibbles > 4 && nextNibble === 0) {\n\t\t\tthrow new Error(\"Invalid size nibble\");\n\t\t}\n\t\tlength |= nextNibble << (i * 4);\n\t}\n\tlength++;\n\n\tconst isUncompressed = !isLast ? br.readBits(1) === 1 : false;\n\treturn { length, isLast, isUncompressed, isMetadata: false };\n}\n\n// Read Huffman code lengths\nfunction readHuffmanCodeLengths(\n\tcodeLengthCodeLengths: Uint8Array,\n\tnumSymbols: number,\n\tcodeLengths: Uint8Array,\n\tbr: BitReader,\n): void {\n\tconst DEFAULT_CODE_LENGTH = 8;\n\tconst CODE_LENGTH_REPEAT_CODE = 16;\n\n\tlet symbol = 0;\n\tlet prevCodeLen = DEFAULT_CODE_LENGTH;\n\tlet repeat = 0;\n\tlet repeatCodeLen = 0;\n\tlet space = 32768;\n\n\tconst table: HuffmanCode[] = [];\n\tfor (let i = 0; i < 32; i++) {\n\t\ttable.push({ bits: 0, value: 0 });\n\t}\n\n\tbuildHuffmanTable(table, 0, 5, codeLengthCodeLengths, CODE_LENGTH_CODES);\n\n\twhile (symbol < numSymbols && space > 0) {\n\t\tbr.readMoreInput();\n\t\tbr.fillBitWindow();\n\t\tconst p = (br.currentVal >>> br.currentBitPos) & 31;\n\t\tbr.currentBitPos += table[p].bits;\n\t\tconst codeLen = table[p].value & 0xff;\n\n\t\tif (codeLen < CODE_LENGTH_REPEAT_CODE) {\n\t\t\trepeat = 0;\n\t\t\tcodeLengths[symbol++] = codeLen;\n\t\t\tif (codeLen !== 0) {\n\t\t\t\tprevCodeLen = codeLen;\n\t\t\t\tspace -= 32768 >> codeLen;\n\t\t\t}\n\t\t} else {\n\t\t\tconst extraBits = codeLen - 14;\n\t\t\tlet newLen = 0;\n\t\t\tif (codeLen === CODE_LENGTH_REPEAT_CODE) {\n\t\t\t\tnewLen = prevCodeLen;\n\t\t\t}\n\t\t\tif (repeatCodeLen !== newLen) {\n\t\t\t\trepeat = 0;\n\t\t\t\trepeatCodeLen = newLen;\n\t\t\t}\n\t\t\tconst oldRepeat = repeat;\n\t\t\tif (repeat > 0) {\n\t\t\t\trepeat -= 2;\n\t\t\t\trepeat <<= extraBits;\n\t\t\t}\n\t\t\trepeat += br.readBits(extraBits) + 3;\n\t\t\tconst repeatDelta = repeat - oldRepeat;\n\n\t\t\tif (symbol + repeatDelta > numSymbols) {\n\t\t\t\tthrow new Error(\"Symbol overflow\");\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < repeatDelta; i++) {\n\t\t\t\tcodeLengths[symbol + i] = repeatCodeLen;\n\t\t\t}\n\t\t\tsymbol += repeatDelta;\n\n\t\t\tif (repeatCodeLen !== 0) {\n\t\t\t\tspace -= repeatDelta << (15 - repeatCodeLen);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (space !== 0) {\n\t\tthrow new Error(\"Invalid code lengths\");\n\t}\n\n\tfor (; symbol < numSymbols; symbol++) {\n\t\tcodeLengths[symbol] = 0;\n\t}\n}\n\n// Read Huffman code\nfunction readHuffmanCode(\n\talphabetSize: number,\n\ttables: HuffmanCode[],\n\ttableOffset: number,\n\tbr: BitReader,\n): number {\n\tconst codeLengths = new Uint8Array(alphabetSize);\n\n\tbr.readMoreInput();\n\n\tconst simpleCodeOrSkip = br.readBits(2);\n\tif (simpleCodeOrSkip === 1) {\n\t\t// Simple code\n\t\tlet maxBitsCounter = alphabetSize - 1;\n\t\tlet maxBits = 0;\n\t\twhile (maxBitsCounter) {\n\t\t\tmaxBitsCounter >>= 1;\n\t\t\tmaxBits++;\n\t\t}\n\n\t\tconst symbols = new Int32Array(4);\n\t\tconst numSymbols = br.readBits(2) + 1;\n\n\t\tfor (let i = 0; i < numSymbols; i++) {\n\t\t\tsymbols[i] = br.readBits(maxBits) % alphabetSize;\n\t\t\tcodeLengths[symbols[i]] = 2;\n\t\t}\n\t\tcodeLengths[symbols[0]] = 1;\n\n\t\tswitch (numSymbols) {\n\t\t\tcase 2:\n\t\t\t\tif (symbols[0] === symbols[1]) throw new Error(\"Invalid symbols\");\n\t\t\t\tcodeLengths[symbols[1]] = 1;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (br.readBits(1)) {\n\t\t\t\t\tcodeLengths[symbols[2]] = 3;\n\t\t\t\t\tcodeLengths[symbols[3]] = 3;\n\t\t\t\t} else {\n\t\t\t\t\tcodeLengths[symbols[0]] = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t// Complex code\n\t\tconst codeLengthCodeLengths = new Uint8Array(CODE_LENGTH_CODES);\n\t\tlet space = 32;\n\t\tlet numCodes = 0;\n\n\t\tconst huff: HuffmanCode[] = [\n\t\t\t{ bits: 2, value: 0 },\n\t\t\t{ bits: 2, value: 4 },\n\t\t\t{ bits: 2, value: 3 },\n\t\t\t{ bits: 3, value: 2 },\n\t\t\t{ bits: 2, value: 0 },\n\t\t\t{ bits: 2, value: 4 },\n\t\t\t{ bits: 2, value: 3 },\n\t\t\t{ bits: 4, value: 1 },\n\t\t\t{ bits: 2, value: 0 },\n\t\t\t{ bits: 2, value: 4 },\n\t\t\t{ bits: 2, value: 3 },\n\t\t\t{ bits: 3, value: 2 },\n\t\t\t{ bits: 2, value: 0 },\n\t\t\t{ bits: 2, value: 4 },\n\t\t\t{ bits: 2, value: 3 },\n\t\t\t{ bits: 4, value: 5 },\n\t\t];\n\n\t\tfor (let i = simpleCodeOrSkip; i < CODE_LENGTH_CODES && space > 0; i++) {\n\t\t\tconst codeLenIdx = CODE_LENGTH_CODE_ORDER[i];\n\t\t\tbr.fillBitWindow();\n\t\t\tconst p = (br.currentVal >>> br.currentBitPos) & 15;\n\t\t\tbr.currentBitPos += huff[p].bits;\n\t\t\tconst v = huff[p].value;\n\t\t\tcodeLengthCodeLengths[codeLenIdx] = v;\n\t\t\tif (v !== 0) {\n\t\t\t\tspace -= 32 >> v;\n\t\t\t\tnumCodes++;\n\t\t\t}\n\t\t}\n\n\t\tif (!(numCodes === 1 || space === 0)) {\n\t\t\tthrow new Error(\"Invalid code length codes\");\n\t\t}\n\n\t\treadHuffmanCodeLengths(\n\t\t\tcodeLengthCodeLengths,\n\t\t\talphabetSize,\n\t\t\tcodeLengths,\n\t\t\tbr,\n\t\t);\n\t}\n\n\treturn buildHuffmanTable(\n\t\ttables,\n\t\ttableOffset,\n\t\tHUFFMAN_TABLE_BITS,\n\t\tcodeLengths,\n\t\talphabetSize,\n\t);\n}\n\n// Huffman tree group\nclass HuffmanTreeGroup {\n\tcodes: HuffmanCode[] = [];\n\thtrees: Uint32Array;\n\n\tconstructor(\n\t\tpublic alphabetSize: number,\n\t\tpublic numHTrees: number,\n\t) {\n\t\tthis.htrees = new Uint32Array(numHTrees);\n\t\tconst maxSize = this.getMaxTableSize();\n\t\tfor (let i = 0; i < numHTrees + numHTrees * maxSize; i++) {\n\t\t\tthis.codes.push({ bits: 0, value: 0 });\n\t\t}\n\t}\n\n\tprivate getMaxTableSize(): number {\n\t\tconst sizes = [\n\t\t\t256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822,\n\t\t\t854, 886, 920, 952, 984, 1016, 1048, 1080,\n\t\t];\n\t\tconst idx = (this.alphabetSize + 31) >>> 5;\n\t\treturn sizes[Math.min(idx, sizes.length - 1)];\n\t}\n\n\tdecode(br: BitReader): void {\n\t\tlet next = 0;\n\t\tfor (let i = 0; i < this.numHTrees; i++) {\n\t\t\tthis.htrees[i] = next;\n\t\t\tconst tableSize = readHuffmanCode(\n\t\t\t\tthis.alphabetSize,\n\t\t\t\tthis.codes,\n\t\t\t\tnext,\n\t\t\t\tbr,\n\t\t\t);\n\t\t\tnext += tableSize;\n\t\t}\n\t}\n}\n\n// Decode context map\nfunction decodeContextMap(\n\tcontextMapSize: number,\n\tbr: BitReader,\n): { numHTrees: number; contextMap: Uint8Array } {\n\tbr.readMoreInput();\n\tconst numHTrees = decodeVarLenUint8(br) + 1;\n\tconst contextMap = new Uint8Array(contextMapSize);\n\n\tif (numHTrees <= 1) {\n\t\treturn { numHTrees, contextMap };\n\t}\n\n\tconst useRleForZeros = br.readBits(1) === 1;\n\tlet maxRunLengthPrefix = 0;\n\tif (useRleForZeros) {\n\t\tmaxRunLengthPrefix = br.readBits(4) + 1;\n\t}\n\n\tconst table: HuffmanCode[] = [];\n\tfor (let i = 0; i < MAX_HUFFMAN_TABLE_SIZE; i++) {\n\t\ttable.push({ bits: 0, value: 0 });\n\t}\n\n\treadHuffmanCode(numHTrees + maxRunLengthPrefix, table, 0, br);\n\n\tfor (let i = 0; i < contextMapSize; ) {\n\t\tbr.readMoreInput();\n\t\tconst code = readSymbol(table, 0, br);\n\t\tif (code === 0) {\n\t\t\tcontextMap[i++] = 0;\n\t\t} else if (code <= maxRunLengthPrefix) {\n\t\t\tconst reps = 1 + (1 << code) + br.readBits(code);\n\t\t\tfor (let j = 1; j < reps && i < contextMapSize; j++) {\n\t\t\t\tcontextMap[i++] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcontextMap[i++] = code - maxRunLengthPrefix;\n\t\t}\n\t}\n\n\t// Inverse move-to-front transform\n\tif (br.readBits(1)) {\n\t\tconst mtf = new Uint8Array(256);\n\t\tfor (let i = 0; i < 256; i++) mtf[i] = i;\n\t\tfor (let i = 0; i < contextMapSize; i++) {\n\t\t\tconst idx = contextMap[i];\n\t\t\tcontextMap[i] = mtf[idx];\n\t\t\tif (idx) {\n\t\t\t\tconst value = mtf[idx];\n\t\t\t\tfor (let j = idx; j > 0; j--) mtf[j] = mtf[j - 1];\n\t\t\t\tmtf[0] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { numHTrees, contextMap };\n}\n\n// Read block length\nfunction readBlockLength(\n\ttable: HuffmanCode[],\n\ttableOffset: number,\n\tbr: BitReader,\n): number {\n\tconst code = readSymbol(table, tableOffset, br);\n\tconst prefix = BLOCK_LENGTH_PREFIX[code];\n\treturn prefix.offset + br.readBits(prefix.nbits);\n}\n\n// Translate short distance codes\nfunction translateShortCodes(\n\tcode: number,\n\tringBuffer: number[],\n\tindex: number,\n): number {\n\tif (code < NUM_DISTANCE_SHORT_CODES) {\n\t\tconst idx = (index + DISTANCE_SHORT_CODE_INDEX_OFFSET[code]) & 3;\n\t\treturn ringBuffer[idx] + DISTANCE_SHORT_CODE_VALUE_OFFSET[code];\n\t}\n\treturn code - NUM_DISTANCE_SHORT_CODES + 1;\n}\n\n/**\n * Decompress Brotli-compressed data\n */\nexport function decompress(data: Uint8Array): Uint8Array {\n\tconst br = new BitReader(data);\n\n\t// Decode window bits\n\tconst windowBits = decodeWindowBits(br);\n\tconst maxBackwardDistance = (1 << windowBits) - 16;\n\tconst ringBufferSize = 1 << windowBits;\n\tconst ringBufferMask = ringBufferSize - 1;\n\tconst ringBuffer = new Uint8Array(ringBufferSize + 578); // Extra space for dictionary words\n\n\tlet pos = 0;\n\tlet maxDistance = 0;\n\tconst distRb = [16, 15, 11, 4];\n\tlet distRbIdx = 0;\n\tlet prevByte1 = 0;\n\tlet prevByte2 = 0;\n\n\tconst output: number[] = [];\n\n\twhile (true) {\n\t\tbr.readMoreInput();\n\n\t\tconst meta = decodeMetaBlockLength(br);\n\t\tif (meta.length === 0 && meta.isLast) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (meta.isMetadata) {\n\t\t\t// Skip metadata\n\t\t\tbr.currentBitPos = (br.currentBitPos + 7) & ~7;\n\t\t\tfor (let i = 0; i < meta.length; i++) {\n\t\t\t\tbr.readMoreInput();\n\t\t\t\tbr.readBits(8);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet metaBlockRemaining = meta.length;\n\t\tif (metaBlockRemaining === 0) continue;\n\n\t\tif (meta.isUncompressed) {\n\t\t\tbr.currentBitPos = (br.currentBitPos + 7) & ~7;\n\t\t\tfor (let i = 0; i < metaBlockRemaining; i++) {\n\t\t\t\tbr.readMoreInput();\n\t\t\t\tconst byte = br.readBits(8);\n\t\t\t\tringBuffer[pos & ringBufferMask] = byte;\n\t\t\t\tif ((pos & ringBufferMask) === ringBufferMask) {\n\t\t\t\t\toutput.push(...ringBuffer.slice(0, ringBufferSize));\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Decode block types\n\t\tconst numBlockTypes = [1, 1, 1];\n\t\tconst blockLength = [1 << 28, 1 << 28, 1 << 28];\n\t\tconst blockType = [0, 0, 0];\n\t\tconst blockTypeRb = [0, 1, 0, 1, 0, 1];\n\t\tconst blockTypeRbIndex = [0, 0, 0];\n\n\t\tconst blockTypeTrees: HuffmanCode[] = [];\n\t\tconst blockLenTrees: HuffmanCode[] = [];\n\t\tfor (let i = 0; i < 3 * MAX_HUFFMAN_TABLE_SIZE; i++) {\n\t\t\tblockTypeTrees.push({ bits: 0, value: 0 });\n\t\t\tblockLenTrees.push({ bits: 0, value: 0 });\n\t\t}\n\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tnumBlockTypes[i] = decodeVarLenUint8(br) + 1;\n\t\t\tif (numBlockTypes[i] >= 2) {\n\t\t\t\treadHuffmanCode(\n\t\t\t\t\tnumBlockTypes[i] + 2,\n\t\t\t\t\tblockTypeTrees,\n\t\t\t\t\ti * MAX_HUFFMAN_TABLE_SIZE,\n\t\t\t\t\tbr,\n\t\t\t\t);\n\t\t\t\treadHuffmanCode(\n\t\t\t\t\tNUM_BLOCK_LENGTH_CODES,\n\t\t\t\t\tblockLenTrees,\n\t\t\t\t\ti * MAX_HUFFMAN_TABLE_SIZE,\n\t\t\t\t\tbr,\n\t\t\t\t);\n\t\t\t\tblockLength[i] = readBlockLength(\n\t\t\t\t\tblockLenTrees,\n\t\t\t\t\ti * MAX_HUFFMAN_TABLE_SIZE,\n\t\t\t\t\tbr,\n\t\t\t\t);\n\t\t\t\tblockTypeRbIndex[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tbr.readMoreInput();\n\n\t\tconst distancePostfixBits = br.readBits(2);\n\t\tconst numDirectDistanceCodes =\n\t\t\tNUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distancePostfixBits);\n\t\tconst distancePostfixMask = (1 << distancePostfixBits) - 1;\n\t\tconst numDistanceCodes =\n\t\t\tnumDirectDistanceCodes + (48 << distancePostfixBits);\n\n\t\tconst contextModes = new Uint8Array(numBlockTypes[0]);\n\t\tfor (let i = 0; i < numBlockTypes[0]; i++) {\n\t\t\tbr.readMoreInput();\n\t\t\tcontextModes[i] = br.readBits(2) << 1;\n\t\t}\n\n\t\tconst literalContextMap = decodeContextMap(numBlockTypes[0] << 6, br);\n\t\tconst distContextMap = decodeContextMap(numBlockTypes[2] << 2, br);\n\n\t\tconst hgroup = [\n\t\t\tnew HuffmanTreeGroup(NUM_LITERAL_CODES, literalContextMap.numHTrees),\n\t\t\tnew HuffmanTreeGroup(NUM_INSERT_AND_COPY_CODES, numBlockTypes[1]),\n\t\t\tnew HuffmanTreeGroup(numDistanceCodes, distContextMap.numHTrees),\n\t\t];\n\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\thgroup[i].decode(br);\n\t\t}\n\n\t\tlet contextMapSlice = 0;\n\t\tlet distContextMapSlice = 0;\n\t\tlet contextMode = contextModes[blockType[0]];\n\t\tlet contextLookupOffset1 = CONTEXT_LOOKUP_OFFSETS[contextMode];\n\t\tlet contextLookupOffset2 = CONTEXT_LOOKUP_OFFSETS[contextMode + 1];\n\t\tlet htreeCommand = hgroup[1].htrees[0];\n\n\t\twhile (metaBlockRemaining > 0) {\n\t\t\tbr.readMoreInput();\n\n\t\t\tif (blockLength[1] === 0) {\n\t\t\t\t// Decode block type\n\t\t\t\tconst typeCode = readSymbol(blockTypeTrees, MAX_HUFFMAN_TABLE_SIZE, br);\n\t\t\t\tlet bt: number;\n\t\t\t\tif (typeCode === 0) {\n\t\t\t\t\tbt = blockTypeRb[2 + (blockTypeRbIndex[1] & 1)];\n\t\t\t\t} else if (typeCode === 1) {\n\t\t\t\t\tbt = blockTypeRb[2 + ((blockTypeRbIndex[1] - 1) & 1)] + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbt = typeCode - 2;\n\t\t\t\t}\n\t\t\t\tif (bt >= numBlockTypes[1]) bt -= numBlockTypes[1];\n\t\t\t\tblockType[1] = bt;\n\t\t\t\tblockTypeRb[2 + (blockTypeRbIndex[1] & 1)] = bt;\n\t\t\t\tblockTypeRbIndex[1]++;\n\t\t\t\tblockLength[1] = readBlockLength(\n\t\t\t\t\tblockLenTrees,\n\t\t\t\t\tMAX_HUFFMAN_TABLE_SIZE,\n\t\t\t\t\tbr,\n\t\t\t\t);\n\t\t\t\thtreeCommand = hgroup[1].htrees[blockType[1]];\n\t\t\t}\n\t\t\tblockLength[1]--;\n\n\t\t\tconst cmdCode = readSymbol(hgroup[1].codes, htreeCommand, br);\n\t\t\tconst rangeIdx = cmdCode >> 6;\n\t\t\tlet distanceCode: number;\n\t\t\tif (rangeIdx >= 2) {\n\t\t\t\tdistanceCode = -1;\n\t\t\t} else {\n\t\t\t\tdistanceCode = 0;\n\t\t\t}\n\n\t\t\tconst insertCode = INSERT_RANGE_LUT[rangeIdx] + ((cmdCode >> 3) & 7);\n\t\t\tconst copyCode = COPY_RANGE_LUT[rangeIdx] + (cmdCode & 7);\n\t\t\tconst insertLength =\n\t\t\t\tINSERT_LENGTH_PREFIX[insertCode].offset +\n\t\t\t\tbr.readBits(INSERT_LENGTH_PREFIX[insertCode].nbits);\n\t\t\tconst copyLength =\n\t\t\t\tCOPY_LENGTH_PREFIX[copyCode].offset +\n\t\t\t\tbr.readBits(COPY_LENGTH_PREFIX[copyCode].nbits);\n\n\t\t\tprevByte1 = ringBuffer[(pos - 1) & ringBufferMask];\n\t\t\tprevByte2 = ringBuffer[(pos - 2) & ringBufferMask];\n\n\t\t\tfor (let j = 0; j < insertLength; j++) {\n\t\t\t\tbr.readMoreInput();\n\n\t\t\t\tif (blockLength[0] === 0) {\n\t\t\t\t\t// Decode block type for literals\n\t\t\t\t\tconst typeCode = readSymbol(blockTypeTrees, 0, br);\n\t\t\t\t\tlet bt: number;\n\t\t\t\t\tif (typeCode === 0) {\n\t\t\t\t\t\tbt = blockTypeRb[blockTypeRbIndex[0] & 1];\n\t\t\t\t\t} else if (typeCode === 1) {\n\t\t\t\t\t\tbt = blockTypeRb[(blockTypeRbIndex[0] - 1) & 1] + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbt = typeCode - 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (bt >= numBlockTypes[0]) bt -= numBlockTypes[0];\n\t\t\t\t\tblockType[0] = bt;\n\t\t\t\t\tblockTypeRb[blockTypeRbIndex[0] & 1] = bt;\n\t\t\t\t\tblockTypeRbIndex[0]++;\n\t\t\t\t\tblockLength[0] = readBlockLength(blockLenTrees, 0, br);\n\t\t\t\t\tconst contextOffset = blockType[0] << 6;\n\t\t\t\t\tcontextMapSlice = contextOffset;\n\t\t\t\t\tcontextMode = contextModes[blockType[0]];\n\t\t\t\t\tcontextLookupOffset1 = CONTEXT_LOOKUP_OFFSETS[contextMode];\n\t\t\t\t\tcontextLookupOffset2 = CONTEXT_LOOKUP_OFFSETS[contextMode + 1];\n\t\t\t\t}\n\n\t\t\t\tconst context =\n\t\t\t\t\tCONTEXT_LOOKUP[contextLookupOffset1 + prevByte1] |\n\t\t\t\t\tCONTEXT_LOOKUP[contextLookupOffset2 + prevByte2];\n\t\t\t\tconst literalHtreeIndex =\n\t\t\t\t\tliteralContextMap.contextMap[contextMapSlice + context];\n\t\t\t\tblockLength[0]--;\n\n\t\t\t\tprevByte2 = prevByte1;\n\t\t\t\tprevByte1 = readSymbol(\n\t\t\t\t\thgroup[0].codes,\n\t\t\t\t\thgroup[0].htrees[literalHtreeIndex],\n\t\t\t\t\tbr,\n\t\t\t\t);\n\t\t\t\tringBuffer[pos & ringBufferMask] = prevByte1;\n\t\t\t\tif ((pos & ringBufferMask) === ringBufferMask) {\n\t\t\t\t\toutput.push(...ringBuffer.slice(0, ringBufferSize));\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\n\t\t\tmetaBlockRemaining -= insertLength;\n\t\t\tif (metaBlockRemaining <= 0) break;\n\n\t\t\tif (distanceCode < 0) {\n\t\t\t\tbr.readMoreInput();\n\t\t\t\tif (blockLength[2] === 0) {\n\t\t\t\t\t// Decode block type for distances\n\t\t\t\t\tconst typeCode = readSymbol(\n\t\t\t\t\t\tblockTypeTrees,\n\t\t\t\t\t\t2 * MAX_HUFFMAN_TABLE_SIZE,\n\t\t\t\t\t\tbr,\n\t\t\t\t\t);\n\t\t\t\t\tlet bt: number;\n\t\t\t\t\tif (typeCode === 0) {\n\t\t\t\t\t\tbt = blockTypeRb[4 + (blockTypeRbIndex[2] & 1)];\n\t\t\t\t\t} else if (typeCode === 1) {\n\t\t\t\t\t\tbt = blockTypeRb[4 + ((blockTypeRbIndex[2] - 1) & 1)] + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbt = typeCode - 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (bt >= numBlockTypes[2]) bt -= numBlockTypes[2];\n\t\t\t\t\tblockType[2] = bt;\n\t\t\t\t\tblockTypeRb[4 + (blockTypeRbIndex[2] & 1)] = bt;\n\t\t\t\t\tblockTypeRbIndex[2]++;\n\t\t\t\t\tblockLength[2] = readBlockLength(\n\t\t\t\t\t\tblockLenTrees,\n\t\t\t\t\t\t2 * MAX_HUFFMAN_TABLE_SIZE,\n\t\t\t\t\t\tbr,\n\t\t\t\t\t);\n\t\t\t\t\tdistContextMapSlice = blockType[2] << 2;\n\t\t\t\t}\n\t\t\t\tblockLength[2]--;\n\n\t\t\t\tconst context = (copyLength > 4 ? 3 : copyLength - 2) & 0xff;\n\t\t\t\tconst distHtreeIndex =\n\t\t\t\t\tdistContextMap.contextMap[distContextMapSlice + context];\n\t\t\t\tdistanceCode = readSymbol(\n\t\t\t\t\thgroup[2].codes,\n\t\t\t\t\thgroup[2].htrees[distHtreeIndex],\n\t\t\t\t\tbr,\n\t\t\t\t);\n\n\t\t\t\tif (distanceCode >= numDirectDistanceCodes) {\n\t\t\t\t\tdistanceCode -= numDirectDistanceCodes;\n\t\t\t\t\tconst postfix = distanceCode & distancePostfixMask;\n\t\t\t\t\tdistanceCode >>= distancePostfixBits;\n\t\t\t\t\tconst nbits = (distanceCode >> 1) + 1;\n\t\t\t\t\tconst offset = ((2 + (distanceCode & 1)) << nbits) - 4;\n\t\t\t\t\tdistanceCode =\n\t\t\t\t\t\tnumDirectDistanceCodes +\n\t\t\t\t\t\t((offset + br.readBits(nbits)) << distancePostfixBits) +\n\t\t\t\t\t\tpostfix;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst distance = translateShortCodes(distanceCode, distRb, distRbIdx);\n\t\t\tif (distance < 0) {\n\t\t\t\tthrow new Error(\"Invalid distance\");\n\t\t\t}\n\n\t\t\tif (pos < maxBackwardDistance && maxDistance !== maxBackwardDistance) {\n\t\t\t\tmaxDistance = pos;\n\t\t\t} else {\n\t\t\t\tmaxDistance = maxBackwardDistance;\n\t\t\t}\n\n\t\t\tlet copyDst = pos & ringBufferMask;\n\n\t\t\tif (distance > maxDistance) {\n\t\t\t\t// Dictionary reference\n\t\t\t\tif (copyLength >= 4 && copyLength <= 24) {\n\t\t\t\t\tconst offset = DICTIONARY_OFFSETS_BY_LENGTH[copyLength];\n\t\t\t\t\tconst wordId = distance - maxDistance - 1;\n\t\t\t\t\tconst shift = DICTIONARY_SIZE_BITS_BY_LENGTH[copyLength];\n\t\t\t\t\tconst mask = (1 << shift) - 1;\n\t\t\t\t\tconst wordIdx = wordId & mask;\n\t\t\t\t\tconst transformIdx = wordId >> shift;\n\t\t\t\t\tconst wordOffset = offset + wordIdx * copyLength;\n\n\t\t\t\t\tif (transformIdx < TRANSFORMS.length) {\n\t\t\t\t\t\tconst len = transformDictionaryWord(\n\t\t\t\t\t\t\tringBuffer,\n\t\t\t\t\t\t\tcopyDst,\n\t\t\t\t\t\t\twordOffset,\n\t\t\t\t\t\t\tcopyLength,\n\t\t\t\t\t\t\ttransformIdx,\n\t\t\t\t\t\t\tDICTIONARY,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcopyDst += len;\n\t\t\t\t\t\tpos += len;\n\t\t\t\t\t\tmetaBlockRemaining -= len;\n\t\t\t\t\t\tif (copyDst >= ringBufferSize) {\n\t\t\t\t\t\t\toutput.push(...ringBuffer.slice(0, ringBufferSize));\n\t\t\t\t\t\t\tfor (let i = 0; i < copyDst - ringBufferSize; i++) {\n\t\t\t\t\t\t\t\tringBuffer[i] = ringBuffer[ringBufferSize + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Invalid backward reference\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Invalid backward reference\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (distanceCode > 0) {\n\t\t\t\t\tdistRb[distRbIdx & 3] = distance;\n\t\t\t\t\tdistRbIdx++;\n\t\t\t\t}\n\n\t\t\t\tif (copyLength > metaBlockRemaining) {\n\t\t\t\t\tthrow new Error(\"Invalid backward reference\");\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < copyLength; j++) {\n\t\t\t\t\tringBuffer[pos & ringBufferMask] =\n\t\t\t\t\t\tringBuffer[(pos - distance) & ringBufferMask];\n\t\t\t\t\tif ((pos & ringBufferMask) === ringBufferMask) {\n\t\t\t\t\t\toutput.push(...ringBuffer.slice(0, ringBufferSize));\n\t\t\t\t\t}\n\t\t\t\t\tpos++;\n\t\t\t\t\tmetaBlockRemaining--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprevByte1 = ringBuffer[(pos - 1) & ringBufferMask];\n\t\t\tprevByte2 = ringBuffer[(pos - 2) & ringBufferMask];\n\t\t}\n\n\t\tif (meta.isLast) break;\n\t}\n\n\t// Flush remaining data\n\toutput.push(...ringBuffer.slice(0, pos & ringBufferMask));\n\n\treturn new Uint8Array(output);\n}\n\n// Export internal functions for testing\nexport const __testing = {\n\tgetNextKey,\n\treplicateValue,\n\tnextTableBitSize,\n\tbuildHuffmanTable,\n\treadBlockLength,\n\treadHuffmanCodeLengths,\n\tBitReader,\n\tHuffmanCode: {} as { bits: number; value: number },\n\tCODE_LENGTH_CODES,\n};\n",
    "import type {\n\tClassTable,\n\tContextualEntry,\n\tInsertionEntry,\n\tLigatureEntry,\n\tMorxContextualSubtable,\n\tMorxInsertionSubtable,\n\tMorxLigatureSubtable,\n\tMorxRearrangementSubtable,\n} from \"../font/tables/morx.ts\";\nimport type { GlyphId, GlyphInfo } from \"../types.ts\";\n\n/**\n * State machine driver for AAT processing\n */\nexport interface StateMachineContext {\n\t/** Current position in buffer */\n\tpos: number;\n\t/** Mark position (for some operations) */\n\tmark: number;\n\t/** Glyph stack for ligatures */\n\tstack: number[];\n}\n\n/**\n * Special class values\n */\nconst CLASS_END_OF_TEXT = 0;\nconst CLASS_OUT_OF_BOUNDS = 1;\nconst _CLASS_DELETED_GLYPH = 2;\nconst _CLASS_END_OF_LINE = 3;\n\n/**\n * Get the class value for a glyph from the class table\n * @param classTable - The class lookup table\n * @param glyphId - The glyph ID to look up\n * @returns The class value, or CLASS_OUT_OF_BOUNDS if the glyph is not in the table\n */\nexport function getGlyphClass(\n\tclassTable: ClassTable,\n\tglyphId: GlyphId,\n): number {\n\tif (glyphId < 0 || glyphId >= classTable.classArray.length) {\n\t\treturn CLASS_OUT_OF_BOUNDS;\n\t}\n\treturn classTable.classArray[glyphId] ?? CLASS_OUT_OF_BOUNDS;\n}\n\n/**\n * Process rearrangement subtable to reorder glyphs based on state machine rules\n * @param subtable - The rearrangement subtable containing state machine and rules\n * @param infos - Array of glyph infos to be reordered in place\n */\nexport function processRearrangement(\n\tsubtable: MorxRearrangementSubtable,\n\tinfos: GlyphInfo[],\n): void {\n\tconst { stateTable } = subtable;\n\tlet state = 0;\n\tlet markFirst = 0;\n\tlet markLast = 0;\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass];\n\t\tif (!entry) break;\n\n\t\tconst flags = entry.flags;\n\n\t\t// Set mark first\n\t\tif (flags & 0x8000) {\n\t\t\tmarkFirst = i;\n\t\t}\n\n\t\t// Set mark last\n\t\tif (flags & 0x2000) {\n\t\t\tmarkLast = i;\n\t\t}\n\n\t\t// Perform rearrangement\n\t\tconst verb = flags & 0x000f;\n\t\tif (verb !== 0 && markFirst <= markLast && markLast < infos.length) {\n\t\t\trearrangeGlyphs(infos, markFirst, markLast, verb);\n\t\t}\n\n\t\t// Don't advance if flag set\n\t\tif (!(flags & 0x4000)) {\n\t\t\t// Stay at current position\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n}\n\n/**\n * Rearrangement verbs\n */\nfunction rearrangeGlyphs(\n\tinfos: GlyphInfo[],\n\tfirst: number,\n\tlast: number,\n\tverb: number,\n): void {\n\tif (first >= last || first >= infos.length || last >= infos.length) return;\n\n\tconst a = infos[first];\n\tconst b = infos[first + 1];\n\tconst c = infos[last - 1];\n\tconst d = infos[last];\n\n\tif (!a || !d) return;\n\n\tswitch (verb) {\n\t\tcase 1: // Ax => xA\n\t\t\tif (b) {\n\t\t\t\tinfos[first] = b;\n\t\t\t\tinfos[first + 1] = a;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // xD => Dx\n\t\t\tif (c) {\n\t\t\t\tinfos[last] = c;\n\t\t\t\tinfos[last - 1] = d;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: // AxD => DxA\n\t\t\tinfos[first] = d;\n\t\t\tinfos[last] = a;\n\t\t\tbreak;\n\t\tcase 4: // ABx => xAB\n\t\t\tif (b && c) {\n\t\t\t\tconst temp = infos.slice(first, first + 2);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst thirdItem = infos[first + 2];\n\t\t\t\tif (tempFirst && tempSecond && thirdItem) {\n\t\t\t\t\tinfos[first] = thirdItem;\n\t\t\t\t\tinfos[first + 1] = tempFirst;\n\t\t\t\t\tinfos[first + 2] = tempSecond;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5: // ABx => xBA\n\t\t\tif (b && c) {\n\t\t\t\tconst temp = infos.slice(first, first + 2);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst thirdItem = infos[first + 2];\n\t\t\t\tif (tempFirst && tempSecond && thirdItem) {\n\t\t\t\t\tinfos[first] = thirdItem;\n\t\t\t\t\tinfos[first + 1] = tempSecond;\n\t\t\t\t\tinfos[first + 2] = tempFirst;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6: // xCD => CDx\n\t\t\tif (c && b) {\n\t\t\t\tconst temp = infos.slice(last - 1, last + 1);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst prevItem = infos[last - 2];\n\t\t\t\tif (tempFirst && tempSecond && prevItem) {\n\t\t\t\t\tinfos[last] = prevItem;\n\t\t\t\t\tinfos[last - 1] = tempSecond;\n\t\t\t\t\tinfos[last - 2] = tempFirst;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7: // xCD => DCx\n\t\t\tif (c && b) {\n\t\t\t\tconst temp = infos.slice(last - 1, last + 1);\n\t\t\t\tconst [tempFirst, tempSecond] = temp;\n\t\t\t\tconst prevItem = infos[last - 2];\n\t\t\t\tif (tempFirst && tempSecond && prevItem) {\n\t\t\t\t\tinfos[last] = prevItem;\n\t\t\t\t\tinfos[last - 1] = tempFirst;\n\t\t\t\t\tinfos[last - 2] = tempSecond;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8: // AxCD => CDxA\n\t\t\tif (c) {\n\t\t\t\tconst tempA = a;\n\t\t\t\tinfos[first] = c;\n\t\t\t\tinfos[last - 1] = d;\n\t\t\t\tinfos[last] = tempA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9: // AxCD => DCxA\n\t\t\tif (c) {\n\t\t\t\tconst tempA = a;\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[last - 1] = c;\n\t\t\t\tinfos[last] = tempA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 10: // ABxD => DxAB\n\t\t\tif (b && c) {\n\t\t\t\tconst tempA = a;\n\t\t\t\tconst tempB = b;\n\t\t\t\tconst tempC = c;\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[first + 1] = tempC;\n\t\t\t\tinfos[last - 1] = tempA;\n\t\t\t\tinfos[last] = tempB;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11: // ABxD => DxBA\n\t\t\tif (b && c) {\n\t\t\t\tconst tempA = a;\n\t\t\t\tconst tempB = b;\n\t\t\t\tconst tempC = c;\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[first + 1] = tempC;\n\t\t\t\tinfos[last - 1] = tempB;\n\t\t\t\tinfos[last] = tempA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 12: // ABxCD => CDxAB\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = c;\n\t\t\t\tinfos[first + 1] = d;\n\t\t\t\tinfos[last - 1] = tempAB[0];\n\t\t\t\tinfos[last] = tempAB[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 13: // ABxCD => CDxBA\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = c;\n\t\t\t\tinfos[first + 1] = d;\n\t\t\t\tinfos[last - 1] = tempAB[1];\n\t\t\t\tinfos[last] = tempAB[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14: // ABxCD => DCxAB\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[first + 1] = c;\n\t\t\t\tinfos[last - 1] = tempAB[0];\n\t\t\t\tinfos[last] = tempAB[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 15: // ABxCD => DCxBA\n\t\t\tif (b && c) {\n\t\t\t\tconst tempAB = [a, b];\n\t\t\t\tinfos[first] = d;\n\t\t\t\tinfos[first + 1] = c;\n\t\t\t\tinfos[last - 1] = tempAB[1];\n\t\t\t\tinfos[last] = tempAB[0];\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Process contextual substitution subtable to replace glyphs based on context\n * @param subtable - The contextual subtable containing state machine and substitution tables\n * @param infos - Array of glyph infos to be modified in place with contextual substitutions\n */\nexport function processContextual(\n\tsubtable: MorxContextualSubtable,\n\tinfos: GlyphInfo[],\n): void {\n\tconst { stateTable, substitutionTable } = subtable;\n\tlet state = 0;\n\tlet markIndex = -1;\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass] as ContextualEntry | undefined;\n\t\tif (!entry) break;\n\n\t\t// Set mark\n\t\tif (entry.flags & 0x8000) {\n\t\t\tmarkIndex = i;\n\t\t}\n\n\t\t// Apply substitution at mark\n\t\tif (\n\t\t\tentry.markIndex !== 0xffff &&\n\t\t\tmarkIndex >= 0 &&\n\t\t\tmarkIndex < infos.length\n\t\t) {\n\t\t\tconst substTable = substitutionTable[entry.markIndex];\n\t\t\tif (substTable) {\n\t\t\t\tconst markedInfo = infos[markIndex];\n\t\t\t\tif (markedInfo) {\n\t\t\t\t\tconst replacement = substTable.get(markedInfo.glyphId);\n\t\t\t\t\tif (replacement !== undefined) {\n\t\t\t\t\t\tmarkedInfo.glyphId = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Apply substitution at current\n\t\tif (!isEnd && entry.currentIndex !== 0xffff) {\n\t\t\tconst substTable = substitutionTable[entry.currentIndex];\n\t\t\tif (substTable) {\n\t\t\t\tconst currentInfo = infos[i];\n\t\t\t\tif (currentInfo) {\n\t\t\t\t\tconst replacement = substTable.get(currentInfo.glyphId);\n\t\t\t\t\tif (replacement !== undefined) {\n\t\t\t\t\t\tcurrentInfo.glyphId = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don't advance\n\t\tif (!(entry.flags & 0x4000)) {\n\t\t\t// Stay\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n}\n\n/**\n * Process ligature subtable to combine multiple glyphs into ligatures\n * @param subtable - The ligature subtable containing state machine, actions, and component tables\n * @param infos - Array of glyph infos to process\n * @returns New array of glyph infos with ligatures applied and component glyphs removed\n */\nexport function processLigature(\n\tsubtable: MorxLigatureSubtable,\n\tinfos: GlyphInfo[],\n): GlyphInfo[] {\n\tconst { stateTable, ligatureActions, components, ligatures } = subtable;\n\tlet state = 0;\n\tconst stack: number[] = [];\n\tconst result: GlyphInfo[] = [];\n\tconst deleted = new Set<number>();\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass] as LigatureEntry | undefined;\n\t\tif (!entry) break;\n\n\t\t// Push to stack\n\t\tif (entry.flags & 0x8000) {\n\t\t\tstack.push(i);\n\t\t}\n\n\t\t// Perform ligature action\n\t\tif (entry.flags & 0x2000 && entry.ligActionIndex < ligatureActions.length) {\n\t\t\tlet actionIndex = entry.ligActionIndex;\n\t\t\tlet ligatureGlyph: GlyphId = 0;\n\t\t\tconst componentIndices: number[] = [];\n\n\t\t\t// Process action chain\n\t\t\twhile (actionIndex < ligatureActions.length) {\n\t\t\t\tconst action = ligatureActions[actionIndex];\n\t\t\t\tif (action === undefined) break;\n\n\t\t\t\tconst last = (action & 0x80000000) !== 0;\n\t\t\t\tconst store = (action & 0x40000000) !== 0;\n\t\t\t\tconst componentOffset = ((action & 0x3fffffff) << 2) >> 2; // Sign extend\n\n\t\t\t\tconst stackIdx = stack.pop();\n\t\t\t\tif (stackIdx !== undefined && stackIdx < infos.length) {\n\t\t\t\t\tcomponentIndices.push(stackIdx);\n\t\t\t\t\tconst info = infos[stackIdx];\n\t\t\t\t\tif (info) {\n\t\t\t\t\t\tconst componentIdx = componentOffset;\n\n\t\t\t\t\t\tif (componentIdx >= 0 && componentIdx < components.length) {\n\t\t\t\t\t\t\tconst component = components[componentIdx];\n\t\t\t\t\t\t\tif (component !== undefined) {\n\t\t\t\t\t\t\t\tligatureGlyph = ligatureGlyph + component;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (store && ligatureGlyph < ligatures.length) {\n\t\t\t\t\t// Replace first component with ligature\n\t\t\t\t\tconst firstIdx = componentIndices[componentIndices.length - 1];\n\t\t\t\t\tif (firstIdx !== undefined && firstIdx < infos.length) {\n\t\t\t\t\t\tconst firstInfo = infos[firstIdx];\n\t\t\t\t\t\tconst ligature = ligatures[ligatureGlyph];\n\t\t\t\t\t\tif (firstInfo && ligature !== undefined) {\n\t\t\t\t\t\t\tfirstInfo.glyphId = ligature;\n\t\t\t\t\t\t\t// Mark other components for deletion\n\t\t\t\t\t\t\tfor (let j = 0; j < componentIndices.length; j++) {\n\t\t\t\t\t\t\t\tif (j < componentIndices.length - 1) {\n\t\t\t\t\t\t\t\t\tconst idx = componentIndices[j]!;\n\t\t\t\t\t\t\t\t\tdeleted.add(idx);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tligatureGlyph = 0;\n\t\t\t\t}\n\n\t\t\t\tif (last) break;\n\t\t\t\tactionIndex++;\n\t\t\t}\n\t\t}\n\n\t\t// Don't advance\n\t\tif (!(entry.flags & 0x4000)) {\n\t\t\t// Stay\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n\n\t// Build result without deleted glyphs\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tif (!deleted.has(i)) {\n\t\t\tconst info = infos[i]!;\n\t\t\tresult.push(info);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Process insertion subtable to insert additional glyphs before or after existing glyphs\n * @param subtable - The insertion subtable containing state machine and insertion glyph table\n * @param infos - Array of glyph infos to process\n * @returns New array of glyph infos with inserted glyphs added at specified positions\n */\nexport function processInsertion(\n\tsubtable: MorxInsertionSubtable,\n\tinfos: GlyphInfo[],\n): GlyphInfo[] {\n\tconst { stateTable, insertionGlyphs } = subtable;\n\tlet state = 0;\n\tlet markIndex = -1;\n\tconst result: GlyphInfo[] = [];\n\tconst insertions: Map<number, { before: GlyphId[]; after: GlyphId[] }> =\n\t\tnew Map();\n\n\tfor (let i = 0; i <= infos.length; i++) {\n\t\tconst isEnd = i >= infos.length;\n\t\tconst glyphClass = isEnd\n\t\t\t? CLASS_END_OF_TEXT\n\t\t\t: getGlyphClass(stateTable.classTable, infos[i]?.glyphId);\n\n\t\tconst stateRow = stateTable.stateArray[state];\n\t\tif (!stateRow) break;\n\n\t\tconst entry = stateRow[glyphClass] as InsertionEntry | undefined;\n\t\tif (!entry) break;\n\n\t\t// Set mark\n\t\tif (entry.flags & 0x8000) {\n\t\t\tmarkIndex = i;\n\t\t}\n\n\t\t// Insert at marked position\n\t\tif (entry.markedInsertIndex !== 0xffff && markIndex >= 0) {\n\t\t\tconst count = (entry.flags >> 5) & 0x1f;\n\t\t\tconst insertBefore = (entry.flags & 0x0800) !== 0;\n\t\t\tconst glyphs = insertionGlyphs.slice(\n\t\t\t\tentry.markedInsertIndex,\n\t\t\t\tentry.markedInsertIndex + count,\n\t\t\t);\n\n\t\t\tlet ins = insertions.get(markIndex);\n\t\t\tif (!ins) {\n\t\t\t\tins = { before: [], after: [] };\n\t\t\t\tinsertions.set(markIndex, ins);\n\t\t\t}\n\t\t\tif (insertBefore) {\n\t\t\t\tins.before.push(...glyphs);\n\t\t\t} else {\n\t\t\t\tins.after.push(...glyphs);\n\t\t\t}\n\t\t}\n\n\t\t// Insert at current position\n\t\tif (!isEnd && entry.currentInsertIndex !== 0xffff) {\n\t\t\tconst count = entry.flags & 0x1f;\n\t\t\tconst insertBefore = (entry.flags & 0x0020) !== 0;\n\t\t\tconst glyphs = insertionGlyphs.slice(\n\t\t\t\tentry.currentInsertIndex,\n\t\t\t\tentry.currentInsertIndex + count,\n\t\t\t);\n\n\t\t\tlet ins = insertions.get(i);\n\t\t\tif (!ins) {\n\t\t\t\tins = { before: [], after: [] };\n\t\t\t\tinsertions.set(i, ins);\n\t\t\t}\n\t\t\tif (insertBefore) {\n\t\t\t\tins.before.push(...glyphs);\n\t\t\t} else {\n\t\t\t\tins.after.push(...glyphs);\n\t\t\t}\n\t\t}\n\n\t\t// Don't advance\n\t\tif (!(entry.flags & 0x4000)) {\n\t\t\t// Stay\n\t\t}\n\n\t\tstate = entry.newState;\n\t}\n\n\t// Build result with insertions\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst ins = insertions.get(i);\n\n\t\tif (ins) {\n\t\t\t// Insert before\n\t\t\tfor (let j = 0; j < ins.before.length; j++) {\n\t\t\t\tconst glyph = ins.before[j]!;\n\t\t\t\tresult.push({\n\t\t\t\t\tglyphId: glyph,\n\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\tmask: info.mask,\n\t\t\t\t\tcodepoint: 0,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresult.push(info);\n\n\t\tif (ins) {\n\t\t\t// Insert after\n\t\t\tfor (let j = 0; j < ins.after.length; j++) {\n\t\t\t\tconst glyph = ins.after[j]!;\n\t\t\t\tresult.push({\n\t\t\t\t\tglyphId: glyph,\n\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\tmask: info.mask,\n\t\t\t\t\tcodepoint: 0,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n",
    "/**\n * Arithmetic and logic instructions\n */\n\nimport type { ExecContext } from \"../types.ts\";\n\nfunction mulDiv(a: number, b: number, c: number): number {\n\tif (c === 0) return (a ^ b) < 0 ? -0x7fffffff : 0x7fffffff;\n\n\tlet sign = 1;\n\tif (a < 0) {\n\t\ta = -a;\n\t\tsign = -sign;\n\t}\n\tif (b < 0) {\n\t\tb = -b;\n\t\tsign = -sign;\n\t}\n\tif (c < 0) {\n\t\tc = -c;\n\t\tsign = -sign;\n\t}\n\n\tconst result = Math.floor((a * b + (c >> 1)) / c);\n\treturn sign < 0 ? -result : result;\n}\n\nfunction mulDivNoRound(a: number, b: number, c: number): number {\n\tif (c === 0) return (a ^ b) < 0 ? -0x7fffffff : 0x7fffffff;\n\n\tlet sign = 1;\n\tif (a < 0) {\n\t\ta = -a;\n\t\tsign = -sign;\n\t}\n\tif (b < 0) {\n\t\tb = -b;\n\t\tsign = -sign;\n\t}\n\tif (c < 0) {\n\t\tc = -c;\n\t\tsign = -sign;\n\t}\n\n\tconst result = Math.floor((a * b) / c);\n\treturn sign < 0 ? -result : result;\n}\n\n/** ADD - Add top two values */\nexport function ADD(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"ADD: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a + b;\n}\n\n/** SUB - Subtract top two values */\nexport function SUB(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"SUB: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a - b;\n}\n\n/** DIV - Divide (26.6 fixed-point) */\nexport function DIV(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"DIV: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\tif (b === 0) {\n\t\tctx.error = \"DIV: division by zero\";\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\t// Result is (a * 64) / b for 26.6 precision (rounded)\n\tctx.stack[ctx.stackTop++] = mulDiv(a, 64, b);\n}\n\n/** MUL - Multiply (26.6 fixed-point) */\nexport function MUL(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"MUL: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\t// Result is (a * b) / 64 for 26.6 precision (rounded)\n\tctx.stack[ctx.stackTop++] = mulDiv(a, b, 64);\n}\n\n/** ABS - Absolute value */\nexport function ABS(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"ABS: stack underflow\";\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop - 1] = val < 0 ? -val : val;\n}\n\n/** NEG - Negate */\nexport function NEG(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"NEG: stack underflow\";\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop - 1] = -val;\n}\n\n/** FLOOR - Floor to 26.6 integer (multiple of 64) */\nexport function FLOOR(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"FLOOR: stack underflow\";\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop - 1] = val & ~63;\n}\n\n/** CEILING - Ceiling to 26.6 integer (multiple of 64) */\nexport function CEILING(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"CEILING: stack underflow\";\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop - 1] = (val + 63) & ~63;\n}\n\n/** MAX - Maximum of top two */\nexport function MAX(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"MAX: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a > b ? a : b;\n}\n\n/** MIN - Minimum of top two */\nexport function MIN(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"MIN: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a < b ? a : b;\n}\n\n// Comparison instructions\n\n/** LT - Less than */\nexport function LT(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"LT: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a < b ? 1 : 0;\n}\n\n/** LTEQ - Less than or equal */\nexport function LTEQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"LTEQ: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a <= b ? 1 : 0;\n}\n\n/** GT - Greater than */\nexport function GT(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"GT: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a > b ? 1 : 0;\n}\n\n/** GTEQ - Greater than or equal */\nexport function GTEQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"GTEQ: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a >= b ? 1 : 0;\n}\n\n/** EQ - Equal */\nexport function EQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"EQ: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a === b ? 1 : 0;\n}\n\n/** NEQ - Not equal */\nexport function NEQ(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"NEQ: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a !== b ? 1 : 0;\n}\n\n/** ODD - Test if odd (after rounding to pixels) */\nexport function ODD(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"ODD: stack underflow\";\n\t\treturn;\n\t}\n\t// Round to nearest pixel and test bit 6\n\tconst rounded = (val + 32) & ~63;\n\tctx.stack[ctx.stackTop - 1] = rounded & 64 ? 1 : 0;\n}\n\n/** EVEN - Test if even (after rounding to pixels) */\nexport function EVEN(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"EVEN: stack underflow\";\n\t\treturn;\n\t}\n\t// Round to nearest pixel and test bit 6\n\tconst rounded = (val + 32) & ~63;\n\tctx.stack[ctx.stackTop - 1] = rounded & 64 ? 0 : 1;\n}\n\n// Logic instructions\n\n/** AND - Logical AND */\nexport function AND(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"AND: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a && b ? 1 : 0;\n}\n\n/** OR - Logical OR */\nexport function OR(ctx: ExecContext): void {\n\tconst b = ctx.stack[--ctx.stackTop];\n\tconst a = ctx.stack[--ctx.stackTop];\n\tif (a === undefined || b === undefined) {\n\t\tctx.error = \"OR: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = a || b ? 1 : 0;\n}\n\n/** NOT - Logical NOT */\nexport function NOT(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tif (val === undefined) {\n\t\tctx.error = \"NOT: stack underflow\";\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop - 1] = val ? 0 : 1;\n}\n",
    "/**\n * Control flow instructions\n */\n\nimport type { ExecContext } from \"../types.ts\";\n\n/** IF - Conditional branch */\nexport function IF(ctx: ExecContext): void {\n\tconst condition = ctx.stack[--ctx.stackTop];\n\tif (condition === undefined) {\n\t\tctx.error = \"IF: stack underflow\";\n\t\tctx.stackTop++;\n\t\treturn;\n\t}\n\n\tif (condition) {\n\t\t// Continue execution (true branch)\n\t\treturn;\n\t}\n\n\t// Skip to ELSE or EIF\n\tlet depth = 1;\n\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst opcode = ctx.code[ctx.IP++];\n\t\tif (opcode === undefined) break;\n\n\t\tswitch (opcode) {\n\t\t\tcase 0x58: // IF\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase 0x1b: // ELSE\n\t\t\t\tif (depth === 1) {\n\t\t\t\t\t// Found matching ELSE, continue from here\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x59: // EIF\n\t\t\t\tdepth--;\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Skip push instructions\n\t\t\tcase 0x40: // NPUSHB\n\t\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);\n\t\t\t\tbreak;\n\t\t\tcase 0x41: // NPUSHW\n\t\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\t\t\t\t// PUSHB[n]\n\t\t\t\t\tctx.IP += opcode - 0xb0 + 1;\n\t\t\t\t} else if (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\t\t\t\t// PUSHW[n]\n\t\t\t\t\tctx.IP += (opcode - 0xb8 + 1) * 2;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tctx.error = \"IF: missing EIF\";\n}\n\n/** ELSE - Alternative branch */\nexport function ELSE(ctx: ExecContext): void {\n\t// We're in the true branch and hit ELSE, skip to EIF\n\tlet depth = 1;\n\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst opcode = ctx.code[ctx.IP++];\n\t\tif (opcode === undefined) break;\n\n\t\tswitch (opcode) {\n\t\t\tcase 0x58: // IF\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase 0x59: // EIF\n\t\t\t\tdepth--;\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x40: // NPUSHB\n\t\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);\n\t\t\t\tbreak;\n\t\t\tcase 0x41: // NPUSHW\n\t\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\t\t\t\tctx.IP += opcode - 0xb0 + 1;\n\t\t\t\t} else if (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\t\t\t\tctx.IP += (opcode - 0xb8 + 1) * 2;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tctx.error = \"ELSE: missing EIF\";\n}\n\n/** EIF - End IF */\nexport function EIF(_ctx: ExecContext): void {\n\t// Nothing to do - just a marker\n}\n\n/** JMPR - Jump relative */\nexport function JMPR(ctx: ExecContext): void {\n\tconst offset = ctx.stack[--ctx.stackTop];\n\tif (offset === undefined) {\n\t\tctx.error = \"JMPR: stack underflow\";\n\t\tctx.stackTop++;\n\t\treturn;\n\t}\n\t// Jump is relative to the current instruction address.\n\t// IP is already advanced by one, so subtract 1 to match TT semantics.\n\tctx.IP += offset - 1;\n}\n\n/** JROT - Jump relative on true */\nexport function JROT(ctx: ExecContext): void {\n\tconst condition = ctx.stack[--ctx.stackTop];\n\tconst offset = ctx.stack[--ctx.stackTop];\n\tif (condition === undefined || offset === undefined) {\n\t\tctx.error = \"JROT: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\treturn;\n\t}\n\n\tif (condition) {\n\t\tctx.IP += offset - 1;\n\t}\n}\n\n/** JROF - Jump relative on false */\nexport function JROF(ctx: ExecContext): void {\n\tconst condition = ctx.stack[--ctx.stackTop];\n\tconst offset = ctx.stack[--ctx.stackTop];\n\tif (condition === undefined || offset === undefined) {\n\t\tctx.error = \"JROF: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\treturn;\n\t}\n\n\tif (!condition) {\n\t\tctx.IP += offset - 1;\n\t}\n}\n\n/** FDEF - Define function */\nexport function FDEF(ctx: ExecContext): void {\n\tconst funcNum = ctx.stack[--ctx.stackTop];\n\tif (funcNum === undefined) {\n\t\tctx.error = \"FDEF: stack underflow\";\n\t\tctx.stackTop++;\n\t\treturn;\n\t}\n\tif (funcNum < 0 || funcNum > 0xffff) {\n\t\tctx.error = `FDEF: invalid function number ${funcNum}`;\n\t\treturn;\n\t}\n\n\tlet def = ctx.FDefs.find((entry) => entry.active && entry.id === funcNum);\n\tif (!def) {\n\t\tdef = ctx.FDefs.find((entry) => !entry.active);\n\t}\n\tif (!def) {\n\t\tctx.error = `FDEF: too many function definitions`;\n\t\treturn;\n\t}\n\tdef.id = funcNum;\n\tdef.start = ctx.IP;\n\tdef.active = true;\n\tdef.range = ctx.currentRange;\n\n\t// Skip to ENDF\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst opcode = ctx.code[ctx.IP++];\n\t\tif (opcode === undefined) break;\n\n\t\tif (opcode === 0x2d) {\n\t\t\t// ENDF\n\t\t\tdef.end = ctx.IP;\n\t\t\treturn;\n\t\t}\n\n\t\t// Skip push instructions\n\t\tif (opcode === 0x40) {\n\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);\n\t\t} else if (opcode === 0x41) {\n\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;\n\t\t} else if (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\t\tctx.IP += opcode - 0xb0 + 1;\n\t\t} else if (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\t\tctx.IP += (opcode - 0xb8 + 1) * 2;\n\t\t}\n\t}\n\n\tctx.error = \"FDEF: missing ENDF\";\n}\n\n/** ENDF - End function definition */\nexport function ENDF(ctx: ExecContext): void {\n\t// Called when returning from function call\n\tif (ctx.callStackTop <= 0) {\n\t\tctx.error = \"ENDF: not in function call\";\n\t\treturn;\n\t}\n\n\tconst call = ctx.callStack[ctx.callStackTop - 1];\n\tif (!call) {\n\t\tctx.error = \"ENDF: missing call frame\";\n\t\treturn;\n\t}\n\n\t// Decrement loop count for LOOPCALL\n\tcall.count--;\n\n\tif (call.count > 0) {\n\t\t// Loop again\n\t\tctx.IP = call.def.start;\n\t} else {\n\t\t// Return to caller\n\t\tctx.callStackTop--;\n\t\tctx.IP = call.callerIP;\n\t\tctx.currentRange = call.callerRange;\n\n\t\t// Restore code pointer\n\t\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\t\tif (range) {\n\t\t\tctx.code = range.code;\n\t\t\tctx.codeSize = range.size;\n\t\t}\n\t}\n}\n\n/** CALL - Call function */\nexport function CALL(ctx: ExecContext): void {\n\tconst funcNum = ctx.stack[--ctx.stackTop];\n\tif (funcNum === undefined) {\n\t\tctx.error = \"CALL: stack underflow\";\n\t\tctx.stackTop++;\n\t\treturn;\n\t}\n\tif (funcNum < 0 || funcNum > 0xffff) {\n\t\tctx.error = `CALL: invalid function number ${funcNum}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.FDefs.find((entry) => entry.active && entry.id === funcNum);\n\tif (!def) {\n\t\tctx.error = `CALL: function ${funcNum} not defined`;\n\t\treturn;\n\t}\n\n\tif (ctx.callStackTop >= ctx.maxCallStack) {\n\t\tctx.error = \"CALL: call stack overflow\";\n\t\treturn;\n\t}\n\t// Push call record\n\tconst call = ctx.callStack[ctx.callStackTop++];\n\tif (!call) {\n\t\tctx.error = \"CALL: no call frame available\";\n\t\tctx.callStackTop--;\n\t\treturn;\n\t}\n\tcall.callerIP = ctx.IP;\n\tcall.callerRange = ctx.currentRange;\n\tcall.def = def;\n\tcall.count = 1;\n\n\t// Switch to function's code range\n\tctx.currentRange = def.range;\n\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\tif (range) {\n\t\tctx.code = range.code;\n\t\tctx.codeSize = range.size;\n\t}\n\tctx.IP = def.start;\n}\n\n/** LOOPCALL - Call function with loop count */\nexport function LOOPCALL(ctx: ExecContext): void {\n\tconst funcNum = ctx.stack[--ctx.stackTop];\n\tconst count = ctx.stack[--ctx.stackTop];\n\tif (funcNum === undefined || count === undefined) {\n\t\tctx.error = \"LOOPCALL: stack underflow\";\n\t\tctx.stackTop += 2;\n\t\treturn;\n\t}\n\n\tif (funcNum < 0 || funcNum > 0xffff) {\n\t\tctx.error = `LOOPCALL: invalid function number ${funcNum}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.FDefs.find((entry) => entry.active && entry.id === funcNum);\n\tif (!def) {\n\t\tctx.error = `LOOPCALL: function ${funcNum} not defined`;\n\t\treturn;\n\t}\n\n\tif (count <= 0) {\n\t\treturn; // Nothing to do\n\t}\n\n\tif (ctx.callStackTop >= ctx.maxCallStack) {\n\t\tctx.error = \"LOOPCALL: call stack overflow\";\n\t\treturn;\n\t}\n\n\t// Push call record\n\tconst call = ctx.callStack[ctx.callStackTop++];\n\tif (!call) {\n\t\tctx.error = \"LOOPCALL: no call frame available\";\n\t\tctx.callStackTop--;\n\t\treturn;\n\t}\n\tcall.callerIP = ctx.IP;\n\tcall.callerRange = ctx.currentRange;\n\tcall.def = def;\n\tcall.count = count;\n\n\t// Switch to function's code range\n\tctx.currentRange = def.range;\n\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\tif (range) {\n\t\tctx.code = range.code;\n\t\tctx.codeSize = range.size;\n\t}\n\tctx.IP = def.start;\n}\n\n/** IDEF - Define instruction */\nexport function IDEF(ctx: ExecContext): void {\n\tconst opcode = ctx.stack[--ctx.stackTop];\n\tif (opcode === undefined) {\n\t\tctx.error = \"IDEF: stack underflow\";\n\t\tctx.stackTop++;\n\t\treturn;\n\t}\n\n\tif (opcode < 0 || opcode >= ctx.maxIDefs) {\n\t\tctx.error = `IDEF: invalid opcode ${opcode}`;\n\t\treturn;\n\t}\n\n\tconst def = ctx.IDefs[opcode];\n\tif (!def) {\n\t\tctx.error = `IDEF: no slot for opcode ${opcode}`;\n\t\treturn;\n\t}\n\tdef.opcode = opcode;\n\tdef.start = ctx.IP;\n\tdef.active = true;\n\tdef.range = ctx.currentRange;\n\n\t// Skip to ENDF\n\twhile (ctx.IP < ctx.codeSize) {\n\t\tconst op = ctx.code[ctx.IP++];\n\t\tif (op === undefined) break;\n\n\t\tif (op === 0x2d) {\n\t\t\t// ENDF\n\t\t\tdef.end = ctx.IP;\n\t\t\treturn;\n\t\t}\n\n\t\t// Skip push instructions\n\t\tif (op === 0x40) {\n\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0);\n\t\t} else if (op === 0x41) {\n\t\t\tctx.IP += 1 + (ctx.code[ctx.IP] ?? 0) * 2;\n\t\t} else if (op >= 0xb0 && op <= 0xb7) {\n\t\t\tctx.IP += op - 0xb0 + 1;\n\t\t} else if (op >= 0xb8 && op <= 0xbf) {\n\t\t\tctx.IP += (op - 0xb8 + 1) * 2;\n\t\t}\n\t}\n\n\tctx.error = \"IDEF: missing ENDF\";\n}\n",
    "/**\n * TrueType Hinting Types\n *\n * Based on FreeType's ttinterp.h and ttobjs.h\n */\n\n/**\n * 26.6 fixed-point number (used for coordinates)\n */\nexport type F26Dot6 = number;\n\n/**\n * 2.14 fixed-point number (used for unit vectors)\n */\nexport type F2Dot14 = number;\n\n/**\n * Unit vector in 2.14 format\n */\nexport interface UnitVector {\n\tx: F2Dot14;\n\ty: F2Dot14;\n}\n\n/**\n * Point coordinate\n */\nexport interface Point {\n\tx: F26Dot6;\n\ty: F26Dot6;\n}\n\n/**\n * Rounding mode for ROUND instruction\n */\nexport enum RoundMode {\n\tToHalfGrid = 0,\n\tToGrid = 1,\n\tToDoubleGrid = 2,\n\tDownToGrid = 3,\n\tUpToGrid = 4,\n\tOff = 5,\n\tSuper = 6,\n\tSuper45 = 7,\n}\n\n/**\n * Touch flags for points\n */\nexport enum TouchFlag {\n\tX = 0x10,\n\tY = 0x20,\n\tBoth = 0x30,\n}\n\n/**\n * Render mode used for GETINFO responses.\n */\nexport type HintRenderMode = \"mono\" | \"gray\" | \"lcd\" | \"lcd_v\";\n\n/**\n * Glyph zone - holds glyph points\n */\nexport interface GlyphZone {\n\t/** Number of points */\n\tnPoints: number;\n\t/** Number of contours */\n\tnContours: number;\n\t/** Original point positions (before hinting) */\n\torg: Point[];\n\t/** Current point positions (after hinting) */\n\tcur: Point[];\n\t/** Original unscaled positions */\n\torus: Point[];\n\t/** Touch flags per point */\n\ttags: Uint8Array;\n\t/** Contour end indices */\n\tcontours: Uint16Array;\n}\n\n/**\n * TrueType Graphics State\n *\n * Contains all state variables that control how instructions operate\n */\nexport interface GraphicsState {\n\t// Reference points\n\trp0: number;\n\trp1: number;\n\trp2: number;\n\n\t// Dual projection vector (for getting distances)\n\tdualVector: UnitVector;\n\t// Projection vector (direction along which we measure)\n\tprojVector: UnitVector;\n\t// Freedom vector (direction in which points can move)\n\tfreeVector: UnitVector;\n\n\t// Loop counter for repeated operations\n\tloop: number;\n\n\t// Minimum distance\n\tminimumDistance: F26Dot6;\n\n\t// Round state\n\troundState: RoundMode;\n\n\t// Auto flip for MIRP/MDRP\n\tautoFlip: boolean;\n\n\t// Control value cut-in\n\tcontrolValueCutIn: F26Dot6;\n\n\t// Single width cut-in\n\tsingleWidthCutIn: F26Dot6;\n\t// Single width value\n\tsingleWidthValue: F26Dot6;\n\n\t// Delta base (for DELTA instructions)\n\tdeltaBase: number;\n\t// Delta shift (for DELTA instructions)\n\tdeltaShift: number;\n\n\t// Instruction control flags\n\tinstructControl: number;\n\n\t// Scan control flags\n\tscanControl: number;\n\tscanType: number;\n\n\t// Zone pointers (0 = twilight, 1 = glyph)\n\tgep0: number;\n\tgep1: number;\n\tgep2: number;\n\n\t// Super rounding parameters\n\tperiod: F26Dot6;\n\tphase: F26Dot6;\n\tthreshold: F26Dot6;\n}\n\n/**\n * Create default graphics state\n */\nexport function createDefaultGraphicsState(): GraphicsState {\n\treturn {\n\t\trp0: 0,\n\t\trp1: 0,\n\t\trp2: 0,\n\t\tdualVector: { x: 0x4000, y: 0 }, // 1.0, 0.0 in 2.14\n\t\tprojVector: { x: 0x4000, y: 0 },\n\t\tfreeVector: { x: 0x4000, y: 0 },\n\t\tloop: 1,\n\t\tminimumDistance: 64, // 1 pixel in 26.6\n\t\troundState: RoundMode.ToGrid,\n\t\tautoFlip: true,\n\t\tcontrolValueCutIn: 68, // 17/16 pixel in 26.6\n\t\tsingleWidthCutIn: 0,\n\t\tsingleWidthValue: 0,\n\t\tdeltaBase: 9,\n\t\tdeltaShift: 3,\n\t\tinstructControl: 0,\n\t\tscanControl: 0,\n\t\tscanType: 0,\n\t\tgep0: 1,\n\t\tgep1: 1,\n\t\tgep2: 1,\n\t\tperiod: 64,\n\t\tphase: 0,\n\t\tthreshold: 32,\n\t};\n}\n\n/**\n * Function definition (from FDEF instruction)\n */\nexport interface FunctionDef {\n\t/** Function number */\n\tid: number;\n\t/** Start offset in bytecode */\n\tstart: number;\n\t/** End offset (just after ENDF) */\n\tend: number;\n\t/** Active (has been defined) */\n\tactive: boolean;\n\t/** Which code range */\n\trange: CodeRange;\n}\n\n/**\n * Instruction definition (from IDEF instruction)\n */\nexport interface InstructionDef {\n\t/** Opcode being redefined */\n\topcode: number;\n\t/** Start offset */\n\tstart: number;\n\t/** End offset */\n\tend: number;\n\t/** Active */\n\tactive: boolean;\n\t/** Code range */\n\trange: CodeRange;\n}\n\n/**\n * Code range type\n */\nexport enum CodeRange {\n\tNone = 0,\n\tFont = 1, // fpgm table\n\tCVT = 2, // prep table\n\tGlyph = 3, // glyph instructions\n}\n\n/**\n * Call stack record\n */\nexport interface CallRecord {\n\t/** Caller's instruction pointer */\n\tcallerIP: number;\n\t/** Caller's code range */\n\tcallerRange: CodeRange;\n\t/** Function definition */\n\tdef: FunctionDef;\n\t/** Loop count (for LOOPCALL) */\n\tcount: number;\n}\n\n/**\n * Execution context for the TrueType interpreter\n */\nexport interface ExecContext {\n\t// Graphics state\n\tGS: GraphicsState;\n\t// Default graphics state (reset after each glyph)\n\tdefaultGS: GraphicsState;\n\n\t// Zone pointers\n\tzp0: GlyphZone;\n\tzp1: GlyphZone;\n\tzp2: GlyphZone;\n\n\t// Twilight zone (synthetic points)\n\ttwilight: GlyphZone;\n\t// Glyph zone (actual glyph points)\n\tpts: GlyphZone;\n\n\t// Stack\n\tstack: Int32Array;\n\tstackTop: number;\n\n\t// Instruction pointer and code\n\tIP: number;\n\tcode: Uint8Array;\n\tcodeSize: number;\n\tcurrentRange: CodeRange;\n\n\t// Current opcode\n\topcode: number;\n\t// Number of arguments for current opcode\n\tnumArgs: number;\n\n\t// Control Value Table (scaled)\n\tcvt: Int32Array;\n\tcvtSize: number;\n\n\t// Storage area\n\tstorage: Int32Array;\n\tstorageSize: number;\n\n\t// Function definitions\n\tFDefs: FunctionDef[];\n\tmaxFDefs: number;\n\n\t// Instruction definitions\n\tIDefs: InstructionDef[];\n\tmaxIDefs: number;\n\n\t// Call stack\n\tcallStack: CallRecord[];\n\tcallStackTop: number;\n\tmaxCallStack: number;\n\n\t// Code ranges\n\tcodeRanges: Map<CodeRange, { code: Uint8Array; size: number }>;\n\n\t// Pixels per EM\n\tppem: number;\n\t// Point size\n\tpointSize: number;\n\n\t// Scale factor from font units to 26.6 pixels\n\tscale: number;\n\t// Scale factor in 16.16 fixed-point\n\tscaleFix: number;\n\t// Light hinting mode (vertical-only for grayscale rendering)\n\tlightMode: boolean;\n\t// Grayscale hinting flag (FreeType exc->grayscale)\n\tgrayscale: boolean;\n\t// Render mode used for GETINFO responses\n\trenderMode: HintRenderMode;\n\t// Backward compatibility flags (bit2 = active, bits0-1 track IUP)\n\tbackwardCompatibility: number;\n\t// True if current glyph is composite\n\tisComposite: boolean;\n\n\t// Error state\n\terror: string | null;\n\n\t// Instruction execution count (for infinite loop protection)\n\tinstructionCount: number;\n\tmaxInstructions: number;\n}\n\n/**\n * Create an empty glyph zone\n */\nexport function createGlyphZone(\n\tmaxPoints: number,\n\tmaxContours: number,\n): GlyphZone {\n\treturn {\n\t\tnPoints: 0,\n\t\tnContours: 0,\n\t\torg: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),\n\t\tcur: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),\n\t\torus: new Array(maxPoints).fill(null).map(() => ({ x: 0, y: 0 })),\n\t\ttags: new Uint8Array(maxPoints),\n\t\tcontours: new Uint16Array(maxContours),\n\t};\n}\n\n/**\n * Create execution context\n */\nexport function createExecContext(\n\tmaxStack: number = 256,\n\tmaxStorage: number = 64,\n\tmaxFDefs: number = 64,\n\tmaxIDefs: number = 64,\n\tmaxCallStack: number = 32,\n\tmaxTwilightPoints: number = 16,\n): ExecContext {\n\tconst defaultGS = createDefaultGraphicsState();\n\n\treturn {\n\t\tGS: { ...defaultGS },\n\t\tdefaultGS,\n\n\t\tzp0: createGlyphZone(0, 0),\n\t\tzp1: createGlyphZone(0, 0),\n\t\tzp2: createGlyphZone(0, 0),\n\n\t\ttwilight: createGlyphZone(maxTwilightPoints, 1),\n\t\tpts: createGlyphZone(0, 0),\n\n\t\tstack: new Int32Array(maxStack),\n\t\tstackTop: 0,\n\n\t\tIP: 0,\n\t\tcode: new Uint8Array(0),\n\t\tcodeSize: 0,\n\t\tcurrentRange: CodeRange.None,\n\n\t\topcode: 0,\n\t\tnumArgs: 0,\n\n\t\tcvt: new Int32Array(0),\n\t\tcvtSize: 0,\n\n\t\tstorage: new Int32Array(maxStorage),\n\t\tstorageSize: maxStorage,\n\n\t\tFDefs: new Array(maxFDefs).fill(null).map((_, i) => ({\n\t\t\tid: i,\n\t\t\tstart: 0,\n\t\t\tend: 0,\n\t\t\tactive: false,\n\t\t\trange: CodeRange.None,\n\t\t})),\n\t\tmaxFDefs,\n\n\t\tIDefs: new Array(maxIDefs).fill(null).map((_, i) => ({\n\t\t\topcode: i,\n\t\t\tstart: 0,\n\t\t\tend: 0,\n\t\t\tactive: false,\n\t\t\trange: CodeRange.None,\n\t\t})),\n\t\tmaxIDefs,\n\n\t\tcallStack: new Array(maxCallStack).fill(null).map(() => ({\n\t\t\tcallerIP: 0,\n\t\t\tcallerRange: CodeRange.None,\n\t\t\tdef: { id: 0, start: 0, end: 0, active: false, range: CodeRange.None },\n\t\t\tcount: 0,\n\t\t})),\n\t\tcallStackTop: 0,\n\t\tmaxCallStack,\n\n\t\tcodeRanges: new Map(),\n\n\tppem: 12,\n\tpointSize: 12,\n\tscale: 1,\n\tscaleFix: 0x10000,\n\tlightMode: false,\n\tgrayscale: true,\n\trenderMode: \"gray\",\n\tbackwardCompatibility: 0,\n\tisComposite: false,\n\n\t\terror: null,\n\n\t\tinstructionCount: 0,\n\t\tmaxInstructions: 1000000,\n\t};\n}\n\n/**\n * TrueType Opcodes\n */\nexport const Opcode = {\n\t// Push instructions\n\tNPUSHB: 0x40,\n\tNPUSHW: 0x41,\n\tPUSHB_0: 0xb0,\n\tPUSHB_1: 0xb1,\n\tPUSHB_2: 0xb2,\n\tPUSHB_3: 0xb3,\n\tPUSHB_4: 0xb4,\n\tPUSHB_5: 0xb5,\n\tPUSHB_6: 0xb6,\n\tPUSHB_7: 0xb7,\n\tPUSHW_0: 0xb8,\n\tPUSHW_1: 0xb9,\n\tPUSHW_2: 0xba,\n\tPUSHW_3: 0xbb,\n\tPUSHW_4: 0xbc,\n\tPUSHW_5: 0xbd,\n\tPUSHW_6: 0xbe,\n\tPUSHW_7: 0xbf,\n\n\t// Storage instructions\n\tRS: 0x43,\n\tWS: 0x42,\n\n\t// CVT instructions\n\tRCVT: 0x45,\n\tWCVTP: 0x44,\n\tWCVTF: 0x70,\n\n\t// Stack operations\n\tDUP: 0x20,\n\tPOP: 0x21,\n\tCLEAR: 0x22,\n\tSWAP: 0x23,\n\tDEPTH: 0x24,\n\tCINDEX: 0x25,\n\tMINDEX: 0x26,\n\tROLL: 0x8a,\n\n\t// Arithmetic\n\tADD: 0x60,\n\tSUB: 0x61,\n\tDIV: 0x62,\n\tMUL: 0x63,\n\tABS: 0x64,\n\tNEG: 0x65,\n\tFLOOR: 0x66,\n\tCEILING: 0x67,\n\tMAX: 0x8b,\n\tMIN: 0x8c,\n\n\t// Comparison\n\tLT: 0x50,\n\tLTEQ: 0x51,\n\tGT: 0x52,\n\tGTEQ: 0x53,\n\tEQ: 0x54,\n\tNEQ: 0x55,\n\tODD: 0x56,\n\tEVEN: 0x57,\n\n\t// Logic\n\tAND: 0x5a,\n\tOR: 0x5b,\n\tNOT: 0x5c,\n\n\t// Control flow\n\tIF: 0x58,\n\tELSE: 0x1b,\n\tEIF: 0x59,\n\tJMPR: 0x1c,\n\tJROT: 0x78,\n\tJROF: 0x79,\n\n\t// Functions\n\tFDEF: 0x2c,\n\tENDF: 0x2d,\n\tCALL: 0x2b,\n\tLOOPCALL: 0x2a,\n\tIDEF: 0x89,\n\n\t// Graphics state - vectors\n\tSVTCA_Y: 0x00,\n\tSVTCA_X: 0x01,\n\tSPVTCA_Y: 0x02,\n\tSPVTCA_X: 0x03,\n\tSFVTCA_Y: 0x04,\n\tSFVTCA_X: 0x05,\n\tSPVTL_0: 0x06,\n\tSPVTL_1: 0x07,\n\tSFVTL_0: 0x08,\n\tSFVTL_1: 0x09,\n\tSDPVTL_0: 0x86,\n\tSDPVTL_1: 0x87,\n\tSPVFS: 0x0a,\n\tSFVFS: 0x0b,\n\tGPV: 0x0c,\n\tGFV: 0x0d,\n\tSFVTPV: 0x0e,\n\tISECT: 0x0f,\n\n\t// Graphics state - reference points\n\tSRP0: 0x10,\n\tSRP1: 0x11,\n\tSRP2: 0x12,\n\n\t// Graphics state - zone pointers\n\tSZP0: 0x13,\n\tSZP1: 0x14,\n\tSZP2: 0x15,\n\tSZPS: 0x16,\n\n\t// Graphics state - other\n\tSLOOP: 0x17,\n\tRTG: 0x18,\n\tRTHG: 0x19,\n\tSMD: 0x1a,\n\tRDTG: 0x7d,\n\tRUTG: 0x7c,\n\tROFF: 0x7a,\n\tSROUND: 0x76,\n\tS45ROUND: 0x77,\n\tSCVTCI: 0x1d,\n\tSSWCI: 0x1e,\n\tSSW: 0x1f,\n\tFLIPON: 0x4d,\n\tFLIPOFF: 0x4e,\n\tSANGW: 0x7e,\n\tSDB: 0x5e,\n\tSDS: 0x5f,\n\n\t// Point operations\n\tGC_0: 0x46,\n\tGC_1: 0x47,\n\tSCFS: 0x48,\n\tMD_0: 0x49,\n\tMD_1: 0x4a,\n\tMPPEM: 0x4b,\n\tMPS: 0x4c,\n\tFLIPPT: 0x80,\n\tFLIPRGON: 0x81,\n\tFLIPRGOFF: 0x82,\n\n\t// Point movement\n\tSHP_0: 0x32,\n\tSHP_1: 0x33,\n\tSHC_0: 0x34,\n\tSHC_1: 0x35,\n\tSHZ_0: 0x36,\n\tSHZ_1: 0x37,\n\tSHPIX: 0x38,\n\tIP: 0x39,\n\tMSIRP_0: 0x3a,\n\tMSIRP_1: 0x3b,\n\tALIGNRP: 0x3c,\n\tRTDG: 0x3d,\n\tMIAP_0: 0x3e,\n\tMIAP_1: 0x3f,\n\n\t// ALIGNPTS - Align Points\n\tALIGNPTS: 0x27,\n\n\t// UTP - UnTouch Point\n\tUTP: 0x29,\n\n\t// MDAP - Move Direct Absolute Point\n\tMDAP_0: 0x2e,\n\tMDAP_1: 0x2f,\n\n\t// IUP - Interpolate Untouched Points\n\tIUP_Y: 0x30,\n\tIUP_X: 0x31,\n\n\t// Delta instructions\n\tDELTAP1: 0x5d,\n\tDELTAP2: 0x71,\n\tDELTAP3: 0x72,\n\tDELTAC1: 0x73,\n\tDELTAC2: 0x74,\n\tDELTAC3: 0x75,\n\n\t// Rounding\n\tROUND_0: 0x68,\n\tROUND_1: 0x69,\n\tROUND_2: 0x6a,\n\tROUND_3: 0x6b,\n\tNROUND_0: 0x6c,\n\tNROUND_1: 0x6d,\n\tNROUND_2: 0x6e,\n\tNROUND_3: 0x6f,\n\n\t// Other\n\tGETINFO: 0x88,\n\tINSTCTRL: 0x8e,\n\tSCANCTRL: 0x85,\n\tSCANTYPE: 0x8d,\n\tAA: 0x7f,\n\tDEBUG: 0x4f,\n\n\t// MDRP - Move Direct Relative Point (32 variants: 0xc0-0xdf)\n\tMDRP_BASE: 0xc0,\n\n\t// MIRP - Move Indirect Relative Point (32 variants: 0xe0-0xff)\n\tMIRP_BASE: 0xe0,\n} as const;\n\n/**\n * Number of values popped from stack for each opcode\n */\nexport const OpcodePops: Record<number, number> = {\n\t[Opcode.RS]: 1,\n\t[Opcode.WS]: 2,\n\t[Opcode.RCVT]: 1,\n\t[Opcode.WCVTP]: 2,\n\t[Opcode.WCVTF]: 2,\n\t[Opcode.DUP]: 1,\n\t[Opcode.POP]: 1,\n\t[Opcode.CLEAR]: 0,\n\t[Opcode.SWAP]: 2,\n\t[Opcode.DEPTH]: 0,\n\t[Opcode.CINDEX]: 1,\n\t[Opcode.MINDEX]: 1,\n\t[Opcode.ROLL]: 3,\n\t[Opcode.ADD]: 2,\n\t[Opcode.SUB]: 2,\n\t[Opcode.DIV]: 2,\n\t[Opcode.MUL]: 2,\n\t[Opcode.ABS]: 1,\n\t[Opcode.NEG]: 1,\n\t[Opcode.FLOOR]: 1,\n\t[Opcode.CEILING]: 1,\n\t[Opcode.MAX]: 2,\n\t[Opcode.MIN]: 2,\n\t[Opcode.LT]: 2,\n\t[Opcode.LTEQ]: 2,\n\t[Opcode.GT]: 2,\n\t[Opcode.GTEQ]: 2,\n\t[Opcode.EQ]: 2,\n\t[Opcode.NEQ]: 2,\n\t[Opcode.ODD]: 1,\n\t[Opcode.EVEN]: 1,\n\t[Opcode.AND]: 2,\n\t[Opcode.OR]: 2,\n\t[Opcode.NOT]: 1,\n\t[Opcode.IF]: 1,\n\t[Opcode.JMPR]: 1,\n\t[Opcode.JROT]: 2,\n\t[Opcode.JROF]: 2,\n\t[Opcode.CALL]: 1,\n\t[Opcode.LOOPCALL]: 2,\n\t[Opcode.SRP0]: 1,\n\t[Opcode.SRP1]: 1,\n\t[Opcode.SRP2]: 1,\n\t[Opcode.SZP0]: 1,\n\t[Opcode.SZP1]: 1,\n\t[Opcode.SZP2]: 1,\n\t[Opcode.SZPS]: 1,\n\t[Opcode.SLOOP]: 1,\n\t[Opcode.SMD]: 1,\n\t[Opcode.SCVTCI]: 1,\n\t[Opcode.SSWCI]: 1,\n\t[Opcode.SSW]: 1,\n\t[Opcode.SDB]: 1,\n\t[Opcode.SDS]: 1,\n\t[Opcode.SPVFS]: 2,\n\t[Opcode.SFVFS]: 2,\n\t[Opcode.SPVTL_0]: 2,\n\t[Opcode.SPVTL_1]: 2,\n\t[Opcode.SFVTL_0]: 2,\n\t[Opcode.SFVTL_1]: 2,\n\t[Opcode.SCFS]: 2,\n\t[Opcode.GC_0]: 1,\n\t[Opcode.GC_1]: 1,\n\t[Opcode.MD_0]: 2,\n\t[Opcode.MD_1]: 2,\n\t[Opcode.ISECT]: 5,\n\t[Opcode.ALIGNRP]: 0, // Uses loop\n\t[Opcode.IP]: 0, // Uses loop\n\t[Opcode.SHPIX]: 1, // Plus loop points\n\t[Opcode.MSIRP_0]: 2,\n\t[Opcode.MSIRP_1]: 2,\n\t[Opcode.MIAP_0]: 2,\n\t[Opcode.MIAP_1]: 2,\n\t[Opcode.MDAP_0]: 1,\n\t[Opcode.MDAP_1]: 1,\n\t[Opcode.DELTAP1]: 1,\n\t[Opcode.DELTAP2]: 1,\n\t[Opcode.DELTAP3]: 1,\n\t[Opcode.DELTAC1]: 1,\n\t[Opcode.DELTAC2]: 1,\n\t[Opcode.DELTAC3]: 1,\n\t[Opcode.SROUND]: 1,\n\t[Opcode.S45ROUND]: 1,\n\t[Opcode.ROUND_0]: 1,\n\t[Opcode.ROUND_1]: 1,\n\t[Opcode.ROUND_2]: 1,\n\t[Opcode.ROUND_3]: 1,\n\t[Opcode.NROUND_0]: 1,\n\t[Opcode.NROUND_1]: 1,\n\t[Opcode.NROUND_2]: 1,\n\t[Opcode.NROUND_3]: 1,\n\t[Opcode.INSTCTRL]: 2,\n\t[Opcode.SCANCTRL]: 1,\n\t[Opcode.SCANTYPE]: 1,\n\t[Opcode.GETINFO]: 1,\n\t[Opcode.FLIPPT]: 0, // Uses loop\n\t[Opcode.FLIPRGON]: 2,\n\t[Opcode.FLIPRGOFF]: 2,\n};\n",
    "/**\n * TrueType rounding functions\n *\n * These implement the various rounding modes used by the interpreter.\n */\n\nimport { type F26Dot6, type GraphicsState, RoundMode } from \"./types.ts\";\n\n/**\n * Round to grid (nearest integer pixel)\n */\nexport function roundToGrid(distance: F26Dot6, compensation: F26Dot6): F26Dot6 {\n\tif (distance >= 0) {\n\t\tconst val = (distance + compensation + 32) & -64;\n\t\treturn val < 0 ? 0 : val;\n\t} else {\n\t\tconst val = -((-distance + compensation + 32) & -64);\n\t\treturn val > 0 ? 0 : val;\n\t}\n}\n\n/**\n * Round to half grid (nearest half pixel)\n */\nexport function roundToHalfGrid(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n): F26Dot6 {\n\tif (distance >= 0) {\n\t\tconst val = ((distance + compensation) & -64) + 32;\n\t\treturn val < 0 ? 32 : val;\n\t} else {\n\t\tconst val = -(((-distance + compensation) & -64) + 32);\n\t\treturn val > 0 ? -32 : val;\n\t}\n}\n\n/**\n * Round to double grid (nearest half pixel boundary)\n */\nexport function roundToDoubleGrid(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n): F26Dot6 {\n\tif (distance >= 0) {\n\t\tconst val = (distance + compensation + 16) & -32;\n\t\treturn val < 0 ? 0 : val;\n\t} else {\n\t\tconst val = -((-distance + compensation + 16) & -32);\n\t\treturn val > 0 ? 0 : val;\n\t}\n}\n\n/**\n * Round down to grid (floor to pixel)\n */\nexport function roundDownToGrid(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n): F26Dot6 {\n\tif (distance >= 0) {\n\t\tconst val = (distance + compensation) & -64;\n\t\treturn val < 0 ? 0 : val;\n\t} else {\n\t\tconst val = -((-distance + compensation) & -64);\n\t\treturn val > 0 ? 0 : val;\n\t}\n}\n\n/**\n * Round up to grid (ceiling to pixel)\n */\nexport function roundUpToGrid(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n): F26Dot6 {\n\tif (distance >= 0) {\n\t\tconst val = (distance + compensation + 63) & -64;\n\t\treturn val < 0 ? 0 : val;\n\t} else {\n\t\tconst val = -((-distance + compensation + 63) & -64);\n\t\treturn val > 0 ? 0 : val;\n\t}\n}\n\n/**\n * No rounding\n */\nexport function roundOff(distance: F26Dot6, _compensation: F26Dot6): F26Dot6 {\n\treturn distance;\n}\n\n/**\n * Super rounding (parametric rounding)\n */\nexport function roundSuper(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n\tGS: GraphicsState,\n): F26Dot6 {\n\tconst { period, phase, threshold } = GS;\n\n\tif (distance >= 0) {\n\t\tconst val = (distance + threshold - phase + compensation) & -period;\n\t\treturn val + phase;\n\t} else {\n\t\tconst val = (-distance + threshold - phase + compensation) & -period;\n\t\treturn -(val + phase);\n\t}\n}\n\n/**\n * Super rounding 45 degrees (for diagonal lines)\n */\nexport function roundSuper45(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n\tGS: GraphicsState,\n): F26Dot6 {\n\t// Same as super rounding but with 45-degree adjusted period\n\t// Period is multiplied by sqrt(2)/2  0.707\n\tconst { period, phase, threshold } = GS;\n\tconst period45 = Math.round((period * 46) / 64); // sqrt(2)/2  46/64\n\n\tif (distance >= 0) {\n\t\tconst val = (distance + threshold - phase + compensation) & -period45;\n\t\treturn val + phase;\n\t} else {\n\t\tconst val = (-distance + threshold - phase + compensation) & -period45;\n\t\treturn -(val + phase);\n\t}\n}\n\n/**\n * Apply current rounding mode\n */\nexport function round(\n\tdistance: F26Dot6,\n\tcompensation: F26Dot6,\n\tGS: GraphicsState,\n): F26Dot6 {\n\tswitch (GS.roundState) {\n\t\tcase RoundMode.ToGrid:\n\t\t\treturn roundToGrid(distance, compensation);\n\t\tcase RoundMode.ToHalfGrid:\n\t\t\treturn roundToHalfGrid(distance, compensation);\n\t\tcase RoundMode.ToDoubleGrid:\n\t\t\treturn roundToDoubleGrid(distance, compensation);\n\t\tcase RoundMode.DownToGrid:\n\t\t\treturn roundDownToGrid(distance, compensation);\n\t\tcase RoundMode.UpToGrid:\n\t\t\treturn roundUpToGrid(distance, compensation);\n\t\tcase RoundMode.Off:\n\t\t\treturn roundOff(distance, compensation);\n\t\tcase RoundMode.Super:\n\t\t\treturn roundSuper(distance, compensation, GS);\n\t\tcase RoundMode.Super45:\n\t\t\treturn roundSuper45(distance, compensation, GS);\n\t\tdefault:\n\t\t\treturn roundToGrid(distance, compensation);\n\t}\n}\n\n/**\n * Parse SROUND/S45ROUND selector byte\n */\nexport function parseSuperRound(selector: number, GS: GraphicsState): void {\n\t// Period selection (bits 6-7)\n\tswitch ((selector >> 6) & 0x03) {\n\t\tcase 0:\n\t\t\tGS.period = 32; // 1/2 pixel\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tGS.period = 64; // 1 pixel\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tGS.period = 128; // 2 pixels\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Reserved\n\t\t\tGS.period = 64;\n\t}\n\n\t// Phase selection (bits 4-5)\n\tswitch ((selector >> 4) & 0x03) {\n\t\tcase 0:\n\t\t\tGS.phase = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tGS.phase = GS.period >> 2; // period/4\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tGS.phase = GS.period >> 1; // period/2\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tGS.phase = (GS.period * 3) >> 2; // 3*period/4\n\t\t\tbreak;\n\t}\n\n\t// Threshold selection (bits 0-3)\n\tconst thresholdBits = selector & 0x0f;\n\tif (thresholdBits === 0) {\n\t\tGS.threshold = GS.period - 1;\n\t} else {\n\t\tGS.threshold = ((thresholdBits - 4) * GS.period) >> 3;\n\t}\n}\n\n/**\n * Compensate distance for engine characteristics\n * Used with ROUND and movement instructions\n */\nexport function compensate(_distance: F26Dot6, _GS: GraphicsState): F26Dot6 {\n\t// Engine compensation is typically 0 for modern displays\n\t// But some fonts depend on it for grid-fitting\n\treturn 0;\n}\n",
    "/**\n * Fixed-point scaling helpers (match FreeType rounding behavior).\n */\n\n// Multiply by 16.16 fixed-point with rounding, ties away from zero.\nexport function mulFix(value: number, scaleFix: number): number {\n\tif (value === 0 || scaleFix === 0) return 0;\n\tlet sign = 1;\n\tlet a = value;\n\tlet b = scaleFix;\n\tif (a < 0) {\n\t\ta = -a;\n\t\tsign = -sign;\n\t}\n\tif (b < 0) {\n\t\tb = -b;\n\t\tsign = -sign;\n\t}\n\tconst result = Math.floor((a * b + 0x8000) / 0x10000);\n\treturn sign < 0 ? -result : result;\n}\n\n// Divide with 16.16 fixed-point result, rounding to nearest.\nexport function divFix(value: number, divisor: number): number {\n\tif (divisor === 0) return value < 0 ? -0x7fffffff : 0x7fffffff;\n\tlet sign = 1;\n\tlet a = value;\n\tlet b = divisor;\n\tif (a < 0) {\n\t\ta = -a;\n\t\tsign = -sign;\n\t}\n\tif (b < 0) {\n\t\tb = -b;\n\t\tsign = -sign;\n\t}\n\tconst result = Math.floor((a * 0x10000 + (b >> 1)) / b);\n\treturn sign < 0 ? -result : result;\n}\n\n// Scale font units to 26.6 using a 16.16 scale factor.\nexport function scaleFUnits(value: number, scaleFix: number): number {\n\treturn mulFix(value, scaleFix);\n}\n",
    "/**\n * Point movement instructions\n *\n * These are the core hinting operations that actually move glyph points.\n */\n\nimport { compensate, round } from \"../rounding.ts\";\nimport { scaleFUnits } from \"../scale.ts\";\nimport {\n\tCodeRange,\n\ttype ExecContext,\n\ttype F26Dot6,\n\ttype GlyphZone,\n\ttype Point,\n\tRoundMode,\n\tTouchFlag,\n} from \"../types.ts\";\n\nfunction dotFix14(\n\tax: F26Dot6,\n\tay: F26Dot6,\n\tbx: number,\n\tby: number,\n): F26Dot6 {\n\tconst c = ax * bx + ay * by;\n\tconst rounded = c + 0x2000 + (c < 0 ? -1 : 0);\n\treturn Math.floor(rounded / 0x4000);\n}\n\nfunction mulFix14(a: F26Dot6, b: number): F26Dot6 {\n\tconst c = a * b;\n\tconst rounded = c + 0x2000 + (c < 0 ? -1 : 0);\n\treturn Math.floor(rounded / 0x4000);\n}\n\nfunction dotFix14Vectors(ax: number, ay: number, bx: number, by: number): number {\n\tconst c = ax * bx + ay * by;\n\tconst rounded = c + 0x2000 + (c < 0 ? -1 : 0);\n\treturn Math.floor(rounded / 0x4000);\n}\n\nfunction dualProjectOrusDelta(\n\tctx: ExecContext,\n\tzone1: GlyphZone,\n\tp1: number,\n\tzone2: GlyphZone,\n\tp2: number,\n): F26Dot6 {\n\tconst pt1 = zone1.orus[p1];\n\tconst pt2 = zone2.orus[p2];\n\tif (!pt1 || !pt2) return 0;\n\n\tconst dx = pt1.x - pt2.x;\n\tconst dy = pt1.y - pt2.y;\n\tconst dist = dotFix14(dx, dy, ctx.GS.dualVector.x, ctx.GS.dualVector.y);\n\treturn scaleFUnits(dist, ctx.scaleFix);\n}\n\nfunction mulDiv(a: number, b: number, c: number): number {\n\tif (c === 0) return (a ^ b) < 0 ? -0x7fffffff : 0x7fffffff;\n\n\tlet sign = 1;\n\tif (a < 0) {\n\t\ta = -a;\n\t\tsign = -sign;\n\t}\n\tif (b < 0) {\n\t\tb = -b;\n\t\tsign = -sign;\n\t}\n\tif (c < 0) {\n\t\tc = -c;\n\t\tsign = -sign;\n\t}\n\n\tconst result = Math.floor((a * b + (c >> 1)) / c);\n\treturn sign < 0 ? -result : result;\n}\n\n/**\n * Project a point onto the projection vector\n */\nexport function project(ctx: ExecContext, p: Point): F26Dot6 {\n\treturn dotFix14(p.x, p.y, ctx.GS.projVector.x, ctx.GS.projVector.y);\n}\n\n/**\n * Project using dual vector (for original positions)\n */\nexport function dualProject(ctx: ExecContext, p: Point): F26Dot6 {\n\treturn dotFix14(p.x, p.y, ctx.GS.dualVector.x, ctx.GS.dualVector.y);\n}\n\n/**\n * Move a point along the freedom vector\n */\nexport function movePoint(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n\tdistance: F26Dot6,\n): void {\n\tconst pt = zone.cur[pointIndex];\n\n\t// Calculate movement along freedom vector\n\t// freedom vector is in 2.14 format, so divide by 0x4000\n\tconst fv = ctx.GS.freeVector;\n\tconst pv = ctx.GS.projVector;\n\n\t// Calculate dot product of freedom and projection vectors (F2Dot14)\n\tconst dot = dotFix14Vectors(fv.x, fv.y, pv.x, pv.y);\n\n\tif (dot === 0) {\n\t\t// Vectors are perpendicular, can't move\n\t\treturn;\n\t}\n\n\t// Scale distance by freedom/projection relationship\n\tconst dx = mulDiv(distance, fv.x, dot);\n\tconst dy = mulDiv(distance, fv.y, dot);\n\tlet moveX = dx;\n\tlet moveY = dy;\n\n\t// Backward compatibility (light hinting): ignore X moves, and block\n\t// all moves after both IUP[x] and IUP[y] have run.\n\tif (ctx.backwardCompatibility) {\n\t\tif (fv.x !== 0) moveX = 0;\n\t\tif (fv.y !== 0 && ctx.backwardCompatibility === 0x7) moveY = 0;\n\t}\n\n\tpt.x += moveX;\n\tpt.y += moveY;\n\n\t// Twilight points have no true original positions; keep org in sync.\n\tif (zone === ctx.twilight) {\n\t\tconst orgPt = zone.org[pointIndex];\n\t\torgPt.x += moveX;\n\t\torgPt.y += moveY;\n\t}\n}\n\n/**\n * Get current position of a point projected onto projection vector\n */\nexport function getCurrent(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n): F26Dot6 {\n\tconst pt = zone.cur[pointIndex];\n\tif (!pt) return 0;\n\treturn project(ctx, pt);\n}\n\n/**\n * Get original position of a point projected onto dual vector\n */\nexport function getOriginal(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n): F26Dot6 {\n\tconst pt = zone.org[pointIndex];\n\tif (!pt) return 0;\n\treturn dualProject(ctx, pt);\n}\n\n/**\n * Mark point as touched in the current direction\n */\nexport function touchPoint(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n): void {\n\t// Set touch flag based on freedom vector direction\n\tconst fv = ctx.GS.freeVector;\n\tif (fv.y !== 0) {\n\t\tzone.tags[pointIndex] |= TouchFlag.Y;\n\t}\n\tif (fv.x !== 0) {\n\t\tzone.tags[pointIndex] |= TouchFlag.X;\n\t}\n}\n\n// =============================================================================\n// MDAP - Move Direct Absolute Point\n// =============================================================================\n\n/** MDAP - Move Direct Absolute Point */\nexport function MDAP(ctx: ExecContext, doRound: boolean): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\tconst zone = ctx.zp0;\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `MDAP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tlet distance = getCurrent(ctx, zone, pointIndex);\n\n\tif (doRound) {\n\t\tconst comp = compensate(distance, ctx.GS);\n\t\tdistance = round(distance, comp, ctx.GS) - distance;\n\t} else {\n\t\tdistance = 0;\n\t}\n\n\tmovePoint(ctx, zone, pointIndex, distance);\n\ttouchPoint(ctx, zone, pointIndex);\n\n\tctx.GS.rp0 = pointIndex;\n\tctx.GS.rp1 = pointIndex;\n}\n\n// =============================================================================\n// MIAP - Move Indirect Absolute Point\n// =============================================================================\n\n/** MIAP - Move Indirect Absolute Point (uses CVT) */\nexport function MIAP(ctx: ExecContext, doRound: boolean): void {\n\tconst cvtIndex = ctx.stack[--ctx.stackTop];\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\tconst zone = ctx.zp0;\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `MIAP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tif (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {\n\t\treturn;\n\t}\n\n\tlet cvtDistance = ctx.cvt[cvtIndex];\n\tconst currentPos = getCurrent(ctx, zone, pointIndex);\n\n\tif (doRound) {\n\t\t// Check if we should use CVT value or current position\n\t\tconst diff = Math.abs(cvtDistance - currentPos);\n\n\t\tif (diff > ctx.GS.controlValueCutIn) {\n\t\t\t// Difference too large, use current position\n\t\t\tcvtDistance = currentPos;\n\t\t}\n\n\t\tconst comp = compensate(cvtDistance, ctx.GS);\n\t\tcvtDistance = round(cvtDistance, comp, ctx.GS);\n\t}\n\n\tconst distance = cvtDistance - currentPos;\n\tmovePoint(ctx, zone, pointIndex, distance);\n\ttouchPoint(ctx, zone, pointIndex);\n\n\tctx.GS.rp0 = pointIndex;\n\tctx.GS.rp1 = pointIndex;\n}\n\n// =============================================================================\n// MDRP - Move Direct Relative Point\n// =============================================================================\n\n/** MDRP - Move Direct Relative Point */\nexport function MDRP(ctx: ExecContext, flags: number): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\tconst setRp0 = (flags & 0x10) !== 0;\n\tconst keepMinDist = (flags & 0x08) !== 0;\n\tconst doRound = (flags & 0x04) !== 0;\n\tconst distanceType = flags & 0x03;\n\tlet roundState = ctx.GS.roundState;\n\tif (distanceType === 1) {\n\t\troundState = RoundMode.ToGrid;\n\t} else if (distanceType === 2) {\n\t\troundState = RoundMode.ToHalfGrid;\n\t} else if (distanceType === 3) {\n\t\troundState = RoundMode.ToDoubleGrid;\n\t}\n\n\tconst zp0 = ctx.zp0;\n\tconst zp1 = ctx.zp1;\n\n\tif (pointIndex < 0 || pointIndex >= zp1.nPoints) {\n\t\tctx.error = `MDRP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tconst rp0 = ctx.GS.rp0;\n\tif (rp0 < 0 || rp0 >= zp0.nPoints) {\n\t\tctx.error = `MDRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\t// Get original distance (using dual projection vector)\n\tlet orgDist =\n\t\tgetOriginal(ctx, zp1, pointIndex) - getOriginal(ctx, zp0, rp0);\n\n\t// Single width cut-in test\n\tif (\n\t\tctx.GS.singleWidthCutIn > 0 &&\n\t\tMath.abs(orgDist - ctx.GS.singleWidthValue) < ctx.GS.singleWidthCutIn\n\t) {\n\t\torgDist = orgDist >= 0 ? ctx.GS.singleWidthValue : -ctx.GS.singleWidthValue;\n\t}\n\n\tconst comp = compensate(orgDist, ctx.GS);\n\tlet distance: F26Dot6;\n\tif (doRound) {\n\t\tconst savedRound = ctx.GS.roundState;\n\t\tctx.GS.roundState = roundState;\n\t\tdistance = round(orgDist, comp, ctx.GS);\n\t\tctx.GS.roundState = savedRound;\n\t} else {\n\t\tdistance = orgDist + comp;\n\t}\n\n\t// Apply minimum distance\n\tif (keepMinDist) {\n\t\tif (orgDist >= 0) {\n\t\t\tif (distance < ctx.GS.minimumDistance) {\n\t\t\t\tdistance = ctx.GS.minimumDistance;\n\t\t\t}\n\t\t} else {\n\t\t\tif (distance > -ctx.GS.minimumDistance) {\n\t\t\t\tdistance = -ctx.GS.minimumDistance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate actual movement needed\n\tconst currentDist =\n\t\tgetCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);\n\tconst move = distance - currentDist;\n\tmovePoint(ctx, zp1, pointIndex, move);\n\ttouchPoint(ctx, zp1, pointIndex);\n\n\tctx.GS.rp1 = ctx.GS.rp0;\n\tctx.GS.rp2 = pointIndex;\n\tif (setRp0) {\n\t\tctx.GS.rp0 = pointIndex;\n\t}\n}\n\n// =============================================================================\n// MIRP - Move Indirect Relative Point\n// =============================================================================\n\n/** MIRP - Move Indirect Relative Point (uses CVT) */\nexport function MIRP(ctx: ExecContext, flags: number): void {\n\tconst cvtIndex = ctx.stack[--ctx.stackTop];\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\tconst setRp0 = (flags & 0x10) !== 0;\n\tconst keepMinDist = (flags & 0x08) !== 0;\n\tconst doRound = (flags & 0x04) !== 0;\n\tconst distanceType = flags & 0x03;\n\tlet roundState = ctx.GS.roundState;\n\tif (distanceType === 1) {\n\t\troundState = RoundMode.ToGrid;\n\t} else if (distanceType === 2) {\n\t\troundState = RoundMode.ToHalfGrid;\n\t} else if (distanceType === 3) {\n\t\troundState = RoundMode.ToDoubleGrid;\n\t}\n\n\tconst zp0 = ctx.zp0;\n\tconst zp1 = ctx.zp1;\n\n\tif (pointIndex < 0 || pointIndex >= zp1.nPoints) {\n\t\tctx.error = `MIRP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tif (cvtIndex < -1 || cvtIndex >= ctx.cvtSize) {\n\t\treturn;\n\t}\n\n\tconst rp0 = ctx.GS.rp0;\n\tif (rp0 < 0 || rp0 >= zp0.nPoints) {\n\t\tctx.error = `MIRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\t// Get original distance for comparison\n\tconst orgDist =\n\t\tgetOriginal(ctx, zp1, pointIndex) - getOriginal(ctx, zp0, rp0);\n\n\t// Get CVT distance (cvt[-1] = 0)\n\tlet cvtDist = cvtIndex === -1 ? 0 : ctx.cvt[cvtIndex];\n\n\t// Single width test\n\tif (\n\t\tctx.GS.singleWidthCutIn > 0 &&\n\t\tMath.abs(cvtDist - ctx.GS.singleWidthValue) < ctx.GS.singleWidthCutIn\n\t) {\n\t\tcvtDist = cvtDist >= 0 ? ctx.GS.singleWidthValue : -ctx.GS.singleWidthValue;\n\t}\n\n\t// Twilight points special case: update org/cur from CVT + free vector\n\tif (ctx.GS.gep1 === 0) {\n\t\tconst orgRp0 = ctx.zp0.org[rp0];\n\t\tconst dx = mulFix14(cvtDist, ctx.GS.freeVector.x);\n\t\tconst dy = mulFix14(cvtDist, ctx.GS.freeVector.y);\n\t\tctx.zp1.org[pointIndex].x = orgRp0.x + dx;\n\t\tctx.zp1.org[pointIndex].y = orgRp0.y + dy;\n\t\tctx.zp1.cur[pointIndex].x = ctx.zp1.org[pointIndex].x;\n\t\tctx.zp1.cur[pointIndex].y = ctx.zp1.org[pointIndex].y;\n\t}\n\n\t// Auto-flip test.\n\tif (ctx.GS.autoFlip) {\n\t\tif ((orgDist ^ cvtDist) < 0) {\n\t\t\tcvtDist = -cvtDist;\n\t\t}\n\t}\n\n\tlet distance: F26Dot6 = cvtDist;\n\tconst comp = compensate(cvtDist, ctx.GS);\n\n\tif (doRound) {\n\t\t// Cut-in test only if both points are in the same zone.\n\t\tif (ctx.GS.gep0 === ctx.GS.gep1) {\n\t\t\tconst diff = Math.abs(cvtDist - orgDist);\n\t\t\tif (diff > ctx.GS.controlValueCutIn) {\n\t\t\t\tdistance = orgDist;\n\t\t\t}\n\t\t}\n\t\tconst savedRound = ctx.GS.roundState;\n\t\tctx.GS.roundState = roundState;\n\t\tdistance = round(distance, comp, ctx.GS);\n\t\tctx.GS.roundState = savedRound;\n\t} else {\n\t\tdistance = distance + comp;\n\t}\n\n\t// Apply minimum distance\n\tif (keepMinDist) {\n\t\tif (orgDist >= 0) {\n\t\t\tif (distance < ctx.GS.minimumDistance) {\n\t\t\t\tdistance = ctx.GS.minimumDistance;\n\t\t\t}\n\t\t} else {\n\t\t\tif (distance > -ctx.GS.minimumDistance) {\n\t\t\t\tdistance = -ctx.GS.minimumDistance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate actual movement needed\n\tconst currentDist =\n\t\tgetCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);\n\tconst move = distance - currentDist;\n\tmovePoint(ctx, zp1, pointIndex, move);\n\ttouchPoint(ctx, zp1, pointIndex);\n\n\tctx.GS.rp1 = ctx.GS.rp0;\n\tctx.GS.rp2 = pointIndex;\n\tif (setRp0) {\n\t\tctx.GS.rp0 = pointIndex;\n\t}\n}\n\n// =============================================================================\n// SHP - Shift Point\n// =============================================================================\n\n/** SHP - Shift Point using reference point */\nexport function SHP(ctx: ExecContext, useRp1: boolean): void {\n\tconst refZone = useRp1 ? ctx.zp0 : ctx.zp1;\n\tconst refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;\n\n\tif (refPoint < 0 || refPoint >= refZone.nPoints) {\n\t\tctx.error = `SHP: invalid reference point ${refPoint}`;\n\t\treturn;\n\t}\n\n\t// Calculate shift amount from reference point movement\n\tconst orgRef = project(ctx, refZone.org[refPoint]);\n\tconst curRef = getCurrent(ctx, refZone, refPoint);\n\tconst shift = curRef - orgRef;\n\n\t// Apply to loop count points\n\tconst zone = ctx.zp2;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `SHP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, shift);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// SHC - Shift Contour\n// =============================================================================\n\n/** SHC - Shift Contour using reference point */\nexport function SHC(ctx: ExecContext, useRp1: boolean): void {\n\tconst contourIndex = ctx.stack[--ctx.stackTop];\n\n\tconst refZone = useRp1 ? ctx.zp0 : ctx.zp1;\n\tconst refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;\n\n\tif (refPoint < 0 || refPoint >= refZone.nPoints) {\n\t\tctx.error = `SHC: invalid reference point ${refPoint}`;\n\t\treturn;\n\t}\n\n\tconst zone = ctx.zp2;\n\tif (contourIndex < 0 || contourIndex >= zone.nContours) {\n\t\tctx.error = `SHC: invalid contour ${contourIndex}`;\n\t\treturn;\n\t}\n\n\t// Calculate shift amount\n\tconst orgRef = project(ctx, refZone.org[refPoint]);\n\tconst curRef = getCurrent(ctx, refZone, refPoint);\n\tconst shift = curRef - orgRef;\n\n\t// Get contour bounds\n\tconst start = contourIndex === 0 ? 0 : zone.contours[contourIndex - 1] + 1;\n\tconst end = zone.contours[contourIndex];\n\n\t// Shift all points in contour (except reference point if in same zone)\n\tfor (let i = start; i <= end; i++) {\n\t\tif (zone === refZone && i === refPoint) continue;\n\t\tmovePoint(ctx, zone, i, shift);\n\t\ttouchPoint(ctx, zone, i);\n\t}\n}\n\n// =============================================================================\n// SHZ - Shift Zone\n// =============================================================================\n\n/** SHZ - Shift Zone using reference point */\nexport function SHZ(ctx: ExecContext, useRp1: boolean): void {\n\tconst zoneIndex = ctx.stack[--ctx.stackTop];\n\n\tconst refZone = useRp1 ? ctx.zp0 : ctx.zp1;\n\tconst refPoint = useRp1 ? ctx.GS.rp1 : ctx.GS.rp2;\n\n\tif (refPoint < 0 || refPoint >= refZone.nPoints) {\n\t\tctx.error = `SHZ: invalid reference point ${refPoint}`;\n\t\treturn;\n\t}\n\n\tconst zone = zoneIndex === 0 ? ctx.twilight : ctx.pts;\n\n\t// Calculate shift amount\n\tconst orgRef = project(ctx, refZone.org[refPoint]);\n\tconst curRef = getCurrent(ctx, refZone, refPoint);\n\tconst shift = curRef - orgRef;\n\n\t// Shift all points in zone (except reference point if in same zone)\n\tfor (let i = 0; i < zone.nPoints; i++) {\n\t\tif (zone === refZone && i === refPoint) continue;\n\t\tmovePoint(ctx, zone, i, shift);\n\t\t// Note: SHZ doesn't set touch flags\n\t}\n}\n\n// =============================================================================\n// SHPIX - Shift Point by Pixel Amount\n// =============================================================================\n\nfunction movePointFree(\n\tctx: ExecContext,\n\tzone: GlyphZone,\n\tpointIndex: number,\n\tdx: F26Dot6,\n\tdy: F26Dot6,\n): void {\n\tconst fv = ctx.GS.freeVector;\n\tif (fv.x !== 0) {\n\t\tif (!ctx.backwardCompatibility) {\n\t\t\tzone.cur[pointIndex].x += dx;\n\t\t}\n\t}\n\tif (fv.y !== 0) {\n\t\tif (ctx.backwardCompatibility !== 0x7) {\n\t\t\tzone.cur[pointIndex].y += dy;\n\t\t}\n\t}\n\tif (zone === ctx.twilight) {\n\t\tconst orgPt = zone.org[pointIndex];\n\t\tif (fv.x !== 0 && !ctx.backwardCompatibility) orgPt.x += dx;\n\t\tif (fv.y !== 0 && ctx.backwardCompatibility !== 0x7) orgPt.y += dy;\n\t}\n}\n\n/** SHPIX - Shift Point by Pixel Amount */\nexport function SHPIX(ctx: ExecContext): void {\n\tconst distance = ctx.stack[--ctx.stackTop];\n\n\tconst zone = ctx.zp2;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\tconst inTwilight =\n\t\tctx.GS.gep0 === 0 || ctx.GS.gep1 === 0 || ctx.GS.gep2 === 0;\n\tconst dx = mulFix14(distance, ctx.GS.freeVector.x);\n\tconst dy = mulFix14(distance, ctx.GS.freeVector.y);\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `SHPIX: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctx.backwardCompatibility) {\n\t\t\tif (\n\t\t\t\tinTwilight ||\n\t\t\t\t(ctx.backwardCompatibility !== 0x7 &&\n\t\t\t\t\t((ctx.isComposite && ctx.GS.freeVector.y !== 0) ||\n\t\t\t\t\t\t(zone.tags[pointIndex] & TouchFlag.Y)))\n\t\t\t) {\n\t\t\t\tmovePointFree(ctx, zone, pointIndex, 0, dy);\n\t\t\t\ttouchPoint(ctx, zone, pointIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tmovePointFree(ctx, zone, pointIndex, dx, dy);\n\t\t\ttouchPoint(ctx, zone, pointIndex);\n\t\t}\n\t}\n}\n\n// =============================================================================\n// IP - Interpolate Point\n// =============================================================================\n\n/** IP - Interpolate Point */\nexport function IP(ctx: ExecContext): void {\n\tconst rp1 = ctx.GS.rp1;\n\tconst rp2 = ctx.GS.rp2;\n\n\tif (rp1 < 0 || rp1 >= ctx.zp0.nPoints) {\n\t\tctx.error = `IP: invalid rp1 ${rp1}`;\n\t\treturn;\n\t}\n\tif (rp2 < 0 || rp2 >= ctx.zp1.nPoints) {\n\t\tctx.error = `IP: invalid rp2 ${rp2}`;\n\t\treturn;\n\t}\n\n\t// Get original and current ranges between reference points.\n\tconst orgRange =\n\t\tgetOriginal(ctx, ctx.zp1, rp2) - getOriginal(ctx, ctx.zp0, rp1);\n\tconst curRange =\n\t\tgetCurrent(ctx, ctx.zp1, rp2) - getCurrent(ctx, ctx.zp0, rp1);\n\tconst orgBase = getOriginal(ctx, ctx.zp0, rp1);\n\tconst curBase = getCurrent(ctx, ctx.zp0, rp1);\n\n\tconst zone = ctx.zp2;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `IP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tconst orgDist = getOriginal(ctx, zone, pointIndex) - orgBase;\n\t\tconst curDist = getCurrent(ctx, zone, pointIndex) - curBase;\n\n\t\tlet newDist: F26Dot6;\n\t\tif (orgDist !== 0) {\n\t\t\tif (orgRange !== 0) {\n\t\t\t\tnewDist = mulDiv(orgDist, curRange, orgRange);\n\t\t\t} else {\n\t\t\t\tnewDist = orgDist;\n\t\t\t}\n\t\t} else {\n\t\t\tnewDist = 0;\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, newDist - curDist);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// ALIGNRP - Align Reference Point\n// =============================================================================\n\n/** ALIGNRP - Align to Reference Point */\nexport function ALIGNRP(ctx: ExecContext): void {\n\tconst rp0 = ctx.GS.rp0;\n\n\tif (rp0 < 0 || rp0 >= ctx.zp0.nPoints) {\n\t\tctx.error = `ALIGNRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\tconst refPos = getCurrent(ctx, ctx.zp0, rp0);\n\n\tconst zone = ctx.zp1;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `ALIGNRP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\tconst curPos = getCurrent(ctx, zone, pointIndex);\n\t\tconst distance = refPos - curPos;\n\n\t\tmovePoint(ctx, zone, pointIndex, distance);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n// =============================================================================\n// MSIRP - Move Stack Indirect Relative Point\n// =============================================================================\n\n/** MSIRP - Move Stack Indirect Relative Point */\nexport function MSIRP(ctx: ExecContext, setRp0: boolean): void {\n\tconst distance = ctx.stack[--ctx.stackTop];\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\tconst zp0 = ctx.zp0;\n\tconst zp1 = ctx.zp1;\n\n\tif (pointIndex < 0 || pointIndex >= zp1.nPoints) {\n\t\tctx.error = `MSIRP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tconst rp0 = ctx.GS.rp0;\n\tif (rp0 < 0 || rp0 >= zp0.nPoints) {\n\t\tctx.error = `MSIRP: invalid rp0 ${rp0}`;\n\t\treturn;\n\t}\n\n\t// Calculate current distance and move to achieve desired distance\n\tconst currentDist =\n\t\tgetCurrent(ctx, zp1, pointIndex) - getCurrent(ctx, zp0, rp0);\n\tconst move = distance - currentDist;\n\n\tmovePoint(ctx, zp1, pointIndex, move);\n\ttouchPoint(ctx, zp1, pointIndex);\n\n\tctx.GS.rp1 = ctx.GS.rp0;\n\tctx.GS.rp2 = pointIndex;\n\tif (setRp0) {\n\t\tctx.GS.rp0 = pointIndex;\n\t}\n}\n\n// =============================================================================\n// ISECT - Move Point to Intersection\n// =============================================================================\n\n/** ISECT - Move Point to Intersection of two lines */\nexport function ISECT(ctx: ExecContext): void {\n\tconst b1 = ctx.stack[--ctx.stackTop];\n\tconst b0 = ctx.stack[--ctx.stackTop];\n\tconst a1 = ctx.stack[--ctx.stackTop];\n\tconst a0 = ctx.stack[--ctx.stackTop];\n\tconst point = ctx.stack[--ctx.stackTop];\n\n\t// Line A: points a0 to a1 in zp1\n\t// Line B: points b0 to b1 in zp0\n\t// Move point in zp2 to intersection (FreeType-style)\n\n\tconst zone0 = ctx.zp0;\n\tconst zone1 = ctx.zp1;\n\tconst zone2 = ctx.zp2;\n\n\tif (a0 < 0 || a0 >= zone1.nPoints || a1 < 0 || a1 >= zone1.nPoints) {\n\t\tctx.error = `ISECT: invalid line A points`;\n\t\treturn;\n\t}\n\tif (b0 < 0 || b0 >= zone0.nPoints || b1 < 0 || b1 >= zone0.nPoints) {\n\t\tctx.error = `ISECT: invalid line B points`;\n\t\treturn;\n\t}\n\tif (point < 0 || point >= zone2.nPoints) {\n\t\tctx.error = `ISECT: invalid point ${point}`;\n\t\treturn;\n\t}\n\n\tconst pa0 = zone1.cur[a0];\n\tconst pa1 = zone1.cur[a1];\n\tconst pb0 = zone0.cur[b0];\n\tconst pb1 = zone0.cur[b1];\n\n\tconst dbx = pb1.x - pb0.x;\n\tconst dby = pb1.y - pb0.y;\n\tconst dax = pa1.x - pa0.x;\n\tconst day = pa1.y - pa0.y;\n\tconst dx = pb0.x - pa0.x;\n\tconst dy = pb0.y - pa0.y;\n\n\t// Cross/dot products (scaled by 0x40 like FreeType)\n\tconst discriminant = mulDiv(dax, -dby, 0x40) + mulDiv(day, dbx, 0x40);\n\tconst dotproduct = mulDiv(dax, dbx, 0x40) + mulDiv(day, dby, 0x40);\n\n\tconst pt = zone2.cur[point];\n\tif (Math.abs(discriminant) * 19 > Math.abs(dotproduct) && discriminant !== 0) {\n\t\tconst val = mulDiv(dx, -dby, 0x40) + mulDiv(dy, dbx, 0x40);\n\t\tconst rx = mulDiv(val, dax, discriminant);\n\t\tconst ry = mulDiv(val, day, discriminant);\n\t\tpt.x = pa0.x + rx;\n\t\tpt.y = pa0.y + ry;\n\t} else {\n\t\t// Fallback: average of endpoints\n\t\tpt.x = (pa0.x + pa1.x + pb0.x + pb1.x) >> 2;\n\t\tpt.y = (pa0.y + pa1.y + pb0.y + pb1.y) >> 2;\n\t}\n\n\tzone2.tags[point] |= TouchFlag.Both;\n}\n\n// =============================================================================\n// ALIGNPTS - Align Points\n// =============================================================================\n\n/** ALIGNPTS - Align two points */\nexport function ALIGNPTS(ctx: ExecContext): void {\n\tconst p2 = ctx.stack[--ctx.stackTop];\n\tconst p1 = ctx.stack[--ctx.stackTop];\n\n\tconst zone1 = ctx.zp0;\n\tconst zone2 = ctx.zp1;\n\n\tif (p1 < 0 || p1 >= zone1.nPoints) {\n\t\tctx.error = `ALIGNPTS: invalid point ${p1}`;\n\t\treturn;\n\t}\n\tif (p2 < 0 || p2 >= zone2.nPoints) {\n\t\tctx.error = `ALIGNPTS: invalid point ${p2}`;\n\t\treturn;\n\t}\n\n\t// Get current positions projected\n\tconst pos1 = getCurrent(ctx, zone1, p1);\n\tconst pos2 = getCurrent(ctx, zone2, p2);\n\n\t// Move both to midpoint\n\tconst mid = (pos1 + pos2) >> 1;\n\n\tmovePoint(ctx, zone1, p1, mid - pos1);\n\tmovePoint(ctx, zone2, p2, mid - pos2);\n\n\ttouchPoint(ctx, zone1, p1);\n\ttouchPoint(ctx, zone2, p2);\n}\n\n// =============================================================================\n// GC - Get Coordinate\n// =============================================================================\n\n/** GC - Get Coordinate projected onto projection vector */\nexport function GC(ctx: ExecContext, useOriginal: boolean): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\tconst zone = ctx.zp2;\n\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `GC: invalid point ${pointIndex}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\tconst coord = useOriginal\n\t\t? dualProject(ctx, zone.org[pointIndex])\n\t\t: getCurrent(ctx, zone, pointIndex);\n\n\tctx.stack[ctx.stackTop++] = coord;\n}\n\n// =============================================================================\n// SCFS - Set Coordinate From Stack\n// =============================================================================\n\n/** SCFS - Set Coordinate From Stack */\nexport function SCFS(ctx: ExecContext): void {\n\tconst coord = ctx.stack[--ctx.stackTop];\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\tconst zone = ctx.zp2;\n\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `SCFS: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\tconst current = getCurrent(ctx, zone, pointIndex);\n\tmovePoint(ctx, zone, pointIndex, coord - current);\n\ttouchPoint(ctx, zone, pointIndex);\n}\n\n// =============================================================================\n// MD - Measure Distance\n// =============================================================================\n\n/** MD - Measure Distance between two points */\nexport function MD(ctx: ExecContext, useOriginal: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop];\n\tconst p1 = ctx.stack[--ctx.stackTop];\n\n\tconst zone0 = ctx.zp0;\n\tconst zone1 = ctx.zp1;\n\n\tif (p1 < 0 || p1 >= zone0.nPoints) {\n\t\tctx.error = `MD: invalid point ${p1}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tif (p2 < 0 || p2 >= zone1.nPoints) {\n\t\tctx.error = `MD: invalid point ${p2}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\n\tlet distance: F26Dot6;\n\n\tif (useOriginal) {\n\t\tdistance = getOriginal(ctx, zone1, p2) - getOriginal(ctx, zone0, p1);\n\t} else {\n\t\tdistance = getCurrent(ctx, zone1, p2) - getCurrent(ctx, zone0, p1);\n\t}\n\n\tctx.stack[ctx.stackTop++] = distance;\n}\n\n// =============================================================================\n// MPPEM / MPS - Get Pixels Per EM / Point Size\n// =============================================================================\n\n/** MPPEM - Measure Pixels Per EM */\nexport function MPPEM(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.ppem;\n}\n\n/** MPS - Measure Point Size */\nexport function MPS(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.pointSize;\n}\n\n// =============================================================================\n// FLIPPT - Flip Point\n// =============================================================================\n\n/** FLIPPT - Flip on-curve/off-curve flag */\nexport function FLIPPT(ctx: ExecContext): void {\n\tif (ctx.backwardCompatibility === 0x7) return;\n\tconst zone = ctx.pts;\n\tconst count = ctx.GS.loop;\n\tctx.GS.loop = 1;\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `FLIPPT: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\t// Toggle bit 0 (on-curve flag)\n\t\tzone.tags[pointIndex] ^= 0x01;\n\t}\n}\n\n// =============================================================================\n// FLIPRGON / FLIPRGOFF - Flip Range On/Off\n// =============================================================================\n\n/** FLIPRGON - Set on-curve flag for range */\nexport function FLIPRGON(ctx: ExecContext): void {\n\tif (ctx.backwardCompatibility === 0x7) return;\n\tconst endPoint = ctx.stack[--ctx.stackTop];\n\tconst startPoint = ctx.stack[--ctx.stackTop];\n\n\tconst zone = ctx.pts;\n\n\tif (startPoint < 0 || endPoint >= zone.nPoints || startPoint > endPoint) {\n\t\tctx.error = `FLIPRGON: invalid range ${startPoint}-${endPoint}`;\n\t\treturn;\n\t}\n\n\tfor (let i = startPoint; i <= endPoint; i++) {\n\t\tzone.tags[i] |= 0x01; // Set on-curve\n\t}\n}\n\n/** FLIPRGOFF - Clear on-curve flag for range */\nexport function FLIPRGOFF(ctx: ExecContext): void {\n\tif (ctx.backwardCompatibility === 0x7) return;\n\tconst endPoint = ctx.stack[--ctx.stackTop];\n\tconst startPoint = ctx.stack[--ctx.stackTop];\n\n\tconst zone = ctx.pts;\n\n\tif (startPoint < 0 || endPoint >= zone.nPoints || startPoint > endPoint) {\n\t\tctx.error = `FLIPRGOFF: invalid range ${startPoint}-${endPoint}`;\n\t\treturn;\n\t}\n\n\tfor (let i = startPoint; i <= endPoint; i++) {\n\t\tzone.tags[i] &= ~0x01; // Clear on-curve\n\t}\n}\n\n// =============================================================================\n// ROUND / NROUND - Round Value\n// =============================================================================\n\n/** ROUND - Round value */\nexport function ROUND(ctx: ExecContext, _colorIndex: number): void {\n\tconst value = ctx.stack[--ctx.stackTop];\n\tconst comp = compensate(value, ctx.GS);\n\tctx.stack[ctx.stackTop++] = round(value, comp, ctx.GS);\n}\n\n/** NROUND - No-round (just applies engine compensation) */\nexport function NROUND(ctx: ExecContext, _colorIndex: number): void {\n\tconst value = ctx.stack[--ctx.stackTop];\n\tconst comp = compensate(value, ctx.GS);\n\tctx.stack[ctx.stackTop++] = value + comp;\n}\n",
    "/**\n * Delta instructions\n *\n * These instructions allow fine-tuning of point positions and CVT values\n * at specific pixel-per-em (ppem) sizes. This is useful for fixing\n * rendering issues that only appear at certain sizes.\n */\n\nimport { TouchFlag, type ExecContext } from \"../types.ts\";\nimport { movePoint, touchPoint } from \"./points.ts\";\n\n/**\n * DELTAP1 - Delta exception point (ppem 0-15 + deltaBase)\n */\nexport function DELTAP1(ctx: ExecContext): void {\n\tdeltaPoint(ctx, 0);\n}\n\n/**\n * DELTAP2 - Delta exception point (ppem 16-31 + deltaBase)\n */\nexport function DELTAP2(ctx: ExecContext): void {\n\tdeltaPoint(ctx, 16);\n}\n\n/**\n * DELTAP3 - Delta exception point (ppem 32-47 + deltaBase)\n */\nexport function DELTAP3(ctx: ExecContext): void {\n\tdeltaPoint(ctx, 32);\n}\n\n/**\n * Common logic for DELTAP1/2/3\n */\nfunction deltaPoint(ctx: ExecContext, rangeOffset: number): void {\n\tconst count = ctx.stack[--ctx.stackTop];\n\n\tif (count < 0) {\n\t\tctx.error = `DELTAP: invalid count ${count}`;\n\t\treturn;\n\t}\n\n\tconst zone = ctx.zp0;\n\n\tfor (let i = 0; i < count; i++) {\n\t\t// Per Apple TrueType spec: pop point first, then arg\n\t\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\t\tconst argByte = ctx.stack[--ctx.stackTop];\n\n\t\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\t\tctx.error = `DELTAP: invalid point ${pointIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract ppem delta and magnitude from argByte\n\t\t// High nibble: ppem - deltaBase - rangeOffset\n\t\t// Low nibble: magnitude (0-15, where 0-7 are negative, 8-15 are positive)\n\t\tconst ppemDelta = ((argByte >> 4) & 0x0f) + ctx.GS.deltaBase + rangeOffset;\n\t\tconst magnitude = argByte & 0x0f;\n\n\t\t// Check if we're at the target ppem\n\t\tif (ppemDelta !== ctx.ppem) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Convert magnitude to actual delta value\n\t\tconst deltaStep = 1 << (6 - ctx.GS.deltaShift);\n\t\tlet deltaValue = magnitude - 8;\n\t\tif (deltaValue >= 0) deltaValue += 1;\n\t\tconst delta = deltaValue * deltaStep;\n\n\t\tif (ctx.backwardCompatibility) {\n\t\t\tif (ctx.backwardCompatibility === 0x7) continue;\n\t\t\tif (\n\t\t\t\t!((ctx.isComposite && ctx.GS.freeVector.y !== 0) ||\n\t\t\t\t\t(zone.tags[pointIndex] & TouchFlag.Y))\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmovePoint(ctx, zone, pointIndex, delta);\n\t\ttouchPoint(ctx, zone, pointIndex);\n\t}\n}\n\n/**\n * DELTAC1 - Delta exception CVT (ppem 0-15 + deltaBase)\n */\nexport function DELTAC1(ctx: ExecContext): void {\n\tdeltaCVT(ctx, 0);\n}\n\n/**\n * DELTAC2 - Delta exception CVT (ppem 16-31 + deltaBase)\n */\nexport function DELTAC2(ctx: ExecContext): void {\n\tdeltaCVT(ctx, 16);\n}\n\n/**\n * DELTAC3 - Delta exception CVT (ppem 32-47 + deltaBase)\n */\nexport function DELTAC3(ctx: ExecContext): void {\n\tdeltaCVT(ctx, 32);\n}\n\n/**\n * Common logic for DELTAC1/2/3\n */\nfunction deltaCVT(ctx: ExecContext, rangeOffset: number): void {\n\tconst count = ctx.stack[--ctx.stackTop];\n\n\tif (count < 0) {\n\t\tctx.error = `DELTAC: invalid count ${count}`;\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < count; i++) {\n\t\t// Per Apple TrueType spec: pop CVT index first, then arg\n\t\tconst cvtIndex = ctx.stack[--ctx.stackTop];\n\t\tconst argByte = ctx.stack[--ctx.stackTop];\n\n\t\tif (cvtIndex < 0 || cvtIndex >= ctx.cvtSize) {\n\t\t\tctx.error = `DELTAC: invalid CVT index ${cvtIndex}`;\n\t\t\treturn;\n\t\t}\n\n\t\t// Extract ppem delta and magnitude\n\t\tconst ppemDelta = ((argByte >> 4) & 0x0f) + ctx.GS.deltaBase + rangeOffset;\n\t\tconst magnitude = argByte & 0x0f;\n\n\t\t// Check if we're at the target ppem\n\t\tif (ppemDelta !== ctx.ppem) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Convert magnitude to actual delta value\n\t\tconst deltaStep = 1 << (6 - ctx.GS.deltaShift);\n\t\tlet deltaValue = magnitude - 8;\n\t\tif (deltaValue >= 0) deltaValue += 1;\n\t\tconst delta = deltaValue * deltaStep;\n\n\t\tctx.cvt[cvtIndex] += delta;\n\t}\n}\n",
    "/**\n * Graphics state manipulation instructions\n */\n\nimport { parseSuperRound } from \"../rounding.ts\";\nimport { scaleFUnits } from \"../scale.ts\";\nimport {\n\ttype ExecContext,\n\tCodeRange,\n\tRoundMode,\n\tTouchFlag,\n\ttype UnitVector,\n} from \"../types.ts\";\n\n// Vector instructions\n\n/** SVTCA - Set vectors to coordinate axis (both projection and freedom) */\nexport function SVTCA(ctx: ExecContext, axis: 0 | 1): void {\n\tif (axis === 0) {\n\t\t// Y axis\n\t\tctx.GS.projVector = { x: 0, y: 0x4000 };\n\t\tctx.GS.freeVector = { x: 0, y: 0x4000 };\n\t\tctx.GS.dualVector = { x: 0, y: 0x4000 };\n\t} else {\n\t\t// X axis\n\t\tctx.GS.projVector = { x: 0x4000, y: 0 };\n\t\tctx.GS.freeVector = { x: 0x4000, y: 0 };\n\t\tctx.GS.dualVector = { x: 0x4000, y: 0 };\n\t}\n}\n\n/** SPVTCA - Set projection vector to coordinate axis */\nexport function SPVTCA(ctx: ExecContext, axis: 0 | 1): void {\n\tif (axis === 0) {\n\t\tctx.GS.projVector = { x: 0, y: 0x4000 };\n\t\tctx.GS.dualVector = { x: 0, y: 0x4000 };\n\t} else {\n\t\tctx.GS.projVector = { x: 0x4000, y: 0 };\n\t\tctx.GS.dualVector = { x: 0x4000, y: 0 };\n\t}\n}\n\n/** SFVTCA - Set freedom vector to coordinate axis */\nexport function SFVTCA(ctx: ExecContext, axis: 0 | 1): void {\n\tif (axis === 0) {\n\t\tctx.GS.freeVector = { x: 0, y: 0x4000 };\n\t} else {\n\t\tctx.GS.freeVector = { x: 0x4000, y: 0 };\n\t}\n}\n\n/** Calculate unit vector from two points */\nfunction vectorFromPoints(\n\tctx: ExecContext,\n\tp1: number,\n\tp2: number,\n\tzone1: number,\n\tzone2: number,\n\tuseOriginal: boolean,\n): { vec: UnitVector; isZero: boolean } {\n\tconst z1 = zone1 === 0 ? ctx.twilight : ctx.pts;\n\tconst z2 = zone2 === 0 ? ctx.twilight : ctx.pts;\n\n\tconst pt1 = useOriginal ? z1.org[p1] : z1.cur[p1];\n\tconst pt2 = useOriginal ? z2.org[p2] : z2.cur[p2];\n\n\tif (!pt1 || !pt2) {\n\t\treturn { vec: { x: 0x4000, y: 0 }, isZero: true };\n\t}\n\n\t// Match FreeType: vector is p1 - p2 (zp1 - zp2).\n\tconst dx = pt1.x - pt2.x;\n\tconst dy = pt1.y - pt2.y;\n\n\tif (dx === 0 && dy === 0) {\n\t\treturn { vec: { x: 0x4000, y: 0 }, isZero: true };\n\t}\n\n\tconst len = Math.sqrt(dx * dx + dy * dy);\n\tif (len === 0) {\n\t\treturn { vec: { x: 0x4000, y: 0 }, isZero: true };\n\t}\n\n\treturn {\n\t\tvec: {\n\t\t\tx: Math.round((dx / len) * 0x4000),\n\t\t\ty: Math.round((dy / len) * 0x4000),\n\t\t},\n\t\tisZero: false,\n\t};\n}\n\n/** SPVTL - Set projection vector to line */\nexport function SPVTL(ctx: ExecContext, perpendicular: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop];\n\tconst p1 = ctx.stack[--ctx.stackTop];\n\n\t// FreeType: args[0] from zp1, args[1] from zp2 -> vector = zp1[p2] - zp2[p1]\n\tconst { vec: proj, isZero } = vectorFromPoints(\n\t\tctx,\n\t\tp2,\n\t\tp1,\n\t\tctx.GS.gep1,\n\t\tctx.GS.gep2,\n\t\tfalse,\n\t);\n\n\tif (perpendicular && !isZero) {\n\t\t// Rotate 90 degrees counter-clockwise: (x, y) -> (-y, x)\n\t\tconst tempProj = proj.x;\n\t\tproj.x = -proj.y;\n\t\tproj.y = tempProj;\n\t}\n\n\tctx.GS.projVector = proj;\n\tctx.GS.dualVector = { ...proj };\n}\n\n/** SFVTL - Set freedom vector to line */\nexport function SFVTL(ctx: ExecContext, perpendicular: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop];\n\tconst p1 = ctx.stack[--ctx.stackTop];\n\n\tconst { vec, isZero } = vectorFromPoints(\n\t\tctx,\n\t\tp2,\n\t\tp1,\n\t\tctx.GS.gep1,\n\t\tctx.GS.gep2,\n\t\tfalse,\n\t);\n\n\tif (perpendicular && !isZero) {\n\t\tconst temp = vec.x;\n\t\tvec.x = -vec.y;\n\t\tvec.y = temp;\n\t}\n\n\tctx.GS.freeVector = vec;\n}\n\n/** SDPVTL - Set dual projection vector to line (only sets dualVector, not projVector) */\nexport function SDPVTL(ctx: ExecContext, perpendicular: boolean): void {\n\tconst p2 = ctx.stack[--ctx.stackTop];\n\tconst p1 = ctx.stack[--ctx.stackTop];\n\n\t// SDPVTL uses original points for dual vector and current points for proj.\n\tconst dual = vectorFromPoints(ctx, p2, p1, ctx.GS.gep1, ctx.GS.gep2, true);\n\tconst proj = vectorFromPoints(ctx, p2, p1, ctx.GS.gep1, ctx.GS.gep2, false);\n\n\tif (perpendicular && !dual.isZero) {\n\t\tconst temp = dual.vec.x;\n\t\tdual.vec.x = -dual.vec.y;\n\t\tdual.vec.y = temp;\n\t}\n\tif (perpendicular && !proj.isZero) {\n\t\tconst temp = proj.vec.x;\n\t\tproj.vec.x = -proj.vec.y;\n\t\tproj.vec.y = temp;\n\t}\n\n\tctx.GS.dualVector = dual.vec;\n\tctx.GS.projVector = proj.vec;\n}\n\n/** SPVFS - Set projection vector from stack */\nexport function SPVFS(ctx: ExecContext): void {\n\tconst y = ctx.stack[--ctx.stackTop];\n\tconst x = ctx.stack[--ctx.stackTop];\n\n\t// Normalize\n\tconst len = Math.sqrt(x * x + y * y);\n\tif (len === 0) {\n\t\tctx.GS.projVector = { x: 0x4000, y: 0 };\n\t} else {\n\t\tctx.GS.projVector = {\n\t\t\tx: Math.round((x / len) * 0x4000),\n\t\t\ty: Math.round((y / len) * 0x4000),\n\t\t};\n\t}\n\tctx.GS.dualVector = { ...ctx.GS.projVector };\n}\n\n/** SFVFS - Set freedom vector from stack */\nexport function SFVFS(ctx: ExecContext): void {\n\tconst y = ctx.stack[--ctx.stackTop];\n\tconst x = ctx.stack[--ctx.stackTop];\n\n\tconst len = Math.sqrt(x * x + y * y);\n\tif (len === 0) {\n\t\tctx.GS.freeVector = { x: 0x4000, y: 0 };\n\t} else {\n\t\tctx.GS.freeVector = {\n\t\t\tx: Math.round((x / len) * 0x4000),\n\t\t\ty: Math.round((y / len) * 0x4000),\n\t\t};\n\t}\n}\n\n/** GPV - Get projection vector */\nexport function GPV(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.GS.projVector.x;\n\tctx.stack[ctx.stackTop++] = ctx.GS.projVector.y;\n}\n\n/** GFV - Get freedom vector */\nexport function GFV(ctx: ExecContext): void {\n\tctx.stack[ctx.stackTop++] = ctx.GS.freeVector.x;\n\tctx.stack[ctx.stackTop++] = ctx.GS.freeVector.y;\n}\n\n/** SFVTPV - Set freedom vector to projection vector */\nexport function SFVTPV(ctx: ExecContext): void {\n\tctx.GS.freeVector = { ...ctx.GS.projVector };\n}\n\n// Reference point instructions\n\n/** SRP0 - Set reference point 0 */\nexport function SRP0(ctx: ExecContext): void {\n\tctx.GS.rp0 = ctx.stack[--ctx.stackTop];\n}\n\n/** SRP1 - Set reference point 1 */\nexport function SRP1(ctx: ExecContext): void {\n\tctx.GS.rp1 = ctx.stack[--ctx.stackTop];\n}\n\n/** SRP2 - Set reference point 2 */\nexport function SRP2(ctx: ExecContext): void {\n\tctx.GS.rp2 = ctx.stack[--ctx.stackTop];\n}\n\n// Zone pointer instructions\n\n/** SZP0 - Set zone pointer 0 */\nexport function SZP0(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop];\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZP0: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep0 = zone;\n\tctx.zp0 = zone === 0 ? ctx.twilight : ctx.pts;\n}\n\n/** SZP1 - Set zone pointer 1 */\nexport function SZP1(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop];\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZP1: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep1 = zone;\n\tctx.zp1 = zone === 0 ? ctx.twilight : ctx.pts;\n}\n\n/** SZP2 - Set zone pointer 2 */\nexport function SZP2(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop];\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZP2: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep2 = zone;\n\tctx.zp2 = zone === 0 ? ctx.twilight : ctx.pts;\n}\n\n/** SZPS - Set all zone pointers */\nexport function SZPS(ctx: ExecContext): void {\n\tconst zone = ctx.stack[--ctx.stackTop];\n\tif (zone !== 0 && zone !== 1) {\n\t\tctx.error = `SZPS: invalid zone ${zone}`;\n\t\treturn;\n\t}\n\tctx.GS.gep0 = zone;\n\tctx.GS.gep1 = zone;\n\tctx.GS.gep2 = zone;\n\tconst z = zone === 0 ? ctx.twilight : ctx.pts;\n\tctx.zp0 = z;\n\tctx.zp1 = z;\n\tctx.zp2 = z;\n}\n\n// Other graphics state\n\n/** SLOOP - Set loop counter */\nexport function SLOOP(ctx: ExecContext): void {\n\tconst count = ctx.stack[--ctx.stackTop];\n\tif (count <= 0) {\n\t\t// Lenient handling: a non-positive loop count disables looping.\n\t\tctx.GS.loop = 0;\n\t\treturn;\n\t}\n\tctx.GS.loop = count;\n}\n\n/** SMD - Set minimum distance */\nexport function SMD(ctx: ExecContext): void {\n\tctx.GS.minimumDistance = ctx.stack[--ctx.stackTop];\n}\n\n/** SCVTCI - Set control value table cut-in */\nexport function SCVTCI(ctx: ExecContext): void {\n\tctx.GS.controlValueCutIn = ctx.stack[--ctx.stackTop];\n}\n\n/** SSWCI - Set single width cut-in */\nexport function SSWCI(ctx: ExecContext): void {\n\tctx.GS.singleWidthCutIn = ctx.stack[--ctx.stackTop];\n}\n\n/** SSW - Set single width value */\nexport function SSW(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop];\n\t// SSW value is in font units; scale to 26.6 pixels like FreeType.\n\tctx.GS.singleWidthValue = scaleFUnits(value, ctx.scaleFix);\n}\n\n/** SDB - Set delta base */\nexport function SDB(ctx: ExecContext): void {\n\tctx.GS.deltaBase = ctx.stack[--ctx.stackTop];\n}\n\n/** SDS - Set delta shift */\nexport function SDS(ctx: ExecContext): void {\n\tctx.GS.deltaShift = ctx.stack[--ctx.stackTop];\n}\n\n// Rounding state\n\n/** RTG - Round to grid */\nexport function RTG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.ToGrid;\n}\n\n/** RTHG - Round to half grid */\nexport function RTHG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.ToHalfGrid;\n}\n\n/** RTDG - Round to double grid */\nexport function RTDG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.ToDoubleGrid;\n}\n\n/** RDTG - Round down to grid */\nexport function RDTG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.DownToGrid;\n}\n\n/** RUTG - Round up to grid */\nexport function RUTG(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.UpToGrid;\n}\n\n/** ROFF - Rounding off */\nexport function ROFF(ctx: ExecContext): void {\n\tctx.GS.roundState = RoundMode.Off;\n}\n\n/** SROUND - Super round */\nexport function SROUND(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop];\n\tparseSuperRound(selector, ctx.GS);\n\tctx.GS.roundState = RoundMode.Super;\n}\n\n/** S45ROUND - Super round 45 degrees */\nexport function S45ROUND(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop];\n\tparseSuperRound(selector, ctx.GS);\n\tctx.GS.roundState = RoundMode.Super45;\n}\n\n// Flip auto-flip\n\n/** FLIPON - Turn auto-flip on */\nexport function FLIPON(ctx: ExecContext): void {\n\tctx.GS.autoFlip = true;\n}\n\n/** FLIPOFF - Turn auto-flip off */\nexport function FLIPOFF(ctx: ExecContext): void {\n\tctx.GS.autoFlip = false;\n}\n\n// Scan and instruction control\n\n/** SCANCTRL - Set scan conversion control */\nexport function SCANCTRL(ctx: ExecContext): void {\n\tctx.GS.scanControl = ctx.stack[--ctx.stackTop];\n}\n\n/** SCANTYPE - Set scan type */\nexport function SCANTYPE(ctx: ExecContext): void {\n\tctx.GS.scanType = ctx.stack[--ctx.stackTop];\n}\n\n/** INSTCTRL - Set instruction control */\nexport function INSTCTRL(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop];\n\tconst value = ctx.stack[--ctx.stackTop];\n\n\t// Bit 0: inhibit grid-fitting\n\t// Bit 1: ignore CVT values\n\tif (selector === 1 || selector === 2 || (selector === 3 && ctx.currentRange === CodeRange.CVT)) {\n\t\tconst flag = 1 << (selector - 1);\n\t\tif (value) {\n\t\t\tctx.GS.instructControl |= flag;\n\t\t} else {\n\t\t\tctx.GS.instructControl &= ~flag;\n\t\t}\n\t}\n\n\t// Bit 2 (selector 3): native ClearType mode toggle for glyph programs.\n\tif (selector === 3 && ctx.currentRange === CodeRange.Glyph && ctx.lightMode) {\n\t\t// Mirror FreeType: value is expected to be 0 or flag (4).\n\t\tctx.backwardCompatibility = (value & 4) ^ 4;\n\t}\n}\n\n/** GETINFO - Get font engine info */\nexport function GETINFO(ctx: ExecContext): void {\n\tconst selector = ctx.stack[--ctx.stackTop];\n\tlet result = 0;\n\tconst mode = ctx.renderMode;\n\tconst isMono = mode === \"mono\";\n\tconst isLcd = mode === \"lcd\";\n\tconst isLcdV = mode === \"lcd_v\";\n\tconst grayscale = ctx.grayscale;\n\tconst subpixelHinting = ctx.lightMode;\n\n\t// Bit 0: version (match FreeType's default interpreter version 40)\n\tif (selector & 1) {\n\t\tresult |= 40;\n\t}\n\n\t// Bit 1: glyph rotated\n\t// Bit 2: glyph stretched\n\n\t// Bit 5: grayscale rendering\n\tif ((selector & 32) && grayscale) {\n\t\tresult |= 1 << 12;\n\t}\n\n\t// Subpixel hinting info is only exposed in v40 mode.\n\tif (subpixelHinting && !isMono) {\n\t\t// Bit 6: subpixel hinting (v40 default)\n\t\tif (selector & 64) {\n\t\t\tresult |= 1 << 13;\n\t\t}\n\n\t\t// Bit 8: vertical LCD subpixels\n\t\tif ((selector & 256) && isLcdV) {\n\t\t\tresult |= 1 << 15;\n\t\t}\n\n\t\t// Bit 10: subpixel positioned (FreeType reports support when queried)\n\t\tif (selector & 1024) {\n\t\t\tresult |= 1 << 17;\n\t\t}\n\n\t\t// Bit 11: symmetrical smoothing\n\t\tif ((selector & 2048) && !isMono) {\n\t\t\tresult |= 1 << 18;\n\t\t}\n\n\t\t// Bit 12: ClearType hinting + grayscale rendering\n\t\tif ((selector & 4096) && !isLcd && !isLcdV) {\n\t\t\tresult |= 1 << 19;\n\t\t}\n\t}\n\n\tctx.stack[ctx.stackTop++] = result;\n}\n\n// Storage and CVT\n\n/** RS - Read storage */\nexport function RS(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index < 0 || index >= ctx.storageSize) {\n\t\tctx.error = `RS: invalid index ${index}`;\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = ctx.storage[index];\n}\n\n/** WS - Write storage */\nexport function WS(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop];\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index < 0 || index >= ctx.storageSize) {\n\t\tctx.error = `WS: invalid index ${index}`;\n\t\treturn;\n\t}\n\tctx.storage[index] = value;\n}\n\n/** RCVT - Read CVT value */\nexport function RCVT(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index < 0 || index >= ctx.cvtSize) {\n\t\tctx.stack[ctx.stackTop++] = 0;\n\t\treturn;\n\t}\n\tctx.stack[ctx.stackTop++] = ctx.cvt[index];\n}\n\n/** WCVTP - Write CVT value in pixels */\nexport function WCVTP(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop];\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index < 0 || index >= ctx.cvtSize) {\n\t\treturn;\n\t}\n\tctx.cvt[index] = value;\n}\n\n/** WCVTF - Write CVT value in font units */\nexport function WCVTF(ctx: ExecContext): void {\n\tconst value = ctx.stack[--ctx.stackTop];\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index < 0 || index >= ctx.cvtSize) {\n\t\treturn;\n\t}\n\t// Convert from font units to pixels (26.6)\n\tctx.cvt[index] = scaleFUnits(value, ctx.scaleFix);\n}\n\n/** UTP - UnTouch Point */\nexport function UTP(ctx: ExecContext): void {\n\tconst pointIndex = ctx.stack[--ctx.stackTop];\n\tconst zone = ctx.zp0;\n\n\tif (pointIndex < 0 || pointIndex >= zone.nPoints) {\n\t\tctx.error = `UTP: invalid point ${pointIndex}`;\n\t\treturn;\n\t}\n\n\t// Clear touch flags based on freedom vector direction\n\tconst fv = ctx.GS.freeVector;\n\tif (fv.y !== 0) {\n\t\tzone.tags[pointIndex] &= ~TouchFlag.Y;\n\t}\n\tif (fv.x !== 0) {\n\t\tzone.tags[pointIndex] &= ~TouchFlag.X;\n\t}\n}\n",
    "/**\n * IUP - Interpolate Untouched Points\n *\n * This instruction interpolates all points that haven't been touched\n * by previous hinting instructions. It's typically called near the end\n * of glyph hinting to smooth out the positions of all remaining points.\n */\n\nimport { divFix, mulFix } from \"../scale.ts\";\nimport { type ExecContext, type GlyphZone, TouchFlag } from \"../types.ts\";\n\n/**\n * Interpolate untouched points in X direction\n */\nexport function IUP_X(ctx: ExecContext): void {\n\tif (ctx.backwardCompatibility) {\n\t\tif (ctx.backwardCompatibility === 0x7) return;\n\t\tctx.backwardCompatibility |= 0x2;\n\t}\n\tinterpolateUntouched(ctx, TouchFlag.X, true);\n}\n\n/**\n * Interpolate untouched points in Y direction\n */\nexport function IUP_Y(ctx: ExecContext): void {\n\tif (ctx.backwardCompatibility) {\n\t\tif (ctx.backwardCompatibility === 0x7) return;\n\t\tctx.backwardCompatibility |= 0x1;\n\t}\n\tinterpolateUntouched(ctx, TouchFlag.Y, false);\n}\n\n/**\n * Core interpolation logic\n */\nfunction interpolateUntouched(\n\tctx: ExecContext,\n\ttouchFlag: TouchFlag,\n\tisX: boolean,\n): void {\n\tconst zone = ctx.pts;\n\tconst nPoints = zone.nPoints;\n\tconst nContours = zone.nContours;\n\n\tif (nPoints === 0 || nContours === 0) return;\n\n\t// Process each contour separately\n\tlet contourStart = 0;\n\n\tfor (let c = 0; c < nContours; c++) {\n\t\tconst contourEnd = zone.contours[c];\n\n\t\t// Find first touched point in this contour\n\t\tlet firstTouched = -1;\n\t\tfor (let i = contourStart; i <= contourEnd; i++) {\n\t\t\tif (zone.tags[i] & touchFlag) {\n\t\t\t\tfirstTouched = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firstTouched < 0) {\n\t\t\t// No touched points in contour, skip\n\t\t\tcontourStart = contourEnd + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Walk through contour interpolating untouched points between touched ones\n\t\tlet prevTouched = firstTouched;\n\t\tlet i = firstTouched + 1;\n\t\tlet wrapped = false;\n\n\t\twhile (true) {\n\t\t\t// Find next touched point\n\t\t\tif (i > contourEnd) {\n\t\t\t\tif (wrapped) break;\n\t\t\t\ti = contourStart;\n\t\t\t\twrapped = true;\n\t\t\t}\n\n\t\t\tif (i === firstTouched && wrapped) {\n\t\t\t\t// Back to start, interpolate remaining points\n\t\t\t\tif (prevTouched !== firstTouched) {\n\t\t\t\t\tinterpolateRange(\n\t\t\t\t\t\tzone,\n\t\t\t\t\t\tprevTouched,\n\t\t\t\t\t\tfirstTouched,\n\t\t\t\t\t\tcontourStart,\n\t\t\t\t\t\tcontourEnd,\n\t\t\t\t\t\tisX,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tshiftContour(zone, contourStart, contourEnd, firstTouched, isX);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (zone.tags[i] & touchFlag) {\n\t\t\t\t// Found touched point - interpolate between prevTouched and i\n\t\t\t\tif (prevTouched !== i) {\n\t\t\t\t\tinterpolateRange(zone, prevTouched, i, contourStart, contourEnd, isX);\n\t\t\t\t}\n\t\t\t\tprevTouched = i;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tcontourStart = contourEnd + 1;\n\t}\n}\n\nfunction shiftContour(\n\tzone: GlyphZone,\n\tstart: number,\n\tend: number,\n\ttouched: number,\n\tisX: boolean,\n): void {\n\tconst orgTouched = isX ? zone.org[touched]?.x : zone.org[touched]?.y;\n\tconst curTouched = isX ? zone.cur[touched]?.x : zone.cur[touched]?.y;\n\tconst delta = curTouched - orgTouched;\n\tif (delta === 0) return;\n\n\tfor (let i = start; i <= end; i++) {\n\t\tif (i === touched) continue;\n\t\tif (isX) {\n\t\t\tzone.cur[i].x += delta;\n\t\t} else {\n\t\t\tzone.cur[i].y += delta;\n\t\t}\n\t}\n}\n\n/**\n * Interpolate points between two touched reference points (FreeType-style)\n */\nfunction interpolateRange(\n\tzone: GlyphZone,\n\tp1: number,\n\tp2: number,\n\tcontourStart: number,\n\tcontourEnd: number,\n\tisX: boolean,\n): void {\n\tlet ref1 = p1;\n\tlet ref2 = p2;\n\n\tlet orus1 = isX ? zone.orus[ref1]?.x : zone.orus[ref1]?.y;\n\tlet orus2 = isX ? zone.orus[ref2]?.x : zone.orus[ref2]?.y;\n\tif (orus1 > orus2) {\n\t\tconst tmpO = orus1;\n\t\torus1 = orus2;\n\t\torus2 = tmpO;\n\t\tconst tmpR = ref1;\n\t\tref1 = ref2;\n\t\tref2 = tmpR;\n\t}\n\n\tconst org1 = isX ? zone.org[ref1]?.x : zone.org[ref1]?.y;\n\tconst org2 = isX ? zone.org[ref2]?.x : zone.org[ref2]?.y;\n\tconst cur1 = isX ? zone.cur[ref1]?.x : zone.cur[ref1]?.y;\n\tconst cur2 = isX ? zone.cur[ref2]?.x : zone.cur[ref2]?.y;\n\tconst delta1 = cur1 - org1;\n\tconst delta2 = cur2 - org2;\n\n\tconst useTrivial = cur1 === cur2 || orus1 === orus2;\n\tconst scale = useTrivial ? 0 : divFix(cur2 - cur1, orus2 - orus1);\n\n\tlet i = p1 + 1;\n\tif (i > contourEnd) i = contourStart;\n\n\twhile (i !== p2) {\n\t\tlet org = isX ? zone.org[i]?.x : zone.org[i]?.y;\n\t\tlet newPos: number;\n\n\t\tif (org <= org1) {\n\t\t\tnewPos = org + delta1;\n\t\t} else if (org >= org2) {\n\t\t\tnewPos = org + delta2;\n\t\t} else if (useTrivial) {\n\t\t\tnewPos = cur1;\n\t\t} else {\n\t\t\tconst orus = isX ? zone.orus[i]?.x : zone.orus[i]?.y;\n\t\t\tnewPos = cur1 + mulFix(orus - orus1, scale);\n\t\t}\n\n\t\tif (isX) {\n\t\t\tzone.cur[i].x = newPos;\n\t\t} else {\n\t\t\tzone.cur[i].y = newPos;\n\t\t}\n\n\t\ti++;\n\t\tif (i > contourEnd) i = contourStart;\n\t}\n}\n",
    "/**\n * Stack manipulation instructions\n */\n\nimport type { ExecContext } from \"../types.ts\";\n\n/** DUP - Duplicate top of stack */\nexport function DUP(ctx: ExecContext): void {\n\tconst val = ctx.stack[ctx.stackTop - 1];\n\tctx.stack[ctx.stackTop++] = val;\n}\n\n/** POP - Pop top of stack */\nexport function POP(ctx: ExecContext): void {\n\tctx.stackTop--;\n}\n\n/** CLEAR - Clear the entire stack */\nexport function CLEAR(ctx: ExecContext): void {\n\tctx.stackTop = 0;\n}\n\n/** SWAP - Swap top two elements */\nexport function SWAP(ctx: ExecContext): void {\n\tconst a = ctx.stack[ctx.stackTop - 1];\n\tconst b = ctx.stack[ctx.stackTop - 2];\n\tctx.stack[ctx.stackTop - 1] = b;\n\tctx.stack[ctx.stackTop - 2] = a;\n}\n\n/** DEPTH - Push stack depth */\nexport function DEPTH(ctx: ExecContext): void {\n\tconst depth = ctx.stackTop;\n\tctx.stack[ctx.stackTop++] = depth;\n}\n\n/** CINDEX - Copy indexed element to top */\nexport function CINDEX(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index <= 0 || index > ctx.stackTop) {\n\t\tctx.error = `CINDEX: invalid index ${index}`;\n\t\treturn;\n\t}\n\tconst val = ctx.stack[ctx.stackTop - index];\n\tctx.stack[ctx.stackTop++] = val;\n}\n\n/** MINDEX - Move indexed element to top */\nexport function MINDEX(ctx: ExecContext): void {\n\tconst index = ctx.stack[--ctx.stackTop];\n\tif (index <= 0 || index > ctx.stackTop) {\n\t\tctx.error = `MINDEX: invalid index ${index}`;\n\t\treturn;\n\t}\n\n\tconst val = ctx.stack[ctx.stackTop - index];\n\n\t// Shift elements down\n\tfor (let i = ctx.stackTop - index; i < ctx.stackTop - 1; i++) {\n\t\tctx.stack[i] = ctx.stack[i + 1];\n\t}\n\n\tctx.stack[ctx.stackTop - 1] = val;\n}\n\n/** ROLL - Roll top three elements */\nexport function ROLL(ctx: ExecContext): void {\n\tconst top = ctx.stack[ctx.stackTop - 1];\n\tconst second = ctx.stack[ctx.stackTop - 2];\n\tconst third = ctx.stack[ctx.stackTop - 3];\n\n\t// TrueType ROLL: (third, second, top) -> (second, top, third)\n\tctx.stack[ctx.stackTop - 3] = second;\n\tctx.stack[ctx.stackTop - 2] = top;\n\tctx.stack[ctx.stackTop - 1] = third;\n}\n\n/** Push byte(s) from instruction stream */\nexport function PUSHB(ctx: ExecContext, count: number): void {\n\tfor (let i = 0; i < count; i++) {\n\t\tctx.stack[ctx.stackTop++] = ctx.code[ctx.IP++];\n\t}\n}\n\n/** Push word(s) from instruction stream */\nexport function PUSHW(ctx: ExecContext, count: number): void {\n\tfor (let i = 0; i < count; i++) {\n\t\tconst hi = ctx.code[ctx.IP++];\n\t\tconst lo = ctx.code[ctx.IP++];\n\t\t// Sign extend\n\t\tlet val = (hi << 8) | lo;\n\t\tif (val >= 0x8000) val -= 0x10000;\n\t\tctx.stack[ctx.stackTop++] = val;\n\t}\n}\n\n/** NPUSHB - Push N bytes */\nexport function NPUSHB(ctx: ExecContext): void {\n\tconst n = ctx.code[ctx.IP++];\n\tPUSHB(ctx, n);\n}\n\n/** NPUSHW - Push N words */\nexport function NPUSHW(ctx: ExecContext): void {\n\tconst n = ctx.code[ctx.IP++];\n\tPUSHW(ctx, n);\n}\n",
    "/**\n * TrueType Bytecode Interpreter\n *\n * Main dispatch loop for executing TrueType hinting instructions.\n */\n\nimport {\n\tABS,\n\tADD,\n\tAND,\n\tCEILING,\n\tDIV,\n\tEQ,\n\tEVEN,\n\tFLOOR,\n\tGT,\n\tGTEQ,\n\tLT,\n\tLTEQ,\n\tMAX,\n\tMIN,\n\tMUL,\n\tNEG,\n\tNEQ,\n\tNOT,\n\tODD,\n\tOR,\n\tSUB,\n} from \"./instructions/arithmetic.ts\";\nimport {\n\tCALL,\n\tEIF,\n\tELSE,\n\tENDF,\n\tFDEF,\n\tIDEF,\n\tIF,\n\tJMPR,\n\tJROF,\n\tJROT,\n\tLOOPCALL,\n} from \"./instructions/control-flow.ts\";\nimport {\n\tDELTAC1,\n\tDELTAC2,\n\tDELTAC3,\n\tDELTAP1,\n\tDELTAP2,\n\tDELTAP3,\n} from \"./instructions/delta.ts\";\nimport {\n\tFLIPOFF,\n\tFLIPON,\n\tGETINFO,\n\tGFV,\n\tGPV,\n\tINSTCTRL,\n\tRCVT,\n\tRDTG,\n\tROFF,\n\tRS,\n\tRTDG,\n\tRTG,\n\tRTHG,\n\tRUTG,\n\tS45ROUND,\n\tSCANCTRL,\n\tSCANTYPE,\n\tSCVTCI,\n\tSDB,\n\tSDPVTL,\n\tSDS,\n\tSFVFS,\n\tSFVTCA,\n\tSFVTL,\n\tSFVTPV,\n\tSLOOP,\n\tSMD,\n\tSPVFS,\n\tSPVTCA,\n\tSPVTL,\n\tSROUND,\n\tSRP0,\n\tSRP1,\n\tSRP2,\n\tSSW,\n\tSSWCI,\n\tSVTCA,\n\tSZP0,\n\tSZP1,\n\tSZP2,\n\tSZPS,\n\tUTP,\n\tWCVTF,\n\tWCVTP,\n\tWS,\n} from \"./instructions/graphics-state.ts\";\nimport { IUP_X, IUP_Y } from \"./instructions/interpolate.ts\";\n\nimport {\n\tALIGNPTS,\n\tALIGNRP,\n\tFLIPPT,\n\tFLIPRGOFF,\n\tFLIPRGON,\n\tGC,\n\tIP,\n\tISECT,\n\tMD,\n\tMDAP,\n\tMDRP,\n\tMIAP,\n\tMIRP,\n\tMPPEM,\n\tMPS,\n\tMSIRP,\n\tNROUND,\n\tROUND,\n\tSCFS,\n\tSHC,\n\tSHP,\n\tSHPIX,\n\tSHZ,\n} from \"./instructions/points.ts\";\n// Import instruction implementations\nimport {\n\tCINDEX,\n\tCLEAR,\n\tDEPTH,\n\tDUP,\n\tMINDEX,\n\tNPUSHB,\n\tNPUSHW,\n\tPOP,\n\tPUSHB,\n\tPUSHW,\n\tROLL,\n\tSWAP,\n} from \"./instructions/stack.ts\";\nimport {\n\tCodeRange,\n\tcreateDefaultGraphicsState,\n\ttype ExecContext,\n\tOpcode,\n} from \"./types.ts\";\n\n/**\n * Execute bytecode from the current instruction pointer\n */\nexport function execute(ctx: ExecContext): void {\n\twhile (ctx.IP < ctx.codeSize && ctx.error === null) {\n\t\t// Check instruction limit\n\t\tif (++ctx.instructionCount > ctx.maxInstructions) {\n\t\t\tctx.error = \"Instruction limit exceeded (possible infinite loop)\";\n\t\t\treturn;\n\t\t}\n\n\t\tconst opcode = ctx.code[ctx.IP++];\n\t\tctx.opcode = opcode;\n\n\t\texecuteOpcode(ctx, opcode);\n\t}\n}\n\n/**\n * Execute a single opcode\n */\nfunction executeOpcode(ctx: ExecContext, opcode: number): void {\n\t// Handle PUSHB[n] (0xB0-0xB7)\n\tif (opcode >= 0xb0 && opcode <= 0xb7) {\n\t\tPUSHB(ctx, opcode - 0xb0 + 1);\n\t\treturn;\n\t}\n\n\t// Handle PUSHW[n] (0xB8-0xBF)\n\tif (opcode >= 0xb8 && opcode <= 0xbf) {\n\t\tPUSHW(ctx, opcode - 0xb8 + 1);\n\t\treturn;\n\t}\n\n\t// Handle MDRP[flags] (0xC0-0xDF)\n\tif (opcode >= 0xc0 && opcode <= 0xdf) {\n\t\tMDRP(ctx, opcode & 0x1f);\n\t\treturn;\n\t}\n\n\t// Handle MIRP[flags] (0xE0-0xFF)\n\tif (opcode >= 0xe0 && opcode <= 0xff) {\n\t\tMIRP(ctx, opcode & 0x1f);\n\t\treturn;\n\t}\n\n\tswitch (opcode) {\n\t\t// Vector setting\n\t\tcase Opcode.SVTCA_Y:\n\t\t\tSVTCA(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.SVTCA_X:\n\t\t\tSVTCA(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTCA_Y:\n\t\t\tSPVTCA(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTCA_X:\n\t\t\tSPVTCA(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTCA_Y:\n\t\t\tSFVTCA(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTCA_X:\n\t\t\tSFVTCA(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTL_0:\n\t\t\tSPVTL(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SPVTL_1:\n\t\t\tSPVTL(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTL_0:\n\t\t\tSFVTL(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTL_1:\n\t\t\tSFVTL(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SDPVTL_0:\n\t\t\tSDPVTL(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SDPVTL_1:\n\t\t\tSDPVTL(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SPVFS:\n\t\t\tSPVFS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SFVFS:\n\t\t\tSFVFS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GPV:\n\t\t\tGPV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GFV:\n\t\t\tGFV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SFVTPV:\n\t\t\tSFVTPV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ISECT:\n\t\t\tISECT(ctx);\n\t\t\tbreak;\n\n\t\t// Reference points\n\t\tcase Opcode.SRP0:\n\t\t\tSRP0(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SRP1:\n\t\t\tSRP1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SRP2:\n\t\t\tSRP2(ctx);\n\t\t\tbreak;\n\n\t\t// Zone pointers\n\t\tcase Opcode.SZP0:\n\t\t\tSZP0(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SZP1:\n\t\t\tSZP1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SZP2:\n\t\t\tSZP2(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SZPS:\n\t\t\tSZPS(ctx);\n\t\t\tbreak;\n\n\t\t// Loop and other GS\n\t\tcase Opcode.SLOOP:\n\t\t\tSLOOP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RTG:\n\t\t\tRTG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RTHG:\n\t\t\tRTHG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SMD:\n\t\t\tSMD(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ELSE:\n\t\t\tELSE(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.JMPR:\n\t\t\tJMPR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SCVTCI:\n\t\t\tSCVTCI(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SSWCI:\n\t\t\tSSWCI(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SSW:\n\t\t\tSSW(ctx);\n\t\t\tbreak;\n\n\t\t// Stack operations\n\t\tcase Opcode.DUP:\n\t\t\tDUP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.POP:\n\t\t\tPOP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CLEAR:\n\t\t\tCLEAR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SWAP:\n\t\t\tSWAP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DEPTH:\n\t\t\tDEPTH(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CINDEX:\n\t\t\tCINDEX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MINDEX:\n\t\t\tMINDEX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ROLL:\n\t\t\tROLL(ctx);\n\t\t\tbreak;\n\n\t\t// Functions\n\t\tcase Opcode.FDEF:\n\t\t\tFDEF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ENDF:\n\t\t\tENDF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CALL:\n\t\t\tCALL(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.LOOPCALL:\n\t\t\tLOOPCALL(ctx);\n\t\t\tbreak;\n\n\t\t// Point movement\n\t\tcase Opcode.MDAP_0:\n\t\t\tMDAP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MDAP_1:\n\t\t\tMDAP(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.IUP_Y:\n\t\t\tIUP_Y(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.IUP_X:\n\t\t\tIUP_X(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SHP_0:\n\t\t\tSHP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SHP_1:\n\t\t\tSHP(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SHC_0:\n\t\t\tSHC(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SHC_1:\n\t\t\tSHC(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SHZ_0:\n\t\t\tSHZ(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.SHZ_1:\n\t\t\tSHZ(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SHPIX:\n\t\t\tSHPIX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.IP:\n\t\t\tIP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MSIRP_0:\n\t\t\tMSIRP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MSIRP_1:\n\t\t\tMSIRP(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.ALIGNRP:\n\t\t\tALIGNRP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ALIGNPTS:\n\t\t\tALIGNPTS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.UTP:\n\t\t\tUTP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RTDG:\n\t\t\tRTDG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MIAP_0:\n\t\t\tMIAP(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MIAP_1:\n\t\t\tMIAP(ctx, true);\n\t\t\tbreak;\n\n\t\t// Push instructions\n\t\tcase Opcode.NPUSHB:\n\t\t\tNPUSHB(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NPUSHW:\n\t\t\tNPUSHW(ctx);\n\t\t\tbreak;\n\n\t\t// Storage\n\t\tcase Opcode.WS:\n\t\t\tWS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RS:\n\t\t\tRS(ctx);\n\t\t\tbreak;\n\n\t\t// CVT\n\t\tcase Opcode.WCVTP:\n\t\t\tWCVTP(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RCVT:\n\t\t\tRCVT(ctx);\n\t\t\tbreak;\n\n\t\t// Point operations\n\t\tcase Opcode.GC_0:\n\t\t\tGC(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.GC_1:\n\t\t\tGC(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.SCFS:\n\t\t\tSCFS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MD_0:\n\t\t\tMD(ctx, true);\n\t\t\tbreak;\n\t\tcase Opcode.MD_1:\n\t\t\tMD(ctx, false);\n\t\t\tbreak;\n\t\tcase Opcode.MPPEM:\n\t\t\tMPPEM(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MPS:\n\t\t\tMPS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPON:\n\t\t\tFLIPON(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPOFF:\n\t\t\tFLIPOFF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DEBUG:\n\t\t\t// DEBUG is a no-op\n\t\t\tbreak;\n\n\t\t// Comparison\n\t\tcase Opcode.LT:\n\t\t\tLT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.LTEQ:\n\t\t\tLTEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GT:\n\t\t\tGT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.GTEQ:\n\t\t\tGTEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.EQ:\n\t\t\tEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NEQ:\n\t\t\tNEQ(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ODD:\n\t\t\tODD(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.EVEN:\n\t\t\tEVEN(ctx);\n\t\t\tbreak;\n\n\t\t// Control flow\n\t\tcase Opcode.IF:\n\t\t\tIF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.EIF:\n\t\t\tEIF(ctx);\n\t\t\tbreak;\n\n\t\t// Logic\n\t\tcase Opcode.AND:\n\t\t\tAND(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.OR:\n\t\t\tOR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NOT:\n\t\t\tNOT(ctx);\n\t\t\tbreak;\n\n\t\t// Delta instructions\n\t\tcase Opcode.DELTAP1:\n\t\t\tDELTAP1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SDB:\n\t\t\tSDB(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SDS:\n\t\t\tSDS(ctx);\n\t\t\tbreak;\n\n\t\t// Arithmetic\n\t\tcase Opcode.ADD:\n\t\t\tADD(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SUB:\n\t\t\tSUB(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DIV:\n\t\t\tDIV(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MUL:\n\t\t\tMUL(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.ABS:\n\t\t\tABS(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.NEG:\n\t\t\tNEG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLOOR:\n\t\t\tFLOOR(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.CEILING:\n\t\t\tCEILING(ctx);\n\t\t\tbreak;\n\n\t\t// Rounding\n\t\tcase Opcode.ROUND_0:\n\t\t\tROUND(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.ROUND_1:\n\t\t\tROUND(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.ROUND_2:\n\t\t\tROUND(ctx, 2);\n\t\t\tbreak;\n\t\tcase Opcode.ROUND_3:\n\t\t\tROUND(ctx, 3);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_0:\n\t\t\tNROUND(ctx, 0);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_1:\n\t\t\tNROUND(ctx, 1);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_2:\n\t\t\tNROUND(ctx, 2);\n\t\t\tbreak;\n\t\tcase Opcode.NROUND_3:\n\t\t\tNROUND(ctx, 3);\n\t\t\tbreak;\n\n\t\t// CVT font units\n\t\tcase Opcode.WCVTF:\n\t\t\tWCVTF(ctx);\n\t\t\tbreak;\n\n\t\t// Delta\n\t\tcase Opcode.DELTAP2:\n\t\t\tDELTAP2(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAP3:\n\t\t\tDELTAP3(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAC1:\n\t\t\tDELTAC1(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAC2:\n\t\t\tDELTAC2(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.DELTAC3:\n\t\t\tDELTAC3(ctx);\n\t\t\tbreak;\n\n\t\t// Super rounding\n\t\tcase Opcode.SROUND:\n\t\t\tSROUND(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.S45ROUND:\n\t\t\tS45ROUND(ctx);\n\t\t\tbreak;\n\n\t\t// Jump\n\t\tcase Opcode.JROT:\n\t\t\tJROT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.JROF:\n\t\t\tJROF(ctx);\n\t\t\tbreak;\n\n\t\t// Rounding modes\n\t\tcase Opcode.ROFF:\n\t\t\tROFF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RUTG:\n\t\t\tRUTG(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.RDTG:\n\t\t\tRDTG(ctx);\n\t\t\tbreak;\n\n\t\t// Other\n\t\tcase Opcode.SANGW:\n\t\t\t// SANGW is deprecated (set angle weight), ignore\n\t\t\tctx.stackTop--;\n\t\t\tbreak;\n\t\tcase Opcode.AA:\n\t\t\t// AA (adjust angle) is deprecated, ignore\n\t\t\tctx.stackTop--;\n\t\t\tbreak;\n\n\t\t// Flip\n\t\tcase Opcode.FLIPPT:\n\t\t\tFLIPPT(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPRGON:\n\t\t\tFLIPRGON(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.FLIPRGOFF:\n\t\t\tFLIPRGOFF(ctx);\n\t\t\tbreak;\n\n\t\t// Scan\n\t\tcase Opcode.SCANCTRL:\n\t\t\tSCANCTRL(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.SCANTYPE:\n\t\t\tSCANTYPE(ctx);\n\t\t\tbreak;\n\n\t\t// Min/Max\n\t\tcase Opcode.MAX:\n\t\t\tMAX(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.MIN:\n\t\t\tMIN(ctx);\n\t\t\tbreak;\n\n\t\t// Getinfo and instctrl\n\t\tcase Opcode.GETINFO:\n\t\t\tGETINFO(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.IDEF:\n\t\t\tIDEF(ctx);\n\t\t\tbreak;\n\t\tcase Opcode.INSTCTRL:\n\t\t\tINSTCTRL(ctx);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// Check for user-defined instruction\n\t\t\tif (opcode < ctx.maxIDefs && ctx.IDefs[opcode]?.active) {\n\t\t\t\tconst def = ctx.IDefs[opcode];\n\n\t\t\t\tif (ctx.callStackTop >= ctx.maxCallStack) {\n\t\t\t\t\tctx.error = \"IDEF call: call stack overflow\";\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Push call record\n\t\t\t\tconst call = ctx.callStack[ctx.callStackTop++];\n\t\t\t\tcall.callerIP = ctx.IP;\n\t\t\t\tcall.callerRange = ctx.currentRange;\n\t\t\t\tcall.def = {\n\t\t\t\t\tid: opcode,\n\t\t\t\t\tstart: def.start,\n\t\t\t\t\tend: def.end,\n\t\t\t\t\tactive: true,\n\t\t\t\t\trange: def.range,\n\t\t\t\t};\n\t\t\t\tcall.count = 1;\n\n\t\t\t\t// Switch to IDEF's code range\n\t\t\t\tctx.currentRange = def.range;\n\t\t\t\tconst range = ctx.codeRanges.get(ctx.currentRange);\n\t\t\t\tif (range) {\n\t\t\t\t\tctx.code = range.code;\n\t\t\t\t\tctx.codeSize = range.size;\n\t\t\t\t}\n\t\t\t\tctx.IP = def.start;\n\t\t\t} else {\n\t\t\t\tctx.error = `Unknown opcode 0x${opcode.toString(16)}`;\n\t\t\t}\n\t}\n}\n\n/**\n * Set up execution context with code range\n */\nexport function setCodeRange(\n\tctx: ExecContext,\n\trange: CodeRange,\n\tcode: Uint8Array,\n): void {\n\tctx.codeRanges.set(range, { code, size: code.length });\n}\n\n/**\n * Run code in a specific range\n */\nexport function runProgram(ctx: ExecContext, range: CodeRange): void {\n\tconst codeRange = ctx.codeRanges.get(range);\n\tif (!codeRange) {\n\t\treturn;\n\t}\n\n\t// Reset stack and call stack for each program execution\n\tctx.stackTop = 0;\n\tctx.callStackTop = 0;\n\n\tctx.currentRange = range;\n\tctx.code = codeRange.code;\n\tctx.codeSize = codeRange.size;\n\tctx.IP = 0;\n\tctx.instructionCount = 0;\n\n\texecute(ctx);\n}\n\n/**\n * Run the font program (fpgm table)\n */\nexport function runFontProgram(ctx: ExecContext): void {\n\t// FPGM operates in the twilight zone.\n\tctx.backwardCompatibility = 0;\n\tctx.twilight.nPoints = ctx.twilight.org.length;\n\tfor (let i = 0; i < ctx.twilight.nPoints; i++) {\n\t\tctx.twilight.org[i].x = 0;\n\t\tctx.twilight.org[i].y = 0;\n\t\tctx.twilight.cur[i].x = 0;\n\t\tctx.twilight.cur[i].y = 0;\n\t\tctx.twilight.tags[i] = 0;\n\t}\n\tctx.zp0 = ctx.twilight;\n\tctx.zp1 = ctx.twilight;\n\tctx.zp2 = ctx.twilight;\n\tctx.GS.gep0 = 0;\n\tctx.GS.gep1 = 0;\n\tctx.GS.gep2 = 0;\n\trunProgram(ctx, CodeRange.Font);\n}\n\n/**\n * Run the CVT program (prep table)\n */\nexport function runCVTProgram(ctx: ExecContext): void {\n\t// Reset graphics state to default before prep\n\tctx.GS = { ...ctx.defaultGS };\n\t// CVT program always runs without backward compatibility hacks.\n\tctx.backwardCompatibility = 0;\n\t// PREP operates in the twilight zone.\n\tctx.twilight.nPoints = ctx.twilight.org.length;\n\tfor (let i = 0; i < ctx.twilight.nPoints; i++) {\n\t\tctx.twilight.org[i].x = 0;\n\t\tctx.twilight.org[i].y = 0;\n\t\tctx.twilight.cur[i].x = 0;\n\t\tctx.twilight.cur[i].y = 0;\n\t\tctx.twilight.tags[i] = 0;\n\t}\n\tctx.zp0 = ctx.twilight;\n\tctx.zp1 = ctx.twilight;\n\tctx.zp2 = ctx.twilight;\n\tctx.GS.gep0 = 0;\n\tctx.GS.gep1 = 0;\n\tctx.GS.gep2 = 0;\n\trunProgram(ctx, CodeRange.CVT);\n\t// Save modified GS as new default for glyphs, but reset non-persistent state.\n\tctx.defaultGS = { ...ctx.GS };\n\tctx.defaultGS.projVector = { x: 0x4000, y: 0 };\n\tctx.defaultGS.freeVector = { x: 0x4000, y: 0 };\n\tctx.defaultGS.dualVector = { x: 0x4000, y: 0 };\n\tctx.defaultGS.rp0 = 0;\n\tctx.defaultGS.rp1 = 0;\n\tctx.defaultGS.rp2 = 0;\n\tctx.defaultGS.loop = 1;\n\tctx.defaultGS.gep0 = 1;\n\tctx.defaultGS.gep1 = 1;\n\tctx.defaultGS.gep2 = 1;\n}\n\n/**\n * Run glyph instructions\n */\nexport function runGlyphProgram(\n\tctx: ExecContext,\n\tinstructions: Uint8Array,\n): void {\n\t// Reset graphics state to default\n\tctx.GS = { ...ctx.defaultGS };\n\t// Reset per-glyph state\n\tctx.GS.rp0 = 0;\n\tctx.GS.rp1 = 0;\n\tctx.GS.rp2 = 0;\n\tctx.GS.loop = 1;\n\n\t// Set up glyph zone pointers\n\tctx.zp0 = ctx.pts;\n\tctx.zp1 = ctx.pts;\n\tctx.zp2 = ctx.pts;\n\tctx.GS.gep0 = 1;\n\tctx.GS.gep1 = 1;\n\tctx.GS.gep2 = 1;\n\n\t// Set up glyph code range\n\tsetCodeRange(ctx, CodeRange.Glyph, instructions);\n\trunProgram(ctx, CodeRange.Glyph);\n}\n",
    "/**\n * TrueType Hinting Program Execution\n *\n * This module handles the setup and execution of TrueType hinting programs:\n * - fpgm: Font program (executed once when font is loaded)\n * - prep: CVT program (executed when size changes)\n * - glyph: Per-glyph instructions\n */\n\nimport {\n\trunCVTProgram,\n\trunFontProgram,\n\trunGlyphProgram,\n\tsetCodeRange,\n} from \"./interpreter.ts\";\nimport { roundToGrid } from \"./rounding.ts\";\nimport { scaleFUnits } from \"./scale.ts\";\nimport {\n\tCodeRange,\n\tcreateExecContext,\n\tcreateGlyphZone,\n\ttype ExecContext,\n} from \"./types.ts\";\n\n/**\n * Hinting engine for a font\n */\nexport interface HintingEngine {\n\t/** Execution context */\n\tctx: ExecContext;\n\t/** Units per EM from font */\n\tunitsPerEM: number;\n\t/** Original CVT values in font units */\n\tcvtOriginal?: Int32Array;\n\t/** Scaled CVT baseline after prep */\n\tcvtBase?: Int32Array;\n\t/** Has fpgm been executed */\n\tfpgmExecuted: boolean;\n\t/** Current ppem (prep needs re-run if this changes) */\n\tcurrentPpem: number;\n}\n\n/**\n * Create a hinting engine for a font\n */\nexport function createHintingEngine(\n\tunitsPerEM: number,\n\tmaxStack: number = 256,\n\tmaxStorage: number = 64,\n\tmaxFDefs: number = 64,\n\tmaxTwilightPoints: number = 16,\n\tcvtValues?: Int32Array,\n): HintingEngine {\n\tconst ctx = createExecContext(\n\t\tmaxStack,\n\t\tmaxStorage,\n\t\tmaxFDefs,\n\t\tmaxFDefs, // maxIDefs\n\t\t32, // maxCallStack\n\t\tmaxTwilightPoints,\n\t);\n\n\tlet cvtOriginal: Int32Array | undefined;\n\n\t// Initialize CVT if provided\n\tif (cvtValues) {\n\t\tcvtOriginal = new Int32Array(cvtValues);\n\t\tctx.cvt = new Int32Array(cvtValues);\n\t\tctx.cvtSize = cvtValues.length;\n\t}\n\n\t// Initialize twilight zone with all points available\n\t// Required for fpgm/prep execution that references twilight points\n\tctx.twilight.nPoints = maxTwilightPoints;\n\n\t// Set zone pointers to twilight zone for fpgm/prep execution\n\t// These will be redirected to glyph zone during hintGlyph\n\tctx.zp0 = ctx.twilight;\n\tctx.zp1 = ctx.twilight;\n\tctx.zp2 = ctx.twilight;\n\n\treturn {\n\t\tctx,\n\t\tunitsPerEM,\n\t\tcvtOriginal,\n\t\tfpgmExecuted: false,\n\t\tcurrentPpem: 0,\n\t};\n}\n\n/**\n * Load font program (fpgm table)\n */\nexport function loadFontProgram(engine: HintingEngine, fpgm: Uint8Array): void {\n\tsetCodeRange(engine.ctx, CodeRange.Font, fpgm);\n}\n\n/**\n * Load CVT program (prep table)\n */\nexport function loadCVTProgram(engine: HintingEngine, prep: Uint8Array): void {\n\tsetCodeRange(engine.ctx, CodeRange.CVT, prep);\n}\n\n/**\n * Execute fpgm (should be called once after font load)\n */\nexport function executeFontProgram(engine: HintingEngine): string | null {\n\tif (engine.fpgmExecuted) return null;\n\n\tengine.ctx.error = null;\n\trunFontProgram(engine.ctx);\n\tengine.fpgmExecuted = true;\n\n\treturn engine.ctx.error;\n}\n\n/**\n * Set up for a specific size and execute prep if needed\n */\nexport function setSize(\n\tengine: HintingEngine,\n\tppem: number,\n\tpointSize: number,\n): string | null {\n\t// Always run fpgm first if not done\n\tif (!engine.fpgmExecuted) {\n\t\tconst fpgmError = executeFontProgram(engine);\n\t\tif (fpgmError) return fpgmError;\n\t}\n\n\t// Skip prep if size hasn't changed\n\tif (engine.currentPpem === ppem) return null;\n\n\t// Calculate scale factor: font units to 26.6 pixels\n\t// scale = ppem / unitsPerEM * 64 (for 26.6 format)\n\tengine.ctx.scale = (ppem * 64) / engine.unitsPerEM;\n\tengine.ctx.scaleFix = Math.round(engine.ctx.scale * 0x10000);\n\tengine.ctx.ppem = ppem;\n\tengine.ctx.pointSize = pointSize * 64;\n\tengine.ctx.grayscale =\n\t\tengine.ctx.renderMode !== \"mono\" && !engine.ctx.lightMode;\n\n\t// Scale CVT values from font units to pixels\n\tscaleCVT(engine.ctx, engine.cvtOriginal);\n\n\t// Run prep program\n\tengine.ctx.error = null;\n\trunCVTProgram(engine.ctx);\n\tengine.currentPpem = ppem;\n\tengine.cvtBase = new Int32Array(engine.ctx.cvt);\n\n\treturn engine.ctx.error;\n}\n\n/**\n * Scale CVT values from font units to 26.6 pixels\n */\nfunction scaleCVT(ctx: ExecContext, original?: Int32Array): void {\n\tif (!original) {\n\t\tfor (let i = 0; i < ctx.cvtSize; i++) {\n\t\t\tctx.cvt[i] = scaleFUnits(ctx.cvt[i], ctx.scaleFix);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (let i = 0; i < ctx.cvtSize; i++) {\n\t\tctx.cvt[i] = scaleFUnits(original[i]!, ctx.scaleFix);\n\t}\n}\n\n/**\n * Glyph outline for hinting\n */\nexport interface GlyphOutline {\n\t/** X coordinates in font units */\n\txCoords: number[];\n\t/** Y coordinates in font units */\n\tyCoords: number[];\n\t/** Point flags (bit 0 = on-curve) */\n\tflags: Uint8Array;\n\t/** End point indices for each contour */\n\tcontourEnds: number[];\n\t/** Glyph instructions */\n\tinstructions: Uint8Array;\n\t/** Left side bearing in font units (for phantom point) */\n\tlsb?: number;\n\t/** Advance width in font units (for phantom point) */\n\tadvanceWidth?: number;\n\t/** Top side bearing in font units (for vertical phantom point) */\n\ttsb?: number;\n\t/** Advance height in font units (for vertical phantom point) */\n\tadvanceHeight?: number;\n\t/** True if glyph is composite */\n\tisComposite?: boolean;\n}\n\n/**\n * Hinted glyph result\n */\nexport interface HintedGlyph {\n\t/** Hinted X coordinates in 26.6 pixels */\n\txCoords: number[];\n\t/** Hinted Y coordinates in 26.6 pixels */\n\tyCoords: number[];\n\t/** Point flags */\n\tflags: Uint8Array;\n\t/** Contour end indices */\n\tcontourEnds: number[];\n\t/** Error message if hinting failed */\n\terror: string | null;\n}\n\n/**\n * Hint a glyph\n */\nexport function hintGlyph(\n\tengine: HintingEngine,\n\toutline: GlyphOutline,\n): HintedGlyph {\n\tconst ctx = engine.ctx;\n\tconst nPoints = outline.xCoords.length;\n\tconst nContours = outline.contourEnds.length;\n\n\t// Add phantom points (4 points after glyph points)\n\tconst totalPoints = nPoints + 4;\n\n\t// Set up glyph zone\n\tconst zone = createGlyphZone(totalPoints, nContours);\n\tzone.nPoints = totalPoints;\n\tzone.nContours = nContours;\n\n\t// Scale and copy point coordinates\n\tfor (let i = 0; i < nPoints; i++) {\n\t\tconst x = scaleFUnits(outline.xCoords[i], ctx.scaleFix);\n\t\tconst y = scaleFUnits(outline.yCoords[i], ctx.scaleFix);\n\n\t\tzone.org[i].x = x;\n\t\tzone.org[i].y = y;\n\t\tzone.cur[i].x = x;\n\t\tzone.cur[i].y = y;\n\t\tzone.orus[i].x = outline.xCoords[i];\n\t\tzone.orus[i].y = outline.yCoords[i];\n\t\tzone.tags[i] = outline.flags[i];\n\t}\n\n\t// Set up phantom points (for horizontal/vertical metrics)\n\t// Point n: origin (xMin - lsb, 0)\n\t// Point n+1: advance width point (origin.x + advanceWidth, 0)\n\t// Point n+2: top origin (0, yMax + tsb) - for vertical\n\t// Point n+3: bottom point (0, top - advanceHeight) - for vertical\n\n\t// Calculate xMin from outline for phantom point positioning\n\tlet xMin = Infinity;\n\tfor (let i = 0; i < nPoints; i++) {\n\t\tif (outline.xCoords[i] < xMin) xMin = outline.xCoords[i];\n\t}\n\tif (!Number.isFinite(xMin)) xMin = 0;\n\n\tconst lsb = outline.lsb ?? 0;\n\tconst advW = outline.advanceWidth ?? 0;\n\n\t// Phantom point 0: horizontal origin\n\tconst pp0x = scaleFUnits(xMin - lsb, ctx.scaleFix);\n\tzone.org[nPoints].x = pp0x;\n\tzone.org[nPoints].y = 0;\n\tzone.cur[nPoints].x = pp0x;\n\tzone.cur[nPoints].y = 0;\n\tzone.orus[nPoints].x = xMin - lsb;\n\tzone.orus[nPoints].y = 0;\n\tzone.tags[nPoints] = 0;\n\n\t// Phantom point 1: advance width\n\tconst pp1x = scaleFUnits(xMin - lsb + advW, ctx.scaleFix);\n\tzone.org[nPoints + 1].x = pp1x;\n\tzone.org[nPoints + 1].y = 0;\n\tzone.cur[nPoints + 1].x = pp1x;\n\tzone.cur[nPoints + 1].y = 0;\n\tzone.orus[nPoints + 1].x = xMin - lsb + advW;\n\tzone.orus[nPoints + 1].y = 0;\n\tzone.tags[nPoints + 1] = 0;\n\n\t// Phantom points 2 & 3: vertical metrics (simplified - set to 0)\n\tfor (let i = nPoints + 2; i < totalPoints; i++) {\n\t\tzone.org[i].x = 0;\n\t\tzone.org[i].y = 0;\n\t\tzone.cur[i].x = 0;\n\t\tzone.cur[i].y = 0;\n\t\tzone.orus[i].x = 0;\n\t\tzone.orus[i].y = 0;\n\t\tzone.tags[i] = 0;\n\t}\n\n\t// Round phantom points to grid (matches FreeType behavior).\n\tzone.cur[nPoints].x = roundToGrid(zone.cur[nPoints].x, 0);\n\tzone.cur[nPoints + 1].x = roundToGrid(zone.cur[nPoints + 1].x, 0);\n\tzone.cur[nPoints + 2].y = roundToGrid(zone.cur[nPoints + 2].y, 0);\n\tzone.cur[nPoints + 3].y = roundToGrid(zone.cur[nPoints + 3].y, 0);\n\n\t// Copy contour ends\n\tfor (let i = 0; i < nContours; i++) {\n\t\tzone.contours[i] = outline.contourEnds[i];\n\t}\n\n\t// Set up context\n\tctx.pts = zone;\n\tctx.zp0 = zone;\n\tctx.zp1 = zone;\n\tctx.zp2 = zone;\n\n\t// Reset twilight zone\n\tctx.twilight.nPoints = ctx.twilight.org.length;\n\tfor (let i = 0; i < ctx.twilight.nPoints; i++) {\n\t\tctx.twilight.org[i].x = 0;\n\t\tctx.twilight.org[i].y = 0;\n\t\tctx.twilight.cur[i].x = 0;\n\t\tctx.twilight.cur[i].y = 0;\n\t\tctx.twilight.tags[i] = 0;\n\t}\n\n\t// Run glyph instructions\n\tctx.isComposite = outline.isComposite ?? false;\n\tctx.backwardCompatibility = ctx.lightMode ? 0x4 : 0;\n\tif (engine.cvtBase) {\n\t\tctx.cvt.set(engine.cvtBase);\n\t}\n\tctx.error = null;\n\tif ((ctx.GS.instructControl & 1) !== 0) {\n\t\t// INSTCTRL bit 0: inhibit grid-fitting (skip glyph instructions).\n\t} else if (outline.instructions.length > 0) {\n\t\trunGlyphProgram(ctx, outline.instructions);\n\t}\n\n\t// Extract results\n\tconst xCoords = new Array<number>(nPoints);\n\tconst yCoords = new Array<number>(nPoints);\n\n\tfor (let i = 0; i < nPoints; i++) {\n\t\txCoords[i] = zone.cur[i]?.x;\n\t\tyCoords[i] = zone.cur[i]?.y;\n\t}\n\n\treturn {\n\t\txCoords,\n\t\tyCoords,\n\t\tflags: outline.flags,\n\t\tcontourEnds: outline.contourEnds,\n\t\terror: ctx.error,\n\t};\n}\n\n/**\n * Convert hinted coordinates from 26.6 to floating point pixels\n */\nexport function hintedToPixels(coords: number[]): number[] {\n\treturn coords.map((c) => c / 64);\n}\n",
    "// OpenType primitive types\nexport type uint8 = number;\nexport type int8 = number;\nexport type uint16 = number;\nexport type int16 = number;\nexport type uint32 = number;\nexport type int32 = number;\nexport type Fixed = number; // 16.16 fixed-point\nexport type F2Dot14 = number; // 2.14 fixed-point\nexport type FWord = number; // int16 in font units\nexport type UFWord = number; // uint16 in font units\nexport type Offset16 = number;\nexport type Offset32 = number;\nexport type GlyphId = number;\n\n/** 4-character ASCII tag (packed as uint32 for efficiency) */\nexport type Tag = number;\n\n/** Text direction */\nexport enum Direction {\n\tInvalid = 0,\n\tLTR = 4,\n\tRTL = 5,\n\tTTB = 6,\n\tBTT = 7,\n}\n\n/** Cluster level for glyph-character mapping */\nexport enum ClusterLevel {\n\tMonotoneGraphemes = 0,\n\tMonotoneCharacters = 1,\n\tCharacters = 2,\n}\n\n/** Buffer flags */\nexport enum BufferFlags {\n\tDefault = 0x0,\n\tBeginningOfText = 0x1,\n\tEndOfText = 0x2,\n\tPreserveDefaultIgnorables = 0x4,\n\tRemoveDefaultIgnorables = 0x8,\n\tDoNotInsertDottedCircle = 0x10,\n}\n\n/** Glyph classification from GDEF */\nexport enum GlyphClass {\n\tBase = 1,\n\tLigature = 2,\n\tMark = 3,\n\tComponent = 4,\n}\n\n/** Feature specification for shaping */\nexport interface Feature {\n\ttag: Tag;\n\tvalue: number;\n\tstart: number;\n\tend: number;\n}\n\n/** Variation axis value */\nexport interface Variation {\n\ttag: Tag;\n\tvalue: number;\n}\n\n/** Glyph info during shaping */\nexport interface GlyphInfo {\n\tglyphId: GlyphId;\n\tcluster: number;\n\tmask: number;\n\t/** Unicode codepoint (before shaping) */\n\tcodepoint: number;\n}\n\n/** Glyph position after shaping */\nexport interface GlyphPosition {\n\txAdvance: number;\n\tyAdvance: number;\n\txOffset: number;\n\tyOffset: number;\n}\n\n/** Table record from font directory */\nexport interface TableRecord {\n\ttag: Tag;\n\tchecksum: uint32;\n\toffset: Offset32;\n\tlength: uint32;\n}\n\n/** Lookup flags for controlling glyph matching */\nexport interface LookupFlags {\n\trightToLeft: boolean;\n\tignoreBaseGlyphs: boolean;\n\tignoreLigatures: boolean;\n\tignoreMarks: boolean;\n\tuseMarkFilteringSet: boolean;\n\tmarkAttachmentType: number;\n\tmarkFilteringSet?: number;\n}\n\n// Tag utilities\nexport function tag(str: string): Tag {\n\tif (str.length !== 4) {\n\t\tthrow new Error(`Tag must be exactly 4 characters: \"${str}\"`);\n\t}\n\treturn (\n\t\t(str.charCodeAt(0) << 24) |\n\t\t(str.charCodeAt(1) << 16) |\n\t\t(str.charCodeAt(2) << 8) |\n\t\tstr.charCodeAt(3)\n\t);\n}\n\nexport function tagToString(t: Tag): string {\n\treturn String.fromCharCode(\n\t\t(t >> 24) & 0xff,\n\t\t(t >> 16) & 0xff,\n\t\t(t >> 8) & 0xff,\n\t\tt & 0xff,\n\t);\n}\n\n// Common tags\nexport const Tags = {\n\t// Required tables\n\thead: tag(\"head\"),\n\thhea: tag(\"hhea\"),\n\thmtx: tag(\"hmtx\"),\n\tmaxp: tag(\"maxp\"),\n\tcmap: tag(\"cmap\"),\n\tloca: tag(\"loca\"),\n\tglyf: tag(\"glyf\"),\n\tname: tag(\"name\"),\n\tOS2: tag(\"OS/2\"),\n\tpost: tag(\"post\"),\n\n\t// OpenType layout\n\tGDEF: tag(\"GDEF\"),\n\tGSUB: tag(\"GSUB\"),\n\tGPOS: tag(\"GPOS\"),\n\tBASE: tag(\"BASE\"),\n\tJSTF: tag(\"JSTF\"),\n\tMATH: tag(\"MATH\"),\n\n\t// CFF\n\tCFF: tag(\"CFF \"),\n\tCFF2: tag(\"CFF2\"),\n\n\t// Variable fonts\n\tfvar: tag(\"fvar\"),\n\tgvar: tag(\"gvar\"),\n\tavar: tag(\"avar\"),\n\tHVAR: tag(\"HVAR\"),\n\tVVAR: tag(\"VVAR\"),\n\tMVAR: tag(\"MVAR\"),\n\n\t// AAT\n\tmorx: tag(\"morx\"),\n\tkerx: tag(\"kerx\"),\n\tkern: tag(\"kern\"),\n\ttrak: tag(\"trak\"),\n\tfeat: tag(\"feat\"),\n\n\t// Color\n\tCOLR: tag(\"COLR\"),\n\tCPAL: tag(\"CPAL\"),\n\tSVG: tag(\"SVG \"),\n\tsbix: tag(\"sbix\"),\n\tCBDT: tag(\"CBDT\"),\n\tCBLC: tag(\"CBLC\"),\n\n\t// Style Attributes\n\tSTAT: tag(\"STAT\"),\n\n\t// Vertical\n\tvhea: tag(\"vhea\"),\n\tvmtx: tag(\"vmtx\"),\n\tVORG: tag(\"VORG\"),\n\n\t// Hinting\n\tfpgm: tag(\"fpgm\"),\n\tprep: tag(\"prep\"),\n\tcvt: tag(\"cvt \"),\n\tgasp: tag(\"gasp\"),\n} as const;\n\n// Feature tags\nexport const FeatureTags = {\n\t// GSUB\n\tccmp: tag(\"ccmp\"),\n\tlocl: tag(\"locl\"),\n\trlig: tag(\"rlig\"),\n\tliga: tag(\"liga\"),\n\tclig: tag(\"clig\"),\n\tcalt: tag(\"calt\"),\n\trclt: tag(\"rclt\"),\n\tdlig: tag(\"dlig\"),\n\tsmcp: tag(\"smcp\"),\n\tc2sc: tag(\"c2sc\"),\n\n\t// Arabic\n\tisol: tag(\"isol\"),\n\tinit: tag(\"init\"),\n\tmedi: tag(\"medi\"),\n\tfina: tag(\"fina\"),\n\n\t// GPOS\n\tkern: tag(\"kern\"),\n\tmark: tag(\"mark\"),\n\tmkmk: tag(\"mkmk\"),\n\tcurs: tag(\"curs\"),\n\tdist: tag(\"dist\"),\n} as const;\n",
    "import type { Font } from \"../font/font.ts\";\nimport {\n\tDirection,\n\ttype GlyphId,\n\ttype GlyphInfo,\n\ttype GlyphPosition,\n} from \"../types.ts\";\n\n/**\n * Output buffer containing shaped glyphs.\n * Result of the shaping process.\n */\nexport class GlyphBuffer {\n\t/** Direction used during shaping */\n\tdirection: Direction = Direction.LTR;\n\n\t/** Script used during shaping */\n\tscript: string = \"Zyyy\";\n\n\t/** Language used during shaping */\n\tlanguage: string | null = null;\n\n\t/** Glyph information array */\n\tinfos: GlyphInfo[] = [];\n\n\t/** Glyph position array */\n\tpositions: GlyphPosition[] = [];\n\n\t/** Deleted glyph markers for deferred removal */\n\tprivate _deleted: Uint8Array | null = null;\n\n\t/** Count of deleted glyphs pending compaction */\n\tprivate _deletedCount = 0;\n\n\t/** Pre-allocated info pool for reuse */\n\tprivate _infoPool: GlyphInfo[] = [];\n\t/** Pre-allocated position pool for reuse */\n\tprivate _posPool: GlyphPosition[] = [];\n\t/** Pre-allocated capacity hint */\n\tprivate _capacity = 0;\n\n\t/** Create buffer with pre-allocated capacity (lazy object creation) */\n\tstatic withCapacity(capacity: number): GlyphBuffer {\n\t\tconst buffer = new GlyphBuffer();\n\t\t// Pre-allocate arrays but NOT the objects inside them\n\t\t// Objects are created lazily in initFromCodepointsWithFont\n\t\tbuffer._capacity = capacity;\n\t\treturn buffer;\n\t}\n\n\t/** Number of glyphs */\n\tget length(): number {\n\t\treturn this.infos.length;\n\t}\n\n\t/** Reset buffer for reuse - reuses existing object pool */\n\treset(): void {\n\t\tthis.infos.length = 0;\n\t\tthis.positions.length = 0;\n\t\tthis._deleted = null;\n\t\tthis._deletedCount = 0;\n\t}\n\n\t/** Initialize from codepoints, reusing pooled objects when possible */\n\tinitFromCodepoints(\n\t\tcodepoints: ArrayLike<number>,\n\t\tclusters: ArrayLike<number>,\n\t\tgetGlyphId: (codepoint: number) => number,\n\t): void {\n\t\tconst len = codepoints.length;\n\t\tconst poolLen = this._infoPool.length;\n\n\t\t// Expand pools if needed - batch allocate for efficiency\n\t\tif (poolLen < len) {\n\t\t\t// Pre-allocate to avoid repeated push calls\n\t\t\tconst needed = len - poolLen;\n\t\t\tfor (let i = 0; i < needed; i++) {\n\t\t\t\tthis._infoPool.push({ glyphId: 0, cluster: 0, mask: 0, codepoint: 0 });\n\t\t\t\tthis._posPool.push({\n\t\t\t\t\txAdvance: 0,\n\t\t\t\t\tyAdvance: 0,\n\t\t\t\t\txOffset: 0,\n\t\t\t\t\tyOffset: 0,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Reuse pooled objects\n\t\tthis.infos.length = len;\n\t\tthis.positions.length = len;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst codepoint = codepoints[i]!;\n\t\t\tconst info = this._infoPool[i]!;\n\t\t\tinfo.glyphId = getGlyphId(codepoint);\n\t\t\tinfo.cluster = clusters[i]!;\n\t\t\tinfo.mask = 0xffffffff;\n\t\t\tinfo.codepoint = codepoint;\n\t\t\tthis.infos[i] = info;\n\n\t\t\tconst pos = this._posPool[i]!;\n\t\t\tpos.xAdvance = 0;\n\t\t\tpos.yAdvance = 0;\n\t\t\tpos.xOffset = 0;\n\t\t\tpos.yOffset = 0;\n\t\t\tthis.positions[i] = pos;\n\t\t}\n\n\t\tthis._deleted = null;\n\t\tthis._deletedCount = 0;\n\t}\n\n\t/**\n\t * Initialize from codepoints with direct font access (no closure).\n\t * This is faster than initFromCodepoints for hot paths.\n\t */\n\tinitFromCodepointsWithFont(\n\t\tcodepoints: ArrayLike<number>,\n\t\tclusters: ArrayLike<number>,\n\t\tfont: Font,\n\t): void {\n\t\tconst len = codepoints.length;\n\t\tconst poolLen = this._infoPool.length;\n\n\t\t// Expand pools if needed - batch allocate for efficiency\n\t\tif (poolLen < len) {\n\t\t\tconst needed = len - poolLen;\n\t\t\tfor (let i = 0; i < needed; i++) {\n\t\t\t\tthis._infoPool.push({ glyphId: 0, cluster: 0, mask: 0, codepoint: 0 });\n\t\t\t\tthis._posPool.push({\n\t\t\t\t\txAdvance: 0,\n\t\t\t\t\tyAdvance: 0,\n\t\t\t\t\txOffset: 0,\n\t\t\t\t\tyOffset: 0,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Reuse pooled objects\n\t\tthis.infos.length = len;\n\t\tthis.positions.length = len;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst codepoint = codepoints[i]!;\n\t\t\tconst info = this._infoPool[i]!;\n\t\t\tinfo.glyphId = font.glyphId(codepoint);\n\t\t\tinfo.cluster = clusters[i]!;\n\t\t\tinfo.mask = 0xffffffff;\n\t\t\tinfo.codepoint = codepoint;\n\t\t\tthis.infos[i] = info;\n\n\t\t\tconst pos = this._posPool[i]!;\n\t\t\tpos.xAdvance = 0;\n\t\t\tpos.yAdvance = 0;\n\t\t\tpos.xOffset = 0;\n\t\t\tpos.yOffset = 0;\n\t\t\tthis.positions[i] = pos;\n\t\t}\n\n\t\tthis._deleted = null;\n\t\tthis._deletedCount = 0;\n\t}\n\n\t/** Initialize from glyph infos (positions zeroed) */\n\tinitFromInfos(infos: GlyphInfo[]): void {\n\t\tthis.infos = infos;\n\t\t// Pre-allocate positions array with exact size (avoid map allocation overhead)\n\t\tconst len = infos.length;\n\t\tconst positions: GlyphPosition[] = new Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tpositions[i] = { xAdvance: 0, yAdvance: 0, xOffset: 0, yOffset: 0 };\n\t\t}\n\t\tthis.positions = positions;\n\t}\n\n\t/** Set advance width for a glyph */\n\tsetAdvance(index: number, xAdvance: number, yAdvance = 0): void {\n\t\tconst pos = this.positions[index];\n\t\tif (pos) {\n\t\t\tpos.xAdvance = xAdvance;\n\t\t\tpos.yAdvance = yAdvance;\n\t\t}\n\t}\n\n\t/** Add offset to a glyph position */\n\taddOffset(index: number, xOffset: number, yOffset: number): void {\n\t\tconst pos = this.positions[index];\n\t\tif (pos) {\n\t\t\tpos.xOffset += xOffset;\n\t\t\tpos.yOffset += yOffset;\n\t\t}\n\t}\n\n\t/** Replace glyph at index */\n\treplaceGlyph(index: number, glyphId: GlyphId): void {\n\t\tconst info = this.infos[index];\n\t\tif (info) {\n\t\t\tinfo.glyphId = glyphId;\n\t\t}\n\t}\n\n\t/** Insert glyph at index */\n\tinsertGlyph(index: number, info: GlyphInfo, position: GlyphPosition): void {\n\t\tthis.infos.splice(index, 0, info);\n\t\tthis.positions.splice(index, 0, position);\n\t\t// Expand deleted array if needed\n\t\tif (this._deleted) {\n\t\t\tconst newDeleted = new Uint8Array(this.infos.length);\n\t\t\t// Copy old values, shifting indices after insertion point\n\t\t\tfor (let i = 0; i < index; i++) {\n\t\t\t\tnewDeleted[i] = this._deleted[i];\n\t\t\t}\n\t\t\tnewDeleted[index] = 0; // New glyph is not deleted\n\t\t\tfor (let i = index; i < this._deleted.length; i++) {\n\t\t\t\tnewDeleted[i + 1] = this._deleted[i];\n\t\t\t}\n\t\t\tthis._deleted = newDeleted;\n\t\t}\n\t}\n\n\t/** Remove glyphs in range [start, end) */\n\tremoveRange(start: number, end: number): void {\n\t\tconst count = end - start;\n\t\tthis.infos.splice(start, count);\n\t\tthis.positions.splice(start, count);\n\t\t// Shrink deleted array if exists\n\t\tif (this._deleted && this._deleted.length > this.infos.length) {\n\t\t\tthis._deleted = this._deleted.slice(0, this.infos.length);\n\t\t}\n\t}\n\n\t/**\n\t * Mark a glyph for deferred deletion. Much faster than removeRange for\n\t * multiple deletions - call compact() once at end of GSUB phase.\n\t */\n\tmarkDeleted(index: number): void {\n\t\tif (!this._deleted) {\n\t\t\tthis._deleted = new Uint8Array(this.infos.length);\n\t\t}\n\t\tif (!this._deleted[index]) {\n\t\t\tthis._deleted[index] = 1;\n\t\t\tthis._deletedCount++;\n\t\t}\n\t}\n\n\t/** Check if a glyph is marked for deletion */\n\tisDeleted(index: number): boolean {\n\t\treturn this._deleted ? this._deleted[index] === 1 : false;\n\t}\n\n\t/** Returns true if there are pending deletions */\n\thasPendingDeletions(): boolean {\n\t\treturn this._deletedCount > 0;\n\t}\n\n\t/**\n\t * Compact buffer by removing all marked-for-deletion glyphs in a single O(n) pass.\n\t * Call this after GSUB phase.\n\t */\n\tcompact(): void {\n\t\tif (this._deletedCount === 0 || !this._deleted) return;\n\n\t\tlet writeIdx = 0;\n\t\tfor (let readIdx = 0; readIdx < this.infos.length; readIdx++) {\n\t\t\tif (!this._deleted[readIdx]) {\n\t\t\t\tif (writeIdx !== readIdx) {\n\t\t\t\t\tthis.infos[writeIdx] = this.infos[readIdx];\n\t\t\t\t\tthis.positions[writeIdx] = this.positions[readIdx];\n\t\t\t\t}\n\t\t\t\twriteIdx++;\n\t\t\t}\n\t\t}\n\n\t\tthis.infos.length = writeIdx;\n\t\tthis.positions.length = writeIdx;\n\t\tthis._deleted = null;\n\t\tthis._deletedCount = 0;\n\t}\n\n\t/** Merge clusters from start to end (inclusive) */\n\tmergeClusters(start: number, end: number): void {\n\t\tif (start >= end || start < 0 || end >= this.infos.length) return;\n\n\t\tconst cluster = this.infos[start]?.cluster;\n\t\tfor (let i = start + 1; i <= end; i++) {\n\t\t\tconst info = this.infos[i];\n\t\t\tif (info) {\n\t\t\t\tinfo.cluster = cluster;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Reverse glyph order (for RTL) */\n\treverse(): void {\n\t\tthis.infos.reverse();\n\t\tthis.positions.reverse();\n\t}\n\n\t/** Reverse range [start, end) */\n\treverseRange(start: number, end: number): void {\n\t\tlet i = start;\n\t\tlet j = end - 1;\n\t\twhile (i < j) {\n\t\t\t// Swap infos\n\t\t\tconst tmpInfo = this.infos[i];\n\t\t\tconst tmpInfoJ = this.infos[j];\n\t\t\tif (!tmpInfo || !tmpInfoJ) break;\n\t\t\tthis.infos[i] = tmpInfoJ;\n\t\t\tthis.infos[j] = tmpInfo;\n\n\t\t\t// Swap positions\n\t\t\tconst tmpPos = this.positions[i];\n\t\t\tconst tmpPosJ = this.positions[j];\n\t\t\tif (!tmpPos || !tmpPosJ) break;\n\t\t\tthis.positions[i] = tmpPosJ;\n\t\t\tthis.positions[j] = tmpPos;\n\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\n\t/** Get total advance width */\n\tgetTotalAdvance(): { x: number; y: number } {\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tconst positions = this.positions;\n\t\tfor (let i = 0; i < positions.length; i++) {\n\t\t\tconst pos = positions[i]!;\n\t\t\tx += pos.xAdvance;\n\t\t\ty += pos.yAdvance;\n\t\t}\n\t\treturn { x, y };\n\t}\n\n\t/** Serialize to HarfBuzz-compatible format */\n\tserialize(): string {\n\t\tconst parts: string[] = [];\n\t\tconst infos = this.infos;\n\t\tconst positions = this.positions;\n\n\t\tfor (let i = 0; i < infos.length; i++) {\n\t\t\tconst info = infos[i]!;\n\t\t\tconst pos = positions[i];\n\t\t\tif (!pos) continue;\n\n\t\t\tlet str = `${info.glyphId}`;\n\n\t\t\t// Add cluster if not sequential\n\t\t\tif (i === 0 || info.cluster !== infos[i - 1]?.cluster) {\n\t\t\t\tstr += `=${info.cluster}`;\n\t\t\t}\n\n\t\t\t// Add positioning\n\t\t\tif (pos.xOffset !== 0 || pos.yOffset !== 0) {\n\t\t\t\tstr += `@${pos.xOffset},${pos.yOffset}`;\n\t\t\t}\n\t\t\tif (pos.xAdvance !== 0) {\n\t\t\t\tstr += `+${pos.xAdvance}`;\n\t\t\t}\n\n\t\t\tparts.push(str);\n\t\t}\n\n\t\treturn `[${parts.join(\"|\")}]`;\n\t}\n\n\t/** Get glyph IDs as array */\n\tglyphIds(): GlyphId[] {\n\t\treturn this.infos.map((info) => info.glyphId);\n\t}\n\n\t/** Get clusters as array */\n\tclusters(): number[] {\n\t\treturn this.infos.map((info) => info.cluster);\n\t}\n\n\t/** Iterator for glyph info/position pairs */\n\t*[Symbol.iterator](): Iterator<{ info: GlyphInfo; position: GlyphPosition }> {\n\t\tconst infos = this.infos;\n\t\tconst positions = this.positions;\n\t\tfor (let i = 0; i < infos.length; i++) {\n\t\t\tconst info = infos[i]!;\n\t\t\tconst position = positions[i];\n\t\t\tif (!position) continue;\n\t\t\tyield { info, position };\n\t\t}\n\t}\n}\n",
    "import {\n\tBufferFlags,\n\tClusterLevel,\n\tDirection,\n\ttype GlyphInfo,\n} from \"../types.ts\";\n\n/**\n * Input buffer for text to be shaped.\n * Holds Unicode codepoints with associated properties.\n */\nexport class UnicodeBuffer {\n\tprivate _direction: Direction = Direction.LTR;\n\tprivate _script: string = \"Zyyy\"; // Common/Unknown\n\tprivate _language: string | null = null;\n\tprivate _clusterLevel: ClusterLevel = ClusterLevel.MonotoneGraphemes;\n\tprivate _flags: BufferFlags = BufferFlags.Default;\n\n\t/** Codepoints to shape */\n\treadonly codepoints: number[] = [];\n\t/** Cluster indices (maps each codepoint to its cluster) */\n\treadonly clusters: number[] = [];\n\n\t/** Pre-context (text before the buffer for contextual shaping) */\n\tpreContext: number[] = [];\n\t/** Post-context (text after the buffer for contextual shaping) */\n\tpostContext: number[] = [];\n\n\t/** Add a string to the buffer */\n\taddStr(text: string, startCluster = 0): this {\n\t\tconst len = text.length;\n\t\tif (len === 0) return this;\n\n\t\tconst baseLen = this.codepoints.length;\n\n\t\t// For appending to existing data, use push (rare case)\n\t\tif (baseLen > 0) {\n\t\t\treturn this._addStrAppend(text, startCluster);\n\t\t}\n\n\t\t// Fast path: fresh buffer - use new Array for speed\n\t\tconst codepoints = new Array<number>(len);\n\t\tconst clusters = new Array<number>(len);\n\n\t\tlet cluster = startCluster;\n\t\tlet writeIdx = 0;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst code = text.charCodeAt(i);\n\t\t\t// Check for high surrogate (emoji, etc.)\n\t\t\tif (code >= 0xd800 && code <= 0xdbff && i + 1 < len) {\n\t\t\t\tconst low = text.charCodeAt(i + 1);\n\t\t\t\tif (low >= 0xdc00 && low <= 0xdfff) {\n\t\t\t\t\t// Decode surrogate pair\n\t\t\t\t\tcodepoints[writeIdx] =\n\t\t\t\t\t\t((code - 0xd800) << 10) + (low - 0xdc00) + 0x10000;\n\t\t\t\t\tclusters[writeIdx] = cluster;\n\t\t\t\t\twriteIdx++;\n\t\t\t\t\tcluster++;\n\t\t\t\t\ti++; // Skip low surrogate\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcodepoints[writeIdx] = code;\n\t\t\tclusters[writeIdx] = cluster;\n\t\t\twriteIdx++;\n\t\t\tcluster++;\n\t\t}\n\n\t\t// Trim if surrogates reduced length\n\t\tif (writeIdx < len) {\n\t\t\tcodepoints.length = writeIdx;\n\t\t\tclusters.length = writeIdx;\n\t\t}\n\n\t\t// Replace arrays (cast to bypass readonly)\n\t\t(this as { codepoints: number[] }).codepoints = codepoints;\n\t\t(this as { clusters: number[] }).clusters = clusters;\n\n\t\treturn this;\n\t}\n\n\t/** Append to existing buffer (slower path) */\n\tprivate _addStrAppend(text: string, startCluster: number): this {\n\t\tlet cluster = startCluster;\n\t\tconst len = text.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst code = text.charCodeAt(i);\n\t\t\tif (code >= 0xd800 && code <= 0xdbff && i + 1 < len) {\n\t\t\t\tconst low = text.charCodeAt(i + 1);\n\t\t\t\tif (low >= 0xdc00 && low <= 0xdfff) {\n\t\t\t\t\tthis.codepoints.push(\n\t\t\t\t\t\t((code - 0xd800) << 10) + (low - 0xdc00) + 0x10000,\n\t\t\t\t\t);\n\t\t\t\t\tthis.clusters.push(cluster);\n\t\t\t\t\tcluster++;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.codepoints.push(code);\n\t\t\tthis.clusters.push(cluster);\n\t\t\tcluster++;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Add codepoints directly */\n\taddCodepoints(codepoints: number[], startCluster = 0): this {\n\t\tlet cluster = startCluster;\n\t\tfor (let i = 0; i < codepoints.length; i++) {\n\t\t\tconst cp = codepoints[i]!;\n\t\t\tthis.codepoints.push(cp);\n\t\t\tthis.clusters.push(cluster);\n\t\t\tcluster++;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Add a single codepoint */\n\taddCodepoint(codepoint: number, cluster?: number): this {\n\t\tthis.codepoints.push(codepoint);\n\t\tthis.clusters.push(cluster ?? this.codepoints.length - 1);\n\t\treturn this;\n\t}\n\n\t/** Set text direction */\n\tsetDirection(direction: Direction): this {\n\t\tthis._direction = direction;\n\t\treturn this;\n\t}\n\n\t/** Set script (ISO 15924 tag, e.g., 'Latn', 'Arab') */\n\tsetScript(script: string): this {\n\t\tthis._script = script;\n\t\treturn this;\n\t}\n\n\t/** Set language (BCP 47 tag, e.g., 'en', 'ar') */\n\tsetLanguage(language: string | null): this {\n\t\tthis._language = language;\n\t\treturn this;\n\t}\n\n\t/** Set cluster level */\n\tsetClusterLevel(level: ClusterLevel): this {\n\t\tthis._clusterLevel = level;\n\t\treturn this;\n\t}\n\n\t/** Set buffer flags */\n\tsetFlags(flags: BufferFlags): this {\n\t\tthis._flags = flags;\n\t\treturn this;\n\t}\n\n\t/** Set pre-context string */\n\tsetPreContext(text: string): this {\n\t\tthis.preContext = [];\n\t\tconst len = text.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst code = text.charCodeAt(i);\n\t\t\tif (code >= 0xd800 && code <= 0xdbff && i + 1 < len) {\n\t\t\t\tconst low = text.charCodeAt(i + 1);\n\t\t\t\tif (low >= 0xdc00 && low <= 0xdfff) {\n\t\t\t\t\tthis.preContext.push(\n\t\t\t\t\t\t((code - 0xd800) << 10) + (low - 0xdc00) + 0x10000,\n\t\t\t\t\t);\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.preContext.push(code);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Set post-context string */\n\tsetPostContext(text: string): this {\n\t\tthis.postContext = [];\n\t\tconst len = text.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst code = text.charCodeAt(i);\n\t\t\tif (code >= 0xd800 && code <= 0xdbff && i + 1 < len) {\n\t\t\t\tconst low = text.charCodeAt(i + 1);\n\t\t\t\tif (low >= 0xdc00 && low <= 0xdfff) {\n\t\t\t\t\tthis.postContext.push(\n\t\t\t\t\t\t((code - 0xd800) << 10) + (low - 0xdc00) + 0x10000,\n\t\t\t\t\t);\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.postContext.push(code);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Clear the buffer */\n\tclear(): this {\n\t\tthis.codepoints.length = 0;\n\t\tthis.clusters.length = 0;\n\t\tthis.preContext.length = 0;\n\t\tthis.postContext.length = 0;\n\t\treturn this;\n\t}\n\n\t/** Number of codepoints */\n\tget length(): number {\n\t\treturn this.codepoints.length;\n\t}\n\n\tget direction(): Direction {\n\t\treturn this._direction;\n\t}\n\n\tget script(): string {\n\t\treturn this._script;\n\t}\n\n\tget language(): string | null {\n\t\treturn this._language;\n\t}\n\n\tget clusterLevel(): ClusterLevel {\n\t\treturn this._clusterLevel;\n\t}\n\n\tget flags(): BufferFlags {\n\t\treturn this._flags;\n\t}\n\n\t/** Convert to initial glyph infos (codepoint = glyphId initially) */\n\ttoGlyphInfos(): GlyphInfo[] {\n\t\treturn this.codepoints.map((codepoint, i) => ({\n\t\t\tglyphId: 0, // Will be set during shaping\n\t\t\tcluster: this.clusters[i] ?? 0,\n\t\t\tmask: 0,\n\t\t\tcodepoint,\n\t\t}));\n\t}\n}\n",
    "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Glyph Variations table (gvar)\n * Contains variation data for TrueType glyph outlines\n */\nexport interface GvarTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\taxisCount: uint16;\n\tsharedTupleCount: uint16;\n\tsharedTuples: number[][]; // [tupleIndex][axisIndex]\n\tglyphVariationData: GlyphVariationData[];\n}\n\n/**\n * Variation data for a single glyph\n */\nexport interface GlyphVariationData {\n\ttupleVariationHeaders: TupleVariationHeader[];\n}\n\n/**\n * Tuple variation header\n */\nexport interface TupleVariationHeader {\n\tvariationDataSize: uint16;\n\ttupleIndex: uint16;\n\tpeakTuple: number[] | null; // null if embedded in shared tuples\n\tintermediateStartTuple: number[] | null;\n\tintermediateEndTuple: number[] | null;\n\tserializedData: Uint8Array;\n\tpointNumbers: number[] | null; // null means all points\n\tdeltas: PointDelta[];\n}\n\n/**\n * Delta values for a point\n */\nexport interface PointDelta {\n\tx: int16;\n\ty: int16;\n}\n\n// Tuple flags\nconst EMBEDDED_PEAK_TUPLE = 0x8000;\nconst INTERMEDIATE_REGION = 0x4000;\nconst PRIVATE_POINT_NUMBERS = 0x2000;\nconst TUPLE_INDEX_MASK = 0x0fff;\n\n/**\n * Parse gvar table - glyph variations for TrueType outlines in variable fonts\n * @param reader - Reader positioned at start of gvar table\n * @param _numGlyphs - Number of glyphs (currently unused)\n * @returns Parsed gvar table with per-glyph variation data\n */\nexport function parseGvar(reader: Reader, _numGlyphs: number): GvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst axisCount = reader.uint16();\n\tconst sharedTupleCount = reader.uint16();\n\tconst sharedTuplesOffset = reader.offset32();\n\tconst glyphCount = reader.uint16();\n\tconst flags = reader.uint16();\n\tconst glyphVariationDataArrayOffset = reader.offset32();\n\n\tconst offsetSize = flags & 1 ? 4 : 2;\n\n\t// Read glyph offsets\n\tconst offsets: number[] = [];\n\tfor (let i = 0; i <= glyphCount; i++) {\n\t\tconst offset = offsetSize === 4 ? reader.uint32() : reader.uint16() * 2;\n\t\toffsets.push(offset);\n\t}\n\n\t// Parse shared tuples\n\tconst sharedTuples: number[][] = [];\n\tif (sharedTupleCount > 0) {\n\t\tconst tupleReader = reader.sliceFrom(sharedTuplesOffset);\n\t\tfor (let i = 0; i < sharedTupleCount; i++) {\n\t\t\tconst tuple: number[] = [];\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\ttuple.push(tupleReader.f2dot14());\n\t\t\t}\n\t\t\tsharedTuples.push(tuple);\n\t\t}\n\t}\n\n\t// Parse glyph variation data\n\tconst glyphVariationData: GlyphVariationData[] = [];\n\tfor (let g = 0; g < glyphCount; g++) {\n\t\tconst startOffset = offsets[g];\n\t\tconst endOffset = offsets[g + 1];\n\t\tif (startOffset === undefined || endOffset === undefined) {\n\t\t\tglyphVariationData.push({ tupleVariationHeaders: [] });\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst dataStart = glyphVariationDataArrayOffset + startOffset;\n\t\tconst dataEnd = glyphVariationDataArrayOffset + endOffset;\n\n\t\tif (dataStart === dataEnd) {\n\t\t\t// No variation data for this glyph\n\t\t\tglyphVariationData.push({ tupleVariationHeaders: [] });\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst dataReader = reader.sliceFrom(dataStart);\n\t\tconst variationData = parseGlyphVariationData(\n\t\t\tdataReader,\n\t\t\tdataEnd - dataStart,\n\t\t\taxisCount,\n\t\t\tsharedTuples,\n\t\t);\n\t\tglyphVariationData.push(variationData);\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\taxisCount,\n\t\tsharedTupleCount,\n\t\tsharedTuples,\n\t\tglyphVariationData,\n\t};\n}\n\nfunction parseGlyphVariationData(\n\treader: Reader,\n\tdataLength: number,\n\taxisCount: number,\n\tsharedTuples: number[][],\n): GlyphVariationData {\n\tif (dataLength === 0) {\n\t\treturn { tupleVariationHeaders: [] };\n\t}\n\n\tconst startOffset = reader.offset;\n\tconst tupleVariationCount = reader.uint16();\n\tconst dataOffset = reader.offset16();\n\n\tconst tupleCount = tupleVariationCount & 0x0fff;\n\tconst hasSharedPointNumbers = (tupleVariationCount & 0x8000) !== 0;\n\n\t// Read tuple variation headers first\n\tconst headerData: Array<{\n\t\tvariationDataSize: uint16;\n\t\ttupleIndex: uint16;\n\t\tpeakTuple: number[] | null;\n\t\tintermediateStartTuple: number[] | null;\n\t\tintermediateEndTuple: number[] | null;\n\t}> = [];\n\n\tfor (let i = 0; i < tupleCount; i++) {\n\t\tconst variationDataSize = reader.uint16();\n\t\tconst tupleIndex = reader.uint16();\n\n\t\tlet peakTuple: number[] | null = null;\n\t\tlet intermediateStartTuple: number[] | null = null;\n\t\tlet intermediateEndTuple: number[] | null = null;\n\n\t\tif (tupleIndex & EMBEDDED_PEAK_TUPLE) {\n\t\t\tpeakTuple = [];\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\tpeakTuple.push(reader.f2dot14());\n\t\t\t}\n\t\t} else {\n\t\t\tconst sharedIndex = tupleIndex & TUPLE_INDEX_MASK;\n\t\t\tpeakTuple = sharedTuples[sharedIndex] || null;\n\t\t}\n\n\t\tif (tupleIndex & INTERMEDIATE_REGION) {\n\t\t\tintermediateStartTuple = [];\n\t\t\tintermediateEndTuple = [];\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\tintermediateStartTuple.push(reader.f2dot14());\n\t\t\t}\n\t\t\tfor (let a = 0; a < axisCount; a++) {\n\t\t\t\tintermediateEndTuple.push(reader.f2dot14());\n\t\t\t}\n\t\t}\n\n\t\theaderData.push({\n\t\t\tvariationDataSize,\n\t\t\ttupleIndex,\n\t\t\tpeakTuple,\n\t\t\tintermediateStartTuple,\n\t\t\tintermediateEndTuple,\n\t\t});\n\t}\n\n\t// Now parse serialized data starting at dataOffset\n\tconst dataReader = reader.sliceFrom(startOffset + dataOffset);\n\n\t// Parse shared point numbers if present\n\tlet sharedPoints: number[] | null = null;\n\tif (hasSharedPointNumbers) {\n\t\tsharedPoints = parsePackedPoints(dataReader);\n\t}\n\n\t// Parse each tuple's deltas\n\tconst headers: TupleVariationHeader[] = [];\n\tfor (let i = 0; i < headerData.length; i++) {\n\t\tconst hd = headerData[i]!;\n\t\tconst hasPrivatePoints = (hd.tupleIndex & PRIVATE_POINT_NUMBERS) !== 0;\n\n\t\tlet pointNumbers: number[] | null;\n\t\tif (hasPrivatePoints) {\n\t\t\tpointNumbers = parsePackedPoints(dataReader);\n\t\t} else {\n\t\t\tpointNumbers = sharedPoints;\n\t\t}\n\n\t\t// Calculate number of points to read deltas for\n\t\tconst numPoints = pointNumbers ? pointNumbers.length : 0;\n\n\t\t// Parse x deltas then y deltas\n\t\tconst xDeltas =\n\t\t\tnumPoints > 0 ? parsePackedDeltas(dataReader, numPoints) : [];\n\t\tconst yDeltas =\n\t\t\tnumPoints > 0 ? parsePackedDeltas(dataReader, numPoints) : [];\n\n\t\tconst deltas: PointDelta[] = [];\n\t\tfor (let p = 0; p < xDeltas.length; p++) {\n\t\t\tconst xDelta = xDeltas[p];\n\t\t\tconst yDelta = yDeltas[p];\n\t\t\tdeltas.push({\n\t\t\t\tx: xDelta ?? 0,\n\t\t\t\ty: yDelta ?? 0,\n\t\t\t});\n\t\t}\n\n\t\theaders.push({\n\t\t\tvariationDataSize: hd.variationDataSize,\n\t\t\ttupleIndex: hd.tupleIndex,\n\t\t\tpeakTuple: hd.peakTuple,\n\t\t\tintermediateStartTuple: hd.intermediateStartTuple,\n\t\t\tintermediateEndTuple: hd.intermediateEndTuple,\n\t\t\tserializedData: new Uint8Array(0),\n\t\t\tpointNumbers,\n\t\t\tdeltas,\n\t\t});\n\t}\n\n\treturn { tupleVariationHeaders: headers };\n}\n\n/**\n * Parse packed point numbers\n */\nfunction parsePackedPoints(reader: Reader): number[] {\n\tconst count = reader.uint8();\n\tconst totalPoints =\n\t\tcount === 0\n\t\t\t? 0\n\t\t\t: count & 0x80\n\t\t\t\t? ((count & 0x7f) << 8) | reader.uint8()\n\t\t\t\t: count;\n\n\tif (totalPoints === 0) {\n\t\treturn []; // All points\n\t}\n\n\tconst points: number[] = [];\n\tlet pointIdx = 0;\n\n\twhile (points.length < totalPoints) {\n\t\tconst runHeader = reader.uint8();\n\t\tconst runCount = (runHeader & 0x7f) + 1;\n\t\tconst pointsAreWords = (runHeader & 0x80) !== 0;\n\n\t\tfor (let i = 0; i < runCount && points.length < totalPoints; i++) {\n\t\t\tconst delta = pointsAreWords ? reader.uint16() : reader.uint8();\n\t\t\tpointIdx += delta;\n\t\t\tpoints.push(pointIdx);\n\t\t}\n\t}\n\n\treturn points;\n}\n\n/**\n * Parse packed deltas\n */\nexport function parsePackedDeltas(reader: Reader, count: number): number[] {\n\tconst deltas: number[] = [];\n\n\twhile (deltas.length < count) {\n\t\tconst runHeader = reader.uint8();\n\t\tconst runCount = (runHeader & 0x3f) + 1;\n\t\tconst deltasAreZero = (runHeader & 0x80) !== 0;\n\t\tconst deltasAreWords = (runHeader & 0x40) !== 0;\n\n\t\tfor (let i = 0; i < runCount && deltas.length < count; i++) {\n\t\t\tif (deltasAreZero) {\n\t\t\t\tdeltas.push(0);\n\t\t\t} else if (deltasAreWords) {\n\t\t\t\tdeltas.push(reader.int16());\n\t\t\t} else {\n\t\t\t\tdeltas.push(reader.int8());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deltas;\n}\n\n/**\n * Calculate the scalar for a tuple given axis coordinates\n * Determines how much a variation tuple contributes based on current axis values\n * @param peakTuple - Peak coordinates for each axis where variation is at maximum\n * @param axisCoords - Current normalized axis coordinates\n * @param intermediateStart - Start of intermediate region (null if not used)\n * @param intermediateEnd - End of intermediate region (null if not used)\n * @returns Scalar value between 0 and 1 indicating variation contribution\n */\nexport function calculateTupleScalar(\n\tpeakTuple: number[],\n\taxisCoords: number[],\n\tintermediateStart: number[] | null,\n\tintermediateEnd: number[] | null,\n): number {\n\tlet scalar = 1.0;\n\n\tfor (let i = 0; i < peakTuple.length; i++) {\n\t\tconst peak = peakTuple[i]!;\n\t\tconst coord = axisCoords[i] ?? 0;\n\n\t\tif (peak === 0 || coord === 0) {\n\t\t\tif (peak !== 0) scalar = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (intermediateStart && intermediateEnd) {\n\t\t\tconst start = intermediateStart[i];\n\t\t\tconst end = intermediateEnd[i];\n\t\t\tif (start === undefined || end === undefined) continue;\n\n\t\t\tif (coord < start || coord > end) {\n\t\t\t\tscalar = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (coord < peak) {\n\t\t\t\tscalar *= (coord - start) / (peak - start);\n\t\t\t} else if (coord > peak) {\n\t\t\t\tscalar *= (end - coord) / (end - peak);\n\t\t\t}\n\t\t} else {\n\t\t\t// Simple case\n\t\t\tif ((peak > 0 && coord < 0) || (peak < 0 && coord > 0)) {\n\t\t\t\tscalar = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (Math.abs(coord) < Math.abs(peak)) {\n\t\t\t\tscalar *= coord / peak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn scalar;\n}\n\n/**\n * Get delta for a glyph point at given variation coordinates\n */\nexport function getGlyphDelta(\n\tgvar: GvarTable,\n\tglyphId: GlyphId,\n\tpointIndex: number,\n\taxisCoords: number[],\n): PointDelta {\n\tconst glyphData = gvar.glyphVariationData[glyphId];\n\tif (!glyphData) return { x: 0, y: 0 };\n\n\tlet totalX = 0;\n\tlet totalY = 0;\n\n\tfor (let i = 0; i < glyphData.tupleVariationHeaders.length; i++) {\n\t\tconst header = glyphData.tupleVariationHeaders[i]!;\n\t\tif (!header.peakTuple) continue;\n\n\t\tconst scalar = calculateTupleScalar(\n\t\t\theader.peakTuple,\n\t\t\taxisCoords,\n\t\t\theader.intermediateStartTuple,\n\t\t\theader.intermediateEndTuple,\n\t\t);\n\n\t\tif (scalar === 0) continue;\n\n\t\t// Check if point is in the variation\n\t\tif (header.pointNumbers !== null) {\n\t\t\tconst pointIdx = header.pointNumbers.indexOf(pointIndex);\n\t\t\tif (pointIdx < 0) continue;\n\n\t\t\tconst delta = header.deltas[pointIdx];\n\t\t\tif (delta) {\n\t\t\t\ttotalX += delta.x * scalar;\n\t\t\t\ttotalY += delta.y * scalar;\n\t\t\t}\n\t\t} else {\n\t\t\t// All points\n\t\t\tconst delta = header.deltas[pointIndex];\n\t\t\tif (delta) {\n\t\t\t\ttotalX += delta.x * scalar;\n\t\t\t\ttotalY += delta.y * scalar;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { x: Math.round(totalX), y: Math.round(totalY) };\n}\n",
    "import type { GlyphId, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * loca table - Glyph location index\n * Maps glyph IDs to byte offsets in the glyf table\n */\n\nexport interface LocaTable {\n\t/** Glyph offsets (numGlyphs + 1 entries) */\n\toffsets: uint32[];\n\t/** Whether the font uses short (16-bit) or long (32-bit) offsets */\n\tisShort: boolean;\n}\n\n/**\n * Parse loca table\n * @param reader - Reader positioned at start of loca table\n * @param numGlyphs - Number of glyphs from maxp table\n * @param indexToLocFormat - 0 for short offsets, 1 for long (from head table)\n */\nexport function parseLoca(\n\treader: Reader,\n\tnumGlyphs: number,\n\tindexToLocFormat: number,\n): LocaTable {\n\tconst isShort = indexToLocFormat === 0;\n\tconst offsets: uint32[] = [];\n\n\t// loca has numGlyphs + 1 entries (last entry marks end of last glyph)\n\tconst count = numGlyphs + 1;\n\n\tif (isShort) {\n\t\t// Short format: offsets are uint16, multiply by 2 to get actual byte offset\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffsets.push(reader.uint16() * 2);\n\t\t}\n\t} else {\n\t\t// Long format: offsets are uint32\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffsets.push(reader.uint32());\n\t\t}\n\t}\n\n\treturn { offsets, isShort };\n}\n\n/**\n * Get byte offset and length for a glyph in the glyf table\n * Returns null if glyph has no outline (empty glyph)\n * @param loca - Parsed loca table\n * @param glyphId - Glyph ID to look up\n * @returns Object with offset and length, or null if glyph has no outline\n */\nexport function getGlyphLocation(\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): { offset: uint32; length: uint32 } | null {\n\tif (glyphId < 0 || glyphId >= loca.offsets.length - 1) {\n\t\treturn null;\n\t}\n\n\tconst offset = loca.offsets[glyphId];\n\tconst nextOffset = loca.offsets[glyphId + 1];\n\tif (offset === undefined || nextOffset === undefined) {\n\t\treturn null;\n\t}\n\n\tconst length = nextOffset - offset;\n\n\t// Zero-length means empty glyph (space, etc.)\n\tif (length === 0) {\n\t\treturn null;\n\t}\n\n\treturn { offset, length };\n}\n\n/**\n * Check if a glyph has outline data\n */\nexport function hasGlyphOutline(loca: LocaTable, glyphId: GlyphId): boolean {\n\treturn getGlyphLocation(loca, glyphId) !== null;\n}\n",
    "import type { GlyphId, int16, uint8, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GvarTable, PointDelta } from \"./gvar.ts\";\nimport { calculateTupleScalar } from \"./gvar.ts\";\nimport type { LocaTable } from \"./loca.ts\";\nimport { getGlyphLocation } from \"./loca.ts\";\n\n/**\n * glyf table - Glyph outline data\n * Contains TrueType glyph contours as quadratic Bzier curves\n */\n\n/** Point flags */\nexport const PointFlag = {\n\tOnCurve: 0x01,\n\tXShortVector: 0x02,\n\tYShortVector: 0x04,\n\tRepeat: 0x08,\n\tXIsSameOrPositive: 0x10,\n\tYIsSameOrPositive: 0x20,\n\tOverlapSimple: 0x40,\n} as const;\n\n/** Composite glyph flags */\nexport const CompositeFlag = {\n\tArg1And2AreWords: 0x0001,\n\tArgsAreXYValues: 0x0002,\n\tRoundXYToGrid: 0x0004,\n\tWeHaveAScale: 0x0008,\n\tMoreComponents: 0x0020,\n\tWeHaveAnXAndYScale: 0x0040,\n\tWeHaveATwoByTwo: 0x0080,\n\tWeHaveInstructions: 0x0100,\n\tUseMyMetrics: 0x0200,\n\tOverlapCompound: 0x0400,\n\tScaledComponentOffset: 0x0800,\n\tUnscaledComponentOffset: 0x1000,\n} as const;\n\n/** A point in a glyph contour */\nexport interface GlyphPoint {\n\tx: number;\n\ty: number;\n\tonCurve: boolean;\n\t/** True if this is a cubic bezier control point (CFF fonts) */\n\tcubic?: boolean;\n}\n\n/** A contour is a closed path of points */\nexport type Contour = GlyphPoint[];\n\n/** Simple glyph with contours */\nexport interface SimpleGlyph {\n\ttype: \"simple\";\n\tnumberOfContours: int16;\n\txMin: int16;\n\tyMin: int16;\n\txMax: int16;\n\tyMax: int16;\n\tcontours: Contour[];\n\tinstructions: Uint8Array<ArrayBufferLike>;\n}\n\n/** Component of a composite glyph */\nexport interface GlyphComponent {\n\tglyphId: GlyphId;\n\tflags: uint16;\n\t/** X offset or point number */\n\targ1: number;\n\t/** Y offset or point number */\n\targ2: number;\n\t/** Transformation matrix [a, b, c, d] */\n\ttransform: [number, number, number, number];\n}\n\n/** Composite glyph made of other glyphs */\nexport interface CompositeGlyph {\n\ttype: \"composite\";\n\tnumberOfContours: int16;\n\txMin: int16;\n\tyMin: int16;\n\txMax: int16;\n\tyMax: int16;\n\tcomponents: GlyphComponent[];\n\tinstructions: Uint8Array<ArrayBufferLike>;\n}\n\n/** Empty glyph (space, etc.) */\nexport interface EmptyGlyph {\n\ttype: \"empty\";\n}\n\nexport type Glyph = SimpleGlyph | CompositeGlyph | EmptyGlyph;\n\n/** glyf table stores the raw reader for on-demand glyph parsing */\nexport interface GlyfTable {\n\treader: Reader;\n}\n\nexport function parseGlyf(reader: Reader): GlyfTable {\n\t// We don't parse all glyphs upfront - store reader for lazy access\n\treturn { reader };\n}\n\n/**\n * Parse a single glyph from the glyf table\n */\nexport function parseGlyph(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): Glyph {\n\tconst location = getGlyphLocation(loca, glyphId);\n\tif (!location) {\n\t\treturn { type: \"empty\" };\n\t}\n\n\tconst reader = glyf.reader.slice(location.offset, location.length);\n\treturn parseGlyphData(reader);\n}\n\nfunction parseGlyphData(reader: Reader): Glyph {\n\tconst numberOfContours = reader.int16();\n\tconst xMin = reader.int16();\n\tconst yMin = reader.int16();\n\tconst xMax = reader.int16();\n\tconst yMax = reader.int16();\n\n\tif (numberOfContours >= 0) {\n\t\treturn parseSimpleGlyph(reader, numberOfContours, xMin, yMin, xMax, yMax);\n\t} else {\n\t\treturn parseCompositeGlyph(\n\t\t\treader,\n\t\t\tnumberOfContours,\n\t\t\txMin,\n\t\t\tyMin,\n\t\t\txMax,\n\t\t\tyMax,\n\t\t);\n\t}\n}\n\nfunction parseSimpleGlyph(\n\treader: Reader,\n\tnumberOfContours: int16,\n\txMin: int16,\n\tyMin: int16,\n\txMax: int16,\n\tyMax: int16,\n): SimpleGlyph {\n\tif (numberOfContours === 0) {\n\t\treturn {\n\t\t\ttype: \"simple\",\n\t\t\tnumberOfContours,\n\t\t\txMin,\n\t\t\tyMin,\n\t\t\txMax,\n\t\t\tyMax,\n\t\t\tcontours: [],\n\t\t\tinstructions: new Uint8Array(0),\n\t\t};\n\t}\n\n\t// Read end points of each contour\n\tconst endPtsOfContours: uint16[] = [];\n\tfor (let i = 0; i < numberOfContours; i++) {\n\t\tendPtsOfContours.push(reader.uint16());\n\t}\n\n\t// Total number of points\n\tconst lastEndPt = endPtsOfContours[numberOfContours - 1];\n\tif (lastEndPt === undefined) {\n\t\treturn {\n\t\t\ttype: \"simple\",\n\t\t\tnumberOfContours,\n\t\t\txMin,\n\t\t\tyMin,\n\t\t\txMax,\n\t\t\tyMax,\n\t\t\tcontours: [],\n\t\t\tinstructions: new Uint8Array(0),\n\t\t};\n\t}\n\tconst numPoints = lastEndPt + 1;\n\n\t// Read instructions\n\tconst instructionLength = reader.uint16();\n\tconst instructions = reader.bytes(instructionLength);\n\n\t// Read flags\n\tconst flags: uint8[] = [];\n\twhile (flags.length < numPoints) {\n\t\tconst flag = reader.uint8();\n\t\tflags.push(flag);\n\n\t\t// Handle repeat flag\n\t\tif (flag & PointFlag.Repeat) {\n\t\t\tconst repeatCount = reader.uint8();\n\t\t\tfor (let i = 0; i < repeatCount; i++) {\n\t\t\t\tflags.push(flag);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Read X coordinates\n\tconst xCoordinates: number[] = [];\n\tlet x = 0;\n\tfor (let i = 0; i < flags.length; i++) {\n\t\tconst flag = flags[i]!;\n\t\tif (flag & PointFlag.XShortVector) {\n\t\t\tconst dx = reader.uint8();\n\t\t\tx += flag & PointFlag.XIsSameOrPositive ? dx : -dx;\n\t\t} else if (!(flag & PointFlag.XIsSameOrPositive)) {\n\t\t\tx += reader.int16();\n\t\t}\n\t\t// else x stays the same (XIsSameOrPositive with no short vector)\n\t\txCoordinates.push(x);\n\t}\n\n\t// Read Y coordinates\n\tconst yCoordinates: number[] = [];\n\tlet y = 0;\n\tfor (let i = 0; i < flags.length; i++) {\n\t\tconst flag = flags[i]!;\n\t\tif (flag & PointFlag.YShortVector) {\n\t\t\tconst dy = reader.uint8();\n\t\t\ty += flag & PointFlag.YIsSameOrPositive ? dy : -dy;\n\t\t} else if (!(flag & PointFlag.YIsSameOrPositive)) {\n\t\t\ty += reader.int16();\n\t\t}\n\t\t// else y stays the same\n\t\tyCoordinates.push(y);\n\t}\n\n\t// Build contours\n\tconst contours: Contour[] = [];\n\tlet pointIndex = 0;\n\tfor (let i = 0; i < endPtsOfContours.length; i++) {\n\t\tconst endPt = endPtsOfContours[i]!;\n\t\tconst contour: Contour = [];\n\n\t\twhile (pointIndex <= endPt) {\n\t\t\tconst xCoord = xCoordinates[pointIndex];\n\t\t\tconst yCoord = yCoordinates[pointIndex];\n\t\t\tconst flag = flags[pointIndex];\n\t\t\tif (xCoord === undefined || yCoord === undefined || flag === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcontour.push({\n\t\t\t\tx: xCoord,\n\t\t\t\ty: yCoord,\n\t\t\t\tonCurve: (flag & PointFlag.OnCurve) !== 0,\n\t\t\t});\n\t\t\tpointIndex++;\n\t\t}\n\n\t\tcontours.push(contour);\n\t}\n\n\treturn {\n\t\ttype: \"simple\",\n\t\tnumberOfContours,\n\t\txMin,\n\t\tyMin,\n\t\txMax,\n\t\tyMax,\n\t\tcontours,\n\t\tinstructions,\n\t};\n}\n\nfunction parseCompositeGlyph(\n\treader: Reader,\n\tnumberOfContours: int16,\n\txMin: int16,\n\tyMin: int16,\n\txMax: int16,\n\tyMax: int16,\n): CompositeGlyph {\n\tconst components: GlyphComponent[] = [];\n\tlet flags: uint16;\n\n\tdo {\n\t\tflags = reader.uint16();\n\t\tconst glyphIndex = reader.uint16();\n\n\t\tlet arg1: number;\n\t\tlet arg2: number;\n\n\t\tif (flags & CompositeFlag.Arg1And2AreWords) {\n\t\t\tif (flags & CompositeFlag.ArgsAreXYValues) {\n\t\t\t\targ1 = reader.int16();\n\t\t\t\targ2 = reader.int16();\n\t\t\t} else {\n\t\t\t\targ1 = reader.uint16();\n\t\t\t\targ2 = reader.uint16();\n\t\t\t}\n\t\t} else {\n\t\t\tif (flags & CompositeFlag.ArgsAreXYValues) {\n\t\t\t\targ1 = reader.int8();\n\t\t\t\targ2 = reader.int8();\n\t\t\t} else {\n\t\t\t\targ1 = reader.uint8();\n\t\t\t\targ2 = reader.uint8();\n\t\t\t}\n\t\t}\n\n\t\t// Transformation matrix defaults to identity\n\t\tlet a = 1,\n\t\t\tb = 0,\n\t\t\tc = 0,\n\t\t\td = 1;\n\n\t\tif (flags & CompositeFlag.WeHaveAScale) {\n\t\t\ta = d = reader.f2dot14();\n\t\t} else if (flags & CompositeFlag.WeHaveAnXAndYScale) {\n\t\t\ta = reader.f2dot14();\n\t\t\td = reader.f2dot14();\n\t\t} else if (flags & CompositeFlag.WeHaveATwoByTwo) {\n\t\t\ta = reader.f2dot14();\n\t\t\tb = reader.f2dot14();\n\t\t\tc = reader.f2dot14();\n\t\t\td = reader.f2dot14();\n\t\t}\n\n\t\tcomponents.push({\n\t\t\tglyphId: glyphIndex,\n\t\t\tflags,\n\t\t\targ1,\n\t\t\targ2,\n\t\t\ttransform: [a, b, c, d],\n\t\t});\n\t} while (flags & CompositeFlag.MoreComponents);\n\n\t// Read instructions if present\n\tlet instructions: Uint8Array<ArrayBufferLike> = new Uint8Array(0);\n\tif (flags & CompositeFlag.WeHaveInstructions) {\n\t\tconst instructionLength = reader.uint16();\n\t\tinstructions = reader.bytes(instructionLength);\n\t}\n\n\treturn {\n\t\ttype: \"composite\",\n\t\tnumberOfContours,\n\t\txMin,\n\t\tyMin,\n\t\txMax,\n\t\tyMax,\n\t\tcomponents,\n\t\tinstructions,\n\t};\n}\n\nfunction shouldScaleComponentOffset(\n\tflags: uint16,\n\ta: number,\n\tb: number,\n\tc: number,\n\td: number,\n): boolean {\n\tif (flags & CompositeFlag.UnscaledComponentOffset) return false;\n\tif (flags & CompositeFlag.ScaledComponentOffset) return true;\n\treturn a !== 1 || b !== 0 || c !== 0 || d !== 1;\n}\n\nfunction flattenContoursPoints(contours: Contour[]): GlyphPoint[] {\n\tconst points: GlyphPoint[] = [];\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\tpoints.push(contour[j]!);\n\t\t}\n\t}\n\treturn points;\n}\n\nfunction transformContour(\n\tcontour: Contour,\n\ta: number,\n\tb: number,\n\tc: number,\n\td: number,\n\tdx: number,\n\tdy: number,\n): Contour {\n\tconst transformed: Contour = new Array(contour.length);\n\tfor (let i = 0; i < contour.length; i++) {\n\t\tconst point = contour[i]!;\n\t\tconst x = Math.round(a * point.x + c * point.y + dx);\n\t\tconst y = Math.round(b * point.x + d * point.y + dy);\n\t\tconst transformedPoint: GlyphPoint = { x, y, onCurve: point.onCurve };\n\t\tif (point.cubic) transformedPoint.cubic = true;\n\t\ttransformed[i] = transformedPoint;\n\t}\n\treturn transformed;\n}\n\nfunction appendComponentContours(\n\tresult: Contour[],\n\tparentPoints: GlyphPoint[],\n\tcomponent: GlyphComponent,\n\tcomponentContours: Contour[],\n): void {\n\tconst [a, b, c, d] = component.transform;\n\tconst hasXY = (component.flags & CompositeFlag.ArgsAreXYValues) !== 0;\n\tconst componentPoints = flattenContoursPoints(componentContours);\n\n\tlet dx = 0;\n\tlet dy = 0;\n\n\tif (hasXY) {\n\t\tdx = component.arg1;\n\t\tdy = component.arg2;\n\n\t\tif (shouldScaleComponentOffset(component.flags, a, b, c, d)) {\n\t\t\tconst scaledX = a * dx + c * dy;\n\t\t\tconst scaledY = b * dx + d * dy;\n\t\t\tdx = scaledX;\n\t\t\tdy = scaledY;\n\t\t}\n\n\t\tif (component.flags & CompositeFlag.RoundXYToGrid) {\n\t\t\tdx = Math.round(dx);\n\t\t\tdy = Math.round(dy);\n\t\t}\n\t} else {\n\t\tconst parentIndex = component.arg1;\n\t\tconst compIndex = component.arg2;\n\t\tif (\n\t\t\tparentIndex >= 0 &&\n\t\t\tparentIndex < parentPoints.length &&\n\t\t\tcompIndex >= 0 &&\n\t\t\tcompIndex < componentPoints.length\n\t\t) {\n\t\t\tconst parentPoint = parentPoints[parentIndex]!;\n\t\t\tconst compPoint = componentPoints[compIndex]!;\n\t\t\tconst compX = a * compPoint.x + c * compPoint.y;\n\t\t\tconst compY = b * compPoint.x + d * compPoint.y;\n\t\t\tdx = parentPoint.x - compX;\n\t\t\tdy = parentPoint.y - compY;\n\t\t}\n\t}\n\n\tfor (let i = 0; i < componentContours.length; i++) {\n\t\tconst contour = componentContours[i]!;\n\t\tconst transformedContour = transformContour(contour, a, b, c, d, dx, dy);\n\t\tresult.push(transformedContour);\n\t\tfor (let j = 0; j < transformedContour.length; j++) {\n\t\t\tparentPoints.push(transformedContour[j]!);\n\t\t}\n\t}\n}\n\n/**\n * Flatten a composite glyph into simple contours\n * Recursively resolves all component glyphs and applies transformations\n */\nexport function flattenCompositeGlyph(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyph: CompositeGlyph,\n\tdepth: number = 0,\n): Contour[] {\n\t// Prevent infinite recursion\n\tif (depth > 32) {\n\t\treturn [];\n\t}\n\n\tconst result: Contour[] = [];\n\tconst parentPoints: GlyphPoint[] = [];\n\n\tfor (let i = 0; i < glyph.components.length; i++) {\n\t\tconst component = glyph.components[i]!;\n\t\tconst componentGlyph = parseGlyph(glyf, loca, component.glyphId);\n\n\t\tlet componentContours: Contour[];\n\t\tif (componentGlyph.type === \"simple\") {\n\t\t\tcomponentContours = componentGlyph.contours;\n\t\t} else if (componentGlyph.type === \"composite\") {\n\t\t\tcomponentContours = flattenCompositeGlyph(\n\t\t\t\tglyf,\n\t\t\t\tloca,\n\t\t\t\tcomponentGlyph,\n\t\t\t\tdepth + 1,\n\t\t\t);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tappendComponentContours(result, parentPoints, component, componentContours);\n\t}\n\n\treturn result;\n}\n\n/** LRU cache for composite glyph contours (per glyf table) */\nconst compositeCache = new WeakMap<GlyfTable, Map<GlyphId, Contour[]>>();\nconst COMPOSITE_CACHE_SIZE = 256;\n\nfunction getCompositeCache(glyf: GlyfTable): Map<GlyphId, Contour[]> {\n\tlet cache = compositeCache.get(glyf);\n\tif (!cache) {\n\t\tcache = new Map();\n\t\tcompositeCache.set(glyf, cache);\n\t}\n\treturn cache;\n}\n\n/**\n * Get all contours for a glyph, flattening composites\n */\nexport function getGlyphContours(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): Contour[] {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn [];\n\t} else if (glyph.type === \"simple\") {\n\t\treturn glyph.contours;\n\t} else {\n\t\tconst cache = getCompositeCache(glyf);\n\t\t// Check cache for composite glyphs using numeric key directly\n\t\tconst cached = cache.get(glyphId);\n\t\tif (cached) return cached;\n\n\t\tconst result = flattenCompositeGlyph(glyf, loca, glyph);\n\n\t\t// Cache result with LRU eviction\n\t\tif (cache.size >= COMPOSITE_CACHE_SIZE) {\n\t\t\tconst firstKey = cache.keys().next().value;\n\t\t\tif (firstKey !== undefined) cache.delete(firstKey);\n\t\t}\n\t\tcache.set(glyphId, result);\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Get contours and bounds for a glyph in one parse operation.\n * More efficient than calling getGlyphContours + getGlyphBounds separately.\n */\nexport function getGlyphContoursAndBounds(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): {\n\tcontours: Contour[];\n\tbounds: { xMin: number; yMin: number; xMax: number; yMax: number } | null;\n} {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn { contours: [], bounds: null };\n\t}\n\n\tconst bounds = {\n\t\txMin: glyph.xMin,\n\t\tyMin: glyph.yMin,\n\t\txMax: glyph.xMax,\n\t\tyMax: glyph.yMax,\n\t};\n\n\tif (glyph.type === \"simple\") {\n\t\treturn { contours: glyph.contours, bounds };\n\t}\n\n\t// Composite glyph - check cache using numeric key directly\n\tconst cache = getCompositeCache(glyf);\n\tlet contours = cache.get(glyphId);\n\tif (!contours) {\n\t\tcontours = flattenCompositeGlyph(glyf, loca, glyph);\n\t\tif (cache.size >= COMPOSITE_CACHE_SIZE) {\n\t\t\tconst firstKey = cache.keys().next().value;\n\t\t\tif (firstKey !== undefined) cache.delete(firstKey);\n\t\t}\n\t\tcache.set(glyphId, contours);\n\t}\n\tif (contours.length === 0) {\n\t\treturn { contours, bounds: null };\n\t}\n\n\tlet xMin = Infinity;\n\tlet yMin = Infinity;\n\tlet xMax = -Infinity;\n\tlet yMax = -Infinity;\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\tconst point = contour[j]!;\n\t\t\txMin = Math.min(xMin, point.x);\n\t\t\tyMin = Math.min(yMin, point.y);\n\t\t\txMax = Math.max(xMax, point.x);\n\t\t\tyMax = Math.max(yMax, point.y);\n\t\t}\n\t}\n\n\tconst compositeBounds =\n\t\txMin === Infinity ? null : { xMin, yMin, xMax, yMax };\n\n\treturn { contours, bounds: compositeBounds };\n}\n\n/**\n * Get bounding box for a glyph\n */\nexport function getGlyphBounds(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tglyphId: GlyphId,\n): { xMin: number; yMin: number; xMax: number; yMax: number } | null {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\txMin: glyph.xMin,\n\t\tyMin: glyph.yMin,\n\t\txMax: glyph.xMax,\n\t\tyMax: glyph.yMax,\n\t};\n}\n\n/**\n * Get all deltas for a glyph at given variation coordinates\n */\nexport function getGlyphDeltas(\n\tgvar: GvarTable,\n\tglyphId: GlyphId,\n\tnumPoints: number,\n\taxisCoords: number[],\n): PointDelta[] {\n\tconst glyphData = gvar.glyphVariationData[glyphId];\n\tif (!glyphData) {\n\t\treturn Array(numPoints).fill({ x: 0, y: 0 });\n\t}\n\n\t// Initialize deltas array\n\tconst deltas: PointDelta[] = Array(numPoints)\n\t\t.fill(null)\n\t\t.map(() => ({ x: 0, y: 0 }));\n\n\tfor (let i = 0; i < glyphData.tupleVariationHeaders.length; i++) {\n\t\tconst header = glyphData.tupleVariationHeaders[i]!;\n\t\tif (!header.peakTuple) continue;\n\n\t\tconst scalar = calculateTupleScalar(\n\t\t\theader.peakTuple,\n\t\t\taxisCoords,\n\t\t\theader.intermediateStartTuple,\n\t\t\theader.intermediateEndTuple,\n\t\t);\n\n\t\tif (scalar === 0) continue;\n\n\t\tif (header.pointNumbers !== null) {\n\t\t\t// Sparse point deltas\n\t\t\tfor (let j = 0; j < header.pointNumbers.length; j++) {\n\t\t\t\tconst pointIndex = header.pointNumbers[j]!;\n\t\t\t\tconst delta = deltas[pointIndex];\n\t\t\t\tconst headerDelta = header.deltas[j];\n\t\t\t\tif (pointIndex < numPoints && delta && headerDelta) {\n\t\t\t\t\tdelta.x += headerDelta.x * scalar;\n\t\t\t\t\tdelta.y += headerDelta.y * scalar;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// All points\n\t\t\tfor (let j = 0; j < Math.min(header.deltas.length, numPoints); j++) {\n\t\t\t\tconst delta = deltas[j];\n\t\t\t\tconst headerDelta = header.deltas[j];\n\t\t\t\tif (delta && headerDelta) {\n\t\t\t\t\tdelta.x += headerDelta.x * scalar;\n\t\t\t\t\tdelta.y += headerDelta.y * scalar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Round final values\n\tfor (let i = 0; i < deltas.length; i++) {\n\t\tconst d = deltas[i]!;\n\t\td.x = Math.round(d.x);\n\t\td.y = Math.round(d.y);\n\t}\n\n\treturn deltas;\n}\n\n/**\n * Apply variation deltas to contours\n */\nexport function applyVariationDeltas(\n\tcontours: Contour[],\n\tdeltas: PointDelta[],\n): Contour[] {\n\tconst result: Contour[] = [];\n\tlet pointIndex = 0;\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tconst newContour: Contour = [];\n\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\tconst point = contour[j]!;\n\t\t\tconst delta = deltas[pointIndex] ?? { x: 0, y: 0 };\n\t\t\tnewContour.push({\n\t\t\t\tx: point.x + delta.x,\n\t\t\t\ty: point.y + delta.y,\n\t\t\t\tonCurve: point.onCurve,\n\t\t\t});\n\t\t\tpointIndex++;\n\t\t}\n\t\tresult.push(newContour);\n\t}\n\n\treturn result;\n}\n\n/**\n * Get contours for a glyph with variation applied\n */\nexport function getGlyphContoursWithVariation(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tgvar: GvarTable | null,\n\tglyphId: GlyphId,\n\taxisCoords?: number[],\n): Contour[] {\n\tconst glyph = parseGlyph(glyf, loca, glyphId);\n\n\tif (glyph.type === \"empty\") {\n\t\treturn [];\n\t}\n\n\tlet contours: Contour[];\n\tif (glyph.type === \"simple\") {\n\t\tcontours = glyph.contours;\n\t} else {\n\t\tcontours = flattenCompositeGlyphWithVariation(\n\t\t\tglyf,\n\t\t\tloca,\n\t\t\tgvar,\n\t\t\tglyph,\n\t\t\taxisCoords,\n\t\t);\n\t}\n\n\t// Apply variation if we have gvar and axis coordinates\n\tif (gvar && axisCoords && axisCoords.length > 0) {\n\t\t// Count total points\n\t\tlet numPoints = 0;\n\t\tfor (let i = 0; i < contours.length; i++) {\n\t\t\tconst c = contours[i]!;\n\t\t\tnumPoints += c.length;\n\t\t}\n\t\t// Add phantom points (4)\n\t\tnumPoints += 4;\n\n\t\tconst deltas = getGlyphDeltas(gvar, glyphId, numPoints, axisCoords);\n\t\tcontours = applyVariationDeltas(contours, deltas);\n\t}\n\n\treturn contours;\n}\n\n/**\n * Flatten composite glyph with variation support\n */\nfunction flattenCompositeGlyphWithVariation(\n\tglyf: GlyfTable,\n\tloca: LocaTable,\n\tgvar: GvarTable | null,\n\tglyph: CompositeGlyph,\n\taxisCoords?: number[],\n\tdepth: number = 0,\n): Contour[] {\n\tif (depth > 32) {\n\t\treturn [];\n\t}\n\n\tconst result: Contour[] = [];\n\tconst parentPoints: GlyphPoint[] = [];\n\n\tfor (let i = 0; i < glyph.components.length; i++) {\n\t\tconst component = glyph.components[i]!;\n\t\tconst componentGlyph = parseGlyph(glyf, loca, component.glyphId);\n\n\t\tlet componentContours: Contour[];\n\t\tif (componentGlyph.type === \"simple\") {\n\t\t\tcomponentContours = componentGlyph.contours;\n\n\t\t\t// Apply variation to component\n\t\t\tif (gvar && axisCoords && axisCoords.length > 0) {\n\t\t\t\tlet numPoints = 0;\n\t\t\t\tfor (let j = 0; j < componentContours.length; j++) {\n\t\t\t\t\tconst c = componentContours[j]!;\n\t\t\t\t\tnumPoints += c.length;\n\t\t\t\t}\n\t\t\t\tnumPoints += 4; // phantom points\n\n\t\t\t\tconst deltas = getGlyphDeltas(\n\t\t\t\t\tgvar,\n\t\t\t\t\tcomponent.glyphId,\n\t\t\t\t\tnumPoints,\n\t\t\t\t\taxisCoords,\n\t\t\t\t);\n\t\t\t\tcomponentContours = applyVariationDeltas(componentContours, deltas);\n\t\t\t}\n\t\t} else if (componentGlyph.type === \"composite\") {\n\t\t\tcomponentContours = flattenCompositeGlyphWithVariation(\n\t\t\t\tglyf,\n\t\t\t\tloca,\n\t\t\t\tgvar,\n\t\t\t\tcomponentGlyph,\n\t\t\t\taxisCoords,\n\t\t\t\tdepth + 1,\n\t\t\t);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tappendComponentContours(result, parentPoints, component, componentContours);\n\t}\n\n\treturn result;\n}\n",
    "/**\n * Outline Transform Operations\n *\n * Provides geometric transformations for glyph outlines:\n * - 90 rotation\n * - Power-of-2 scaling\n * - 2D affine transforms (translate, rotate, scale, shear)\n * - 3D perspective transforms\n * - Bounding box computation\n */\n\nimport type { GlyphPath, PathCommand } from \"./path.ts\";\n\n/**\n * 2D affine transformation matrix [a, b, c, d, tx, ty]\n * Transforms point (x, y) to:\n *   x' = a*x + c*y + tx\n *   y' = b*x + d*y + ty\n */\nexport type Matrix2D = [number, number, number, number, number, number];\n\n/**\n * 3x3 transformation matrix for 2D homogeneous coordinates\n * | m00 m01 m02 |   | x |   | x' |\n * | m10 m11 m12 |  | y | = | y' |\n * | m20 m21 m22 |   | 1 |   | w  |\n *\n * Final coordinates: (x'/w, y'/w)\n */\nexport type Matrix3x3 = [\n\t[number, number, number],\n\t[number, number, number],\n\t[number, number, number],\n];\n\n/**\n * Axis-aligned bounding box\n */\nexport interface BoundingBox {\n\txMin: number;\n\tyMin: number;\n\txMax: number;\n\tyMax: number;\n}\n\n/**\n * Control box (bounding box of control points, not tight bounds)\n */\nexport interface ControlBox extends BoundingBox {}\n\n/**\n * Create identity 2D matrix\n */\nexport function identity2D(): Matrix2D {\n\treturn [1, 0, 0, 1, 0, 0];\n}\n\n/**\n * Create identity 3x3 matrix\n */\nexport function identity3x3(): Matrix3x3 {\n\treturn [\n\t\t[1, 0, 0],\n\t\t[0, 1, 0],\n\t\t[0, 0, 1],\n\t];\n}\n\n/**\n * Create translation matrix\n */\nexport function translate2D(tx: number, ty: number): Matrix2D {\n\treturn [1, 0, 0, 1, tx, ty];\n}\n\n/**\n * Create scale matrix\n */\nexport function scale2D(sx: number, sy: number): Matrix2D {\n\treturn [sx, 0, 0, sy, 0, 0];\n}\n\n/**\n * Create rotation matrix (angle in radians)\n */\nexport function rotate2D(angle: number): Matrix2D {\n\tconst cos = Math.cos(angle);\n\tconst sin = Math.sin(angle);\n\treturn [cos, sin, -sin, cos, 0, 0];\n}\n\n/**\n * Create shear/skew matrix\n */\nexport function shear2D(shearX: number, shearY: number): Matrix2D {\n\treturn [1, shearY, shearX, 1, 0, 0];\n}\n\n/**\n * Multiply two 2D matrices: result = a  b\n */\nexport function multiply2D(a: Matrix2D, b: Matrix2D): Matrix2D {\n\treturn [\n\t\ta[0] * b[0] + a[2] * b[1],\n\t\ta[1] * b[0] + a[3] * b[1],\n\t\ta[0] * b[2] + a[2] * b[3],\n\t\ta[1] * b[2] + a[3] * b[3],\n\t\ta[0] * b[4] + a[2] * b[5] + a[4],\n\t\ta[1] * b[4] + a[3] * b[5] + a[5],\n\t];\n}\n\n/**\n * Multiply two 3x3 matrices: result = a  b\n */\nexport function multiply3x3(a: Matrix3x3, b: Matrix3x3): Matrix3x3 {\n\tconst result: Matrix3x3 = [\n\t\t[0, 0, 0],\n\t\t[0, 0, 0],\n\t\t[0, 0, 0],\n\t];\n\tfor (let i = 0; i < 3; i++) {\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tresult[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Transform a point using 2D matrix\n */\nexport function transformPoint2D(\n\tx: number,\n\ty: number,\n\tm: Matrix2D,\n): { x: number; y: number } {\n\treturn {\n\t\tx: m[0] * x + m[2] * y + m[4],\n\t\ty: m[1] * x + m[3] * y + m[5],\n\t};\n}\n\n/**\n * Transform a point using 3x3 matrix (with perspective division)\n */\nexport function transformPoint3x3(\n\tx: number,\n\ty: number,\n\tm: Matrix3x3,\n): { x: number; y: number } {\n\tconst w = m[2][0] * x + m[2][1] * y + m[2][2];\n\t// Clamp w to prevent extreme coordinates when approaching or crossing zero\n\t// w <= 0 means point is at or behind the \"camera\" plane\n\t// w very small means coordinates would explode\n\tconst minW = 0.01;\n\tif (w < minW) {\n\t\t// Clamp to minimum positive w to prevent inversion and explosion\n\t\tconst clampedW = minW;\n\t\treturn {\n\t\t\tx: (m[0][0] * x + m[0][1] * y + m[0][2]) / clampedW,\n\t\t\ty: (m[1][0] * x + m[1][1] * y + m[1][2]) / clampedW,\n\t\t};\n\t}\n\treturn {\n\t\tx: (m[0][0] * x + m[0][1] * y + m[0][2]) / w,\n\t\ty: (m[1][0] * x + m[1][1] * y + m[1][2]) / w,\n\t};\n}\n\n/**\n * Rotate outline by 90 degrees counter-clockwise around origin\n * Optionally apply offset after rotation\n */\nexport function rotateOutline90(\n\tpath: GlyphPath,\n\toffsetX: number = 0,\n\toffsetY: number = 0,\n): GlyphPath {\n\t// 90 CCW rotation: (x, y) -> (-y, x)\n\tconst commands = path.commands.map((cmd): PathCommand => {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\tx: -cmd.y + offsetX,\n\t\t\t\t\ty: cmd.x + offsetY,\n\t\t\t\t};\n\t\t\tcase \"Q\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\tx1: -cmd.y1 + offsetX,\n\t\t\t\t\ty1: cmd.x1 + offsetY,\n\t\t\t\t\tx: -cmd.y + offsetX,\n\t\t\t\t\ty: cmd.x + offsetY,\n\t\t\t\t};\n\t\t\tcase \"C\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: -cmd.y1 + offsetX,\n\t\t\t\t\ty1: cmd.x1 + offsetY,\n\t\t\t\t\tx2: -cmd.y2 + offsetX,\n\t\t\t\t\ty2: cmd.x2 + offsetY,\n\t\t\t\t\tx: -cmd.y + offsetX,\n\t\t\t\t\ty: cmd.x + offsetY,\n\t\t\t\t};\n\t\t\tcase \"Z\":\n\t\t\t\treturn { type: \"Z\" };\n\t\t\tdefault:\n\t\t\t\treturn cmd;\n\t\t}\n\t});\n\n\t// Rotate bounds\n\tlet bounds: BoundingBox | null = null;\n\tif (path.bounds) {\n\t\tconst b = path.bounds;\n\t\tbounds = {\n\t\t\txMin: -b.yMax + offsetX,\n\t\t\tyMin: b.xMin + offsetY,\n\t\t\txMax: -b.yMin + offsetX,\n\t\t\tyMax: b.xMax + offsetY,\n\t\t};\n\t\t// Normalize (ensure min < max)\n\t\tif (bounds.xMin > bounds.xMax) {\n\t\t\t[bounds.xMin, bounds.xMax] = [bounds.xMax, bounds.xMin];\n\t\t}\n\t\tif (bounds.yMin > bounds.yMax) {\n\t\t\t[bounds.yMin, bounds.yMax] = [bounds.yMax, bounds.yMin];\n\t\t}\n\t}\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Scale outline by power of 2\n * scaleOrdX/Y: shift amount (positive = enlarge, negative = shrink)\n * e.g., scaleOrdX=1 means multiply x by 2, scaleOrdX=-1 means divide by 2\n */\nexport function scaleOutlinePow2(\n\tpath: GlyphPath,\n\tscaleOrdX: number,\n\tscaleOrdY: number,\n): GlyphPath {\n\tconst scaleX = scaleOrdX >= 0 ? 1 << scaleOrdX : 1 / (1 << -scaleOrdX);\n\tconst scaleY = scaleOrdY >= 0 ? 1 << scaleOrdY : 1 / (1 << -scaleOrdY);\n\n\tconst commands = path.commands.map((cmd): PathCommand => {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\tx: cmd.x * scaleX,\n\t\t\t\t\ty: cmd.y * scaleY,\n\t\t\t\t};\n\t\t\tcase \"Q\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\tx1: cmd.x1 * scaleX,\n\t\t\t\t\ty1: cmd.y1 * scaleY,\n\t\t\t\t\tx: cmd.x * scaleX,\n\t\t\t\t\ty: cmd.y * scaleY,\n\t\t\t\t};\n\t\t\tcase \"C\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: cmd.x1 * scaleX,\n\t\t\t\t\ty1: cmd.y1 * scaleY,\n\t\t\t\t\tx2: cmd.x2 * scaleX,\n\t\t\t\t\ty2: cmd.y2 * scaleY,\n\t\t\t\t\tx: cmd.x * scaleX,\n\t\t\t\t\ty: cmd.y * scaleY,\n\t\t\t\t};\n\t\t\tcase \"Z\":\n\t\t\t\treturn { type: \"Z\" };\n\t\t\tdefault:\n\t\t\t\treturn cmd;\n\t\t}\n\t});\n\n\tlet bounds: BoundingBox | null = null;\n\tif (path.bounds) {\n\t\tbounds = {\n\t\t\txMin: path.bounds.xMin * scaleX,\n\t\t\tyMin: path.bounds.yMin * scaleY,\n\t\t\txMax: path.bounds.xMax * scaleX,\n\t\t\tyMax: path.bounds.yMax * scaleY,\n\t\t};\n\t}\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Apply 2D affine transformation to outline\n */\nexport function transformOutline2D(path: GlyphPath, m: Matrix2D): GlyphPath {\n\tconst commands = path.commands.map((cmd): PathCommand => {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y, m);\n\t\t\t\treturn { type: cmd.type, x: p.x, y: p.y };\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint2D(cmd.x1, cmd.y1, m);\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y, m);\n\t\t\t\treturn { type: \"Q\", x1: p1.x, y1: p1.y, x: p.x, y: p.y };\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst cp1 = transformPoint2D(cmd.x1, cmd.y1, m);\n\t\t\t\tconst cp2 = transformPoint2D(cmd.x2, cmd.y2, m);\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y, m);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: cp1.x,\n\t\t\t\t\ty1: cp1.y,\n\t\t\t\t\tx2: cp2.x,\n\t\t\t\t\ty2: cp2.y,\n\t\t\t\t\tx: p.x,\n\t\t\t\t\ty: p.y,\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\treturn { type: \"Z\" };\n\t\t\tdefault:\n\t\t\t\treturn cmd;\n\t\t}\n\t});\n\n\t// Compute new bounds by transforming corners\n\tlet bounds: BoundingBox | null = null;\n\tif (path.bounds) {\n\t\tconst b = path.bounds;\n\t\tconst corners = [\n\t\t\ttransformPoint2D(b.xMin, b.yMin, m),\n\t\t\ttransformPoint2D(b.xMax, b.yMin, m),\n\t\t\ttransformPoint2D(b.xMin, b.yMax, m),\n\t\t\ttransformPoint2D(b.xMax, b.yMax, m),\n\t\t];\n\t\tbounds = {\n\t\t\txMin: Math.min(...corners.map((c) => c.x)),\n\t\t\tyMin: Math.min(...corners.map((c) => c.y)),\n\t\t\txMax: Math.max(...corners.map((c) => c.x)),\n\t\t\tyMax: Math.max(...corners.map((c) => c.y)),\n\t\t};\n\t}\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Apply 3D perspective transformation to outline\n * Uses homogeneous coordinates for perspective projection\n */\nexport function transformOutline3D(path: GlyphPath, m: Matrix3x3): GlyphPath {\n\tconst commands = path.commands.map((cmd): PathCommand => {\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y, m);\n\t\t\t\treturn { type: cmd.type, x: p.x, y: p.y };\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\t// For perspective transforms, we need to subdivide curves\n\t\t\t\t// because Bzier curves don't preserve under perspective\n\t\t\t\t// For now, transform control points (approximation)\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1, m);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y, m);\n\t\t\t\treturn { type: \"Q\", x1: p1.x, y1: p1.y, x: p.x, y: p.y };\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1, m);\n\t\t\t\tconst p2 = transformPoint3x3(cmd.x2, cmd.y2, m);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y, m);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: p1.x,\n\t\t\t\t\ty1: p1.y,\n\t\t\t\t\tx2: p2.x,\n\t\t\t\t\ty2: p2.y,\n\t\t\t\t\tx: p.x,\n\t\t\t\t\ty: p.y,\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\treturn { type: \"Z\" };\n\t\t\tdefault:\n\t\t\t\treturn cmd;\n\t\t}\n\t});\n\n\t// Compute new bounds\n\tlet bounds: BoundingBox | null = null;\n\tif (path.bounds) {\n\t\tconst b = path.bounds;\n\t\tconst corners = [\n\t\t\ttransformPoint3x3(b.xMin, b.yMin, m),\n\t\t\ttransformPoint3x3(b.xMax, b.yMin, m),\n\t\t\ttransformPoint3x3(b.xMin, b.yMax, m),\n\t\t\ttransformPoint3x3(b.xMax, b.yMax, m),\n\t\t];\n\t\tbounds = {\n\t\t\txMin: Math.min(...corners.map((c) => c.x)),\n\t\t\tyMin: Math.min(...corners.map((c) => c.y)),\n\t\t\txMax: Math.max(...corners.map((c) => c.x)),\n\t\t\tyMax: Math.max(...corners.map((c) => c.y)),\n\t\t};\n\t}\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Compute control box (bounding box of all control points)\n * This is faster than computing tight bounds but may be larger\n */\nexport function computeControlBox(path: GlyphPath): ControlBox {\n\tlet xMin = Infinity;\n\tlet yMin = Infinity;\n\tlet xMax = -Infinity;\n\tlet yMax = -Infinity;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\txMin = Math.min(xMin, cmd.x);\n\t\t\t\tyMin = Math.min(yMin, cmd.y);\n\t\t\t\txMax = Math.max(xMax, cmd.x);\n\t\t\t\tyMax = Math.max(yMax, cmd.y);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\txMin = Math.min(xMin, cmd.x1, cmd.x);\n\t\t\t\tyMin = Math.min(yMin, cmd.y1, cmd.y);\n\t\t\t\txMax = Math.max(xMax, cmd.x1, cmd.x);\n\t\t\t\tyMax = Math.max(yMax, cmd.y1, cmd.y);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\txMin = Math.min(xMin, cmd.x1, cmd.x2, cmd.x);\n\t\t\t\tyMin = Math.min(yMin, cmd.y1, cmd.y2, cmd.y);\n\t\t\t\txMax = Math.max(xMax, cmd.x1, cmd.x2, cmd.x);\n\t\t\t\tyMax = Math.max(yMax, cmd.y1, cmd.y2, cmd.y);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!Number.isFinite(xMin)) {\n\t\treturn { xMin: 0, yMin: 0, xMax: 0, yMax: 0 };\n\t}\n\n\treturn { xMin, yMin, xMax, yMax };\n}\n\n/**\n * Find extrema of a quadratic Bzier curve\n * Returns t values in [0, 1] where extrema occur\n */\nfunction quadraticExtrema(p0: number, p1: number, p2: number): number[] {\n\t// Derivative: 2(1-t)(p1-p0) + 2t(p2-p1) = 0\n\t// => t = (p0-p1) / (p0 - 2p1 + p2)\n\tconst denom = p0 - 2 * p1 + p2;\n\tif (Math.abs(denom) < 1e-10) return [];\n\tconst t = (p0 - p1) / denom;\n\tif (t > 0 && t < 1) return [t];\n\treturn [];\n}\n\n/**\n * Find extrema of a cubic Bzier curve\n * Returns t values in [0, 1] where extrema occur\n */\nfunction cubicExtrema(\n\tp0: number,\n\tp1: number,\n\tp2: number,\n\tp3: number,\n): number[] {\n\t// Derivative coefficients\n\tconst a = -p0 + 3 * p1 - 3 * p2 + p3;\n\tconst b = 2 * (p0 - 2 * p1 + p2);\n\tconst c = -p0 + p1;\n\n\tconst result: number[] = [];\n\n\tif (Math.abs(a) < 1e-10) {\n\t\t// Linear: b*t + c = 0\n\t\tif (Math.abs(b) > 1e-10) {\n\t\t\tconst t = -c / b;\n\t\t\tif (t > 0 && t < 1) result.push(t);\n\t\t}\n\t} else {\n\t\t// Quadratic: a*t + b*t + c = 0\n\t\tconst disc = b * b - 4 * a * c;\n\t\tif (disc >= 0) {\n\t\t\tconst sqrtDisc = Math.sqrt(disc);\n\t\t\tconst t1 = (-b + sqrtDisc) / (2 * a);\n\t\t\tconst t2 = (-b - sqrtDisc) / (2 * a);\n\t\t\tif (t1 > 0 && t1 < 1) result.push(t1);\n\t\t\tif (t2 > 0 && t2 < 1) result.push(t2);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Evaluate quadratic Bzier at t\n */\nfunction evalQuadratic(p0: number, p1: number, p2: number, t: number): number {\n\tconst ti = 1 - t;\n\treturn ti * ti * p0 + 2 * ti * t * p1 + t * t * p2;\n}\n\n/**\n * Evaluate cubic Bzier at t\n */\nfunction evalCubic(\n\tp0: number,\n\tp1: number,\n\tp2: number,\n\tp3: number,\n\tt: number,\n): number {\n\tconst ti = 1 - t;\n\treturn (\n\t\tti * ti * ti * p0 +\n\t\t3 * ti * ti * t * p1 +\n\t\t3 * ti * t * t * p2 +\n\t\tt * t * t * p3\n\t);\n}\n\n/**\n * Compute tight bounding box (exact bounds considering curve extrema)\n */\nexport function computeTightBounds(path: GlyphPath): BoundingBox {\n\tlet xMin = Infinity;\n\tlet yMin = Infinity;\n\tlet xMax = -Infinity;\n\tlet yMax = -Infinity;\n\n\tlet curX = 0;\n\tlet curY = 0;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tcurX = cmd.x;\n\t\t\t\tcurY = cmd.y;\n\t\t\t\txMin = Math.min(xMin, curX);\n\t\t\t\tyMin = Math.min(yMin, curY);\n\t\t\t\txMax = Math.max(xMax, curX);\n\t\t\t\tyMax = Math.max(yMax, curY);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tcurX = cmd.x;\n\t\t\t\tcurY = cmd.y;\n\t\t\t\txMin = Math.min(xMin, curX);\n\t\t\t\tyMin = Math.min(yMin, curY);\n\t\t\t\txMax = Math.max(xMax, curX);\n\t\t\t\tyMax = Math.max(yMax, curY);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\": {\n\t\t\t\t// Endpoints\n\t\t\t\txMin = Math.min(xMin, cmd.x);\n\t\t\t\tyMin = Math.min(yMin, cmd.y);\n\t\t\t\txMax = Math.max(xMax, cmd.x);\n\t\t\t\tyMax = Math.max(yMax, cmd.y);\n\t\t\t\t// Extrema\n\t\t\t\tconst xExtrema = quadraticExtrema(curX, cmd.x1, cmd.x);\n\t\t\t\tfor (let j = 0; j < xExtrema.length; j++) {\n\t\t\t\t\tconst t = xExtrema[j]!;\n\t\t\t\t\tconst x = evalQuadratic(curX, cmd.x1, cmd.x, t);\n\t\t\t\t\txMin = Math.min(xMin, x);\n\t\t\t\t\txMax = Math.max(xMax, x);\n\t\t\t\t}\n\t\t\t\tconst yExtrema = quadraticExtrema(curY, cmd.y1, cmd.y);\n\t\t\t\tfor (let j = 0; j < yExtrema.length; j++) {\n\t\t\t\t\tconst t = yExtrema[j]!;\n\t\t\t\t\tconst y = evalQuadratic(curY, cmd.y1, cmd.y, t);\n\t\t\t\t\tyMin = Math.min(yMin, y);\n\t\t\t\t\tyMax = Math.max(yMax, y);\n\t\t\t\t}\n\t\t\t\tcurX = cmd.x;\n\t\t\t\tcurY = cmd.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\t// Endpoints\n\t\t\t\txMin = Math.min(xMin, cmd.x);\n\t\t\t\tyMin = Math.min(yMin, cmd.y);\n\t\t\t\txMax = Math.max(xMax, cmd.x);\n\t\t\t\tyMax = Math.max(yMax, cmd.y);\n\t\t\t\t// Extrema\n\t\t\t\tconst xExtrema = cubicExtrema(curX, cmd.x1, cmd.x2, cmd.x);\n\t\t\t\tfor (let j = 0; j < xExtrema.length; j++) {\n\t\t\t\t\tconst t = xExtrema[j]!;\n\t\t\t\t\tconst x = evalCubic(curX, cmd.x1, cmd.x2, cmd.x, t);\n\t\t\t\t\txMin = Math.min(xMin, x);\n\t\t\t\t\txMax = Math.max(xMax, x);\n\t\t\t\t}\n\t\t\t\tconst yExtrema = cubicExtrema(curY, cmd.y1, cmd.y2, cmd.y);\n\t\t\t\tfor (let j = 0; j < yExtrema.length; j++) {\n\t\t\t\t\tconst t = yExtrema[j]!;\n\t\t\t\t\tconst y = evalCubic(curY, cmd.y1, cmd.y2, cmd.y, t);\n\t\t\t\t\tyMin = Math.min(yMin, y);\n\t\t\t\t\tyMax = Math.max(yMax, y);\n\t\t\t\t}\n\t\t\t\tcurX = cmd.x;\n\t\t\t\tcurY = cmd.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!Number.isFinite(xMin)) {\n\t\treturn { xMin: 0, yMin: 0, xMax: 0, yMax: 0 };\n\t}\n\n\treturn { xMin, yMin, xMax, yMax };\n}\n\n/**\n * Update control box with transformed outline\n * Used for finding minimum X after 3D transform (like libass)\n */\nexport function updateMinTransformedX(\n\tpath: GlyphPath,\n\tm: Matrix3x3,\n\tcurrentMinX: number,\n): number {\n\tlet minX = currentMinX;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y, m);\n\t\t\t\tminX = Math.min(minX, p.x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1, m);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y, m);\n\t\t\t\tminX = Math.min(minX, p1.x, p.x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1, m);\n\t\t\t\tconst p2 = transformPoint3x3(cmd.x2, cmd.y2, m);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y, m);\n\t\t\t\tminX = Math.min(minX, p1.x, p2.x, p.x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minX;\n}\n\n/**\n * Translate outline by offset\n */\nexport function translateOutline(\n\tpath: GlyphPath,\n\tdx: number,\n\tdy: number,\n): GlyphPath {\n\treturn transformOutline2D(path, translate2D(dx, dy));\n}\n\n/**\n * Scale outline uniformly\n */\nexport function scaleOutline(\n\tpath: GlyphPath,\n\tsx: number,\n\tsy: number = sx,\n): GlyphPath {\n\treturn transformOutline2D(path, scale2D(sx, sy));\n}\n\n/**\n * Rotate outline by angle (in radians) around origin\n */\nexport function rotateOutline(path: GlyphPath, angle: number): GlyphPath {\n\treturn transformOutline2D(path, rotate2D(angle));\n}\n\n/**\n * Apply italic/oblique shear to outline\n * @param angle Italic angle in degrees (typically 12-15 for italic)\n */\nexport function italicizeOutline(path: GlyphPath, angle: number): GlyphPath {\n\tconst shearX = Math.tan((angle * Math.PI) / 180);\n\treturn transformOutline2D(path, shear2D(shearX, 0));\n}\n\n/**\n * Create 3x3 perspective matrix\n * @param vanishingPointX X coordinate of vanishing point\n * @param vanishingPointY Y coordinate of vanishing point\n * @param strength Perspective strength (0 = none, larger = more perspective)\n */\nexport function perspectiveMatrix(\n\tvanishingPointX: number,\n\tvanishingPointY: number,\n\tstrength: number,\n): Matrix3x3 {\n\treturn [\n\t\t[1, 0, -vanishingPointX * strength],\n\t\t[0, 1, -vanishingPointY * strength],\n\t\t[0, 0, 1],\n\t];\n}\n\n/**\n * Combine multiple paths into one\n */\nexport function combinePaths(paths: GlyphPath[]): GlyphPath {\n\tconst commands: PathCommand[] = [];\n\tlet xMin = Infinity;\n\tlet yMin = Infinity;\n\tlet xMax = -Infinity;\n\tlet yMax = -Infinity;\n\n\tfor (let i = 0; i < paths.length; i++) {\n\t\tconst path = paths[i]!;\n\t\tcommands.push(...path.commands);\n\t\tif (path.bounds) {\n\t\t\txMin = Math.min(xMin, path.bounds.xMin);\n\t\t\tyMin = Math.min(yMin, path.bounds.yMin);\n\t\t\txMax = Math.max(xMax, path.bounds.xMax);\n\t\t\tyMax = Math.max(yMax, path.bounds.yMax);\n\t\t}\n\t}\n\n\tconst bounds = Number.isFinite(xMin) ? { xMin, yMin, xMax, yMax } : null;\n\treturn { commands, bounds };\n}\n\n/**\n * Clone a path\n */\nexport function clonePath(path: GlyphPath): GlyphPath {\n\treturn {\n\t\tcommands: path.commands.map((cmd) => ({ ...cmd })),\n\t\tbounds: path.bounds ? { ...path.bounds } : null,\n\t\tflags: path.flags,\n\t};\n}\n",
    "import type { GlyphBuffer } from \"../buffer/glyph-buffer.ts\";\nimport type { Font } from \"../font/font.ts\";\nimport type { Contour, GlyphPoint } from \"../font/tables/glyf.ts\";\nimport type { GlyphId } from \"../types.ts\";\nimport {\n\ttype Matrix2D,\n\ttype Matrix3x3,\n\ttransformPoint2D,\n\ttransformPoint3x3,\n} from \"./outline-transform.ts\";\n\n/**\n * Path command types for glyph rendering\n */\nexport type PathCommand =\n\t| { type: \"M\"; x: number; y: number }\n\t| { type: \"L\"; x: number; y: number }\n\t| { type: \"Q\"; x1: number; y1: number; x: number; y: number }\n\t| {\n\t\t\ttype: \"C\";\n\t\t\tx1: number;\n\t\t\ty1: number;\n\t\t\tx2: number;\n\t\t\ty2: number;\n\t\t\tx: number;\n\t\t\ty: number;\n\t  }\n\t| { type: \"Z\" };\n\n/**\n * Outline flags (like FreeType's FT_OUTLINE_* flags)\n */\nexport enum OutlineFlags {\n\t/** No flags */\n\tNone = 0,\n\t/** Use even-odd fill rule instead of non-zero winding */\n\tEvenOddFill = 1 << 0,\n\t/** Outline has been hinted */\n\tHighPrecision = 1 << 1,\n\t/** Outline is a single stroke (not filled) */\n\tSinglePass = 1 << 2,\n}\n\n/**\n * A glyph path is a series of drawing commands\n */\nexport interface GlyphPath {\n\tcommands: PathCommand[];\n\tbounds: { xMin: number; yMin: number; xMax: number; yMax: number } | null;\n\t/** Outline flags (like FreeType's FT_OUTLINE_* flags) */\n\tflags?: OutlineFlags;\n}\n\n/**\n * Convert contours to path commands\n * Handles both TrueType (quadratic Bziers) and CFF (cubic Bziers)\n */\nexport function contourToPath(contour: Contour): PathCommand[] {\n\tif (contour.length === 0) return [];\n\n\t// Fast check: if first off-curve point is cubic, use cubic path\n\t// CFF glyphs always have cubic control points, TrueType never does\n\tfor (let i = 0; i < contour.length; i++) {\n\t\tconst p = contour[i]!;\n\t\tif (!p.onCurve) {\n\t\t\treturn p.cubic\n\t\t\t\t? contourToPathCubic(contour)\n\t\t\t\t: contourToPathQuadratic(contour);\n\t\t}\n\t}\n\n\t// All points on-curve (rare, but possible) - use quadratic\n\treturn contourToPathQuadratic(contour);\n}\n\n/**\n * Convert CFF contour (cubic beziers) to path commands\n */\nfunction contourToPathCubic(contour: Contour): PathCommand[] {\n\tif (contour.length === 0) return [];\n\n\tconst commands: PathCommand[] = [];\n\tlet i = 0;\n\n\t// First point should be on-curve (moveto)\n\tconst first = contour[0];\n\tif (!first) return [];\n\n\tcommands.push({ type: \"M\", x: first.x, y: first.y });\n\ti = 1;\n\n\twhile (i < contour.length) {\n\t\tconst point = contour[i];\n\t\tif (!point) break;\n\n\t\tif (point.onCurve) {\n\t\t\t// Line to\n\t\t\tcommands.push({ type: \"L\", x: point.x, y: point.y });\n\t\t\ti++;\n\t\t} else if (point.cubic) {\n\t\t\t// Cubic bezier: expect cp1, cp2, endpoint\n\t\t\tconst cp1 = point;\n\t\t\tconst cp2 = contour[i + 1];\n\t\t\tconst end = contour[i + 2];\n\n\t\t\tif (!cp2 || !end) {\n\t\t\t\t// Malformed, skip\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcommands.push({\n\t\t\t\ttype: \"C\",\n\t\t\t\tx1: cp1.x,\n\t\t\t\ty1: cp1.y,\n\t\t\t\tx2: cp2.x,\n\t\t\t\ty2: cp2.y,\n\t\t\t\tx: end.x,\n\t\t\t\ty: end.y,\n\t\t\t});\n\t\t\ti += 3;\n\t\t} else {\n\t\t\t// Quadratic bezier (shouldn't happen in CFF but handle anyway)\n\t\t\tconst cp = point;\n\t\t\tconst next = contour[i + 1];\n\t\t\tif (!next) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet endPoint: GlyphPoint;\n\t\t\tif (next.onCurve) {\n\t\t\t\tendPoint = next;\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\tendPoint = {\n\t\t\t\t\tx: (cp.x + next.x) / 2,\n\t\t\t\t\ty: (cp.y + next.y) / 2,\n\t\t\t\t\tonCurve: true,\n\t\t\t\t};\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tcommands.push({\n\t\t\t\ttype: \"Q\",\n\t\t\t\tx1: cp.x,\n\t\t\t\ty1: cp.y,\n\t\t\t\tx: endPoint.x,\n\t\t\t\ty: endPoint.y,\n\t\t\t});\n\t\t}\n\t}\n\n\tcommands.push({ type: \"Z\" });\n\treturn commands;\n}\n\n/**\n * Convert TrueType contour (quadratic beziers) to path commands\n */\nfunction contourToPathQuadratic(contour: Contour): PathCommand[] {\n\tif (contour.length === 0) return [];\n\n\tconst commands: PathCommand[] = [];\n\n\t// Find the first on-curve point to start\n\tlet startIndex = 0;\n\tfor (let i = 0; i < contour.length; i++) {\n\t\tconst point = contour[i]!;\n\t\tif (point.onCurve) {\n\t\t\tstartIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If all points are off-curve, calculate implied on-curve point\n\tconst allOffCurve = contour.every((p) => !p.onCurve);\n\tlet startPoint: GlyphPoint;\n\n\tif (allOffCurve) {\n\t\t// Start at midpoint between first and last off-curve points\n\t\tconst first = contour[0];\n\t\tconst last = contour[contour.length - 1];\n\t\tif (!first || !last) return [];\n\t\tstartPoint = {\n\t\t\tx: (first.x + last.x) / 2,\n\t\t\ty: (first.y + last.y) / 2,\n\t\t\tonCurve: true,\n\t\t};\n\t\tstartIndex = 0;\n\t} else {\n\t\tconst point = contour[startIndex];\n\t\tif (!point) return [];\n\t\tstartPoint = point;\n\t}\n\n\tcommands.push({ type: \"M\", x: startPoint.x, y: startPoint.y });\n\n\tconst n = contour.length;\n\t// Replace modulo with conditional increment for better performance\n\tlet i = allOffCurve ? 0 : startIndex + 1;\n\tif (i >= n) i = 0;\n\tlet current = startPoint;\n\tlet iterations = 0;\n\n\twhile (iterations < n) {\n\t\tconst point = contour[i];\n\t\tif (!point) break;\n\n\t\tif (point.onCurve) {\n\t\t\t// Line to on-curve point\n\t\t\tcommands.push({ type: \"L\", x: point.x, y: point.y });\n\t\t\tcurrent = point;\n\t\t} else {\n\t\t\t// Off-curve point - need to find the end point\n\t\t\tconst nextIndex = i + 1 < n ? i + 1 : 0;\n\t\t\tconst nextPoint = contour[nextIndex];\n\t\t\tif (!nextPoint) break;\n\n\t\t\tlet endPoint: GlyphPoint;\n\t\t\tif (nextPoint.onCurve) {\n\t\t\t\t// Next point is on-curve, use it directly\n\t\t\t\tendPoint = nextPoint;\n\t\t\t\ti = nextIndex;\n\t\t\t\titerations++;\n\t\t\t} else {\n\t\t\t\t// Next point is also off-curve, calculate implied on-curve point\n\t\t\t\tendPoint = {\n\t\t\t\t\tx: (point.x + nextPoint.x) / 2,\n\t\t\t\t\ty: (point.y + nextPoint.y) / 2,\n\t\t\t\t\tonCurve: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Quadratic Bzier curve\n\t\t\tcommands.push({\n\t\t\t\ttype: \"Q\",\n\t\t\t\tx1: point.x,\n\t\t\t\ty1: point.y,\n\t\t\t\tx: endPoint.x,\n\t\t\t\ty: endPoint.y,\n\t\t\t});\n\t\t\tcurrent = endPoint;\n\t\t}\n\n\t\t// Replace modulo with conditional increment\n\t\ti++;\n\t\tif (i >= n) i = 0;\n\t\titerations++;\n\n\t\t// Check if we've returned to start\n\t\tif (current.x === startPoint.x && current.y === startPoint.y) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Close the path\n\tcommands.push({ type: \"Z\" });\n\n\treturn commands;\n}\n\n/**\n * Get path commands for a glyph\n */\n// Path cache: WeakMap allows garbage collection when Font is no longer referenced\nconst pathCache = new WeakMap<Font, Map<GlyphId, GlyphPath | null>>();\n\n/**\n * Get cached glyph path, computing and caching if not already cached\n */\nexport function getGlyphPath(font: Font, glyphId: GlyphId): GlyphPath | null {\n\t// Check cache first\n\tlet fontCache = pathCache.get(font);\n\tif (fontCache) {\n\t\tconst cached = fontCache.get(glyphId);\n\t\tif (cached !== undefined) return cached;\n\t}\n\n\t// Compute path\n\tconst result = font.getGlyphContoursAndBounds(glyphId);\n\tif (!result) {\n\t\t// Cache null result too to avoid recomputing\n\t\tif (!fontCache) {\n\t\t\tfontCache = new Map();\n\t\t\tpathCache.set(font, fontCache);\n\t\t}\n\t\tfontCache.set(glyphId, null);\n\t\treturn null;\n\t}\n\n\tconst commands: PathCommand[] = [];\n\tfor (let i = 0; i < result.contours.length; i++) {\n\t\tconst contour = result.contours[i]!;\n\t\tcommands.push(...contourToPath(contour));\n\t}\n\n\tconst path: GlyphPath = { commands, bounds: result.bounds };\n\n\t// Cache and return\n\tif (!fontCache) {\n\t\tfontCache = new Map();\n\t\tpathCache.set(font, fontCache);\n\t}\n\tfontCache.set(glyphId, path);\n\treturn path;\n}\n\n/**\n * SVG coordinate scaling factor for sub-pixel precision.\n * Path data is output at 10x scale with integer coordinates,\n * viewBox is scaled to match, giving 0.1px precision with integer performance.\n */\nexport const SVG_SCALE = 10;\n\n// Cache for default SVG strings (flipY=true, scale=1)\nconst svgCache = new WeakMap<GlyphPath, string>();\n\n/**\n * Convert path commands to SVG path data string\n * Outputs at SVG_SCALE (10x) with integer coordinates for performance\n * Caches results for default options (flipY=true, scale=1)\n */\nexport function pathToSVG(\n\tpath: GlyphPath,\n\toptions?: { flipY?: boolean; scale?: number },\n): string {\n\tconst scale = options?.scale ?? 1;\n\tconst flipY = options?.flipY ?? true;\n\n\t// Use cache for default options\n\tif (scale === 1 && flipY) {\n\t\tconst cached = svgCache.get(path);\n\t\tif (cached) return cached;\n\t}\n\n\tconst s = scale * SVG_SCALE;\n\tconst ys = flipY ? -s : s;\n\n\tlet result = \"\";\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tif (i > 0) result += \" \";\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tresult += \"M \" + Math.round(cmd.x * s) + \" \" + Math.round(cmd.y * ys);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tresult += \"L \" + Math.round(cmd.x * s) + \" \" + Math.round(cmd.y * ys);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tresult +=\n\t\t\t\t\t\"Q \" +\n\t\t\t\t\tMath.round(cmd.x1 * s) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y1 * ys) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.x * s) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y * ys);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tresult +=\n\t\t\t\t\t\"C \" +\n\t\t\t\t\tMath.round(cmd.x1 * s) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y1 * ys) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.x2 * s) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y2 * ys) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.x * s) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y * ys);\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tresult += \"Z\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Cache for default options\n\tif (scale === 1 && flipY) {\n\t\tsvgCache.set(path, result);\n\t}\n\n\treturn result;\n}\n\n/**\n * Render options for stroke/fill\n */\nexport interface RenderOptions {\n\tflipY?: boolean;\n\tscale?: number;\n\toffsetX?: number;\n\toffsetY?: number;\n\tfill?: string;\n\tstroke?: string;\n\tstrokeWidth?: number;\n\tlineCap?: CanvasLineCap;\n\tlineJoin?: CanvasLineJoin;\n\tmiterLimit?: number;\n}\n\n/**\n * Render path commands to a Canvas 2D context\n */\nexport function pathToCanvas(\n\tctx: CanvasRenderingContext2D | Path2D,\n\tpath: GlyphPath,\n\toptions?: {\n\t\tflipY?: boolean;\n\t\tscale?: number;\n\t\toffsetX?: number;\n\t\toffsetY?: number;\n\t},\n): void {\n\tconst scale = options?.scale ?? 1;\n\tconst flipY = options?.flipY ?? true;\n\tconst offsetX = options?.offsetX ?? 0;\n\tconst offsetY = options?.offsetY ?? 0;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tctx.moveTo(\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tctx.lineTo(\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tctx.quadraticCurveTo(\n\t\t\t\t\tcmd.x1 * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y1 : cmd.y1) * scale + offsetY,\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tctx.bezierCurveTo(\n\t\t\t\t\tcmd.x1 * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y1 : cmd.y1) * scale + offsetY,\n\t\t\t\t\tcmd.x2 * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y2 : cmd.y2) * scale + offsetY,\n\t\t\t\t\tcmd.x * scale + offsetX,\n\t\t\t\t\t(flipY ? -cmd.y : cmd.y) * scale + offsetY,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Generate an SVG element for a glyph\n */\nexport function glyphToSVG(\n\tfont: Font,\n\tglyphId: GlyphId,\n\toptions?: {\n\t\tfontSize?: number;\n\t\tfill?: string;\n\t\tstroke?: string;\n\t\tstrokeWidth?: number;\n\t},\n): string | null {\n\tconst path = getGlyphPath(font, glyphId);\n\tif (!path) return null;\n\n\tconst fontSize = options?.fontSize ?? 100;\n\tconst fill = options?.fill ?? \"currentColor\";\n\tconst stroke = options?.stroke;\n\tconst strokeWidth = options?.strokeWidth ?? 1;\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tconst bounds = path.bounds;\n\tif (!bounds) return null;\n\n\t// Add stroke width to bounds for proper sizing\n\tconst strokePadding = stroke ? strokeWidth / 2 : 0;\n\tconst width = Math.ceil(\n\t\t(bounds.xMax - bounds.xMin) * scale + strokePadding * 2,\n\t);\n\tconst height = Math.ceil(\n\t\t(bounds.yMax - bounds.yMin) * scale + strokePadding * 2,\n\t);\n\t// ViewBox is scaled by SVG_SCALE to match path coordinates\n\tconst vbX = Math.round((bounds.xMin - strokePadding) * SVG_SCALE);\n\tconst vbY = Math.round((-bounds.yMax - strokePadding) * SVG_SCALE);\n\tconst vbW = Math.round((bounds.xMax - bounds.xMin + strokePadding * 2) * SVG_SCALE);\n\tconst vbH = Math.round((bounds.yMax - bounds.yMin + strokePadding * 2) * SVG_SCALE);\n\tconst viewBox = `${vbX} ${vbY} ${vbW} ${vbH}`;\n\n\tconst pathData = pathToSVG(path, { flipY: true, scale: 1 });\n\n\tconst strokeAttr = stroke\n\t\t? ` stroke=\"${stroke}\" stroke-width=\"${strokeWidth * SVG_SCALE}\"`\n\t\t: \"\";\n\n\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${pathData}\" fill=\"${fill}\"${strokeAttr}/>\n</svg>`;\n}\n\n/**\n * Render shaped text to Canvas\n */\nexport interface ShapedGlyph {\n\tglyphId: GlyphId;\n\txOffset: number;\n\tyOffset: number;\n\txAdvance: number;\n\tyAdvance: number;\n}\n\nexport function renderShapedText(\n\tctx: CanvasRenderingContext2D,\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\toptions?: {\n\t\tfontSize?: number;\n\t\tx?: number;\n\t\ty?: number;\n\t\tfill?: string;\n\t\tstroke?: string;\n\t\tstrokeWidth?: number;\n\t\tlineCap?: CanvasLineCap;\n\t\tlineJoin?: CanvasLineJoin;\n\t\t/** 2D affine matrix to apply to glyph coordinates */\n\t\tmatrix?: Matrix2D;\n\t\t/** 3D perspective matrix to apply to glyph coordinates (takes precedence over matrix) */\n\t\tmatrix3D?: Matrix3x3;\n\t},\n): void {\n\tconst fontSize = options?.fontSize ?? 16;\n\tconst startX = options?.x ?? 0;\n\tconst startY = options?.y ?? 0;\n\tconst fill = options?.fill ?? \"black\";\n\tconst stroke = options?.stroke;\n\tconst strokeWidth = options?.strokeWidth ?? 1;\n\tconst matrix = options?.matrix;\n\tconst matrix3D = options?.matrix3D;\n\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tctx.fillStyle = fill;\n\tif (stroke) {\n\t\tctx.strokeStyle = stroke;\n\t\tctx.lineWidth = strokeWidth * scale;\n\t\tif (options?.lineCap) ctx.lineCap = options.lineCap;\n\t\tif (options?.lineJoin) ctx.lineJoin = options.lineJoin;\n\t}\n\n\tlet x = startX;\n\tlet y = startY;\n\n\tfor (let i = 0; i < glyphs.length; i++) {\n\t\tconst glyph = glyphs[i]!;\n\t\tconst path = getGlyphPath(font, glyph.glyphId);\n\t\tif (path) {\n\t\t\tctx.beginPath();\n\n\t\t\tif (matrix3D) {\n\t\t\t\t// Build combined matrix: translate to position, scale, then apply 3D\n\t\t\t\tconst posX = x + glyph.xOffset * scale;\n\t\t\t\tconst posY = y - glyph.yOffset * scale;\n\t\t\t\t// Create combined 3x3 matrix with scale and position baked in\n\t\t\t\tconst combined: Matrix3x3 = [\n\t\t\t\t\t[\n\t\t\t\t\t\tmatrix3D[0][0] * scale,\n\t\t\t\t\t\tmatrix3D[0][1] * scale,\n\t\t\t\t\t\tmatrix3D[0][0] * posX + matrix3D[0][1] * posY + matrix3D[0][2],\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\tmatrix3D[1][0] * scale,\n\t\t\t\t\t\tmatrix3D[1][1] * scale,\n\t\t\t\t\t\tmatrix3D[1][0] * posX + matrix3D[1][1] * posY + matrix3D[1][2],\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\tmatrix3D[2][0] * scale,\n\t\t\t\t\t\tmatrix3D[2][1] * scale,\n\t\t\t\t\t\tmatrix3D[2][0] * posX + matrix3D[2][1] * posY + matrix3D[2][2],\n\t\t\t\t\t],\n\t\t\t\t];\n\t\t\t\tpathToCanvasWithMatrix3D(ctx, path, combined);\n\t\t\t} else if (matrix) {\n\t\t\t\t// Build combined 2D matrix: translate to position, scale, then apply matrix\n\t\t\t\tconst posX = x + glyph.xOffset * scale;\n\t\t\t\tconst posY = y - glyph.yOffset * scale;\n\t\t\t\t// Combined: matrix * [scale, 0, 0, scale, posX, posY]\n\t\t\t\tconst combined: Matrix2D = [\n\t\t\t\t\tmatrix[0] * scale,\n\t\t\t\t\tmatrix[1] * scale,\n\t\t\t\t\tmatrix[2] * scale,\n\t\t\t\t\tmatrix[3] * scale,\n\t\t\t\t\tmatrix[0] * posX + matrix[2] * posY + matrix[4],\n\t\t\t\t\tmatrix[1] * posX + matrix[3] * posY + matrix[5],\n\t\t\t\t];\n\t\t\t\tpathToCanvasWithMatrix(ctx, path, combined);\n\t\t\t} else {\n\t\t\t\tpathToCanvas(ctx, path, {\n\t\t\t\t\tscale,\n\t\t\t\t\tflipY: true,\n\t\t\t\t\toffsetX: x + glyph.xOffset * scale,\n\t\t\t\t\toffsetY: y - glyph.yOffset * scale,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (fill !== \"none\") ctx.fill();\n\t\t\tif (stroke) ctx.stroke();\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n}\n\n/**\n * Generate SVG for shaped text\n */\nexport function shapedTextToSVG(\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\toptions?: {\n\t\tfontSize?: number;\n\t\tfill?: string;\n\t\tstroke?: string;\n\t\tstrokeWidth?: number;\n\t\tlineCap?: \"butt\" | \"round\" | \"square\";\n\t\tlineJoin?: \"miter\" | \"round\" | \"bevel\";\n\t\t/** 2D affine matrix to apply to glyph coordinates */\n\t\tmatrix?: Matrix2D;\n\t\t/** 3D perspective matrix to apply to glyph coordinates (takes precedence over matrix) */\n\t\tmatrix3D?: Matrix3x3;\n\t\t/** If true, use native SVG transform attribute instead of transforming path data (2D only) */\n\t\tuseNativeTransform?: boolean;\n\t},\n): string {\n\tconst fontSize = options?.fontSize ?? 100;\n\tconst fill = options?.fill ?? \"currentColor\";\n\tconst stroke = options?.stroke;\n\tconst strokeWidth = options?.strokeWidth ?? 1;\n\tconst matrix = options?.matrix;\n\tconst matrix3D = options?.matrix3D;\n\tconst useNativeTransform = options?.useNativeTransform ?? false;\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tlet pathsStr = \"\";\n\tlet x = 0;\n\tlet y = 0;\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\n\tfor (let i = 0; i < glyphs.length; i++) {\n\t\tconst glyph = glyphs[i]!;\n\t\tconst path = getGlyphPath(font, glyph.glyphId);\n\t\tif (path?.bounds) {\n\t\t\tconst offsetX = x + glyph.xOffset * scale;\n\t\t\tconst offsetY = y - glyph.yOffset * scale;\n\n\t\t\tlet pathStr: string;\n\n\t\t\tif (matrix3D && !useNativeTransform) {\n\t\t\t\t// Apply 3D matrix to path coordinates\n\t\t\t\tconst combined: Matrix3x3 = [\n\t\t\t\t\t[\n\t\t\t\t\t\tmatrix3D[0][0] * scale,\n\t\t\t\t\t\tmatrix3D[0][1] * scale,\n\t\t\t\t\t\tmatrix3D[0][0] * offsetX +\n\t\t\t\t\t\t\tmatrix3D[0][1] * offsetY +\n\t\t\t\t\t\t\tmatrix3D[0][2],\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\tmatrix3D[1][0] * scale,\n\t\t\t\t\t\tmatrix3D[1][1] * scale,\n\t\t\t\t\t\tmatrix3D[1][0] * offsetX +\n\t\t\t\t\t\t\tmatrix3D[1][1] * offsetY +\n\t\t\t\t\t\t\tmatrix3D[1][2],\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\tmatrix3D[2][0] * scale,\n\t\t\t\t\t\tmatrix3D[2][1] * scale,\n\t\t\t\t\t\tmatrix3D[2][0] * offsetX +\n\t\t\t\t\t\t\tmatrix3D[2][1] * offsetY +\n\t\t\t\t\t\t\tmatrix3D[2][2],\n\t\t\t\t\t],\n\t\t\t\t];\n\t\t\t\tpathStr = pathToSVGWithMatrix3D(path, combined);\n\n\t\t\t\t// Update bounds with transformed corners\n\t\t\t\tconst b = path.bounds;\n\t\t\t\tconst corners = [\n\t\t\t\t\ttransformPoint3x3(\n\t\t\t\t\t\tb.xMin * scale + offsetX,\n\t\t\t\t\t\t-b.yMax * scale + offsetY,\n\t\t\t\t\t\tmatrix3D,\n\t\t\t\t\t),\n\t\t\t\t\ttransformPoint3x3(\n\t\t\t\t\t\tb.xMax * scale + offsetX,\n\t\t\t\t\t\t-b.yMax * scale + offsetY,\n\t\t\t\t\t\tmatrix3D,\n\t\t\t\t\t),\n\t\t\t\t\ttransformPoint3x3(\n\t\t\t\t\t\tb.xMin * scale + offsetX,\n\t\t\t\t\t\t-b.yMin * scale + offsetY,\n\t\t\t\t\t\tmatrix3D,\n\t\t\t\t\t),\n\t\t\t\t\ttransformPoint3x3(\n\t\t\t\t\t\tb.xMax * scale + offsetX,\n\t\t\t\t\t\t-b.yMin * scale + offsetY,\n\t\t\t\t\t\tmatrix3D,\n\t\t\t\t\t),\n\t\t\t\t];\n\t\t\t\tfor (let j = 0; j < corners.length; j++) {\n\t\t\t\t\tconst c = corners[j]!;\n\t\t\t\t\tminX = Math.min(minX, c.x);\n\t\t\t\t\tmaxX = Math.max(maxX, c.x);\n\t\t\t\t\tminY = Math.min(minY, c.y);\n\t\t\t\t\tmaxY = Math.max(maxY, c.y);\n\t\t\t\t}\n\t\t\t} else if (matrix && !useNativeTransform) {\n\t\t\t\t// Apply 2D matrix to path coordinates\n\t\t\t\tconst combined: Matrix2D = [\n\t\t\t\t\tmatrix[0] * scale,\n\t\t\t\t\tmatrix[1] * scale,\n\t\t\t\t\tmatrix[2] * scale,\n\t\t\t\t\tmatrix[3] * scale,\n\t\t\t\t\tmatrix[0] * offsetX + matrix[2] * offsetY + matrix[4],\n\t\t\t\t\tmatrix[1] * offsetX + matrix[3] * offsetY + matrix[5],\n\t\t\t\t];\n\t\t\t\tpathStr = pathToSVGWithMatrix(path, combined);\n\n\t\t\t\t// Update bounds with transformed corners\n\t\t\t\tconst b = path.bounds;\n\t\t\t\tconst corners = [\n\t\t\t\t\ttransformPoint2D(\n\t\t\t\t\t\tb.xMin * scale + offsetX,\n\t\t\t\t\t\t-b.yMax * scale + offsetY,\n\t\t\t\t\t\tmatrix,\n\t\t\t\t\t),\n\t\t\t\t\ttransformPoint2D(\n\t\t\t\t\t\tb.xMax * scale + offsetX,\n\t\t\t\t\t\t-b.yMax * scale + offsetY,\n\t\t\t\t\t\tmatrix,\n\t\t\t\t\t),\n\t\t\t\t\ttransformPoint2D(\n\t\t\t\t\t\tb.xMin * scale + offsetX,\n\t\t\t\t\t\t-b.yMin * scale + offsetY,\n\t\t\t\t\t\tmatrix,\n\t\t\t\t\t),\n\t\t\t\t\ttransformPoint2D(\n\t\t\t\t\t\tb.xMax * scale + offsetX,\n\t\t\t\t\t\t-b.yMin * scale + offsetY,\n\t\t\t\t\t\tmatrix,\n\t\t\t\t\t),\n\t\t\t\t];\n\t\t\t\tfor (let j = 0; j < corners.length; j++) {\n\t\t\t\t\tconst c = corners[j]!;\n\t\t\t\t\tminX = Math.min(minX, c.x);\n\t\t\t\t\tmaxX = Math.max(maxX, c.x);\n\t\t\t\t\tminY = Math.min(minY, c.y);\n\t\t\t\t\tmaxY = Math.max(maxY, c.y);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Direct SVG serialization - no intermediate array allocation\n\t\t\t\tpathStr = pathToSVGDirect(path, scale, offsetX, offsetY);\n\n\t\t\t\t// Update bounds\n\t\t\t\tconst b = path.bounds;\n\t\t\t\tminX = Math.min(minX, offsetX + b.xMin * scale);\n\t\t\t\tmaxX = Math.max(maxX, offsetX + b.xMax * scale);\n\t\t\t\tminY = Math.min(minY, offsetY - b.yMax * scale);\n\t\t\t\tmaxY = Math.max(maxY, offsetY - b.yMin * scale);\n\t\t\t}\n\n\t\t\tif (pathsStr) pathsStr += \" \";\n\t\t\tpathsStr += pathStr;\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n\n\tif (!pathsStr) {\n\t\treturn '<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n\t}\n\n\t// Add stroke padding to bounds\n\tconst strokePadding = stroke ? strokeWidth / 2 : 0;\n\tconst width = Math.ceil(maxX - minX + strokePadding * 2);\n\tconst height = Math.ceil(maxY - minY + strokePadding * 2);\n\t// ViewBox is scaled by SVG_SCALE to match path coordinates\n\tconst vbX = Math.floor((minX - strokePadding) * SVG_SCALE);\n\tconst vbY = Math.floor((minY - strokePadding) * SVG_SCALE);\n\tconst vbW = Math.ceil(width * SVG_SCALE);\n\tconst vbH = Math.ceil(height * SVG_SCALE);\n\tconst viewBox = `${vbX} ${vbY} ${vbW} ${vbH}`;\n\n\tconst strokeAttr = stroke\n\t\t? ` stroke=\"${stroke}\" stroke-width=\"${strokeWidth * SVG_SCALE}\"${options?.lineCap ? ` stroke-linecap=\"${options.lineCap}\"` : \"\"}${options?.lineJoin ? ` stroke-linejoin=\"${options.lineJoin}\"` : \"\"}`\n\t\t: \"\";\n\n\t// Use native transform attribute if requested (only for 2D matrix)\n\tconst transformAttr =\n\t\tuseNativeTransform && matrix\n\t\t\t? ` transform=\"${matrixToSVGTransform(matrix)}\"`\n\t\t\t: \"\";\n\n\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${pathsStr}\" fill=\"${fill}\"${strokeAttr}${transformAttr}/>\n</svg>`;\n}\n\n/**\n * Convert GlyphBuffer output to ShapedGlyph array\n */\nexport function glyphBufferToShapedGlyphs(buffer: GlyphBuffer): ShapedGlyph[] {\n\tconst result: ShapedGlyph[] = [];\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i]!;\n\t\tconst pos = buffer.positions[i];\n\t\tif (!pos) continue;\n\t\tresult.push({\n\t\t\tglyphId: info.glyphId,\n\t\t\txOffset: pos.xOffset,\n\t\t\tyOffset: pos.yOffset,\n\t\t\txAdvance: pos.xAdvance,\n\t\t\tyAdvance: pos.yAdvance,\n\t\t});\n\t}\n\treturn result;\n}\n\n/**\n * Get glyph path with variable font variation applied\n */\nexport function getGlyphPathWithVariation(\n\tfont: Font,\n\tglyphId: GlyphId,\n\taxisCoords: number[],\n): GlyphPath | null {\n\tconst contours = font.getGlyphContoursWithVariation(glyphId, axisCoords);\n\tif (!contours) return null;\n\n\tconst commands: PathCommand[] = [];\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tcommands.push(...contourToPath(contour));\n\t}\n\n\tconst bounds = font.getGlyphBounds(glyphId);\n\n\treturn { commands, bounds };\n}\n\n/**\n * Render shaped text with variable font support\n */\nexport function renderShapedTextWithVariation(\n\tctx: CanvasRenderingContext2D,\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\taxisCoords: number[],\n\toptions?: {\n\t\tfontSize?: number;\n\t\tx?: number;\n\t\ty?: number;\n\t\tfill?: string;\n\t\tstroke?: string;\n\t\tstrokeWidth?: number;\n\t\tlineCap?: CanvasLineCap;\n\t\tlineJoin?: CanvasLineJoin;\n\t},\n): void {\n\tconst fontSize = options?.fontSize ?? 16;\n\tconst startX = options?.x ?? 0;\n\tconst startY = options?.y ?? 0;\n\tconst fill = options?.fill ?? \"black\";\n\tconst stroke = options?.stroke;\n\tconst strokeWidth = options?.strokeWidth ?? 1;\n\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tctx.fillStyle = fill;\n\tif (stroke) {\n\t\tctx.strokeStyle = stroke;\n\t\tctx.lineWidth = strokeWidth * scale;\n\t\tif (options?.lineCap) ctx.lineCap = options.lineCap;\n\t\tif (options?.lineJoin) ctx.lineJoin = options.lineJoin;\n\t}\n\n\tlet x = startX;\n\tlet y = startY;\n\n\tfor (let i = 0; i < glyphs.length; i++) {\n\t\tconst glyph = glyphs[i]!;\n\t\tconst path = getGlyphPathWithVariation(font, glyph.glyphId, axisCoords);\n\t\tif (path) {\n\t\t\tctx.beginPath();\n\t\t\tpathToCanvas(ctx, path, {\n\t\t\t\tscale,\n\t\t\t\tflipY: true,\n\t\t\t\toffsetX: x + glyph.xOffset * scale,\n\t\t\t\toffsetY: y - glyph.yOffset * scale,\n\t\t\t});\n\t\t\tif (fill !== \"none\") ctx.fill();\n\t\t\tif (stroke) ctx.stroke();\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n}\n\n/**\n * Generate SVG for shaped text with variable font support\n */\nexport function shapedTextToSVGWithVariation(\n\tfont: Font,\n\tglyphs: ShapedGlyph[],\n\taxisCoords: number[],\n\toptions?: {\n\t\tfontSize?: number;\n\t\tfill?: string;\n\t\tstroke?: string;\n\t\tstrokeWidth?: number;\n\t\tlineCap?: \"butt\" | \"round\" | \"square\";\n\t\tlineJoin?: \"miter\" | \"round\" | \"bevel\";\n\t},\n): string {\n\tconst fontSize = options?.fontSize ?? 100;\n\tconst fill = options?.fill ?? \"currentColor\";\n\tconst stroke = options?.stroke;\n\tconst strokeWidth = options?.strokeWidth ?? 1;\n\tconst scale = fontSize / font.unitsPerEm;\n\n\tlet pathsStr = \"\";\n\tlet x = 0;\n\tlet y = 0;\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\n\tfor (let i = 0; i < glyphs.length; i++) {\n\t\tconst glyph = glyphs[i]!;\n\t\tconst path = getGlyphPathWithVariation(font, glyph.glyphId, axisCoords);\n\t\tif (path?.bounds) {\n\t\t\tconst offsetX = x + glyph.xOffset * scale;\n\t\t\tconst offsetY = y - glyph.yOffset * scale;\n\n\t\t\t// Direct SVG serialization - no intermediate array allocation\n\t\t\tconst pathStr = pathToSVGDirect(path, scale, offsetX, offsetY);\n\t\t\tif (pathsStr) pathsStr += \" \";\n\t\t\tpathsStr += pathStr;\n\n\t\t\tconst b = path.bounds;\n\t\t\tminX = Math.min(minX, offsetX + b.xMin * scale);\n\t\t\tmaxX = Math.max(maxX, offsetX + b.xMax * scale);\n\t\t\tminY = Math.min(minY, offsetY - b.yMax * scale);\n\t\t\tmaxY = Math.max(maxY, offsetY - b.yMin * scale);\n\t\t}\n\n\t\tx += glyph.xAdvance * scale;\n\t\ty += glyph.yAdvance * scale;\n\t}\n\n\tif (!pathsStr) {\n\t\treturn '<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>';\n\t}\n\n\t// Add stroke padding to bounds\n\tconst strokePadding = stroke ? strokeWidth / 2 : 0;\n\tconst width = Math.ceil(maxX - minX + strokePadding * 2);\n\tconst height = Math.ceil(maxY - minY + strokePadding * 2);\n\t// ViewBox is scaled by SVG_SCALE to match path coordinates\n\tconst vbX = Math.floor((minX - strokePadding) * SVG_SCALE);\n\tconst vbY = Math.floor((minY - strokePadding) * SVG_SCALE);\n\tconst vbW = Math.ceil(width * SVG_SCALE);\n\tconst vbH = Math.ceil(height * SVG_SCALE);\n\tconst viewBox = `${vbX} ${vbY} ${vbW} ${vbH}`;\n\n\tconst strokeAttr = stroke\n\t\t? ` stroke=\"${stroke}\" stroke-width=\"${strokeWidth * SVG_SCALE}\"${options?.lineCap ? ` stroke-linecap=\"${options.lineCap}\"` : \"\"}${options?.lineJoin ? ` stroke-linejoin=\"${options.lineJoin}\"` : \"\"}`\n\t\t: \"\";\n\n\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${pathsStr}\" fill=\"${fill}\"${strokeAttr}/>\n</svg>`;\n}\n\n/**\n * Calculate the total advance width of shaped text\n */\nexport function getTextWidth(\n\tglyphs: ShapedGlyph[],\n\tfont: Font,\n\tfontSize: number,\n): number {\n\tconst scale = fontSize / font.unitsPerEm;\n\tlet width = 0;\n\tfor (let i = 0; i < glyphs.length; i++) {\n\t\tconst glyph = glyphs[i]!;\n\t\twidth += glyph.xAdvance;\n\t}\n\treturn width * scale;\n}\n\n/**\n * Create a Path2D object from glyph path\n */\nexport function createPath2D(\n\tpath: GlyphPath,\n\toptions?: {\n\t\tflipY?: boolean;\n\t\tscale?: number;\n\t\toffsetX?: number;\n\t\toffsetY?: number;\n\t},\n): Path2D {\n\tconst p = new Path2D();\n\tpathToCanvas(p, path, options);\n\treturn p;\n}\n\n/**\n * Render path to canvas with 2D affine matrix transformation applied to coordinates\n * The matrix transforms each point before drawing\n */\nexport function pathToCanvasWithMatrix(\n\tctx: CanvasRenderingContext2D | Path2D,\n\tpath: GlyphPath,\n\tmatrix: Matrix2D,\n\toptions?: { flipY?: boolean },\n): void {\n\tconst flipY = options?.flipY ?? true;\n\tconst ySign = flipY ? -1 : 1;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.quadraticCurveTo(p1.x, p1.y, p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p2 = transformPoint2D(cmd.x2, cmd.y2 * ySign, matrix);\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Convert path to SVG with 2D affine matrix transformation applied to coordinates\n */\nexport function pathToSVGWithMatrix(\n\tpath: GlyphPath,\n\tmatrix: Matrix2D,\n\toptions?: { flipY?: boolean },\n): string {\n\tconst flipY = options?.flipY ?? true;\n\tconst ySign = flipY ? -1 : 1;\n\tlet result = \"\";\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tif (i > 0) result += \" \";\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult += \"M \" + p.x + \" \" + p.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult += \"L \" + p.x + \" \" + p.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult += \"Q \" + p1.x + \" \" + p1.y + \" \" + p.x + \" \" + p.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint2D(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p2 = transformPoint2D(cmd.x2, cmd.y2 * ySign, matrix);\n\t\t\t\tconst p = transformPoint2D(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult +=\n\t\t\t\t\t\"C \" +\n\t\t\t\t\tp1.x +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp1.y +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp2.x +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp2.y +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp.x +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tresult += \"Z\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Render path to canvas with 3D perspective matrix transformation\n * Uses homogeneous coordinates for perspective projection\n */\nexport function pathToCanvasWithMatrix3D(\n\tctx: CanvasRenderingContext2D | Path2D,\n\tpath: GlyphPath,\n\tmatrix: Matrix3x3,\n\toptions?: { flipY?: boolean },\n): void {\n\tconst flipY = options?.flipY ?? true;\n\tconst ySign = flipY ? -1 : 1;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.moveTo(p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.lineTo(p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.quadraticCurveTo(p1.x, p1.y, p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p2 = transformPoint3x3(cmd.x2, cmd.y2 * ySign, matrix);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p.x, p.y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Convert path to SVG with 3D perspective matrix transformation\n * Uses homogeneous coordinates for perspective projection\n */\nexport function pathToSVGWithMatrix3D(\n\tpath: GlyphPath,\n\tmatrix: Matrix3x3,\n\toptions?: { flipY?: boolean },\n): string {\n\tconst flipY = options?.flipY ?? true;\n\tconst ySign = flipY ? -1 : 1;\n\tlet result = \"\";\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tif (i > 0) result += \" \";\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult += \"M \" + p.x + \" \" + p.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult += \"L \" + p.x + \" \" + p.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult += \"Q \" + p1.x + \" \" + p1.y + \" \" + p.x + \" \" + p.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint3x3(cmd.x1, cmd.y1 * ySign, matrix);\n\t\t\t\tconst p2 = transformPoint3x3(cmd.x2, cmd.y2 * ySign, matrix);\n\t\t\t\tconst p = transformPoint3x3(cmd.x, cmd.y * ySign, matrix);\n\t\t\t\tresult +=\n\t\t\t\t\t\"C \" +\n\t\t\t\t\tp1.x +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp1.y +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp2.x +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp2.y +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp.x +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tp.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tresult += \"Z\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Apply 2D affine matrix to canvas context using native transform\n * Use ctx.save() before and ctx.restore() after to preserve context state\n */\nexport function applyMatrixToContext(\n\tctx: CanvasRenderingContext2D,\n\tmatrix: Matrix2D,\n): void {\n\t// Canvas transform: (a, b, c, d, e, f)\n\t// Matrix2D: [a, b, c, d, tx, ty]\n\t// Canvas expects: [a, b, c, d, e, f] where e=tx, f=ty\n\tctx.transform(\n\t\tmatrix[0],\n\t\tmatrix[1],\n\t\tmatrix[2],\n\t\tmatrix[3],\n\t\tmatrix[4],\n\t\tmatrix[5],\n\t);\n}\n\n/**\n * Convert 2D affine matrix to SVG transform attribute string\n * Returns a string like \"matrix(a, b, c, d, tx, ty)\"\n */\nexport function matrixToSVGTransform(matrix: Matrix2D): string {\n\treturn `matrix(${matrix[0]} ${matrix[1]} ${matrix[2]} ${matrix[3]} ${matrix[4]} ${matrix[5]})`;\n}\n\n/**\n * Direct SVG serialization with transform applied in single pass\n * Avoids creating intermediate PathCommand arrays\n * Outputs at SVG_SCALE (10x) with integer coordinates for performance\n */\nexport function pathToSVGDirect(\n\tpath: GlyphPath,\n\tscale: number,\n\toffsetX: number,\n\toffsetY: number,\n): string {\n\tlet result = \"\";\n\tconst s = scale * SVG_SCALE;\n\tconst ns = -scale * SVG_SCALE;\n\tconst ox = offsetX * SVG_SCALE;\n\tconst oy = offsetY * SVG_SCALE;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tif (i > 0) result += \" \";\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tresult +=\n\t\t\t\t\t\"M \" + Math.round(cmd.x * s + ox) + \" \" + Math.round(cmd.y * ns + oy);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tresult +=\n\t\t\t\t\t\"L \" + Math.round(cmd.x * s + ox) + \" \" + Math.round(cmd.y * ns + oy);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tresult +=\n\t\t\t\t\t\"Q \" +\n\t\t\t\t\tMath.round(cmd.x1 * s + ox) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y1 * ns + oy) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.x * s + ox) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y * ns + oy);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tresult +=\n\t\t\t\t\t\"C \" +\n\t\t\t\t\tMath.round(cmd.x1 * s + ox) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y1 * ns + oy) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.x2 * s + ox) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y2 * ns + oy) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.x * s + ox) +\n\t\t\t\t\t\" \" +\n\t\t\t\t\tMath.round(cmd.y * ns + oy);\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tresult += \"Z\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n",
    "/**\n * Fixed-point arithmetic utilities for rasterization\n *\n * FreeType uses several fixed-point formats:\n * - F26Dot6: 26.6 format (64 units per pixel) for coordinates\n * - F16Dot16: 16.16 format for high-precision calculations\n * - F2Dot14: 2.14 format for normalized vectors\n */\n\n// Bit shifts for fixed-point formats\nexport const PIXEL_BITS = 8; // Subpixel precision (256 levels per pixel)\nexport const ONE_PIXEL = 1 << PIXEL_BITS; // 256\nexport const PIXEL_MASK = ONE_PIXEL - 1; // 0xFF\n\n// 26.6 fixed-point (FreeType's standard format)\nexport const F26DOT6_SHIFT = 6;\nexport const F26DOT6_ONE = 1 << F26DOT6_SHIFT; // 64\n\n// 16.16 fixed-point\nexport const F16DOT16_SHIFT = 16;\nexport const F16DOT16_ONE = 1 << F16DOT16_SHIFT; // 65536\n\n/**\n * Convert float to 26.6 fixed-point\n */\nexport function floatToF26Dot6(x: number): number {\n\treturn Math.round(x * F26DOT6_ONE);\n}\n\n/**\n * Convert 26.6 fixed-point to float\n */\nexport function f26Dot6ToFloat(x: number): number {\n\treturn x / F26DOT6_ONE;\n}\n\n/**\n * Convert float to internal raster coordinates (PIXEL_BITS precision)\n * Input is in font units, output has 256 subpixel levels per pixel\n */\nexport function floatToPixel(x: number, scale: number): number {\n\treturn Math.round(x * scale * ONE_PIXEL);\n}\n\n/**\n * Truncate to pixel (floor for positive, ceil for negative)\n */\nexport function truncPixel(x: number): number {\n\treturn x >> PIXEL_BITS;\n}\n\n/**\n * Get fractional part (0 to ONE_PIXEL-1)\n */\nexport function fracPixel(x: number): number {\n\treturn x & PIXEL_MASK;\n}\n\n/**\n * Round to nearest pixel\n */\nexport function roundPixel(x: number): number {\n\treturn (x + (ONE_PIXEL >> 1)) >> PIXEL_BITS;\n}\n\n/**\n * Floor to pixel boundary\n */\nexport function floorPixel(x: number): number {\n\treturn x & ~PIXEL_MASK;\n}\n\n/**\n * Ceiling to pixel boundary\n */\nexport function ceilPixel(x: number): number {\n\treturn (x + PIXEL_MASK) & ~PIXEL_MASK;\n}\n\n/**\n * Upscale from 26.6 to internal PIXEL_BITS format\n * PIXEL_BITS=8 means 2 extra bits of precision vs 26.6\n */\nexport function upscale(x: number): number {\n\treturn x << (PIXEL_BITS - F26DOT6_SHIFT);\n}\n\n/**\n * Downscale from internal format to 26.6\n */\nexport function downscale(x: number): number {\n\treturn x >> (PIXEL_BITS - F26DOT6_SHIFT);\n}\n\n/**\n * Multiply two fixed-point numbers and divide, avoiding overflow\n * Computes (a * b) / c with 64-bit intermediate precision when needed\n */\nexport function mulDiv(a: number, b: number, c: number): number {\n\tif (c === 0) return 0;\n\t// Fast path: use native math when no overflow risk\n\t// Safe when |a * b| < 2^53 (JS safe integer limit)\n\tconst absA = a < 0 ? -a : a;\n\tconst absB = b < 0 ? -b : b;\n\tif (absA < 0x7fffff && absB < 0x7fffff) {\n\t\t// Both under 2^23, product fits in 2^46 < 2^53\n\t\treturn Math.trunc((a * b) / c);\n\t}\n\t// Fallback: use BigInt for 64-bit precision\n\treturn Number((BigInt(a) * BigInt(b)) / BigInt(c));\n}\n\n/**\n * Multiply two 16.16 fixed-point numbers\n */\nexport function mulFix(a: number, b: number): number {\n\treturn mulDiv(a, b, F16DOT16_ONE);\n}\n\n/**\n * Divide two numbers and return 16.16 fixed-point result\n */\nexport function divFix(a: number, b: number): number {\n\tif (b === 0) return 0;\n\treturn mulDiv(a, F16DOT16_ONE, b);\n}\n\n/**\n * Fast approximation of sqrt(x*x + y*y) using \"alpha max plus beta min\" algorithm.\n * Uses alpha = 1, beta = 3/8 for max error < 7% vs exact value.\n * From FreeType's FT_HYPOT macro.\n */\nexport function hypot(x: number, y: number): number {\n\tx = abs(x);\n\ty = abs(y);\n\treturn x > y ? x + ((3 * y) >> 3) : y + ((3 * x) >> 3);\n}\n\n/**\n * Calculate the length of a 2D vector (integer math)\n * Uses FreeType's \"alpha max plus beta min\" approximation\n */\nexport function vectorLength(dx: number, dy: number): number {\n\treturn hypot(dx, dy);\n}\n\n/**\n * Normalize a 2D vector to unit length (16.16 fixed-point output)\n */\nexport function normalizeVector(\n\tdx: number,\n\tdy: number,\n): { x: number; y: number } {\n\tconst len = Math.sqrt(dx * dx + dy * dy);\n\tif (len === 0) return { x: F16DOT16_ONE, y: 0 };\n\treturn {\n\t\tx: Math.round((dx / len) * F16DOT16_ONE),\n\t\ty: Math.round((dy / len) * F16DOT16_ONE),\n\t};\n}\n\n/**\n * Clamp value to range\n */\nexport function clamp(x: number, min: number, max: number): number {\n\treturn x < min ? min : x > max ? max : x;\n}\n\n/**\n * Absolute value\n */\nexport function abs(x: number): number {\n\treturn x < 0 ? -x : x;\n}\n\n/**\n * Sign of value (-1, 0, or 1)\n */\nexport function sign(x: number): number {\n\treturn x < 0 ? -1 : x > 0 ? 1 : 0;\n}\n",
    "/**\n * Cell management for scanline rasterization\n *\n * Based on FreeType's ftgrays.c cell accumulation approach.\n * Each cell tracks coverage and area for anti-aliased rendering.\n *\n * Uses pool-based allocation with overflow detection for bounded memory.\n */\n\nimport { PIXEL_BITS, truncPixel } from \"./fixed-point.ts\";\n\n/** Default pool size - larger than FreeType's 2048 to handle big glyphs */\nconst DEFAULT_POOL_SIZE = 16384;\n\n/** Sentinel X value for null cell */\nconst CELL_MAX_X = 0x7fffffff;\n\n/**\n * Pool overflow error - thrown when cell pool is exhausted\n */\nexport class PoolOverflowError extends Error {\n\tconstructor() {\n\t\tsuper(\"Cell pool overflow\");\n\t\tthis.name = \"PoolOverflowError\";\n\t}\n}\n\n/**\n * A cell accumulates coverage information for one pixel\n */\nexport interface Cell {\n\t/** X coordinate in pixels */\n\tx: number;\n\t/** Accumulated signed area */\n\tarea: number;\n\t/** Accumulated coverage (winding number contribution) */\n\tcover: number;\n\t/** Next cell in linked list (index into pool, -1 for end) */\n\tnext: number;\n}\n\n/**\n * Cell storage with pool-based allocation and linked lists per scanline.\n * Matches FreeType's approach for bounded memory usage.\n */\nexport class CellBuffer {\n\t/** Fixed-size cell pool */\n\tprivate pool: Cell[];\n\t/** Pool size */\n\tprivate poolSize: number;\n\t/** Next free cell index */\n\tprivate freeIndex: number;\n\t/** Per-scanline linked list heads (index into pool, -1 for empty) */\n\tprivate ycells: number[];\n\n\t/** Band bounds (Y range for current render pass) */\n\tprivate bandMinY: number = 0;\n\tprivate bandMaxY: number = 0;\n\n\t/** Bounding box of active cells */\n\tminY: number = Infinity;\n\tmaxY: number = -Infinity;\n\tminX: number = Infinity;\n\tmaxX: number = -Infinity;\n\n\t/** Current position for incremental cell updates */\n\tprivate currentX: number = 0;\n\tprivate currentY: number = 0;\n\tprivate currentCellIndex: number = -1;\n\n\t/** Clip bounds in pixels */\n\tprivate clipMinX: number = -Infinity;\n\tprivate clipMinY: number = -Infinity;\n\tprivate clipMaxX: number = Infinity;\n\tprivate clipMaxY: number = Infinity;\n\n\t/** Null cell index (sentinel at end of pool) */\n\tprivate nullCellIndex: number;\n\n\t/** Whether band bounds have been set */\n\tprivate bandSet: boolean = false;\n\n\tconstructor(poolSize: number = DEFAULT_POOL_SIZE) {\n\t\tthis.poolSize = poolSize;\n\t\tthis.nullCellIndex = poolSize - 1;\n\n\t\t// Pre-allocate pool\n\t\tthis.pool = new Array(poolSize);\n\t\tfor (let i = 0; i < poolSize; i++) {\n\t\t\tthis.pool[i] = { x: 0, area: 0, cover: 0, next: -1 };\n\t\t}\n\n\t\t// Initialize null cell (sentinel)\n\t\tthis.pool[this.nullCellIndex].x = CELL_MAX_X;\n\t\tthis.pool[this.nullCellIndex].next = -1;\n\n\t\tthis.ycells = [];\n\t\tthis.freeIndex = 0;\n\n\t\t// Default band bounds (large range for backward compatibility)\n\t\tthis.bandMinY = -10000;\n\t\tthis.bandMaxY = 10000;\n\t}\n\n\t/**\n\t * Set clipping bounds\n\t */\n\tsetClip(minX: number, minY: number, maxX: number, maxY: number): void {\n\t\tthis.clipMinX = minX;\n\t\tthis.clipMinY = minY;\n\t\tthis.clipMaxX = maxX;\n\t\tthis.clipMaxY = maxY;\n\t}\n\n\t/**\n\t * Set band bounds for current render pass\n\t */\n\tsetBandBounds(minY: number, maxY: number): void {\n\t\tthis.bandMinY = minY;\n\t\tthis.bandMaxY = maxY;\n\t\tthis.bandSet = true;\n\n\t\t// Resize ycells array for band height\n\t\tconst height = maxY - minY;\n\t\tif (this.ycells.length < height) {\n\t\t\tthis.ycells = new Array(height);\n\t\t}\n\n\t\t// Initialize all rows to null cell\n\t\tfor (let i = 0; i < height; i++) {\n\t\t\tthis.ycells[i] = this.nullCellIndex;\n\t\t}\n\n\t\t// Calculate how many cells we need for ycells pointers\n\t\t// Reserve space at start of pool for ycells (like FreeType)\n\t\tthis.freeIndex = 0;\n\t}\n\n\t/**\n\t * Clear all cells for new band\n\t */\n\treset(): void {\n\t\t// Reset pool\n\t\tthis.freeIndex = 0;\n\n\t\t// Reset null cell\n\t\tthis.pool[this.nullCellIndex].x = CELL_MAX_X;\n\t\tthis.pool[this.nullCellIndex].area = 0;\n\t\tthis.pool[this.nullCellIndex].cover = 0;\n\t\tthis.pool[this.nullCellIndex].next = -1;\n\n\t\t// Reset ycells to null (only if band was set; otherwise leave for dynamic expansion)\n\t\tif (this.bandSet) {\n\t\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\t\tthis.ycells[i] = this.nullCellIndex;\n\t\t\t}\n\t\t} else {\n\t\t\t// Clear ycells for dynamic mode - will be initialized on first use\n\t\t\tthis.ycells = [];\n\t\t\t// Use very large bounds to avoid clipping before ensureYCellsCapacity is called\n\t\t\tthis.bandMinY = -100000;\n\t\t\tthis.bandMaxY = 100000;\n\t\t}\n\n\t\tthis.minY = Infinity;\n\t\tthis.maxY = -Infinity;\n\t\tthis.minX = Infinity;\n\t\tthis.maxX = -Infinity;\n\t\tthis.currentCellIndex = -1;\n\t}\n\n\t/**\n\t * Set current position (in subpixel coordinates)\n\t * @throws PoolOverflowError if pool is exhausted\n\t */\n\tsetCurrentCell(x: number, y: number): void {\n\t\tconst px = truncPixel(x);\n\t\tconst py = truncPixel(y);\n\n\t\t// Check if we're already at this cell\n\t\tif (\n\t\t\tthis.currentCellIndex >= 0 &&\n\t\t\tthis.currentX === px &&\n\t\t\tthis.currentY === py\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check clipping (always enforce clip bounds; band bounds only when set)\n\t\tif (\n\t\t\tpy < this.clipMinY ||\n\t\t\tpy >= this.clipMaxY ||\n\t\t\tpx < this.clipMinX ||\n\t\t\tpx >= this.clipMaxX ||\n\t\t\t(this.bandSet && (py < this.bandMinY || py >= this.bandMaxY))\n\t\t) {\n\t\t\tthis.currentCellIndex = this.nullCellIndex;\n\t\t\tthis.currentX = px;\n\t\t\tthis.currentY = py;\n\t\t\treturn;\n\t\t}\n\n\t\t// Get or create cell for this position\n\t\tthis.currentX = px;\n\t\tthis.currentY = py;\n\t\tthis.currentCellIndex = this.findOrCreateCell(px, py);\n\n\t\t// Update bounds\n\t\tthis.minY = Math.min(this.minY, py);\n\t\tthis.maxY = Math.max(this.maxY, py);\n\t\tthis.minX = Math.min(this.minX, px);\n\t\tthis.maxX = Math.max(this.maxX, px);\n\t}\n\n\t/**\n\t * Find or create a cell at the given pixel position\n\t * @throws PoolOverflowError if pool is exhausted\n\t */\n\tprivate findOrCreateCell(x: number, y: number): number {\n\t\t// Auto-expand band if needed (for backward compatibility when setBandBounds not called)\n\t\tif (!this.bandSet) {\n\t\t\tthis.ensureYCellsCapacity(y);\n\t\t}\n\n\t\tconst rowIndex = y - this.bandMinY;\n\t\tif (rowIndex < 0 || rowIndex >= this.ycells.length) {\n\t\t\treturn this.nullCellIndex;\n\t\t}\n\n\t\t// Walk linked list for this row\n\t\tlet prevIndex = -1;\n\t\tlet cellIndex = this.ycells[rowIndex];\n\n\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\tconst cell = this.pool[cellIndex];\n\t\t\tif (cell.x === x) {\n\t\t\t\treturn cellIndex; // Found existing cell\n\t\t\t}\n\t\t\tif (cell.x > x) {\n\t\t\t\tbreak; // Insert before this cell\n\t\t\t}\n\t\t\tprevIndex = cellIndex;\n\t\t\tcellIndex = cell.next;\n\t\t}\n\n\t\t// Check pool overflow - throw to trigger band bisection\n\t\tif (this.freeIndex >= this.nullCellIndex) {\n\t\t\tthrow new PoolOverflowError();\n\t\t}\n\n\t\tconst newIndex = this.freeIndex++;\n\t\tconst newCell = this.pool[newIndex];\n\t\tnewCell.x = x;\n\t\tnewCell.area = 0;\n\t\tnewCell.cover = 0;\n\t\tnewCell.next = cellIndex;\n\n\t\t// Link into list\n\t\tif (prevIndex === -1) {\n\t\t\tthis.ycells[rowIndex] = newIndex;\n\t\t} else {\n\t\t\tthis.pool[prevIndex].next = newIndex;\n\t\t}\n\n\t\treturn newIndex;\n\t}\n\n\t/**\n\t * Ensure ycells array can accommodate the given Y coordinate\n\t * Used for backward compatibility when setBandBounds is not called\n\t */\n\tprivate ensureYCellsCapacity(y: number): void {\n\t\t// Initialize band if first access\n\t\tif (this.ycells.length === 0) {\n\t\t\t// Start with a reasonable range centered around y\n\t\t\tthis.bandMinY = Math.min(y, 0);\n\t\t\tthis.bandMaxY = Math.max(y + 1, 256);\n\t\t\tconst height = this.bandMaxY - this.bandMinY;\n\t\t\tthis.ycells = new Array(height);\n\t\t\tfor (let i = 0; i < height; i++) {\n\t\t\t\tthis.ycells[i] = this.nullCellIndex;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Expand if needed\n\t\tif (y < this.bandMinY) {\n\t\t\tconst expand = this.bandMinY - y;\n\t\t\tconst newYcells = new Array(this.ycells.length + expand);\n\t\t\tfor (let i = 0; i < expand; i++) {\n\t\t\t\tnewYcells[i] = this.nullCellIndex;\n\t\t\t}\n\t\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\t\tnewYcells[expand + i] = this.ycells[i];\n\t\t\t}\n\t\t\tthis.ycells = newYcells;\n\t\t\tthis.bandMinY = y;\n\t\t} else if (y >= this.bandMaxY) {\n\t\t\tconst newMaxY = y + 1;\n\t\t\tconst oldLen = this.ycells.length;\n\t\t\tconst newLen = newMaxY - this.bandMinY;\n\t\t\tif (newLen > oldLen) {\n\t\t\t\tconst newYcells = new Array(newLen);\n\t\t\t\tfor (let i = 0; i < oldLen; i++) {\n\t\t\t\t\tnewYcells[i] = this.ycells[i];\n\t\t\t\t}\n\t\t\t\tfor (let i = oldLen; i < newLen; i++) {\n\t\t\t\t\tnewYcells[i] = this.nullCellIndex;\n\t\t\t\t}\n\t\t\t\tthis.ycells = newYcells;\n\t\t\t}\n\t\t\tthis.bandMaxY = newMaxY;\n\t\t}\n\t}\n\n\t/**\n\t * Add area and cover to current cell\n\t */\n\taddArea(area: number, cover: number): void {\n\t\tif (this.currentCellIndex >= 0) {\n\t\t\tconst cell = this.pool[this.currentCellIndex];\n\t\t\tcell.area += area;\n\t\t\tcell.cover += cover;\n\t\t}\n\t}\n\n\t/**\n\t * Get current cell area (for accumulation)\n\t */\n\tgetArea(): number {\n\t\tif (this.currentCellIndex >= 0) {\n\t\t\treturn this.pool[this.currentCellIndex]?.area;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Get current cell cover\n\t */\n\tgetCover(): number {\n\t\tif (this.currentCellIndex >= 0) {\n\t\t\treturn this.pool[this.currentCellIndex]?.cover;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Get all cells for a given Y coordinate, sorted by X\n\t */\n\tgetCellsForRow(y: number): Cell[] {\n\t\tconst rowIndex = y - this.bandMinY;\n\t\tif (rowIndex < 0 || rowIndex >= this.ycells.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst cells: Cell[] = [];\n\t\tlet cellIndex = this.ycells[rowIndex];\n\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\tcells.push(this.pool[cellIndex]);\n\t\t\tcellIndex = this.pool[cellIndex].next;\n\t\t}\n\t\treturn cells;\n\t}\n\n\t/**\n\t * Iterate over all cells in scanline order within band\n\t */\n\t*iterateCells(): Generator<{ y: number; cells: Cell[] }> {\n\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\tconst y = this.bandMinY + i;\n\t\t\tlet cellIndex = this.ycells[i];\n\t\t\tif (cellIndex === this.nullCellIndex) continue;\n\n\t\t\tconst cells: Cell[] = [];\n\t\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\t\tcells.push(this.pool[cellIndex]);\n\t\t\t\tcellIndex = this.pool[cellIndex].next;\n\t\t\t}\n\t\t\tif (cells.length > 0) {\n\t\t\t\tyield { y, cells };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate scanlines directly without allocating cell arrays\n\t * Returns first cell index for each row, caller walks linked list via pool\n\t */\n\t*iterateScanlines(): Generator<{ y: number; firstCellIndex: number }> {\n\t\tfor (let i = 0; i < this.ycells.length; i++) {\n\t\t\tconst cellIndex = this.ycells[i];\n\t\t\tif (cellIndex !== this.nullCellIndex) {\n\t\t\t\tyield { y: this.bandMinY + i, firstCellIndex: cellIndex };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the cell pool for direct access during sweep\n\t */\n\tgetPool(): Cell[] {\n\t\treturn this.pool;\n\t}\n\n\t/**\n\t * Get the null cell index (sentinel value)\n\t */\n\tgetNullIndex(): number {\n\t\treturn this.nullCellIndex;\n\t}\n\n\t/**\n\t * Get ycells array for direct iteration (avoids generator overhead)\n\t */\n\tgetYCells(): number[] {\n\t\treturn this.ycells;\n\t}\n\n\t/**\n\t * Get band minimum Y for coordinate calculation\n\t */\n\tgetBandMinY(): number {\n\t\treturn this.bandMinY;\n\t}\n\n\t/**\n\t * Iterate cells for a single row (for band sweep)\n\t */\n\t*iterateRowCells(y: number): Generator<Cell> {\n\t\tconst rowIndex = y - this.bandMinY;\n\t\tif (rowIndex < 0 || rowIndex >= this.ycells.length) return;\n\n\t\tlet cellIndex = this.ycells[rowIndex];\n\t\twhile (cellIndex !== this.nullCellIndex) {\n\t\t\tyield this.pool[cellIndex];\n\t\t\tcellIndex = this.pool[cellIndex].next;\n\t\t}\n\t}\n\n\t/**\n\t * Get number of cells currently allocated\n\t */\n\tgetCellCount(): number {\n\t\treturn this.freeIndex;\n\t}\n\n\t/**\n\t * Check if pool is near capacity\n\t */\n\tisNearCapacity(): boolean {\n\t\treturn this.freeIndex > this.poolSize * 0.9;\n\t}\n}\n\n/**\n * Convert cell coverage to 8-bit grayscale value\n *\n * The area is accumulated in 2*PIXEL_BITS precision.\n * We need to shift down to get 0-255 coverage.\n */\nexport function coverageToGray(area: number): number {\n\t// Area is in ONE_PIXEL * ONE_PIXEL precision\n\t// Shift down to 0-255 range\n\tlet coverage = area >> (PIXEL_BITS * 2 - 8);\n\n\t// Clamp to 0-255\n\tif (coverage < 0) coverage = -coverage;\n\tif (coverage > 255) coverage = 255;\n\n\treturn coverage;\n}\n\n/**\n * Apply non-zero winding fill rule\n */\nexport function applyNonZeroRule(cover: number): number {\n\tlet c = cover;\n\tif (c < 0) c = -c;\n\tif (c > 255) c = 255;\n\treturn c;\n}\n\n/**\n * Apply even-odd fill rule\n */\nexport function applyEvenOddRule(cover: number): number {\n\tlet c = cover;\n\tif (c < 0) c = -c;\n\tc &= 511; // Mod 512\n\tif (c > 256) c = 512 - c;\n\tif (c > 255) c = 255;\n\treturn c;\n}\n",
    "/**\n * Gray-scale anti-aliased rasterizer\n *\n * Based on FreeType's ftgrays.c - a coverage-based scanline rasterizer\n * that produces high-quality anti-aliased output.\n *\n * Algorithm overview:\n * 1. Convert outline to line segments (flatten curves)\n * 2. For each line segment, compute coverage contribution to cells\n * 3. Sweep scanlines, accumulating coverage\n * 4. Convert coverage to grayscale pixels\n *\n * Key concepts:\n * - cover: accumulated vertical change (winding contribution)\n * - area: accumulated (y-delta * x-position) for edge anti-aliasing\n *\n * Band processing:\n * - Large glyphs are divided into vertical bands\n * - Each band is rendered with bounded memory pool\n * - On overflow, band is bisected and retried\n */\n\nimport { CellBuffer, PoolOverflowError } from \"./cell.ts\";\nimport {\n\tabs,\n\tfracPixel,\n\tONE_PIXEL,\n\tPIXEL_BITS,\n\ttruncPixel,\n} from \"./fixed-point.ts\";\nimport type { Bitmap, FillRule, Span } from \"./types.ts\";\nimport { FillRule as FillRuleEnum, PixelMode } from \"./types.ts\";\n\n/** Maximum band bisection depth (like FreeType's 32 bands stack) */\nconst MAX_BAND_DEPTH = 32;\n\n/** Span buffer size for direct rendering */\nconst MAX_GRAY_SPANS = 16;\n\n/**\n * Rasterizer state\n */\nexport class GrayRaster {\n\tprivate cells: CellBuffer;\n\n\t// Current position in subpixel coordinates\n\tprivate x: number = 0;\n\tprivate y: number = 0;\n\n\t// Clip bounds in pixels\n\tprivate minX: number = 0;\n\tprivate minY: number = 0;\n\tprivate maxX: number = 0;\n\tprivate maxY: number = 0;\n\n\tconstructor() {\n\t\tthis.cells = new CellBuffer();\n\t}\n\n\t/**\n\t * Set clip rectangle (in pixels)\n\t */\n\tsetClip(minX: number, minY: number, maxX: number, maxY: number): void {\n\t\tthis.minX = minX;\n\t\tthis.minY = minY;\n\t\tthis.maxX = maxX;\n\t\tthis.maxY = maxY;\n\t\tthis.cells.setClip(minX, minY, maxX, maxY);\n\t}\n\n\t/**\n\t * Set band bounds for current render pass\n\t */\n\tsetBandBounds(minY: number, maxY: number): void {\n\t\tthis.cells.setBandBounds(minY, maxY);\n\t}\n\n\t/**\n\t * Reset rasterizer state\n\t */\n\treset(): void {\n\t\tthis.cells.reset();\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t}\n\n\t/**\n\t * Move to a new position (start new contour)\n\t * Coordinates are in subpixel units (ONE_PIXEL per pixel)\n\t */\n\tmoveTo(x: number, y: number): void {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.cells.setCurrentCell(x, y);\n\t}\n\n\t/**\n\t * Draw line to position\n\t */\n\tlineTo(toX: number, toY: number): void {\n\t\tthis.renderLine(toX, toY);\n\t\tthis.x = toX;\n\t\tthis.y = toY;\n\t}\n\n\t/**\n\t * Render a line from current position to (toX, toY)\n\t * This is the core rasterization algorithm.\n\t */\n\tprivate renderLine(toX: number, toY: number): void {\n\t\tlet ey1 = truncPixel(this.y);\n\t\tconst ey2 = truncPixel(toY);\n\n\t\t// Vertical clipping\n\t\tif (\n\t\t\t(ey1 >= this.maxY && ey2 >= this.maxY) ||\n\t\t\t(ey1 < this.minY && ey2 < this.minY)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst fy1 = fracPixel(this.y);\n\t\tconst fy2 = fracPixel(toY);\n\n\t\t// Single scanline case\n\t\tif (ey1 === ey2) {\n\t\t\tthis.renderScanline(ey1, this.x, fy1, toX, fy2);\n\t\t\treturn;\n\t\t}\n\n\t\tconst dx = toX - this.x;\n\t\tconst dy = toY - this.y;\n\n\t\t// Vertical line - optimized path\n\t\tif (dx === 0) {\n\t\t\tconst _ex = truncPixel(this.x);\n\t\t\tconst twoFx = fracPixel(this.x) * 2;\n\n\t\t\tlet first: number;\n\t\t\tlet incr: number;\n\n\t\t\tif (dy > 0) {\n\t\t\t\tfirst = ONE_PIXEL;\n\t\t\t\tincr = 1;\n\t\t\t} else {\n\t\t\t\tfirst = 0;\n\t\t\t\tincr = -1;\n\t\t\t}\n\n\t\t\t// First partial scanline\n\t\t\tlet delta = first - fy1;\n\t\t\tthis.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);\n\t\t\tthis.cells.addArea(delta * twoFx, delta);\n\t\t\tey1 += incr;\n\n\t\t\t// Full scanlines\n\t\t\tthis.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);\n\t\t\tdelta = first + first - ONE_PIXEL;\n\t\t\twhile (ey1 !== ey2) {\n\t\t\t\tthis.cells.addArea(delta * twoFx, delta);\n\t\t\t\tey1 += incr;\n\t\t\t\tthis.cells.setCurrentCell(this.x, ey1 << PIXEL_BITS);\n\t\t\t}\n\n\t\t\t// Last partial scanline\n\t\t\tdelta = fy2 - ONE_PIXEL + first;\n\t\t\tthis.cells.addArea(delta * twoFx, delta);\n\t\t\treturn;\n\t\t}\n\n\t\t// General case: line crosses multiple scanlines\n\t\tlet x = this.x;\n\t\tlet incr: number;\n\t\tlet first: number;\n\t\tlet p: number;\n\t\tconst absDy = abs(dy);\n\n\t\tif (dy > 0) {\n\t\t\tfirst = ONE_PIXEL;\n\t\t\tincr = 1;\n\t\t\tp = (ONE_PIXEL - fy1) * dx;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tincr = -1;\n\t\t\tp = fy1 * dx;\n\t\t}\n\n\t\t// First partial scanline - use FT_DIV_MOD style for accuracy\n\t\tlet delta = Math.trunc(p / absDy);\n\t\tlet mod = p % absDy;\n\t\tif (mod < 0) {\n\t\t\tdelta--;\n\t\t\tmod += absDy;\n\t\t}\n\n\t\tlet x2 = x + delta;\n\t\tthis.renderScanline(ey1, x, fy1, x2, first);\n\t\tx = x2;\n\t\tey1 += incr;\n\n\t\tthis.cells.setCurrentCell(x, ey1 << PIXEL_BITS);\n\n\t\t// Full scanlines - use modular arithmetic to accumulate remainder\n\t\tif (ey1 !== ey2) {\n\t\t\tp = ONE_PIXEL * dx;\n\t\t\tlet lift = Math.trunc(p / absDy);\n\t\t\tlet rem = p % absDy;\n\t\t\t// FT_DIV_MOD: ensure non-negative remainder (floored division)\n\t\t\tif (rem < 0) {\n\t\t\t\tlift--;\n\t\t\t\trem += absDy;\n\t\t\t}\n\n\t\t\twhile (ey1 !== ey2) {\n\t\t\t\tdelta = lift;\n\t\t\t\tmod += rem;\n\t\t\t\tif (mod >= absDy) {\n\t\t\t\t\tmod -= absDy;\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\n\t\t\t\tx2 = x + delta;\n\t\t\t\tthis.renderScanline(ey1, x, ONE_PIXEL - first, x2, first);\n\t\t\t\tx = x2;\n\t\t\t\tey1 += incr;\n\t\t\t\tthis.cells.setCurrentCell(x, ey1 << PIXEL_BITS);\n\t\t\t}\n\t\t}\n\n\t\t// Last partial scanline\n\t\tthis.renderScanline(ey1, x, ONE_PIXEL - first, toX, fy2);\n\t}\n\n\t/**\n\t * Render a line segment within a single scanline\n\t */\n\tprivate renderScanline(\n\t\tey: number,\n\t\tx1: number,\n\t\ty1: number,\n\t\tx2: number,\n\t\ty2: number,\n\t): void {\n\t\tconst ex1 = truncPixel(x1);\n\t\tconst ex2 = truncPixel(x2);\n\n\t\t// Trivial case: horizontal line\n\t\tif (y1 === y2) {\n\t\t\tthis.cells.setCurrentCell(x2, ey << PIXEL_BITS);\n\t\t\treturn;\n\t\t}\n\n\t\tconst fx1 = fracPixel(x1);\n\t\tconst fx2 = fracPixel(x2);\n\n\t\t// Single cell case\n\t\tif (ex1 === ex2) {\n\t\t\tconst delta = y2 - y1;\n\t\t\tthis.cells.setCurrentCell(x1, ey << PIXEL_BITS);\n\t\t\tthis.cells.addArea(delta * (fx1 + fx2), delta);\n\t\t\treturn;\n\t\t}\n\n\t\t// Multiple cells\n\t\tconst dx = x2 - x1;\n\t\tconst dy = y2 - y1;\n\t\tconst absDx = abs(dx);\n\n\t\tlet first: number;\n\t\tlet incr: number;\n\t\tlet p: number; // x distance to cell boundary * dy (FreeType formula)\n\n\t\tif (dx > 0) {\n\t\t\tfirst = ONE_PIXEL;\n\t\t\tincr = 1;\n\t\t\tp = (ONE_PIXEL - fx1) * dy; // Distance from fx1 to right edge\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tincr = -1;\n\t\t\tp = fx1 * dy; // Distance from fx1 to left edge\n\t\t}\n\n\t\t// First cell - use FT_DIV_MOD style for accuracy\n\t\tlet delta = Math.trunc(p / absDx);\n\t\tlet mod = p % absDx;\n\t\tif (mod < 0) {\n\t\t\tdelta--;\n\t\t\tmod += absDx;\n\t\t}\n\t\tthis.cells.setCurrentCell(x1, ey << PIXEL_BITS);\n\t\tthis.cells.addArea(delta * (fx1 + first), delta);\n\n\t\tlet y = y1 + delta;\n\t\tlet ex = ex1 + incr;\n\t\tthis.cells.setCurrentCell(ex << PIXEL_BITS, ey << PIXEL_BITS);\n\n\t\t// Middle cells (full width) - use modular arithmetic\n\t\tif (ex !== ex2) {\n\t\t\tp = ONE_PIXEL * dy;\n\t\t\tlet lift = Math.trunc(p / absDx);\n\t\t\tlet rem = p % absDx;\n\t\t\t// FT_DIV_MOD: ensure non-negative remainder (floored division)\n\t\t\tif (rem < 0) {\n\t\t\t\tlift--;\n\t\t\t\trem += absDx;\n\t\t\t}\n\n\t\t\twhile (ex !== ex2) {\n\t\t\t\tdelta = lift;\n\t\t\t\tmod += rem;\n\t\t\t\tif (mod >= absDx) {\n\t\t\t\t\tmod -= absDx;\n\t\t\t\t\tdelta++;\n\t\t\t\t}\n\t\t\t\tthis.cells.addArea(delta * ONE_PIXEL, delta);\n\t\t\t\ty += delta;\n\t\t\t\tex += incr;\n\t\t\t\tthis.cells.setCurrentCell(ex << PIXEL_BITS, ey << PIXEL_BITS);\n\t\t\t}\n\t\t}\n\n\t\t// Last cell\n\t\tdelta = y2 - y;\n\t\tthis.cells.addArea(delta * (fx2 + ONE_PIXEL - first), delta);\n\t}\n\n\t/**\n\t * Multiply and divide with 64-bit precision\n\t */\n\tprivate mulDiv(a: number, b: number, c: number): number {\n\t\tif (c === 0) return 0;\n\t\treturn Math.trunc((a * b) / c);\n\t}\n\n\t/**\n\t * Draw a quadratic Bezier curve using adaptive subdivision\n\t * Uses flatness test to minimize line segments at small font sizes\n\t */\n\tconicTo(cx: number, cy: number, toX: number, toY: number): void {\n\t\tthis.subdivConic(this.x, this.y, cx, cy, toX, toY, 0);\n\t\tthis.x = toX;\n\t\tthis.y = toY;\n\t}\n\n\t/**\n\t * Recursive quadratic subdivision with flatness test\n\t * Uses FreeType's exact flatness metric: |P0 + P2 - 2*P1| (second derivative)\n\t */\n\tprivate subdivConic(\n\t\tx1: number,\n\t\ty1: number,\n\t\tcx: number,\n\t\tcy: number,\n\t\tx3: number,\n\t\ty3: number,\n\t\tlevel: number,\n\t): void {\n\t\t// Max recursion depth\n\t\tif (level > 16) {\n\t\t\tthis.renderLine(x3, y3);\n\t\t\tthis.x = x3;\n\t\t\tthis.y = y3;\n\t\t\treturn;\n\t\t}\n\n\t\t// FreeType flatness test: |P0 + P2 - 2*P1| <= ONE_PIXEL/4\n\t\t// This measures the second derivative (how curved the quadratic is)\n\t\tlet dx = abs(x1 + x3 - 2 * cx);\n\t\tlet dy = abs(y1 + y3 - 2 * cy);\n\t\tif (dx < dy) dx = dy;\n\n\t\tif (dx <= ONE_PIXEL >> 2) {\n\t\t\t// Flat enough - render as line\n\t\t\tthis.renderLine(x3, y3);\n\t\t\tthis.x = x3;\n\t\t\tthis.y = y3;\n\t\t\treturn;\n\t\t}\n\n\t\t// De Casteljau subdivision at t=0.5\n\t\tconst x12 = (x1 + cx) >> 1;\n\t\tconst y12 = (y1 + cy) >> 1;\n\t\tconst x23 = (cx + x3) >> 1;\n\t\tconst y23 = (cy + y3) >> 1;\n\t\tconst x123 = (x12 + x23) >> 1;\n\t\tconst y123 = (y12 + y23) >> 1;\n\n\t\t// Recurse on both halves\n\t\tthis.subdivConic(x1, y1, x12, y12, x123, y123, level + 1);\n\t\tthis.subdivConic(x123, y123, x23, y23, x3, y3, level + 1);\n\t}\n\n\t/**\n\t * Draw a cubic Bezier curve\n\t */\n\tcubicTo(\n\t\tcx1: number,\n\t\tcy1: number,\n\t\tcx2: number,\n\t\tcy2: number,\n\t\tx: number,\n\t\ty: number,\n\t): void {\n\t\tthis.subdivCubic(this.x, this.y, cx1, cy1, cx2, cy2, x, y, 0);\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tprivate subdivCubic(\n\t\tx1: number,\n\t\ty1: number,\n\t\tcx1: number,\n\t\tcy1: number,\n\t\tcx2: number,\n\t\tcy2: number,\n\t\tx4: number,\n\t\ty4: number,\n\t\tlevel: number,\n\t): void {\n\t\tif (level > 16) {\n\t\t\tthis.renderLine(x4, y4);\n\t\t\tthis.x = x4;\n\t\t\tthis.y = y4;\n\t\t\treturn;\n\t\t}\n\n\t\t// FreeType flatness test: check if control points are close to\n\t\t// chord trisection points. Uses ONE_PIXEL/2 threshold.\n\t\t// |2*P3 - 3*P2 + P0| and |P3 - 3*P1 + 2*P0| for each axis\n\t\tif (\n\t\t\tabs(2 * x4 - 3 * cx2 + x1) > ONE_PIXEL >> 1 ||\n\t\t\tabs(2 * y4 - 3 * cy2 + y1) > ONE_PIXEL >> 1 ||\n\t\t\tabs(x4 - 3 * cx1 + 2 * x1) > ONE_PIXEL >> 1 ||\n\t\t\tabs(y4 - 3 * cy1 + 2 * y1) > ONE_PIXEL >> 1\n\t\t) {\n\t\t\t// Need to subdivide\n\t\t\t// De Casteljau midpoints\n\t\t\tconst x12 = (x1 + cx1) >> 1;\n\t\t\tconst y12 = (y1 + cy1) >> 1;\n\t\t\tconst x23 = (cx1 + cx2) >> 1;\n\t\t\tconst y23 = (cy1 + cy2) >> 1;\n\t\t\tconst x34 = (cx2 + x4) >> 1;\n\t\t\tconst y34 = (cy2 + y4) >> 1;\n\t\t\tconst x123 = (x12 + x23) >> 1;\n\t\t\tconst y123 = (y12 + y23) >> 1;\n\t\t\tconst x234 = (x23 + x34) >> 1;\n\t\t\tconst y234 = (y23 + y34) >> 1;\n\t\t\tconst x1234 = (x123 + x234) >> 1;\n\t\t\tconst y1234 = (y123 + y234) >> 1;\n\n\t\t\tthis.subdivCubic(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);\n\t\t\tthis.subdivCubic(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// Flat enough - render as line\n\t\tthis.renderLine(x4, y4);\n\t\tthis.x = x4;\n\t\tthis.y = y4;\n\t}\n\n\t/**\n\t * Sweep all cells and render to bitmap\n\t *\n\t * Supports both top-down (positive pitch) and bottom-up (negative pitch) bitmaps.\n\t * For positive pitch: y=0 is at top of image (first row in buffer)\n\t * For negative pitch: y=0 is at bottom of image (last row in buffer)\n\t */\n\tsweep(bitmap: Bitmap, fillRule: FillRule = FillRuleEnum.NonZero): void {\n\t\t// Calculate origin offset for pitch direction\n\t\t// Positive pitch (top-down): origin at start of buffer\n\t\t// Negative pitch (bottom-up): origin at (rows-1)*|pitch| for y=0 to be at bottom\n\t\tconst pitch = bitmap.pitch;\n\t\tconst origin = pitch < 0 ? (bitmap.rows - 1) * -pitch : 0;\n\t\tconst bitmapWidth = bitmap.width;\n\t\tconst bitmapRows = bitmap.rows;\n\n\t\t// Get pool and ycells for direct iteration (avoids generator overhead)\n\t\tconst pool = this.cells.getPool();\n\t\tconst nullIndex = this.cells.getNullIndex();\n\t\tconst ycells = this.cells.getYCells();\n\t\tconst bandMinY = this.cells.getBandMinY();\n\t\tconst ycellsLen = ycells.length;\n\n\t\t// Inline the scanline iteration - avoids generator object allocation per scanline\n\t\tfor (let i = 0; i < ycellsLen; i++) {\n\t\t\tconst firstCellIndex = ycells[i];\n\t\t\tif (firstCellIndex === nullIndex) continue;\n\n\t\t\tconst y = bandMinY + i;\n\t\t\tif (y < 0 || y >= bitmapRows) continue;\n\n\t\t\tlet cover = 0;\n\t\t\tlet x = 0;\n\t\t\t// For positive pitch: row = y * pitch (y=0 at top)\n\t\t\t// For negative pitch: row = origin - y * |pitch| (y=0 at bottom)\n\t\t\tconst row = pitch < 0 ? origin - y * -pitch : y * pitch;\n\n\t\t\t// Walk linked list directly through pool\n\t\t\tlet cellIndex = firstCellIndex;\n\t\t\twhile (cellIndex !== nullIndex) {\n\t\t\t\tconst cell = pool[cellIndex];\n\n\t\t\t\t// Fill span from previous x to current cell\n\t\t\t\t// FreeType: coverage = area >> (PIXEL_BITS * 2 + 1 - 8) = >> 9\n\t\t\t\tif (cell.x > x && cover !== 0) {\n\t\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\t\tfillRule,\n\t\t\t\t\t);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\t// Inline Math.max/min with ternary\n\t\t\t\t\t\tconst start = x < 0 ? 0 : x;\n\t\t\t\t\t\tconst end = cell.x > bitmapWidth ? bitmapWidth : cell.x;\n\t\t\t\t\t\tthis.fillSpan(bitmap, row, start, end, gray);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute anti-aliased coverage for this edge cell\n\t\t\t\t// FreeType: cover += cell->cover * (ONE_PIXEL * 2)\n\t\t\t\t//           area = cover - cell->area\n\t\t\t\t// IMPORTANT: Update cover BEFORE calculating area (FreeType order)\n\t\t\t\tcover += cell.cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = cover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\n\t\t\t\tif (gray > 0 && cell.x >= 0 && cell.x < bitmapWidth) {\n\t\t\t\t\tthis.setPixel(bitmap, row, cell.x, gray);\n\t\t\t\t}\n\n\t\t\t\tx = cell.x + 1;\n\t\t\t\tcellIndex = cell.next;\n\t\t\t}\n\n\t\t\t// Fill remaining span\n\t\t\tif (x < bitmapWidth && cover !== 0) {\n\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\tfillRule,\n\t\t\t\t);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tthis.fillSpan(bitmap, row, x, bitmapWidth, gray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate applyFillRule(value: number, fillRule: FillRule): number {\n\t\tlet v = value;\n\t\tif (v < 0) v = -v;\n\n\t\tif (fillRule === FillRuleEnum.EvenOdd) {\n\t\t\tv &= 511;\n\t\t\tif (v > 256) v = 512 - v;\n\t\t}\n\n\t\treturn v > 255 ? 255 : v;\n\t}\n\n\tprivate fillSpan(\n\t\tbitmap: Bitmap,\n\t\trow: number,\n\t\tstart: number,\n\t\tend: number,\n\t\tgray: number,\n\t): void {\n\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t// Use native TypedArray.fill() for contiguous spans\n\t\t\tbitmap.buffer.fill(gray, row + start, row + end);\n\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\tif (gray >= 128) {\n\t\t\t\tfor (let x = start; x < end; x++) {\n\t\t\t\t\tconst byteIdx = row + (x >> 3);\n\t\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\t\tbitmap.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (\n\t\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t\t) {\n\t\t\t// LCD/LCD_V: 3 bytes per pixel (RGB subpixels)\n\t\t\t// For now, write same coverage to all 3 subpixels\n\t\t\t// A proper implementation would use subpixel positioning/orientation\n\t\t\tfor (let x = start; x < end; x++) {\n\t\t\t\tconst idx = row + x * 3;\n\t\t\t\tbitmap.buffer[idx] = gray;\n\t\t\t\tbitmap.buffer[idx + 1] = gray;\n\t\t\t\tbitmap.buffer[idx + 2] = gray;\n\t\t\t}\n\t\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\t\t// RGBA: encode coverage in alpha, leave RGB black (mask texture)\n\t\t\tfor (let x = start; x < end; x++) {\n\t\t\t\tconst idx = row + x * 4;\n\t\t\t\tbitmap.buffer[idx] = 0;\n\t\t\t\tbitmap.buffer[idx + 1] = 0;\n\t\t\t\tbitmap.buffer[idx + 2] = 0;\n\t\t\t\tbitmap.buffer[idx + 3] = gray;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setPixel(bitmap: Bitmap, row: number, x: number, gray: number): void {\n\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\tbitmap.buffer[row + x] = gray;\n\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\tif (gray >= 128) {\n\t\t\t\tconst byteIdx = row + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tbitmap.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t}\n\t\t} else if (\n\t\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t\t) {\n\t\t\t// LCD/LCD_V: 3 bytes per pixel (RGB subpixels)\n\t\t\tconst idx = row + x * 3;\n\t\t\tbitmap.buffer[idx] = gray;\n\t\t\tbitmap.buffer[idx + 1] = gray;\n\t\t\tbitmap.buffer[idx + 2] = gray;\n\t\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\t\tconst idx = row + x * 4;\n\t\t\tbitmap.buffer[idx] = 0;\n\t\t\tbitmap.buffer[idx + 1] = 0;\n\t\t\tbitmap.buffer[idx + 2] = 0;\n\t\t\tbitmap.buffer[idx + 3] = gray;\n\t\t}\n\t}\n\n\t/**\n\t * Sweep and call span callback (unbuffered)\n\t * @param callback Span callback function\n\t * @param fillRule Fill rule to apply\n\t * @param userData User data passed to callback (like FreeType's render_span_data)\n\t */\n\tsweepSpans<T = void>(\n\t\tcallback: (y: number, spans: Span[], userData: T) => void,\n\t\tfillRule: FillRule = FillRuleEnum.NonZero,\n\t\tuserData?: T,\n\t): void {\n\t\tconst ycells = this.cells.getYCells();\n\t\tconst pool = this.cells.getPool();\n\t\tconst nullIndex = this.cells.getNullIndex();\n\t\tconst bandMinY = this.cells.getBandMinY();\n\n\t\tfor (let i = 0; i < ycells.length; i++) {\n\t\t\tlet cellIndex = ycells[i];\n\t\t\tif (cellIndex === nullIndex) continue;\n\n\t\t\tconst y = bandMinY + i;\n\t\t\tconst spans: Span[] = [];\n\t\t\tlet cover = 0;\n\t\t\tlet spanStart = -1;\n\n\t\t\twhile (cellIndex !== nullIndex) {\n\t\t\t\tconst cell = pool[cellIndex];\n\t\t\t\t// If we have cover, emit span\n\t\t\t\tif (cover !== 0 && cell.x > spanStart + 1) {\n\t\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\t\tfillRule,\n\t\t\t\t\t);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tspans.push({\n\t\t\t\t\t\t\tx: spanStart + 1,\n\t\t\t\t\t\t\tlen: cell.x - spanStart - 1,\n\t\t\t\t\t\t\tcoverage: gray,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Edge cell - update cover BEFORE calculating area (FreeType order)\n\t\t\t\tcover += cell.cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = cover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tspans.push({ x: cell.x, len: 1, coverage: gray });\n\t\t\t\t}\n\n\t\t\t\tspanStart = cell.x;\n\t\t\t\tcellIndex = cell.next;\n\t\t\t}\n\n\t\t\tif (spans.length > 0) {\n\t\t\t\tcallback(y, spans, userData as T);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Sweep with span buffering (like FreeType's gray_sweep_direct)\n\t * Buffers up to 16 spans before flushing for better performance\n\t * @param callback Span callback function\n\t * @param fillRule Fill rule to apply\n\t * @param minX Minimum X clip bound\n\t * @param maxX Maximum X clip bound\n\t * @param userData User data passed to callback (like FreeType's render_span_data)\n\t */\n\tsweepDirect<T = void>(\n\t\tcallback: (y: number, spans: Span[], userData: T) => void,\n\t\tfillRule: FillRule = FillRuleEnum.NonZero,\n\t\tminX: number = 0,\n\t\tmaxX: number = Infinity,\n\t\tuserData?: T,\n\t): void {\n\t\tconst spanBuffer: Span[] = [];\n\t\tconst ycells = this.cells.getYCells();\n\t\tconst pool = this.cells.getPool();\n\t\tconst nullIndex = this.cells.getNullIndex();\n\t\tconst bandMinY = this.cells.getBandMinY();\n\n\t\tfor (let i = 0; i < ycells.length; i++) {\n\t\t\tlet cellIndex = ycells[i];\n\t\t\tif (cellIndex === nullIndex) continue;\n\n\t\t\tconst y = bandMinY + i;\n\t\t\tlet cover = 0;\n\t\t\tlet x = minX;\n\n\t\t\twhile (cellIndex !== nullIndex) {\n\t\t\t\tconst cell = pool[cellIndex];\n\t\t\t\t// Fill span from previous x to current cell\n\t\t\t\tif (cover !== 0 && cell.x > x) {\n\t\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\t\tfillRule,\n\t\t\t\t\t);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tspanBuffer.push({ x, len: cell.x - x, coverage: gray });\n\t\t\t\t\t\tif (spanBuffer.length >= MAX_GRAY_SPANS) {\n\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\tspanBuffer.splice(0, spanBuffer.length),\n\t\t\t\t\t\t\t\tuserData as T,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Edge cell - update cover BEFORE calculating area (FreeType order)\n\t\t\t\tcover += cell.cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = cover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\t\t\t\tif (gray > 0 && cell.x >= minX && cell.x < maxX) {\n\t\t\t\t\tspanBuffer.push({ x: cell.x, len: 1, coverage: gray });\n\t\t\t\t\tif (spanBuffer.length >= MAX_GRAY_SPANS) {\n\t\t\t\t\t\tcallback(y, spanBuffer.splice(0, spanBuffer.length), userData as T);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx = cell.x + 1;\n\t\t\t\tcellIndex = cell.next;\n\t\t\t}\n\n\t\t\t// Fill remaining span\n\t\t\tif (cover !== 0 && x < maxX) {\n\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\tfillRule,\n\t\t\t\t);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tspanBuffer.push({\n\t\t\t\t\t\tx,\n\t\t\t\t\t\tlen: Math.min(maxX, this.maxX + 1) - x,\n\t\t\t\t\t\tcoverage: gray,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flush remaining spans for this row\n\t\t\tif (spanBuffer.length > 0) {\n\t\t\t\tcallback(y, spanBuffer.splice(0, spanBuffer.length), userData as T);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render with band processing for bounded memory.\n\t * Divides large glyphs into bands, retries with bisection on overflow.\n\t * Supports both Y-dimension (vertical) and X-dimension (horizontal) bisection\n\t * like FreeType's ftgrays.c gray_convert_glyph.\n\t *\n\t * @param bitmap Target bitmap\n\t * @param decomposeFn Function that decomposes outline to rasterizer commands\n\t * @param bounds Glyph bounds (minY, maxY, optionally minX, maxX)\n\t * @param fillRule Fill rule to apply\n\t */\n\trenderWithBands(\n\t\tbitmap: Bitmap,\n\t\tdecomposeFn: () => void,\n\t\tbounds: { minY: number; maxY: number; minX?: number; maxX?: number },\n\t\tfillRule: FillRule = FillRuleEnum.NonZero,\n\t): void {\n\t\t// Calculate initial band height based on pool size\n\t\t// Aim for bands that use ~1/8 of pool to leave room for overflow\n\t\tconst poolSize = 2048;\n\t\tconst height = bounds.maxY - bounds.minY;\n\t\tlet bandHeight = Math.max(1, Math.floor(poolSize / 8));\n\n\t\t// Adjust if glyph is small enough for single band\n\t\tif (height <= bandHeight) {\n\t\t\tbandHeight = height;\n\t\t}\n\n\t\t// X bounds default to bitmap width\n\t\tconst xMin = bounds.minX ?? 0;\n\t\tconst xMax = bounds.maxX ?? bitmap.width;\n\n\t\t// Stack for band bisection (like FreeType's bands[32])\n\t\t// Each band has Y bounds and X bounds for 2D bisection\n\t\tconst bandStack: Array<{\n\t\t\tminY: number;\n\t\t\tmaxY: number;\n\t\t\tminX: number;\n\t\t\tmaxX: number;\n\t\t\tdepth: number;\n\t\t}> = [];\n\n\t\t// Initial bands (full X range for each Y band)\n\t\tfor (let y = bounds.minY; y < bounds.maxY; y += bandHeight) {\n\t\t\tbandStack.push({\n\t\t\t\tminY: y,\n\t\t\t\tmaxY: Math.min(y + bandHeight, bounds.maxY),\n\t\t\t\tminX: xMin,\n\t\t\t\tmaxX: xMax,\n\t\t\t\tdepth: 0,\n\t\t\t});\n\t\t}\n\n\t\t// Process bands with 2D bisection on overflow\n\t\twhile (bandStack.length > 0) {\n\t\t\tconst band = bandStack.pop();\n\t\t\tif (!band) break;\n\n\t\t\tif (\n\t\t\t\tthis.renderBandWithXClip(\n\t\t\t\t\tbitmap,\n\t\t\t\t\tdecomposeFn,\n\t\t\t\t\tband.minY,\n\t\t\t\t\tband.maxY,\n\t\t\t\t\tband.minX,\n\t\t\t\t\tband.maxX,\n\t\t\t\t\tfillRule,\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue; // Success\n\t\t\t}\n\n\t\t\t// Overflow - try X bisection first (like FreeType), then Y\n\t\t\tconst bandDepth = band.depth;\n\t\t\tif (bandDepth >= MAX_BAND_DEPTH) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Rasterizer: band overflow at (${band.minX},${band.minY}), depth limit reached`,\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst childDepth = bandDepth + 1;\n\t\t\tconst midX = (band.minX + band.maxX) >> 1;\n\t\t\tif (midX > band.minX) {\n\t\t\t\t// Bisect in X dimension\n\t\t\t\tbandStack.push({\n\t\t\t\t\tminY: band.minY,\n\t\t\t\t\tmaxY: band.maxY,\n\t\t\t\t\tminX: midX,\n\t\t\t\t\tmaxX: band.maxX,\n\t\t\t\t\tdepth: childDepth,\n\t\t\t\t});\n\t\t\t\tbandStack.push({\n\t\t\t\t\tminY: band.minY,\n\t\t\t\t\tmaxY: band.maxY,\n\t\t\t\t\tminX: band.minX,\n\t\t\t\t\tmaxX: midX,\n\t\t\t\t\tdepth: childDepth,\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// X can't be bisected, try Y\n\t\t\tconst midY = (band.minY + band.maxY) >> 1;\n\t\t\tif (midY > band.minY) {\n\t\t\t\t// Bisect in Y dimension\n\t\t\t\tbandStack.push({\n\t\t\t\t\tminY: midY,\n\t\t\t\t\tmaxY: band.maxY,\n\t\t\t\t\tminX: band.minX,\n\t\t\t\t\tmaxX: band.maxX,\n\t\t\t\t\tdepth: childDepth,\n\t\t\t\t});\n\t\t\t\tbandStack.push({\n\t\t\t\t\tminY: band.minY,\n\t\t\t\t\tmaxY: midY,\n\t\t\t\t\tminX: band.minX,\n\t\t\t\t\tmaxX: band.maxX,\n\t\t\t\t\tdepth: childDepth,\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Can't bisect in either dimension - rotten glyph\n\t\t\tconsole.warn(\n\t\t\t\t`Rasterizer: band overflow at (${band.minX},${band.minY}), cannot bisect further`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Render a single band with X clipping\n\t * @returns true on success, false on pool overflow\n\t */\n\tprivate renderBandWithXClip(\n\t\tbitmap: Bitmap,\n\t\tdecomposeFn: () => void,\n\t\tminY: number,\n\t\tmaxY: number,\n\t\tminX: number,\n\t\tmaxX: number,\n\t\tfillRule: FillRule,\n\t): boolean {\n\t\t// Clip to band bounds so X/Y bisection reduces cell usage\n\t\tthis.setClip(minX, minY, maxX, maxY);\n\n\t\t// Set up band bounds\n\t\tthis.cells.setBandBounds(minY, maxY);\n\t\tthis.cells.reset();\n\t\tthis.minY = minY;\n\t\tthis.maxY = maxY;\n\n\t\ttry {\n\t\t\t// Decompose outline (may throw PoolOverflowError)\n\t\t\tdecomposeFn();\n\n\t\t\t// Sweep and render to bitmap with X clipping\n\t\t\tthis.sweepBandWithXClip(bitmap, minY, maxY, minX, maxX, fillRule);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tif (e instanceof PoolOverflowError) {\n\t\t\t\treturn false; // Need to bisect\n\t\t\t}\n\t\t\tthrow e; // Re-throw other errors\n\t\t}\n\t}\n\n\t/**\n\t * Sweep a band with X clipping and render to bitmap\n\t */\n\tprivate sweepBandWithXClip(\n\t\tbitmap: Bitmap,\n\t\tminY: number,\n\t\tmaxY: number,\n\t\tminX: number,\n\t\tmaxX: number,\n\t\tfillRule: FillRule,\n\t): void {\n\t\tconst pitch = bitmap.pitch;\n\t\tconst origin = pitch < 0 ? (bitmap.rows - 1) * -pitch : 0;\n\t\tconst ycells = this.cells.getYCells();\n\t\tconst pool = this.cells.getPool();\n\t\tconst nullIndex = this.cells.getNullIndex();\n\t\tconst bandMinY = this.cells.getBandMinY();\n\n\t\tfor (let y = minY; y < maxY; y++) {\n\t\t\tif (y < 0 || y >= bitmap.rows) continue;\n\n\t\t\tconst rowIndex = y - bandMinY;\n\t\t\tif (rowIndex < 0 || rowIndex >= ycells.length) continue;\n\n\t\t\tlet cellIndex = ycells[rowIndex];\n\t\t\tif (cellIndex === nullIndex) continue;\n\n\t\t\tlet cover = 0;\n\t\t\tlet x = minX;\n\t\t\tconst row = pitch < 0 ? origin - y * -pitch : y * pitch;\n\n\t\t\twhile (cellIndex !== nullIndex) {\n\t\t\t\tconst cell = pool[cellIndex];\n\t\t\t\t// Skip cells outside X clip\n\t\t\t\tif (cell.x < minX) {\n\t\t\t\t\tcover += cell.cover * (ONE_PIXEL * 2);\n\t\t\t\t\tcellIndex = cell.next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cell.x >= maxX) {\n\t\t\t\t\t// Fill remaining clipped span\n\t\t\t\t\tif (cover !== 0 && x < maxX) {\n\t\t\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\t\t\tfillRule,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\t\tthis.fillSpan(\n\t\t\t\t\t\t\t\tbitmap,\n\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\tMath.max(0, x),\n\t\t\t\t\t\t\t\tMath.min(bitmap.width, maxX),\n\t\t\t\t\t\t\t\tgray,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Fill span from previous x to current cell\n\t\t\t\tif (cell.x > x && cover !== 0) {\n\t\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\t\tfillRule,\n\t\t\t\t\t);\n\t\t\t\t\tif (gray > 0) {\n\t\t\t\t\t\tconst start = Math.max(0, x);\n\t\t\t\t\t\tconst end = Math.min(bitmap.width, cell.x);\n\t\t\t\t\t\tthis.fillSpan(bitmap, row, start, end, gray);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Edge cell - update cover BEFORE calculating area (FreeType order)\n\t\t\t\tcover += cell.cover * (ONE_PIXEL * 2);\n\t\t\t\tconst area = cover - cell.area;\n\t\t\t\tconst gray = this.applyFillRule(area >> (PIXEL_BITS + 1), fillRule);\n\n\t\t\t\tif (gray > 0 && cell.x >= 0 && cell.x < bitmap.width) {\n\t\t\t\t\tthis.setPixel(bitmap, row, cell.x, gray);\n\t\t\t\t}\n\n\t\t\t\tx = cell.x + 1;\n\t\t\t\tcellIndex = cell.next;\n\t\t\t}\n\n\t\t\t// Fill remaining span within X clip\n\t\t\tif (x < maxX && x < bitmap.width && cover !== 0) {\n\t\t\t\tconst gray = this.applyFillRule(\n\t\t\t\t\tcover >> (PIXEL_BITS + 1),\n\t\t\t\t\tfillRule,\n\t\t\t\t);\n\t\t\t\tif (gray > 0) {\n\t\t\t\t\tthis.fillSpan(bitmap, row, x, Math.min(bitmap.width, maxX), gray);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "/**\n * Decompose path commands into rasterizer calls\n */\n\nimport {\n\ttype GlyphPath,\n\tOutlineFlags,\n\ttype PathCommand,\n} from \"../render/path.ts\";\nimport { ONE_PIXEL } from \"./fixed-point.ts\";\nimport type { GrayRaster } from \"./gray-raster.ts\";\nimport { FillRule } from \"./types.ts\";\n\n/**\n * Outline validation error types (like FreeType's error codes)\n */\nexport enum OutlineError {\n\tOk = 0,\n\tInvalidOutline = 1,\n\tInvalidArgument = 2,\n\tEmptyOutline = 3,\n}\n\n/**\n * Validation result with error code and message\n */\nexport interface ValidationResult {\n\terror: OutlineError;\n\tmessage?: string;\n}\n\n/**\n * Validate a GlyphPath before rasterization (like FreeType's outline validation)\n * Checks: path existence, command structure validity, and proper contour closure\n * @param path Glyph path to validate\n * @param allowEmpty Whether empty paths are considered valid (default: true)\n * @returns Validation result with error code and optional message\n */\nexport function validateOutline(\n\tpath: GlyphPath | null | undefined,\n\tallowEmpty: boolean = true,\n): ValidationResult {\n\t// Check for null/undefined path\n\tif (!path) {\n\t\treturn {\n\t\t\terror: OutlineError.InvalidOutline,\n\t\t\tmessage: \"Path is null or undefined\",\n\t\t};\n\t}\n\n\t// Check commands array exists\n\tif (!path.commands) {\n\t\treturn {\n\t\t\terror: OutlineError.InvalidOutline,\n\t\t\tmessage: \"Path commands array is missing\",\n\t\t};\n\t}\n\n\t// Check for empty path\n\tif (path.commands.length === 0) {\n\t\tif (allowEmpty) {\n\t\t\treturn { error: OutlineError.EmptyOutline };\n\t\t}\n\t\treturn { error: OutlineError.InvalidOutline, message: \"Path is empty\" };\n\t}\n\n\t// Validate command structure\n\tlet hasMove = false;\n\tlet inContour = false;\n\tlet contourCount = 0;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i];\n\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tif (inContour) {\n\t\t\t\t\t// Implicit close - allowed but noted\n\t\t\t\t}\n\t\t\t\thasMove = true;\n\t\t\t\tinContour = true;\n\t\t\t\tcontourCount++;\n\t\t\t\t// Validate coordinates are finite numbers\n\t\t\t\tif (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}: (${cmd.x}, ${cmd.y})`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tif (!hasMove) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Line command at ${i} without preceding moveTo`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Q\":\n\t\t\t\tif (!hasMove) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Quadratic curve at ${i} without preceding moveTo`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!Number.isFinite(cmd.x1) ||\n\t\t\t\t\t!Number.isFinite(cmd.y1) ||\n\t\t\t\t\t!Number.isFinite(cmd.x) ||\n\t\t\t\t\t!Number.isFinite(cmd.y)\n\t\t\t\t) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"C\":\n\t\t\t\tif (!hasMove) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Cubic curve at ${i} without preceding moveTo`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!Number.isFinite(cmd.x1) ||\n\t\t\t\t\t!Number.isFinite(cmd.y1) ||\n\t\t\t\t\t!Number.isFinite(cmd.x2) ||\n\t\t\t\t\t!Number.isFinite(cmd.y2) ||\n\t\t\t\t\t!Number.isFinite(cmd.x) ||\n\t\t\t\t\t!Number.isFinite(cmd.y)\n\t\t\t\t) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\t\tmessage: `Invalid coordinates at command ${i}`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Z\":\n\t\t\t\tinContour = false;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn {\n\t\t\t\t\terror: OutlineError.InvalidOutline,\n\t\t\t\t\tmessage: `Unknown command type at ${i}: ${(cmd as PathCommand).type}`,\n\t\t\t\t};\n\t\t}\n\t}\n\n\t// Warn if no contours found (valid but useless)\n\tif (contourCount === 0 && !allowEmpty) {\n\t\treturn { error: OutlineError.EmptyOutline, message: \"No contours in path\" };\n\t}\n\n\treturn { error: OutlineError.Ok };\n}\n\n/**\n * Convert a GlyphPath to rasterizer commands\n * @param raster The rasterizer instance to receive commands\n * @param path Path commands to decompose\n * @param scale Scale factor (font units to pixels)\n * @param offsetX X offset in pixels (default: 0)\n * @param offsetY Y offset in pixels (default: 0)\n * @param flipY Flip Y axis - font coords are Y-up, bitmap is Y-down (default: true)\n */\nexport function decomposePath(\n\traster: GrayRaster,\n\tpath: GlyphPath,\n\tscale: number,\n\toffsetX: number = 0,\n\toffsetY: number = 0,\n\tflipY: boolean = true,\n): void {\n\tlet startX = 0;\n\tlet startY = 0;\n\tlet inContour = false;\n\n\t// Precompute scale factors to avoid per-command branching\n\tconst scaleX = scale * ONE_PIXEL;\n\tconst scaleY = (flipY ? -scale : scale) * ONE_PIXEL;\n\tconst offX = offsetX * ONE_PIXEL;\n\tconst offY = offsetY * ONE_PIXEL;\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\t// Close previous contour if open\n\t\t\t\tif (inContour) {\n\t\t\t\t\traster.lineTo(startX, startY);\n\t\t\t\t}\n\n\t\t\t\t// Convert to subpixel coordinates with precomputed factors\n\t\t\t\tconst x = Math.round(cmd.x * scaleX + offX);\n\t\t\t\tconst y = Math.round(cmd.y * scaleY + offY);\n\n\t\t\t\traster.moveTo(x, y);\n\t\t\t\tstartX = x;\n\t\t\t\tstartY = y;\n\t\t\t\tinContour = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"L\": {\n\t\t\t\tconst x = Math.round(cmd.x * scaleX + offX);\n\t\t\t\tconst y = Math.round(cmd.y * scaleY + offY);\n\t\t\t\traster.lineTo(x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"Q\": {\n\t\t\t\tconst cx = Math.round(cmd.x1 * scaleX + offX);\n\t\t\t\tconst cy = Math.round(cmd.y1 * scaleY + offY);\n\t\t\t\tconst x = Math.round(cmd.x * scaleX + offX);\n\t\t\t\tconst y = Math.round(cmd.y * scaleY + offY);\n\t\t\t\traster.conicTo(cx, cy, x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"C\": {\n\t\t\t\tconst cx1 = Math.round(cmd.x1 * scaleX + offX);\n\t\t\t\tconst cy1 = Math.round(cmd.y1 * scaleY + offY);\n\t\t\t\tconst cx2 = Math.round(cmd.x2 * scaleX + offX);\n\t\t\t\tconst cy2 = Math.round(cmd.y2 * scaleY + offY);\n\t\t\t\tconst x = Math.round(cmd.x * scaleX + offX);\n\t\t\t\tconst y = Math.round(cmd.y * scaleY + offY);\n\t\t\t\traster.cubicTo(cx1, cy1, cx2, cy2, x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"Z\": {\n\t\t\t\t// Close contour\n\t\t\t\tif (inContour) {\n\t\t\t\t\traster.lineTo(startX, startY);\n\t\t\t\t\tinContour = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Close final contour if still open\n\tif (inContour) {\n\t\traster.lineTo(startX, startY);\n\t}\n}\n\n/**\n * Calculate bounding box of path in pixel coordinates\n * @param path Glyph path to measure\n * @param scale Scale factor (font units to pixels)\n * @param flipY Flip Y axis for bitmap coordinates (default: true)\n * @returns Bounding box in pixel coordinates, or null if path has no bounds\n */\nfunction mulFix(value: number, scaleFix: number): number {\n\tif (value === 0 || scaleFix === 0) return 0;\n\tlet sign = 1;\n\tlet a = value;\n\tlet b = scaleFix;\n\tif (a < 0) {\n\t\ta = -a;\n\t\tsign = -sign;\n\t}\n\tif (b < 0) {\n\t\tb = -b;\n\t\tsign = -sign;\n\t}\n\tconst result = Math.floor((a * b + 0x8000) / 0x10000);\n\treturn sign < 0 ? -result : result;\n}\n\nexport function getPathBounds(\n\tpath: GlyphPath,\n\tscale: number,\n\tflipY: boolean = true,\n\troundToGrid: boolean = false,\n): { minX: number; minY: number; maxX: number; maxY: number } | null {\n\tif (roundToGrid) {\n\t\tconst scale26Fix = Math.round(scale * 64 * 0x10000);\n\t\tlet minX26 = Infinity;\n\t\tlet minY26 = Infinity;\n\t\tlet maxX26 = -Infinity;\n\t\tlet maxY26 = -Infinity;\n\n\t\tconst update = (x: number, y: number): void => {\n\t\t\tconst rx = mulFix(x, scale26Fix);\n\t\t\tconst ry = mulFix(y, scale26Fix);\n\t\t\tif (rx < minX26) minX26 = rx;\n\t\t\tif (rx > maxX26) maxX26 = rx;\n\t\t\tif (ry < minY26) minY26 = ry;\n\t\t\tif (ry > maxY26) maxY26 = ry;\n\t\t};\n\n\t\tfor (const cmd of path.commands) {\n\t\t\tswitch (cmd.type) {\n\t\t\t\tcase \"M\":\n\t\t\t\tcase \"L\":\n\t\t\t\t\tupdate(cmd.x, cmd.y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Q\":\n\t\t\t\t\tupdate(cmd.x1, cmd.y1);\n\t\t\t\t\tupdate(cmd.x, cmd.y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"C\":\n\t\t\t\t\tupdate(cmd.x1, cmd.y1);\n\t\t\t\t\tupdate(cmd.x2, cmd.y2);\n\t\t\t\t\tupdate(cmd.x, cmd.y);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!Number.isFinite(minX26) || !Number.isFinite(minY26)) return null;\n\n\t\tif (flipY) {\n\t\t\tconst flippedMinY = -maxY26;\n\t\t\tconst flippedMaxY = -minY26;\n\t\t\treturn {\n\t\t\t\tminX: Math.floor(minX26 / 64),\n\t\t\t\tminY: Math.floor(flippedMinY / 64),\n\t\t\t\tmaxX: Math.floor((maxX26 + 63) / 64),\n\t\t\t\tmaxY: Math.floor((flippedMaxY + 63) / 64),\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tminX: Math.floor(minX26 / 64),\n\t\t\tminY: Math.floor(minY26 / 64),\n\t\t\tmaxX: Math.floor((maxX26 + 63) / 64),\n\t\t\tmaxY: Math.floor((maxY26 + 63) / 64),\n\t\t};\n\t}\n\n\tif (!path.bounds) return null;\n\n\tconst b = path.bounds;\n\tif (flipY) {\n\t\treturn {\n\t\t\tminX: Math.floor(b.xMin * scale),\n\t\t\tminY: Math.floor(-b.yMax * scale),\n\t\t\tmaxX: Math.ceil(b.xMax * scale),\n\t\t\tmaxY: Math.ceil(-b.yMin * scale),\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\tminX: Math.floor(b.xMin * scale),\n\t\t\tminY: Math.floor(b.yMin * scale),\n\t\t\tmaxX: Math.ceil(b.xMax * scale),\n\t\t\tmaxY: Math.ceil(b.yMax * scale),\n\t\t};\n\t}\n}\n\n/**\n * Get fill rule from outline flags (like FreeType's FT_OUTLINE_EVEN_ODD_FILL check)\n * @param path Path with optional flags\n * @param defaultRule Default fill rule if flags not set (default: NonZero)\n * @returns Fill rule to use for rendering\n */\nexport function getFillRuleFromFlags(\n\tpath: GlyphPath | null | undefined,\n\tdefaultRule: FillRule = FillRule.NonZero,\n): FillRule {\n\tif (!path?.flags) return defaultRule;\n\treturn (path.flags & OutlineFlags.EvenOddFill) !== 0\n\t\t? FillRule.EvenOdd\n\t\t: FillRule.NonZero;\n}\n",
    "/**\n * High-level rasterization API\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport { CompositeFlag } from \"../font/tables/glyf.ts\";\nimport {\n\tcreateHintingEngine,\n\ttype GlyphOutline,\n\ttype HintedGlyph,\n\ttype HintingEngine,\n\thintGlyph,\n\tloadCVTProgram,\n\tloadFontProgram,\n\tsetSize,\n} from \"../hinting/programs.ts\";\nimport { scaleFUnits } from \"../hinting/scale.ts\";\nimport { type GlyphPath, getGlyphPath } from \"../render/path.ts\";\nimport type { Matrix2D, Matrix3x3 } from \"../render/outline-transform.ts\";\nimport type { GlyphId } from \"../types.ts\";\nimport { PoolOverflowError } from \"./cell.ts\";\nimport { GrayRaster } from \"./gray-raster.ts\";\nimport { decomposePath, getPathBounds } from \"./outline-decompose.ts\";\nimport {\n\ttype Bitmap,\n\tcreateBitmap,\n\tFillRule,\n\tPixelMode,\n\ttype GlyphRasterizeOptions,\n\ttype RasterizedGlyph,\n\ttype RasterizeOptions,\n\ttype TextRasterizeOptions,\n} from \"./types.ts\";\nimport { transformBitmap2D, transformBitmap3D } from \"./bitmap-utils.ts\";\nimport { resolveFontScale, resolveFontSize } from \"./size.ts\";\n\n/** Cached hinting engines per font */\nconst hintingEngineCache = new WeakMap<Font, HintingEngine>();\n\n/** Shared GrayRaster instance for reuse (avoids 2KB allocation per glyph) */\nlet sharedRaster: GrayRaster | null = null;\n\n/** Get or create shared rasterizer */\nfunction getSharedRaster(): GrayRaster {\n\tif (!sharedRaster) sharedRaster = new GrayRaster();\n\treturn sharedRaster;\n}\n\n/** Shared bitmap buffer for reuse */\nlet sharedBuffer: Uint8Array | null = null;\nlet sharedBufferSize = 0;\n\n/** Get or create shared buffer, reusing if possible */\nfunction getSharedBuffer(size: number): Uint8Array {\n\tif (size <= sharedBufferSize && sharedBuffer) {\n\t\tsharedBuffer.fill(0, 0, size);\n\t\treturn sharedBuffer;\n\t}\n\t// Allocate new buffer (with some extra capacity for future reuse)\n\tconst allocSize = Math.max(size, 4096);\n\tsharedBuffer = new Uint8Array(allocSize);\n\tsharedBufferSize = allocSize;\n\treturn sharedBuffer;\n}\n\n/** Create bitmap with shared buffer */\nfunction createBitmapShared(\n\twidth: number,\n\theight: number,\n\tpixelMode: PixelMode,\n): Bitmap {\n\tconst bytesPerPixel =\n\t\tpixelMode === PixelMode.RGBA\n\t\t\t? 4\n\t\t\t: pixelMode === PixelMode.LCD || pixelMode === PixelMode.LCD_V\n\t\t\t\t? 3\n\t\t\t\t: pixelMode === PixelMode.Mono\n\t\t\t\t\t? 0.125\n\t\t\t\t\t: 1;\n\tconst pitch =\n\t\tpixelMode === PixelMode.Mono\n\t\t\t? Math.ceil(width / 8)\n\t\t\t: Math.ceil(width * bytesPerPixel);\n\tconst size = pitch * height;\n\tconst buffer = getSharedBuffer(size);\n\n\treturn {\n\t\twidth,\n\t\trows: height,\n\t\tpitch,\n\t\tbuffer: buffer.subarray(0, size),\n\t\tpixelMode,\n\t\tnumGrays: pixelMode === PixelMode.Mono ? 2 : 256,\n\t};\n}\n\n/** Cached hinted glyphs per font */\nconst hintedGlyphCache = new WeakMap<Font, Map<string, HintedGlyph | null>>();\n\nfunction shouldScaleComponentOffset(flags: number): boolean {\n\tif (flags & CompositeFlag.UnscaledComponentOffset) return false;\n\tif (flags & CompositeFlag.ScaledComponentOffset) return true;\n\treturn false;\n}\n\nfunction roundOffsetToGrid(value26: number): number {\n\treturn Math.round(value26 / 64) * 64;\n}\n\ntype Points26 = {\n\txCoords: number[];\n\tyCoords: number[];\n\tflags: Uint8Array;\n\tcontourEnds: number[];\n};\n\nfunction buildGlyphPoints26(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tscale: number,\n\tdepth: number = 0,\n\toptions?: { roundCompositeOffsets?: boolean },\n): Points26 | null {\n\tif (depth > 32) return null;\n\tconst glyph = font.getGlyph(glyphId);\n\tif (!glyph || glyph.type === \"empty\") return null;\n\tconst roundCompositeOffsets = options?.roundCompositeOffsets ?? true;\n\n\tif (glyph.type === \"simple\") {\n\t\tconst xCoords: number[] = [];\n\t\tconst yCoords: number[] = [];\n\t\tconst flags: number[] = [];\n\t\tconst contourEnds: number[] = [];\n\t\tlet pointIndex = 0;\n\t\tfor (const contour of glyph.contours) {\n\t\t\tfor (const point of contour) {\n\t\t\t\txCoords.push(Math.round(point.x * scale));\n\t\t\t\tyCoords.push(Math.round(point.y * scale));\n\t\t\t\tflags.push(point.onCurve ? 1 : 0);\n\t\t\t\tpointIndex++;\n\t\t\t}\n\t\t\tcontourEnds.push(pointIndex - 1);\n\t\t}\n\t\treturn {\n\t\t\txCoords,\n\t\t\tyCoords,\n\t\t\tflags: new Uint8Array(flags),\n\t\t\tcontourEnds,\n\t\t};\n\t}\n\n\tconst xCoords: number[] = [];\n\tconst yCoords: number[] = [];\n\tconst flags: number[] = [];\n\tconst contourEnds: number[] = [];\n\tconst parentPoints: { x: number; y: number }[] = [];\n\tlet pointIndex = 0;\n\n\tfor (const component of glyph.components) {\n\t\tconst comp = buildGlyphPoints26(font, component.glyphId, scale, depth + 1, {\n\t\t\troundCompositeOffsets,\n\t\t});\n\t\tif (!comp || comp.xCoords.length === 0) continue;\n\n\t\tconst [a, b, c, d] = component.transform;\n\t\tconst hasXY = (component.flags & CompositeFlag.ArgsAreXYValues) !== 0;\n\n\t\tconst tx: number[] = new Array(comp.xCoords.length);\n\t\tconst ty: number[] = new Array(comp.yCoords.length);\n\t\tfor (let i = 0; i < comp.xCoords.length; i++) {\n\t\t\tconst cx = comp.xCoords[i]!;\n\t\t\tconst cy = comp.yCoords[i]!;\n\t\t\ttx[i] = Math.round(a * cx + c * cy);\n\t\t\tty[i] = Math.round(b * cx + d * cy);\n\t\t}\n\n\t\tlet dx26 = 0;\n\t\tlet dy26 = 0;\n\n\t\tif (hasXY) {\n\t\t\tconst rawDx = component.arg1;\n\t\t\tconst rawDy = component.arg2;\n\t\t\tif (shouldScaleComponentOffset(component.flags)) {\n\t\t\t\tconst dx = Math.round(rawDx * scale);\n\t\t\t\tconst dy = Math.round(rawDy * scale);\n\t\t\t\tdx26 = Math.round(a * dx + c * dy);\n\t\t\t\tdy26 = Math.round(b * dx + d * dy);\n\t\t\t} else {\n\t\t\t\tdx26 = Math.round(rawDx * scale);\n\t\t\t\tdy26 = Math.round(rawDy * scale);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\troundCompositeOffsets &&\n\t\t\t\t(component.flags & CompositeFlag.RoundXYToGrid)\n\t\t\t) {\n\t\t\t\tdx26 = roundOffsetToGrid(dx26);\n\t\t\t\tdy26 = roundOffsetToGrid(dy26);\n\t\t\t}\n\t\t} else {\n\t\t\tconst parentIndex = component.arg1;\n\t\t\tconst compIndex = component.arg2;\n\t\t\tif (\n\t\t\t\tparentIndex >= 0 &&\n\t\t\t\tparentIndex < parentPoints.length &&\n\t\t\t\tcompIndex >= 0 &&\n\t\t\t\tcompIndex < tx.length\n\t\t\t) {\n\t\t\t\tconst parentPoint = parentPoints[parentIndex]!;\n\t\t\t\tdx26 = parentPoint.x - tx[compIndex]!;\n\t\t\t\tdy26 = parentPoint.y - ty[compIndex]!;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < tx.length; i++) {\n\t\t\tconst x = tx[i]! + dx26;\n\t\t\tconst y = ty[i]! + dy26;\n\t\t\txCoords.push(x);\n\t\t\tyCoords.push(y);\n\t\t\tflags.push(comp.flags[i] ?? 0);\n\t\t\tparentPoints.push({ x, y });\n\t\t}\n\n\t\tfor (let i = 0; i < comp.contourEnds.length; i++) {\n\t\t\tcontourEnds.push(pointIndex + comp.contourEnds[i]!);\n\t\t}\n\t\tpointIndex += tx.length;\n\t}\n\n\tif (xCoords.length === 0) return null;\n\treturn {\n\t\txCoords,\n\t\tyCoords,\n\t\tflags: new Uint8Array(flags),\n\t\tcontourEnds,\n\t};\n}\n\nfunction hintCompositeGlyph(\n\tengine: HintingEngine,\n\tfont: Font,\n\tglyph: NonNullable<ReturnType<Font[\"getGlyph\"]>>,\n\tppem: number,\n\tdepth: number,\n): HintedGlyph | null {\n\tif (glyph.type !== \"composite\") return null;\n\tif (depth > 16) return null;\n\n\tconst xCoords: number[] = [];\n\tconst yCoords: number[] = [];\n\tconst flags: number[] = [];\n\tconst contourEnds: number[] = [];\n\tconst parentPoints: { x: number; y: number }[] = [];\n\tlet pointIndex = 0;\n\n\tfor (let i = 0; i < glyph.components.length; i++) {\n\t\tconst component = glyph.components[i]!;\n\t\tconst hinted = getCachedHintedGlyph(\n\t\t\tengine,\n\t\t\tfont,\n\t\t\tcomponent.glyphId,\n\t\t\tppem,\n\t\t\tdepth + 1,\n\t\t);\n\t\tif (!hinted || hinted.xCoords.length === 0) continue;\n\n\t\tconst [a, b, c, d] = component.transform;\n\t\tconst hasXY = (component.flags & CompositeFlag.ArgsAreXYValues) !== 0;\n\n\t\tlet dx26 = 0;\n\t\tlet dy26 = 0;\n\n\t\tif (hasXY) {\n\t\t\tlet dx = component.arg1;\n\t\t\tlet dy = component.arg2;\n\t\t\tif (shouldScaleComponentOffset(component.flags)) {\n\t\t\t\tconst scaledX = a * dx + c * dy;\n\t\t\t\tconst scaledY = b * dx + d * dy;\n\t\t\t\tdx = scaledX;\n\t\t\t\tdy = scaledY;\n\t\t\t}\n\t\t\tdx26 = scaleFUnits(dx, engine.ctx.scaleFix);\n\t\t\tdy26 = scaleFUnits(dy, engine.ctx.scaleFix);\n\t\t\tif (component.flags & CompositeFlag.RoundXYToGrid) {\n\t\t\t\tdx26 = roundOffsetToGrid(dx26);\n\t\t\t\tdy26 = roundOffsetToGrid(dy26);\n\t\t\t}\n\t\t} else {\n\t\t\tconst parentIndex = component.arg1;\n\t\t\tconst compIndex = component.arg2;\n\t\t\tif (\n\t\t\t\tparentIndex >= 0 &&\n\t\t\t\tparentIndex < parentPoints.length &&\n\t\t\t\tcompIndex >= 0 &&\n\t\t\t\tcompIndex < hinted.xCoords.length\n\t\t\t) {\n\t\t\t\tconst parentPoint = parentPoints[parentIndex]!;\n\t\t\t\tconst compX = a * hinted.xCoords[compIndex]! + c * hinted.yCoords[compIndex]!;\n\t\t\t\tconst compY = b * hinted.xCoords[compIndex]! + d * hinted.yCoords[compIndex]!;\n\t\t\t\tdx26 = Math.round(parentPoint.x - compX);\n\t\t\t\tdy26 = Math.round(parentPoint.y - compY);\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = 0; j < hinted.xCoords.length; j++) {\n\t\t\tconst hx = hinted.xCoords[j]!;\n\t\t\tconst hy = hinted.yCoords[j]!;\n\t\t\tconst x = Math.round(a * hx + c * hy + dx26);\n\t\t\tconst y = Math.round(b * hx + d * hy + dy26);\n\t\t\txCoords.push(x);\n\t\t\tyCoords.push(y);\n\t\t\tflags.push(hinted.flags[j] ?? 0);\n\t\t\tparentPoints.push({ x, y });\n\t\t}\n\n\t\tfor (let j = 0; j < hinted.contourEnds.length; j++) {\n\t\t\tcontourEnds.push(pointIndex + hinted.contourEnds[j]!);\n\t\t}\n\t\tpointIndex += hinted.xCoords.length;\n\t}\n\n\tif (xCoords.length === 0) return null;\n\treturn {\n\t\txCoords,\n\t\tyCoords,\n\t\tflags: new Uint8Array(flags),\n\t\tcontourEnds,\n\t\terror: null,\n\t};\n}\n\n/** Get cached hinted glyph or compute and cache it */\nfunction getCachedHintedGlyph(\n\tengine: HintingEngine,\n\tfont: Font,\n\tglyphId: GlyphId,\n\tppem: number,\n\tpointSize: number,\n\tdepth: number = 0,\n): HintedGlyph | null {\n\tconst pointKey = Math.round(pointSize * 64);\n\tconst key = `${glyphId}:${ppem}:${pointKey}:${engine.ctx.lightMode ? \"light\" : \"full\"}`;\n\tlet cache = hintedGlyphCache.get(font);\n\tif (!cache) {\n\t\tcache = new Map();\n\t\thintedGlyphCache.set(font, cache);\n\t}\n\n\tconst cached = cache.get(key);\n\tif (cached !== undefined) return cached;\n\n\tconst glyph = font.getGlyph(glyphId);\n\tif (!glyph || glyph.type === \"empty\") {\n\t\tcache.set(key, null);\n\t\treturn null;\n\t}\n\n\tconst error = setSize(engine, ppem, pointSize);\n\tif (error) {\n\t\tcache.set(key, null);\n\t\treturn null;\n\t}\n\n\tif (glyph.type === \"composite\" && glyph.instructions.length === 0) {\n\t\tconst compositeHinted = hintCompositeGlyph(engine, font, glyph, ppem, depth);\n\t\tif (compositeHinted && compositeHinted.xCoords.length > 0) {\n\t\t\tcache.set(key, compositeHinted);\n\t\t\treturn compositeHinted;\n\t\t}\n\t}\n\n\t// Compute hinted glyph from flattened outline\n\tconst outline = glyphToOutline(font, glyphId, engine.ctx.scale);\n\tif (!outline) {\n\t\tcache.set(key, null);\n\t\treturn null;\n\t}\n\n\tconst hinted = hintGlyph(engine, outline);\n\tif (hinted.error || hinted.xCoords.length === 0) {\n\t\tcache.set(key, null);\n\t\treturn null;\n\t}\n\n\tcache.set(key, hinted);\n\treturn hinted;\n}\n\n/** Get or create hinting engine for a font */\nfunction getHintingEngine(font: Font): HintingEngine | null {\n\tif (!font.isTrueType || !font.hasHinting) return null;\n\n\tlet engine = hintingEngineCache.get(font);\n\tif (engine) return engine;\n\n\tconst cvt = font.cvtTable;\n\tconst cvtValues = cvt ? new Int32Array(cvt.values) : undefined;\n\n\tconst maxp = font.maxp;\n\tengine = createHintingEngine(\n\t\tfont.unitsPerEm,\n\t\t\"maxStackElements\" in maxp ? maxp.maxStackElements : 256,\n\t\t\"maxStorage\" in maxp ? maxp.maxStorage : 64,\n\t\t\"maxFunctionDefs\" in maxp ? maxp.maxFunctionDefs : 64,\n\t\t\"maxTwilightPoints\" in maxp ? maxp.maxTwilightPoints : 16,\n\t\tcvtValues,\n\t);\n\n\tconst fpgm = font.fpgm;\n\tif (fpgm) loadFontProgram(engine, fpgm.instructions);\n\n\tconst prep = font.prep;\n\tif (prep) loadCVTProgram(engine, prep.instructions);\n\n\thintingEngineCache.set(font, engine);\n\treturn engine;\n}\n\n/** Convert TrueType glyph to outline for hinting */\nfunction glyphToOutline(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tscale?: number,\n): GlyphOutline | null {\n\tconst glyph = font.getGlyph(glyphId);\n\tif (!glyph || glyph.type === \"empty\") return null;\n\n\tconst xCoords: number[] = [];\n\tconst yCoords: number[] = [];\n\tconst flags: number[] = [];\n\tconst contourEnds: number[] = [];\n\n\t// Get metrics for phantom points\n\tconst advanceWidth = font.advanceWidth(glyphId);\n\tconst lsb = font.leftSideBearing(glyphId);\n\n\tif (glyph.type === \"composite\" && glyph.instructions.length > 0 && scale) {\n\t\tconst points26 = buildGlyphPoints26(font, glyphId, scale);\n\t\tif (!points26 || points26.xCoords.length === 0) return null;\n\t\tconst invScale = 1 / scale;\n\t\tfor (let i = 0; i < points26.xCoords.length; i++) {\n\t\t\txCoords.push(points26.xCoords[i]! * invScale);\n\t\t\tyCoords.push(points26.yCoords[i]! * invScale);\n\t\t\tflags.push(points26.flags[i] ?? 0);\n\t\t}\n\t\tfor (let i = 0; i < points26.contourEnds.length; i++) {\n\t\t\tcontourEnds.push(points26.contourEnds[i]!);\n\t\t}\n\t} else {\n\t\tconst contours =\n\t\t\tglyph.type === \"simple\"\n\t\t\t\t? glyph.contours\n\t\t\t\t: font.getGlyphContours(glyphId);\n\t\tif (!contours || contours.length === 0) return null;\n\n\t\tlet pointIndex = 0;\n\t\tfor (let i = 0; i < contours.length; i++) {\n\t\t\tconst contour = contours[i]!;\n\t\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\t\tconst point = contour[j]!;\n\t\t\t\txCoords.push(point.x);\n\t\t\t\tyCoords.push(point.y);\n\t\t\t\tflags.push(point.onCurve ? 1 : 0);\n\t\t\t\tpointIndex++;\n\t\t\t}\n\t\t\tcontourEnds.push(pointIndex - 1);\n\t\t}\n\t}\n\n\treturn {\n\t\txCoords,\n\t\tyCoords,\n\t\tflags: new Uint8Array(flags),\n\t\tcontourEnds,\n\t\tinstructions: glyph.instructions,\n\t\tlsb,\n\t\tadvanceWidth,\n\t\tisComposite: glyph.type === \"composite\",\n\t};\n}\n\n/** Decompose hinted glyph to rasterizer */\nfunction decomposeHintedGlyph(\n\traster: GrayRaster,\n\thinted: HintedGlyph,\n\toffsetX: number,\n\toffsetY: number,\n): void {\n\tconst { xCoords, yCoords, flags, contourEnds } = hinted;\n\n\tlet contourIdx = 0;\n\tlet contourStart = 0;\n\n\tfor (let i = 0; i < xCoords.length; i++) {\n\t\tconst contourEnd = contourEnds[contourIdx]!;\n\t\tconst isEnd = i === contourEnd;\n\n\t\t// Convert 26.6 to rasterizer format (shift left 2 for 26.8)\n\t\tconst x = ((xCoords[i]! << 2) | 0) + (offsetX << 8);\n\t\tconst y = ((-yCoords[i]! << 2) | 0) + (offsetY << 8); // Flip Y\n\t\tconst onCurve = (flags[i]! & 1) !== 0;\n\n\t\tif (i === contourStart) {\n\t\t\traster.moveTo(x, y);\n\t\t} else if (onCurve) {\n\t\t\traster.lineTo(x, y);\n\t\t} else {\n\t\t\t// Off-curve point: draw conic to next point or implicit midpoint\n\t\t\tconst nextIdx = isEnd ? contourStart : i + 1;\n\t\t\tconst nx = ((xCoords[nextIdx]! << 2) | 0) + (offsetX << 8);\n\t\t\tconst ny = ((-yCoords[nextIdx]! << 2) | 0) + (offsetY << 8);\n\t\t\tconst nextOn = (flags[nextIdx]! & 1) !== 0;\n\n\t\t\tif (nextOn) {\n\t\t\t\traster.conicTo(x, y, nx, ny);\n\t\t\t\t// Skip next point since we used it as conic destination\n\t\t\t\t// But check if we're skipping over contour end\n\t\t\t\tif (!isEnd) {\n\t\t\t\t\ti++;\n\t\t\t\t\t// After skipping, check if we landed on contour end\n\t\t\t\t\tif (i === contourEnd) {\n\t\t\t\t\t\t// Close contour back to start\n\t\t\t\t\t\tconst sx = ((xCoords[contourStart]! << 2) | 0) + (offsetX << 8);\n\t\t\t\t\t\tconst sy =\n\t\t\t\t\t\t\t((-yCoords[contourStart]! << 2) | 0) + (offsetY << 8);\n\t\t\t\t\t\traster.lineTo(sx, sy);\n\t\t\t\t\t\tcontourIdx++;\n\t\t\t\t\t\tcontourStart = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Two consecutive off-curve points: draw to implicit midpoint\n\t\t\t\traster.conicTo(x, y, (x + nx) >> 1, (y + ny) >> 1);\n\t\t\t}\n\t\t}\n\n\t\t// Close contour if this is the end (and we didn't already close above)\n\t\tif (isEnd && i === contourEnd) {\n\t\t\tconst sx = ((xCoords[contourStart]! << 2) | 0) + (offsetX << 8);\n\t\t\tconst sy = ((-yCoords[contourStart]! << 2) | 0) + (offsetY << 8);\n\t\t\t// Only draw closing line if we didn't just draw to start via conic\n\t\t\tif (onCurve && i !== contourStart) {\n\t\t\t\traster.lineTo(sx, sy);\n\t\t\t} else if (!onCurve) {\n\t\t\t\t// Last point is off-curve, need to close with curve to start\n\t\t\t\tconst startOn = (flags[contourStart]! & 1) !== 0;\n\t\t\t\tif (startOn) {\n\t\t\t\t\t// Already handled in conic branch above when isEnd is true\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontourIdx++;\n\t\t\tcontourStart = i + 1;\n\t\t}\n\t}\n}\n\n/** Threshold for using band processing (height in pixels) */\nconst BAND_PROCESSING_THRESHOLD = 256;\n\n/**\n * Rasterize a glyph path to a bitmap\n * @param path Glyph path to rasterize\n * @param options Rasterization options including dimensions, scale, and pixel mode\n * @returns Rendered bitmap of the glyph\n */\nexport function rasterizePath(\n\tpath: GlyphPath,\n\toptions: RasterizeOptions,\n): Bitmap {\n\tconst {\n\t\twidth,\n\t\theight,\n\t\tscale,\n\t\toffsetX = 0,\n\t\toffsetY = 0,\n\t\tpixelMode = PixelMode.Gray,\n\t\tfillRule = FillRule.NonZero,\n\t\tflipY = true,\n\t} = options;\n\n\t// Create bitmap (non-shared since this is a public API and callers keep references)\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\n\t// Reuse shared rasterizer\n\tconst raster = getSharedRaster();\n\traster.setClip(0, 0, width, height);\n\n\t// Use band processing for large glyphs to ensure bounded memory\n\tif (height > BAND_PROCESSING_THRESHOLD) {\n\t\tconst decomposeFn = () =>\n\t\t\tdecomposePath(raster, path, scale, offsetX, offsetY, flipY);\n\t\traster.renderWithBands(\n\t\t\tbitmap,\n\t\t\tdecomposeFn,\n\t\t\t{ minY: 0, maxY: height },\n\t\t\tfillRule,\n\t\t);\n\t} else {\n\t\t// Small glyph - render in single pass with full height band\n\t\traster.setBandBounds(0, height);\n\t\traster.reset();\n\t\tdecomposePath(raster, path, scale, offsetX, offsetY, flipY);\n\t\traster.sweep(bitmap, fillRule);\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Rasterize a glyph from a font\n * @param font Font containing the glyph\n * @param glyphId ID of the glyph to rasterize\n * @param fontSize Font size in pixels\n * @param options Optional rendering settings (pixel mode, padding, hinting)\n * @returns Rasterized glyph with bitmap and bearing information, or null if glyph is empty\n */\nexport function rasterizeGlyph(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tfontSize: number,\n\toptions?: GlyphRasterizeOptions,\n): RasterizedGlyph | null {\n\tconst padding = options?.padding ?? 0;\n\tconst pixelMode = options?.pixelMode ?? PixelMode.Gray;\n\tconst useHinting = options?.hinting ?? false;\n\tconst sizeMode = options?.sizeMode;\n\tconst effectiveSize = resolveFontSize(font, fontSize, sizeMode);\n\n\t// Try hinted rendering if requested\n\tif (useHinting && font.hasHinting) {\n\t\tconst pointSize = sizeMode === \"height\" ? fontSize : effectiveSize;\n\t\tconst result = rasterizeHintedGlyph(\n\t\t\tfont,\n\t\t\tglyphId,\n\t\t\teffectiveSize,\n\t\t\tpadding,\n\t\t\tpixelMode,\n\t\t\tpointSize,\n\t\t);\n\t\tif (result) return result;\n\t}\n\n\t// Fall back to unhinted rendering\n\tif (font.isTrueType) {\n\t\tconst scale26 = (effectiveSize * 64) / font.unitsPerEm;\n\t\tconst points26 = buildGlyphPoints26(font, glyphId, scale26, 0, {\n\t\t\troundCompositeOffsets: false,\n\t\t});\n\t\tif (points26) {\n\t\t\tconst raster = rasterizeTrueTypePoints26(points26, padding, pixelMode);\n\t\t\tif (raster) return raster;\n\t\t}\n\t}\n\n\tconst path = getGlyphPath(font, glyphId);\n\tif (!path) return null;\n\n\tconst scale = effectiveSize / font.unitsPerEm;\n\n\t// Get bounds\n\tconst bounds = getPathBounds(path, scale, true, true);\n\tif (!bounds) {\n\t\treturn {\n\t\t\tbitmap: createBitmap(1, 1, pixelMode),\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t};\n\t}\n\n\tconst width = bounds.maxX - bounds.minX + padding * 2;\n\tconst height = bounds.maxY - bounds.minY + padding * 2;\n\n\tif (width <= 0 || height <= 0) {\n\t\treturn {\n\t\t\tbitmap: createBitmap(1, 1, pixelMode),\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t};\n\t}\n\n\tconst offsetX = -bounds.minX + padding;\n\tconst offsetY = -bounds.minY + padding;\n\n\tconst bitmap = rasterizePath(path, {\n\t\twidth,\n\t\theight,\n\t\tscale,\n\t\toffsetX,\n\t\toffsetY,\n\t\tpixelMode,\n\t\tflipY: true,\n\t});\n\n\treturn {\n\t\tbitmap,\n\t\tbearingX: bounds.minX - padding,\n\t\tbearingY: -(bounds.minY - padding),\n\t};\n}\n\n/**\n * Rasterize a glyph and apply a bitmap transform (2D or 3D)\n */\nexport function rasterizeGlyphWithTransform(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tfontSize: number,\n\tmatrix: Matrix2D | Matrix3x3,\n\toptions?: GlyphRasterizeOptions & {\n\t\t/** Translation offset in 26.6 units (applied after matrix) */\n\t\toffsetX26?: number;\n\t\t/** Translation offset in 26.6 units (applied after matrix) */\n\t\toffsetY26?: number;\n\t},\n): RasterizedGlyph | null {\n\tconst raster = rasterizeGlyph(font, glyphId, fontSize, options);\n\tif (!raster) return null;\n\n\tconst transformOptions = {\n\t\tbearingX: raster.bearingX,\n\t\tbearingY: raster.bearingY,\n\t\toffsetX26: options?.offsetX26,\n\t\toffsetY26: options?.offsetY26,\n\t};\n\n\tif (Array.isArray(matrix[0])) {\n\t\tconst result = transformBitmap3D(\n\t\t\traster.bitmap,\n\t\t\tmatrix as Matrix3x3,\n\t\t\ttransformOptions,\n\t\t);\n\t\treturn result;\n\t}\n\n\tconst result = transformBitmap2D(\n\t\traster.bitmap,\n\t\tmatrix as Matrix2D,\n\t\ttransformOptions,\n\t);\n\treturn result;\n}\n\n/** Rasterize a glyph with TrueType hinting */\nfunction rasterizeHintedGlyph(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tfontSize: number,\n\tpadding: number,\n\tpixelMode: PixelMode,\n\tpointSize: number = fontSize,\n): RasterizedGlyph | null {\n\tconst engine = getHintingEngine(font);\n\tif (!engine) return null;\n\n\tconst ppem = Math.round(fontSize);\n\tengine.ctx.lightMode = pixelMode === PixelMode.Gray;\n\tengine.ctx.renderMode =\n\t\tpixelMode === PixelMode.Mono\n\t\t\t? \"mono\"\n\t\t\t: pixelMode === PixelMode.LCD\n\t\t\t\t? \"lcd\"\n\t\t\t\t: pixelMode === PixelMode.LCD_V\n\t\t\t\t\t? \"lcd_v\"\n\t\t\t\t\t: \"gray\";\n\tengine.ctx.grayscale =\n\t\tengine.ctx.renderMode !== \"mono\" && !engine.ctx.lightMode;\n\n\t// Get cached hinted glyph (includes outline computation and hinting)\n\tconst hinted = getCachedHintedGlyph(engine, font, glyphId, ppem, pointSize);\n\tif (!hinted) return null;\n\tconst hintedForRaster = hinted;\n\n\t// Calculate bounds from hinted coordinates (26.6 fixed point)\n\t// Keep in 26.6 format, divide once at end (batch conversion)\n\tconst xCoords = hintedForRaster.xCoords;\n\tconst yCoords = hintedForRaster.yCoords;\n\tlet minX26 = xCoords[0];\n\tlet minY26 = yCoords[0];\n\tlet maxX26 = xCoords[0];\n\tlet maxY26 = yCoords[0];\n\tfor (let i = 1; i < xCoords.length; i++) {\n\t\tconst x = xCoords[i];\n\t\tconst y = yCoords[i];\n\t\tif (x < minX26) minX26 = x;\n\t\tif (x > maxX26) maxX26 = x;\n\t\tif (y < minY26) minY26 = y;\n\t\tif (y > maxY26) maxY26 = y;\n\t}\n\n\tif (!Number.isFinite(minX26)) {\n\t\treturn { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };\n\t}\n\n\tconst glyphBounds = font.getGlyphBounds(glyphId);\n\tif (glyphBounds) {\n\t\tconst scale = fontSize / font.unitsPerEm;\n\t\tconst unhintedWidth = (glyphBounds.xMax - glyphBounds.xMin) * scale;\n\t\tconst unhintedHeight = (glyphBounds.yMax - glyphBounds.yMin) * scale;\n\t\tconst maxWidth = Math.max(unhintedWidth * 8, fontSize * 8, unhintedWidth + 64);\n\t\tconst maxHeight = Math.max(\n\t\t\tunhintedHeight * 8,\n\t\t\tfontSize * 8,\n\t\t\tunhintedHeight + 64,\n\t\t);\n\n\t\tconst hintedWidth = (maxX26 - minX26) / 64;\n\t\tconst hintedHeight = (maxY26 - minY26) / 64;\n\t\tif (hintedWidth > maxWidth || hintedHeight > maxHeight) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst bMinX = Math.floor(minX26 / 64);\n\tconst bMinY = Math.floor(minY26 / 64);\n\tconst bMaxX = Math.floor((maxX26 + 63) / 64);\n\tconst bMaxY = Math.floor((maxY26 + 63) / 64);\n\tconst width = bMaxX - bMinX + padding * 2;\n\tconst height = bMaxY - bMinY + padding * 2;\n\tif (width <= 0 || height <= 0) {\n\t\treturn { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };\n\t}\n\n\t// Render to shared buffer first, then copy to output bitmap\n\tconst tempBitmap = createBitmapShared(width, height, pixelMode);\n\n\t// Reuse shared rasterizer\n\tconst raster = getSharedRaster();\n\traster.setClip(0, 0, width, height);\n\traster.setBandBounds(0, height);\n\traster.reset();\n\n\tconst offsetX = -bMinX + padding;\n\tconst offsetY = bMaxY + padding;\n\n\tconst decomposeFn = () =>\n\t\tdecomposeHintedGlyph(raster, hintedForRaster, offsetX, offsetY);\n\n\ttry {\n\t\tdecomposeFn();\n\t\traster.sweep(tempBitmap, FillRule.NonZero);\n\t} catch (e) {\n\t\tif (e instanceof PoolOverflowError) {\n\t\t\traster.reset();\n\t\t\traster.renderWithBands(\n\t\t\t\ttempBitmap,\n\t\t\t\tdecomposeFn,\n\t\t\t\t{ minY: 0, maxY: height, minX: 0, maxX: width },\n\t\t\t\tFillRule.NonZero,\n\t\t\t);\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// Copy to owned buffer (shared buffer will be reused on next call)\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\tbitmap.buffer.set(tempBitmap.buffer);\n\n\treturn {\n\t\tbitmap,\n\t\tbearingX: bMinX - padding,\n\t\tbearingY: bMaxY + padding,\n\t};\n}\n\nfunction rasterizeTrueTypePoints26(\n\tpoints: Points26,\n\tpadding: number,\n\tpixelMode: PixelMode,\n): RasterizedGlyph | null {\n\tconst xCoords = points.xCoords;\n\tconst yCoords = points.yCoords;\n\tif (xCoords.length === 0) return null;\n\n\tlet minX26 = xCoords[0]!;\n\tlet minY26 = yCoords[0]!;\n\tlet maxX26 = xCoords[0]!;\n\tlet maxY26 = yCoords[0]!;\n\tfor (let i = 1; i < xCoords.length; i++) {\n\t\tconst x = xCoords[i]!;\n\t\tconst y = yCoords[i]!;\n\t\tif (x < minX26) minX26 = x;\n\t\tif (x > maxX26) maxX26 = x;\n\t\tif (y < minY26) minY26 = y;\n\t\tif (y > maxY26) maxY26 = y;\n\t}\n\n\tif (!Number.isFinite(minX26)) {\n\t\treturn { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };\n\t}\n\n\tconst bMinX = Math.floor(minX26 / 64);\n\tconst bMinY = Math.floor(minY26 / 64);\n\tconst bMaxX = Math.floor((maxX26 + 63) / 64);\n\tconst bMaxY = Math.floor((maxY26 + 63) / 64);\n\tconst width = bMaxX - bMinX + padding * 2;\n\tconst height = bMaxY - bMinY + padding * 2;\n\tif (width <= 0 || height <= 0) {\n\t\treturn { bitmap: createBitmap(1, 1, pixelMode), bearingX: 0, bearingY: 0 };\n\t}\n\n\tconst tempBitmap = createBitmapShared(width, height, pixelMode);\n\tconst raster = getSharedRaster();\n\traster.setClip(0, 0, width, height);\n\traster.setBandBounds(0, height);\n\traster.reset();\n\n\tconst offsetX = -bMinX + padding;\n\tconst offsetY = bMaxY + padding;\n\tconst hinted: HintedGlyph = {\n\t\txCoords: points.xCoords,\n\t\tyCoords: points.yCoords,\n\t\tflags: points.flags,\n\t\tcontourEnds: points.contourEnds,\n\t\terror: null,\n\t};\n\n\tconst decomposeFn = () => decomposeHintedGlyph(raster, hinted, offsetX, offsetY);\n\ttry {\n\t\tdecomposeFn();\n\t\traster.sweep(tempBitmap, FillRule.NonZero);\n\t} catch (e) {\n\t\tif (e instanceof PoolOverflowError) {\n\t\t\traster.reset();\n\t\t\traster.renderWithBands(\n\t\t\t\ttempBitmap,\n\t\t\t\tdecomposeFn,\n\t\t\t\t{ minY: 0, maxY: height, minX: 0, maxX: width },\n\t\t\t\tFillRule.NonZero,\n\t\t\t);\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\tbitmap.buffer.set(tempBitmap.buffer);\n\n\treturn {\n\t\tbitmap,\n\t\tbearingX: bMinX - padding,\n\t\tbearingY: bMaxY + padding,\n\t};\n}\n\n/**\n * Rasterize text string using shaped glyphs\n * @param font Font to use for rendering\n * @param text Text string to rasterize\n * @param fontSize Font size in pixels\n * @param options Optional rendering settings (pixel mode, padding)\n * @returns Bitmap containing rendered text, or null if no glyphs\n */\nexport function rasterizeText(\n\tfont: Font,\n\ttext: string,\n\tfontSize: number,\n\toptions?: TextRasterizeOptions,\n): Bitmap | null {\n\t// This would integrate with the shaper\n\t// For now, simple glyph-by-glyph rendering\n\n\tconst scale = resolveFontScale(font, fontSize, options?.sizeMode);\n\tconst padding = options?.padding ?? 0;\n\tconst pixelMode = options?.pixelMode ?? PixelMode.Gray;\n\n\t// Get glyphs for text\n\tconst glyphs: { glyphId: GlyphId; advance: number }[] = [];\n\tlet totalAdvance = 0;\n\tlet maxAscent = 0;\n\tlet maxDescent = 0;\n\n\tconst textArray = [...text];\n\tfor (let i = 0; i < textArray.length; i++) {\n\t\tconst char = textArray[i]!;\n\t\tconst codepoint = char.codePointAt(0);\n\t\tif (codepoint === undefined) continue;\n\n\t\tconst glyphId = font.glyphId(codepoint);\n\t\tif (glyphId === undefined) continue;\n\n\t\tconst advance = font.advanceWidth(glyphId) * scale;\n\t\tconst path = getGlyphPath(font, glyphId);\n\n\t\tif (path?.bounds) {\n\t\t\tmaxAscent = Math.max(maxAscent, -path.bounds.yMin * scale);\n\t\t\tmaxDescent = Math.max(maxDescent, path.bounds.yMax * scale);\n\t\t}\n\n\t\tglyphs.push({ glyphId, advance });\n\t\ttotalAdvance += advance;\n\t}\n\n\tif (glyphs.length === 0) return null;\n\n\t// Create bitmap\n\tconst width = Math.ceil(totalAdvance) + padding * 2;\n\tconst height = Math.ceil(maxAscent + maxDescent) + padding * 2;\n\n\tconst bitmap = createBitmap(width, height, pixelMode);\n\tconst raster = getSharedRaster();\n\traster.setClip(0, 0, width, height);\n\traster.setBandBounds(0, height);\n\n\t// Render each glyph\n\tlet x = padding;\n\tconst baseline = maxDescent + padding;\n\n\tfor (let i = 0; i < glyphs.length; i++) {\n\t\tconst glyph = glyphs[i]!;\n\t\tconst path = getGlyphPath(font, glyph.glyphId);\n\t\tif (path) {\n\t\t\traster.reset();\n\t\t\tdecomposePath(raster, path, scale, x, baseline, true);\n\t\t\traster.sweep(bitmap);\n\t\t}\n\t\tx += glyph.advance;\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Export bitmap to raw RGBA pixels (for WebGL textures, etc.)\n * @param bitmap Source bitmap to convert\n * @returns RGBA pixel array (4 bytes per pixel)\n */\nexport function bitmapToRGBA(bitmap: Bitmap): Uint8Array {\n\t// bitmap.width is always the pixel width\n\t// For LCD mode, pitch = width * 3 (3 bytes per pixel for R, G, B subpixels)\n\tconst isLCD = bitmap.pixelMode === PixelMode.LCD;\n\tconst isLCDV = bitmap.pixelMode === PixelMode.LCD_V;\n\tconst rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);\n\tconst pitch = bitmap.pitch;\n\tconst absPitch = Math.abs(pitch);\n\tconst origin = pitch < 0 ? (bitmap.rows - 1) * absPitch : 0;\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tconst srcRow = origin + y * pitch;\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tconst dstIdx = (y * bitmap.width + x) * 4;\n\n\t\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t\tconst srcIdx = srcRow + x;\n\t\t\t\tconst alpha = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\t// Black text on white background\n\t\t\t\trgba[dstIdx] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 1] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 2] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\t\tconst byteIdx = srcRow + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tconst alpha = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1 ? 255 : 0;\n\t\t\t\trgba[dstIdx] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 1] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 2] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t} else if (isLCD || isLCDV) {\n\t\t\t\t// LCD/LCD_V: 3 bytes per pixel (R, G, B subpixel coverage)\n\t\t\t\tconst srcIdx = srcRow + x * 3;\n\t\t\t\tconst r = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tconst g = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tconst b = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t\t// Black text on white background with subpixel colors\n\t\t\t\trgba[dstIdx] = 255 - r;\n\t\t\t\trgba[dstIdx + 1] = 255 - g;\n\t\t\t\trgba[dstIdx + 2] = 255 - b;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\t\t\tconst srcIdx = srcRow + x * 4;\n\t\t\t\trgba[dstIdx] = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\trgba[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\trgba[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t\trgba[dstIdx + 3] = bitmap.buffer[srcIdx + 3] ?? 0;\n\t\t\t} else {\n\t\t\t\t// Fallback for other modes (treat as gray mask)\n\t\t\t\tconst srcIdx = srcRow + x;\n\t\t\t\tconst alpha = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\trgba[dstIdx] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 1] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 2] = 255 - alpha;\n\t\t\t\trgba[dstIdx + 3] = 255;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rgba;\n}\n\n/**\n * Export bitmap to grayscale array\n * @param bitmap Source bitmap to convert\n * @returns Grayscale pixel array (1 byte per pixel)\n */\nexport function bitmapToGray(bitmap: Bitmap): Uint8Array {\n\tif (bitmap.pixelMode === PixelMode.Gray && bitmap.pitch === bitmap.width) {\n\t\treturn bitmap.buffer;\n\t}\n\n\tconst gray = new Uint8Array(bitmap.width * bitmap.rows);\n\tconst pitch = bitmap.pitch;\n\tconst absPitch = Math.abs(pitch);\n\tconst origin = pitch < 0 ? (bitmap.rows - 1) * absPitch : 0;\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tconst srcRow = origin + y * pitch;\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tconst dstIdx = y * bitmap.width + x;\n\n\t\t\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t\tgray[dstIdx] = bitmap.buffer[srcRow + x] ?? 0;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\t\tconst byteIdx = srcRow + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tgray[dstIdx] = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1 ? 255 : 0;\n\t\t\t} else if (\n\t\t\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\t\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t\t\t) {\n\t\t\t\tconst srcIdx = srcRow + x * 3;\n\t\t\t\tconst r = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tconst g = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tconst b = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t\tgray[dstIdx] = Math.round((r + g + b) / 3);\n\t\t\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\t\t\tconst srcIdx = srcRow + x * 4;\n\t\t\t\t// Use alpha as coverage\n\t\t\t\tgray[dstIdx] = bitmap.buffer[srcIdx + 3] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn gray;\n}\n\n// Re-export bbox\nexport {\n\ttype BBox,\n\tevaluateCubic,\n\tevaluateQuadratic,\n\tgetCubicExtrema,\n\tgetExactBounds,\n\tgetQuadraticExtrema,\n} from \"./bbox.ts\";\n// Re-export bitmap utilities\nexport {\n\tblendBitmap,\n\tconvertBitmap,\n\tcopyBitmap,\n\temboldenBitmap,\n\tresizeBitmap,\n\tresizeBitmapBilinear,\n} from \"./bitmap-utils.ts\";\n// Re-export blur filters\nexport {\n\tblurBitmap,\n\tboxBlur,\n\tcreateGaussianKernel,\n\tgaussianBlur,\n} from \"./blur.ts\";\n// Re-export gradient\nexport {\n\ttype ColorStop,\n\tcreateGradientBitmap,\n\ttype Gradient,\n\tinterpolateGradient,\n\ttype LinearGradient,\n\ttype RadialGradient,\n\trasterizePathWithGradient,\n} from \"./gradient.ts\";\n// Re-export SDF\nexport { renderSdf, type SdfOptions } from \"./sdf.ts\";\n// Re-export stroker\nexport {\n\ttype LineCap,\n\ttype LineJoin,\n\ttype StrokerOptions,\n\tstrokePath,\n} from \"./stroker.ts\";\n// Re-export synthetic effects\nexport {\n\tcondensePath,\n\temboldenPath,\n\tobliquePath,\n\ttransformPath,\n} from \"./synth.ts\";\n// Re-export types\nexport {\n\ttype Bitmap,\n\tclearBitmap,\n\tcreateBitmap,\n\tcreateBottomUpBitmap,\n\tFillRule,\n\tPixelMode,\n\ttype RasterizedGlyph,\n\ttype RasterizeOptions,\n\ttype Span,\n} from \"./types.ts\";\n",
    "/**\n * Bitmap manipulation utilities\n */\n\nimport { type Bitmap, createBitmap, PixelMode } from \"./types.ts\";\nimport type { Matrix2D, Matrix3x3 } from \"../render/outline-transform.ts\";\n\nexport interface BitmapTransformOptions {\n\t/** Glyph bearing X (left edge from origin) */\n\tbearingX?: number;\n\t/** Glyph bearing Y (top edge from origin) */\n\tbearingY?: number;\n\t/** Optional translation in 26.6 units (applied after matrix) */\n\toffsetX26?: number;\n\t/** Optional translation in 26.6 units (applied after matrix) */\n\toffsetY26?: number;\n}\n\nexport interface RasterMetrics {\n\twidth: number;\n\theight: number;\n\tbearingX: number;\n\tbearingY: number;\n\tascent: number;\n\tdescent: number;\n}\n\nexport interface RasterEffectOptions {\n\tblur?: number;\n\tbe?: number;\n\tborder?: number;\n\tshadowX?: number;\n\tshadowY?: number;\n}\n\n/**\n * Embolden a bitmap by dilating pixel values\n * Makes text bolder by spreading coverage in x and y directions\n * @param bitmap Source bitmap to embolden\n * @param xStrength Horizontal dilation strength in pixels\n * @param yStrength Vertical dilation strength in pixels\n * @returns New bitmap with emboldened content\n */\nexport function emboldenBitmap(\n\tbitmap: Bitmap,\n\txStrength: number,\n\tyStrength: number,\n): Bitmap {\n\tif (xStrength === 0 && yStrength === 0) {\n\t\treturn copyBitmap(bitmap);\n\t}\n\n\tconst result = createBitmap(bitmap.width, bitmap.rows, bitmap.pixelMode);\n\n\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tlet maxVal = 0;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet dy = -Math.floor(yStrength);\n\t\t\t\t\tdy <= Math.ceil(yStrength);\n\t\t\t\t\tdy++\n\t\t\t\t) {\n\t\t\t\t\tfor (\n\t\t\t\t\t\tlet dx = -Math.floor(xStrength);\n\t\t\t\t\t\tdx <= Math.ceil(xStrength);\n\t\t\t\t\t\tdx++\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst sx = x + dx;\n\t\t\t\t\t\tconst sy = y + dy;\n\n\t\t\t\t\t\tif (sx >= 0 && sx < bitmap.width && sy >= 0 && sy < bitmap.rows) {\n\t\t\t\t\t\t\tconst val = bitmap.buffer[sy * bitmap.pitch + sx] ?? 0;\n\t\t\t\t\t\t\tmaxVal = Math.max(maxVal, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.buffer[y * result.pitch + x] = maxVal;\n\t\t\t}\n\t\t}\n\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tlet hasSet = false;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet dy = -Math.floor(yStrength);\n\t\t\t\t\tdy <= Math.ceil(yStrength);\n\t\t\t\t\tdy++\n\t\t\t\t) {\n\t\t\t\t\tfor (\n\t\t\t\t\t\tlet dx = -Math.floor(xStrength);\n\t\t\t\t\t\tdx <= Math.ceil(xStrength);\n\t\t\t\t\t\tdx++\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst sx = x + dx;\n\t\t\t\t\t\tconst sy = y + dy;\n\n\t\t\t\t\t\tif (sx >= 0 && sx < bitmap.width && sy >= 0 && sy < bitmap.rows) {\n\t\t\t\t\t\t\tconst byteIdx = sy * bitmap.pitch + (sx >> 3);\n\t\t\t\t\t\t\tconst bitIdx = 7 - (sx & 7);\n\t\t\t\t\t\t\tconst bit = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1;\n\t\t\t\t\t\t\tif (bit) {\n\t\t\t\t\t\t\t\thasSet = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hasSet) break;\n\t\t\t\t}\n\n\t\t\t\tif (hasSet) {\n\t\t\t\t\tconst dstByteIdx = y * result.pitch + (x >> 3);\n\t\t\t\t\tconst dstBitIdx = 7 - (x & 7);\n\t\t\t\t\tresult.buffer[dstByteIdx] |= 1 << dstBitIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tlet maxR = 0,\n\t\t\t\t\tmaxG = 0,\n\t\t\t\t\tmaxB = 0;\n\n\t\t\t\tfor (\n\t\t\t\t\tlet dy = -Math.floor(yStrength);\n\t\t\t\t\tdy <= Math.ceil(yStrength);\n\t\t\t\t\tdy++\n\t\t\t\t) {\n\t\t\t\t\tfor (\n\t\t\t\t\t\tlet dx = -Math.floor(xStrength);\n\t\t\t\t\t\tdx <= Math.ceil(xStrength);\n\t\t\t\t\t\tdx++\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst sx = x + dx;\n\t\t\t\t\t\tconst sy = y + dy;\n\n\t\t\t\t\t\tif (sx >= 0 && sx < bitmap.width && sy >= 0 && sy < bitmap.rows) {\n\t\t\t\t\t\t\tconst idx = sy * bitmap.pitch + sx * 3;\n\t\t\t\t\t\t\tmaxR = Math.max(maxR, bitmap.buffer[idx] ?? 0);\n\t\t\t\t\t\t\tmaxG = Math.max(maxG, bitmap.buffer[idx + 1] ?? 0);\n\t\t\t\t\t\t\tmaxB = Math.max(maxB, bitmap.buffer[idx + 2] ?? 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dstIdx = y * result.pitch + x * 3;\n\t\t\t\tresult.buffer[dstIdx] = maxR;\n\t\t\t\tresult.buffer[dstIdx + 1] = maxG;\n\t\t\t\tresult.buffer[dstIdx + 2] = maxB;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert bitmap between pixel modes\n * @param bitmap Source bitmap to convert\n * @param targetMode Target pixel format\n * @returns New bitmap in the target format\n */\nexport function convertBitmap(bitmap: Bitmap, targetMode: PixelMode): Bitmap {\n\tif (bitmap.pixelMode === targetMode) {\n\t\treturn bitmap;\n\t}\n\n\tconst result = createBitmap(bitmap.width, bitmap.rows, targetMode);\n\n\tif (bitmap.pixelMode === PixelMode.Gray && targetMode === PixelMode.Mono) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst gray = bitmap.buffer[y * bitmap.pitch + x] ?? 0;\n\t\t\t\tif (gray >= 128) {\n\t\t\t\t\tconst byteIdx = y * result.pitch + (x >> 3);\n\t\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\t\tresult.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.Mono &&\n\t\ttargetMode === PixelMode.Gray\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst byteIdx = y * bitmap.pitch + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tconst bit = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1;\n\t\t\t\tresult.buffer[y * result.pitch + x] = bit ? 255 : 0;\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.Gray &&\n\t\ttargetMode === PixelMode.LCD\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst gray = bitmap.buffer[y * bitmap.pitch + x] ?? 0;\n\t\t\t\tconst dstIdx = y * result.pitch + x * 3;\n\t\t\t\tresult.buffer[dstIdx] = gray;\n\t\t\t\tresult.buffer[dstIdx + 1] = gray;\n\t\t\t\tresult.buffer[dstIdx + 2] = gray;\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.Mono &&\n\t\ttargetMode === PixelMode.LCD\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst byteIdx = y * bitmap.pitch + (x >> 3);\n\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\tconst bit = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1;\n\t\t\t\tconst val = bit ? 255 : 0;\n\t\t\t\tconst dstIdx = y * result.pitch + x * 3;\n\t\t\t\tresult.buffer[dstIdx] = val;\n\t\t\t\tresult.buffer[dstIdx + 1] = val;\n\t\t\t\tresult.buffer[dstIdx + 2] = val;\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.Gray &&\n\t\ttargetMode === PixelMode.LCD_V\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst gray = bitmap.buffer[y * bitmap.pitch + x] ?? 0;\n\t\t\t\tconst dstIdx = y * result.pitch + x * 3;\n\t\t\t\tresult.buffer[dstIdx] = gray;\n\t\t\t\tresult.buffer[dstIdx + 1] = gray;\n\t\t\t\tresult.buffer[dstIdx + 2] = gray;\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.LCD &&\n\t\ttargetMode === PixelMode.Gray\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst srcIdx = y * bitmap.pitch + x * 3;\n\t\t\t\tconst r = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tconst g = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tconst b = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t\tresult.buffer[y * result.pitch + x] = Math.floor((r + g + b) / 3);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Alpha blend src bitmap onto dst bitmap at position (x, y)\n * @param dst Destination bitmap to blend onto (modified in place)\n * @param src Source bitmap to blend\n * @param x X position in destination\n * @param y Y position in destination\n * @param opacity Blend opacity from 0 to 1\n */\nexport function blendBitmap(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tx: number,\n\ty: number,\n\topacity: number,\n): void {\n\tif (dst.pixelMode !== PixelMode.Gray || src.pixelMode !== PixelMode.Gray) {\n\t\treturn;\n\t}\n\n\topacity = Math.max(0, Math.min(1, opacity));\n\n\tconst startX = Math.max(0, -x);\n\tconst startY = Math.max(0, -y);\n\tconst endX = Math.min(src.width, dst.width - x);\n\tconst endY = Math.min(src.rows, dst.rows - y);\n\n\tfor (let sy = startY; sy < endY; sy++) {\n\t\tfor (let sx = startX; sx < endX; sx++) {\n\t\t\tconst dx = x + sx;\n\t\t\tconst dy = y + sy;\n\n\t\t\tif (dx >= 0 && dx < dst.width && dy >= 0 && dy < dst.rows) {\n\t\t\t\tconst srcVal = src.buffer[sy * src.pitch + sx] ?? 0;\n\t\t\t\tconst dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;\n\n\t\t\t\tconst blended = dstVal + srcVal * opacity;\n\t\t\t\tdst.buffer[dy * dst.pitch + dx] = Math.min(255, Math.floor(blended));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Create a deep copy of a bitmap\n * @param bitmap Bitmap to copy\n * @returns New bitmap with copied data\n */\nexport function copyBitmap(bitmap: Bitmap): Bitmap {\n\treturn {\n\t\tbuffer: new Uint8Array(bitmap.buffer),\n\t\twidth: bitmap.width,\n\t\trows: bitmap.rows,\n\t\tpitch: bitmap.pitch,\n\t\tpixelMode: bitmap.pixelMode,\n\t\tnumGrays: bitmap.numGrays,\n\t};\n}\n\n/**\n * Resize bitmap using nearest-neighbor interpolation\n * @param bitmap Source bitmap to resize\n * @param newWidth Target width in pixels\n * @param newHeight Target height in pixels\n * @returns New bitmap resized to target dimensions\n */\nexport function resizeBitmap(\n\tbitmap: Bitmap,\n\tnewWidth: number,\n\tnewHeight: number,\n): Bitmap {\n\tconst result = createBitmap(newWidth, newHeight, bitmap.pixelMode);\n\n\tconst xRatio = bitmap.width / newWidth;\n\tconst yRatio = bitmap.rows / newHeight;\n\n\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\tfor (let y = 0; y < newHeight; y++) {\n\t\t\tfor (let x = 0; x < newWidth; x++) {\n\t\t\t\tconst sx = Math.floor(x * xRatio);\n\t\t\t\tconst sy = Math.floor(y * yRatio);\n\t\t\t\tresult.buffer[y * result.pitch + x] =\n\t\t\t\t\tbitmap.buffer[sy * bitmap.pitch + sx] ?? 0;\n\t\t\t}\n\t\t}\n\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\tfor (let y = 0; y < newHeight; y++) {\n\t\t\tfor (let x = 0; x < newWidth; x++) {\n\t\t\t\tconst sx = Math.floor(x * xRatio);\n\t\t\t\tconst sy = Math.floor(y * yRatio);\n\n\t\t\t\tconst srcByteIdx = sy * bitmap.pitch + (sx >> 3);\n\t\t\t\tconst srcBitIdx = 7 - (sx & 7);\n\t\t\t\tconst bit = ((bitmap.buffer[srcByteIdx] ?? 0) >> srcBitIdx) & 1;\n\n\t\t\t\tif (bit) {\n\t\t\t\t\tconst dstByteIdx = y * result.pitch + (x >> 3);\n\t\t\t\t\tconst dstBitIdx = 7 - (x & 7);\n\t\t\t\t\tresult.buffer[dstByteIdx] |= 1 << dstBitIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tfor (let y = 0; y < newHeight; y++) {\n\t\t\tfor (let x = 0; x < newWidth; x++) {\n\t\t\t\tconst sx = Math.floor(x * xRatio);\n\t\t\t\tconst sy = Math.floor(y * yRatio);\n\n\t\t\t\tconst srcIdx = sy * bitmap.pitch + sx * 3;\n\t\t\t\tconst dstIdx = y * result.pitch + x * 3;\n\n\t\t\t\tresult.buffer[dstIdx] = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tresult.buffer[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tresult.buffer[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Resize bitmap using bilinear interpolation\n * Produces smoother results than nearest-neighbor, ideal for downsampling\n * @param bitmap Source bitmap to resize\n * @param newWidth Target width in pixels\n * @param newHeight Target height in pixels\n * @returns New bitmap resized with smooth interpolation\n */\nexport function resizeBitmapBilinear(\n\tbitmap: Bitmap,\n\tnewWidth: number,\n\tnewHeight: number,\n): Bitmap {\n\tconst result = createBitmap(newWidth, newHeight, bitmap.pixelMode);\n\n\tconst xRatio = (bitmap.width - 1) / Math.max(1, newWidth - 1);\n\tconst yRatio = (bitmap.rows - 1) / Math.max(1, newHeight - 1);\n\n\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\tfor (let y = 0; y < newHeight; y++) {\n\t\t\tconst srcY = y * yRatio;\n\t\t\tconst y0 = Math.floor(srcY);\n\t\t\tconst y1 = Math.min(y0 + 1, bitmap.rows - 1);\n\t\t\tconst yFrac = srcY - y0;\n\n\t\t\tfor (let x = 0; x < newWidth; x++) {\n\t\t\t\tconst srcX = x * xRatio;\n\t\t\t\tconst x0 = Math.floor(srcX);\n\t\t\t\tconst x1 = Math.min(x0 + 1, bitmap.width - 1);\n\t\t\t\tconst xFrac = srcX - x0;\n\n\t\t\t\tconst p00 = bitmap.buffer[y0 * bitmap.pitch + x0] ?? 0;\n\t\t\t\tconst p10 = bitmap.buffer[y0 * bitmap.pitch + x1] ?? 0;\n\t\t\t\tconst p01 = bitmap.buffer[y1 * bitmap.pitch + x0] ?? 0;\n\t\t\t\tconst p11 = bitmap.buffer[y1 * bitmap.pitch + x1] ?? 0;\n\n\t\t\t\tconst top = p00 + (p10 - p00) * xFrac;\n\t\t\t\tconst bottom = p01 + (p11 - p01) * xFrac;\n\t\t\t\tconst value = top + (bottom - top) * yFrac;\n\n\t\t\t\tresult.buffer[y * result.pitch + x] = Math.round(value);\n\t\t\t}\n\t\t}\n\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\t// For mono, fall back to nearest-neighbor (bilinear doesn't make sense for 1-bit)\n\t\treturn resizeBitmap(bitmap, newWidth, newHeight);\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tfor (let y = 0; y < newHeight; y++) {\n\t\t\tconst srcY = y * yRatio;\n\t\t\tconst y0 = Math.floor(srcY);\n\t\t\tconst y1 = Math.min(y0 + 1, bitmap.rows - 1);\n\t\t\tconst yFrac = srcY - y0;\n\n\t\t\tfor (let x = 0; x < newWidth; x++) {\n\t\t\t\tconst srcX = x * xRatio;\n\t\t\t\tconst x0 = Math.floor(srcX);\n\t\t\t\tconst x1 = Math.min(x0 + 1, bitmap.width - 1);\n\t\t\t\tconst xFrac = srcX - x0;\n\n\t\t\t\tconst idx00 = y0 * bitmap.pitch + x0 * 3;\n\t\t\t\tconst idx10 = y0 * bitmap.pitch + x1 * 3;\n\t\t\t\tconst idx01 = y1 * bitmap.pitch + x0 * 3;\n\t\t\t\tconst idx11 = y1 * bitmap.pitch + x1 * 3;\n\n\t\t\t\tfor (let c = 0; c < 3; c++) {\n\t\t\t\t\tconst p00 = bitmap.buffer[idx00 + c] ?? 0;\n\t\t\t\t\tconst p10 = bitmap.buffer[idx10 + c] ?? 0;\n\t\t\t\t\tconst p01 = bitmap.buffer[idx01 + c] ?? 0;\n\t\t\t\t\tconst p11 = bitmap.buffer[idx11 + c] ?? 0;\n\n\t\t\t\t\tconst top = p00 + (p10 - p00) * xFrac;\n\t\t\t\t\tconst bottom = p01 + (p11 - p01) * xFrac;\n\t\t\t\t\tconst value = top + (bottom - top) * yFrac;\n\n\t\t\t\t\tresult.buffer[y * result.pitch + x * 3 + c] = Math.round(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Add two bitmaps together (additive blend)\n * Result: dst = clamp(dst + src, 0, 255)\n * Used for combining glyph with shadow/glow\n * @param dst Destination bitmap (modified in place)\n * @param src Source bitmap to add\n * @param srcX X offset of source in destination (default: 0)\n * @param srcY Y offset of source in destination (default: 0)\n */\nexport function addBitmaps(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number = 0,\n\tsrcY: number = 0,\n): void {\n\tif (dst.pixelMode !== PixelMode.Gray || src.pixelMode !== PixelMode.Gray) {\n\t\treturn;\n\t}\n\n\tconst startX = Math.max(0, -srcX);\n\tconst startY = Math.max(0, -srcY);\n\tconst endX = Math.min(src.width, dst.width - srcX);\n\tconst endY = Math.min(src.rows, dst.rows - srcY);\n\n\tfor (let sy = startY; sy < endY; sy++) {\n\t\tconst dy = srcY + sy;\n\t\tif (dy < 0 || dy >= dst.rows) continue;\n\n\t\tfor (let sx = startX; sx < endX; sx++) {\n\t\t\tconst dx = srcX + sx;\n\t\t\tif (dx < 0 || dx >= dst.width) continue;\n\n\t\t\tconst srcVal = src.buffer[sy * src.pitch + sx] ?? 0;\n\t\t\tconst dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;\n\t\t\tdst.buffer[dy * dst.pitch + dx] = Math.min(255, srcVal + dstVal);\n\t\t}\n\t}\n}\n\n/**\n * Multiply two bitmaps (multiplicative blend)\n * Result: dst = (dst * src) / 255\n * Used for masking operations\n * @param dst Destination bitmap (modified in place)\n * @param src Source bitmap to multiply\n * @param srcX X offset of source in destination (default: 0)\n * @param srcY Y offset of source in destination (default: 0)\n */\nexport function mulBitmaps(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number = 0,\n\tsrcY: number = 0,\n): void {\n\tif (dst.pixelMode !== PixelMode.Gray || src.pixelMode !== PixelMode.Gray) {\n\t\treturn;\n\t}\n\n\tconst startX = Math.max(0, -srcX);\n\tconst startY = Math.max(0, -srcY);\n\tconst endX = Math.min(src.width, dst.width - srcX);\n\tconst endY = Math.min(src.rows, dst.rows - srcY);\n\n\tfor (let sy = startY; sy < endY; sy++) {\n\t\tconst dy = srcY + sy;\n\t\tif (dy < 0 || dy >= dst.rows) continue;\n\n\t\tfor (let sx = startX; sx < endX; sx++) {\n\t\t\tconst dx = srcX + sx;\n\t\t\tif (dx < 0 || dx >= dst.width) continue;\n\n\t\t\tconst srcVal = src.buffer[sy * src.pitch + sx] ?? 0;\n\t\t\tconst dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;\n\t\t\t// Use integer math for speed: (a * b + 127) / 255  (a * b) >> 8\n\t\t\tdst.buffer[dy * dst.pitch + dx] = Math.floor(\n\t\t\t\t(srcVal * dstVal + 127) / 255,\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * Subtract src from dst (subtractive blend)\n * Result: dst = clamp(dst - src, 0, 255)\n * Used for outline effects\n * @param dst Destination bitmap (modified in place)\n * @param src Source bitmap to subtract\n * @param srcX X offset of source in destination (default: 0)\n * @param srcY Y offset of source in destination (default: 0)\n */\nexport function subBitmaps(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number = 0,\n\tsrcY: number = 0,\n): void {\n\tif (dst.pixelMode !== PixelMode.Gray || src.pixelMode !== PixelMode.Gray) {\n\t\treturn;\n\t}\n\n\tconst startX = Math.max(0, -srcX);\n\tconst startY = Math.max(0, -srcY);\n\tconst endX = Math.min(src.width, dst.width - srcX);\n\tconst endY = Math.min(src.rows, dst.rows - srcY);\n\n\tfor (let sy = startY; sy < endY; sy++) {\n\t\tconst dy = srcY + sy;\n\t\tif (dy < 0 || dy >= dst.rows) continue;\n\n\t\tfor (let sx = startX; sx < endX; sx++) {\n\t\t\tconst dx = srcX + sx;\n\t\t\tif (dx < 0 || dx >= dst.width) continue;\n\n\t\t\tconst srcVal = src.buffer[sy * src.pitch + sx] ?? 0;\n\t\t\tconst dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;\n\t\t\tdst.buffer[dy * dst.pitch + dx] = Math.max(0, dstVal - srcVal);\n\t\t}\n\t}\n}\n\n/**\n * Alpha composite src over dst using src as alpha\n * Result: dst = src + dst * (1 - src/255)\n * Standard Porter-Duff \"over\" operation\n * @param dst Destination bitmap (modified in place)\n * @param src Source bitmap to composite\n * @param srcX X offset of source in destination (default: 0)\n * @param srcY Y offset of source in destination (default: 0)\n */\nexport function compositeBitmaps(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number = 0,\n\tsrcY: number = 0,\n): void {\n\tif (dst.pixelMode !== PixelMode.Gray || src.pixelMode !== PixelMode.Gray) {\n\t\treturn;\n\t}\n\n\tconst startX = Math.max(0, -srcX);\n\tconst startY = Math.max(0, -srcY);\n\tconst endX = Math.min(src.width, dst.width - srcX);\n\tconst endY = Math.min(src.rows, dst.rows - srcY);\n\n\tfor (let sy = startY; sy < endY; sy++) {\n\t\tconst dy = srcY + sy;\n\t\tif (dy < 0 || dy >= dst.rows) continue;\n\n\t\tfor (let sx = startX; sx < endX; sx++) {\n\t\t\tconst dx = srcX + sx;\n\t\t\tif (dx < 0 || dx >= dst.width) continue;\n\n\t\t\tconst srcVal = src.buffer[sy * src.pitch + sx] ?? 0;\n\t\t\tconst dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;\n\t\t\t// src + dst * (255 - src) / 255\n\t\t\tconst result = srcVal + Math.floor((dstVal * (255 - srcVal) + 127) / 255);\n\t\t\tdst.buffer[dy * dst.pitch + dx] = Math.min(255, result);\n\t\t}\n\t}\n}\n\n/**\n * Shift bitmap position by integer offset\n * Creates a new bitmap with the content shifted\n * @param bitmap Source bitmap to shift\n * @param shiftX Horizontal shift in pixels\n * @param shiftY Vertical shift in pixels\n * @returns New bitmap with shifted content\n */\nexport function shiftBitmap(\n\tbitmap: Bitmap,\n\tshiftX: number,\n\tshiftY: number,\n): Bitmap {\n\tconst result = createBitmap(bitmap.width, bitmap.rows, bitmap.pixelMode);\n\n\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tconst sy = y - shiftY;\n\t\t\tif (sy < 0 || sy >= bitmap.rows) continue;\n\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst sx = x - shiftX;\n\t\t\t\tif (sx < 0 || sx >= bitmap.width) continue;\n\n\t\t\t\tresult.buffer[y * result.pitch + x] =\n\t\t\t\t\tbitmap.buffer[sy * bitmap.pitch + sx] ?? 0;\n\t\t\t}\n\t\t}\n\t} else if (bitmap.pixelMode === PixelMode.Mono) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tconst sy = y - shiftY;\n\t\t\tif (sy < 0 || sy >= bitmap.rows) continue;\n\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst sx = x - shiftX;\n\t\t\t\tif (sx < 0 || sx >= bitmap.width) continue;\n\n\t\t\t\tconst srcByteIdx = sy * bitmap.pitch + (sx >> 3);\n\t\t\t\tconst srcBitIdx = 7 - (sx & 7);\n\t\t\t\tconst bit = ((bitmap.buffer[srcByteIdx] ?? 0) >> srcBitIdx) & 1;\n\n\t\t\t\tif (bit) {\n\t\t\t\t\tconst dstByteIdx = y * result.pitch + (x >> 3);\n\t\t\t\t\tconst dstBitIdx = 7 - (x & 7);\n\t\t\t\t\tresult.buffer[dstByteIdx] |= 1 << dstBitIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tconst sy = y - shiftY;\n\t\t\tif (sy < 0 || sy >= bitmap.rows) continue;\n\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst sx = x - shiftX;\n\t\t\t\tif (sx < 0 || sx >= bitmap.width) continue;\n\n\t\t\t\tconst srcIdx = sy * bitmap.pitch + sx * 3;\n\t\t\t\tconst dstIdx = y * result.pitch + x * 3;\n\n\t\t\t\tresult.buffer[dstIdx] = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tresult.buffer[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tresult.buffer[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Fix outline bitmap by removing glyph interior\n * Used when you want only the border, not the filled shape\n * Result: outline = outline - glyph (where glyph coverage > threshold)\n * @param outlineBitmap Outline bitmap to fix (modified in place)\n * @param glyphBitmap Glyph bitmap containing filled shape\n * @param glyphX X position of glyph in outline (default: 0)\n * @param glyphY Y position of glyph in outline (default: 0)\n * @param threshold Coverage threshold for removal (default: 128)\n */\nexport function fixOutline(\n\toutlineBitmap: Bitmap,\n\tglyphBitmap: Bitmap,\n\tglyphX: number = 0,\n\tglyphY: number = 0,\n\tthreshold: number = 128,\n): void {\n\tif (\n\t\toutlineBitmap.pixelMode !== PixelMode.Gray ||\n\t\tglyphBitmap.pixelMode !== PixelMode.Gray\n\t) {\n\t\treturn;\n\t}\n\n\tconst startX = Math.max(0, -glyphX);\n\tconst startY = Math.max(0, -glyphY);\n\tconst endX = Math.min(glyphBitmap.width, outlineBitmap.width - glyphX);\n\tconst endY = Math.min(glyphBitmap.rows, outlineBitmap.rows - glyphY);\n\n\tfor (let gy = startY; gy < endY; gy++) {\n\t\tconst oy = glyphY + gy;\n\t\tif (oy < 0 || oy >= outlineBitmap.rows) continue;\n\n\t\tfor (let gx = startX; gx < endX; gx++) {\n\t\t\tconst ox = glyphX + gx;\n\t\t\tif (ox < 0 || ox >= outlineBitmap.width) continue;\n\n\t\t\tconst glyphVal = glyphBitmap.buffer[gy * glyphBitmap.pitch + gx] ?? 0;\n\t\t\tif (glyphVal >= threshold) {\n\t\t\t\t// Zero out outline where glyph is solid\n\t\t\t\toutlineBitmap.buffer[oy * outlineBitmap.pitch + ox] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Maximum blend: take the maximum of two bitmaps\n * Result: dst = max(dst, src)\n * Used for combining multiple layers\n * @param dst Destination bitmap (modified in place)\n * @param src Source bitmap to compare\n * @param srcX X offset of source in destination (default: 0)\n * @param srcY Y offset of source in destination (default: 0)\n */\nexport function maxBitmaps(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number = 0,\n\tsrcY: number = 0,\n): void {\n\tif (dst.pixelMode !== PixelMode.Gray || src.pixelMode !== PixelMode.Gray) {\n\t\treturn;\n\t}\n\n\tconst startX = Math.max(0, -srcX);\n\tconst startY = Math.max(0, -srcY);\n\tconst endX = Math.min(src.width, dst.width - srcX);\n\tconst endY = Math.min(src.rows, dst.rows - srcY);\n\n\tfor (let sy = startY; sy < endY; sy++) {\n\t\tconst dy = srcY + sy;\n\t\tif (dy < 0 || dy >= dst.rows) continue;\n\n\t\tfor (let sx = startX; sx < endX; sx++) {\n\t\t\tconst dx = srcX + sx;\n\t\t\tif (dx < 0 || dx >= dst.width) continue;\n\n\t\t\tconst srcVal = src.buffer[sy * src.pitch + sx] ?? 0;\n\t\t\tconst dstVal = dst.buffer[dy * dst.pitch + dx] ?? 0;\n\t\t\tdst.buffer[dy * dst.pitch + dx] = Math.max(srcVal, dstVal);\n\t\t}\n\t}\n}\n\n/**\n * Create a padded copy of a bitmap with extra space around edges\n * Useful before blur operations to prevent edge artifacts\n * @param bitmap Source bitmap to pad\n * @param padLeft Left padding in pixels\n * @param padTop Top padding in pixels\n * @param padRight Right padding in pixels\n * @param padBottom Bottom padding in pixels\n * @returns New bitmap with padding added\n */\nexport function padBitmap(\n\tbitmap: Bitmap,\n\tpadLeft: number,\n\tpadTop: number,\n\tpadRight: number,\n\tpadBottom: number,\n): Bitmap {\n\tconst newWidth = bitmap.width + padLeft + padRight;\n\tconst newHeight = bitmap.rows + padTop + padBottom;\n\tconst result = createBitmap(newWidth, newHeight, bitmap.pixelMode);\n\n\tif (bitmap.pixelMode === PixelMode.Gray) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tresult.buffer[(y + padTop) * result.pitch + (x + padLeft)] =\n\t\t\t\t\tbitmap.buffer[y * bitmap.pitch + x] ?? 0;\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\t\tconst srcIdx = y * bitmap.pitch + x * 3;\n\t\t\t\tconst dstIdx = (y + padTop) * result.pitch + (x + padLeft) * 3;\n\t\t\t\tresult.buffer[dstIdx] = bitmap.buffer[srcIdx] ?? 0;\n\t\t\t\tresult.buffer[dstIdx + 1] = bitmap.buffer[srcIdx + 1] ?? 0;\n\t\t\t\tresult.buffer[dstIdx + 2] = bitmap.buffer[srcIdx + 2] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Create an expanded bitmap that can contain both dst and src\n * Returns the expanded bitmap and the offsets for both original bitmaps\n * @param dst Destination bitmap\n * @param src Source bitmap to fit\n * @param srcX X position of source relative to destination\n * @param srcY Y position of source relative to destination\n * @returns Expanded bitmap and offset positions for both original bitmaps\n */\nexport function expandToFit(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number,\n\tsrcY: number,\n): {\n\texpanded: Bitmap;\n\tdstOffsetX: number;\n\tdstOffsetY: number;\n\tsrcOffsetX: number;\n\tsrcOffsetY: number;\n} {\n\t// Calculate bounds\n\tconst dstLeft = 0;\n\tconst dstTop = 0;\n\tconst dstRight = dst.width;\n\tconst dstBottom = dst.rows;\n\n\tconst srcLeft = srcX;\n\tconst srcTop = srcY;\n\tconst srcRight = srcX + src.width;\n\tconst srcBottom = srcY + src.rows;\n\n\tconst left = Math.min(dstLeft, srcLeft);\n\tconst top = Math.min(dstTop, srcTop);\n\tconst right = Math.max(dstRight, srcRight);\n\tconst bottom = Math.max(dstBottom, srcBottom);\n\n\tconst newWidth = right - left;\n\tconst newHeight = bottom - top;\n\n\tconst expanded = createBitmap(newWidth, newHeight, dst.pixelMode);\n\n\tconst dstOffsetX = dstLeft - left;\n\tconst dstOffsetY = dstTop - top;\n\tconst srcOffsetX = srcLeft - left;\n\tconst srcOffsetY = srcTop - top;\n\n\t// Copy dst to expanded\n\tif (dst.pixelMode === PixelMode.Gray) {\n\t\tfor (let y = 0; y < dst.rows; y++) {\n\t\t\tfor (let x = 0; x < dst.width; x++) {\n\t\t\t\texpanded.buffer[(y + dstOffsetY) * expanded.pitch + (x + dstOffsetX)] =\n\t\t\t\t\tdst.buffer[y * dst.pitch + x] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { expanded, dstOffsetX, dstOffsetY, srcOffsetX, srcOffsetY };\n}\n\nfunction getRowOffset(bitmap: Bitmap, y: number): number {\n\tconst pitch = bitmap.pitch;\n\tconst absPitch = Math.abs(pitch);\n\tconst origin = pitch < 0 ? (bitmap.rows - 1) * absPitch : 0;\n\treturn origin + y * pitch;\n}\n\nfunction getPixelChannel(\n\tbitmap: Bitmap,\n\tx: number,\n\ty: number,\n\tchannel: number,\n): number {\n\tif (x < 0 || y < 0 || x >= bitmap.width || y >= bitmap.rows) return 0;\n\tconst row = getRowOffset(bitmap, y);\n\tswitch (bitmap.pixelMode) {\n\t\tcase PixelMode.Gray:\n\t\t\treturn bitmap.buffer[row + x] ?? 0;\n\t\tcase PixelMode.Mono: {\n\t\t\tconst byteIdx = row + (x >> 3);\n\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\tconst bit = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1;\n\t\t\treturn bit ? 255 : 0;\n\t\t}\n\t\tcase PixelMode.LCD:\n\t\tcase PixelMode.LCD_V: {\n\t\t\tconst idx = row + x * 3 + channel;\n\t\t\treturn bitmap.buffer[idx] ?? 0;\n\t\t}\n\t\tcase PixelMode.RGBA: {\n\t\t\tconst idx = row + x * 4 + channel;\n\t\t\treturn bitmap.buffer[idx] ?? 0;\n\t\t}\n\t}\n}\n\nfunction sampleBilinear(\n\tbitmap: Bitmap,\n\tx: number,\n\ty: number,\n\tchannels: number,\n\tout: number[],\n): void {\n\tconst x0 = Math.floor(x);\n\tconst y0 = Math.floor(y);\n\tconst x1 = x0 + 1;\n\tconst y1 = y0 + 1;\n\n\tconst wx = x - x0;\n\tconst wy = y - y0;\n\tconst w00 = (1 - wx) * (1 - wy);\n\tconst w10 = wx * (1 - wy);\n\tconst w01 = (1 - wx) * wy;\n\tconst w11 = wx * wy;\n\n\tfor (let c = 0; c < channels; c++) {\n\t\tconst p00 = getPixelChannel(bitmap, x0, y0, c);\n\t\tconst p10 = getPixelChannel(bitmap, x1, y0, c);\n\t\tconst p01 = getPixelChannel(bitmap, x0, y1, c);\n\t\tconst p11 = getPixelChannel(bitmap, x1, y1, c);\n\t\tconst value = p00 * w00 + p10 * w10 + p01 * w01 + p11 * w11;\n\t\tout[c] = Math.min(255, Math.max(0, Math.round(value)));\n\t}\n}\n\nfunction invert2D(\n\tmatrix: Matrix2D,\n): { inv: Matrix2D; det: number } | null {\n\tconst [a, b, c, d, e, f] = matrix;\n\tconst det = a * d - b * c;\n\tif (det === 0) return null;\n\tconst invA = d / det;\n\tconst invB = -b / det;\n\tconst invC = -c / det;\n\tconst invD = a / det;\n\tconst invE = (c * f - d * e) / det;\n\tconst invF = (b * e - a * f) / det;\n\treturn { inv: [invA, invB, invC, invD, invE, invF], det };\n}\n\nfunction invert3x3(matrix: Matrix3x3): Matrix3x3 | null {\n\tconst a = matrix[0][0];\n\tconst b = matrix[0][1];\n\tconst c = matrix[0][2];\n\tconst d = matrix[1][0];\n\tconst e = matrix[1][1];\n\tconst f = matrix[1][2];\n\tconst g = matrix[2][0];\n\tconst h = matrix[2][1];\n\tconst i = matrix[2][2];\n\n\tconst a00 = e * i - f * h;\n\tconst a01 = c * h - b * i;\n\tconst a02 = b * f - c * e;\n\tconst a10 = f * g - d * i;\n\tconst a11 = a * i - c * g;\n\tconst a12 = c * d - a * f;\n\tconst a20 = d * h - e * g;\n\tconst a21 = b * g - a * h;\n\tconst a22 = a * e - b * d;\n\n\tconst det = a * a00 + b * a10 + c * a20;\n\tif (det === 0) return null;\n\tconst invDet = 1 / det;\n\n\treturn [\n\t\t[a00 * invDet, a01 * invDet, a02 * invDet],\n\t\t[a10 * invDet, a11 * invDet, a12 * invDet],\n\t\t[a20 * invDet, a21 * invDet, a22 * invDet],\n\t];\n}\n\nfunction transformPoint3x3Safe(\n\tx: number,\n\ty: number,\n\tmatrix: Matrix3x3,\n): { x: number; y: number } {\n\tconst w = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2];\n\tconst minW = 1e-6;\n\tconst safeW = Math.abs(w) < minW ? (w < 0 ? -minW : minW) : w;\n\treturn {\n\t\tx: (matrix[0][0] * x + matrix[0][1] * y + matrix[0][2]) / safeW,\n\t\ty: (matrix[1][0] * x + matrix[1][1] * y + matrix[1][2]) / safeW,\n\t};\n}\n\n/**\n * Subtract src from dst (alias for subBitmaps)\n */\nexport function subtractBitmap(\n\tdst: Bitmap,\n\tsrc: Bitmap,\n\tsrcX: number = 0,\n\tsrcY: number = 0,\n): void {\n\tsubBitmaps(dst, src, srcX, srcY);\n}\n\n/**\n * Fix outline bitmap by removing glyph interior (alias for fixOutline)\n */\nexport function fixOutlineBitmap(\n\toutlineBitmap: Bitmap,\n\tglyphBitmap: Bitmap,\n\tglyphX: number = 0,\n\tglyphY: number = 0,\n\tthreshold: number = 128,\n): void {\n\tfixOutline(outlineBitmap, glyphBitmap, glyphX, glyphY, threshold);\n}\n\n/**\n * Measure rasterized glyph ascent/descent from bitmap coverage\n */\nexport function measureRasterGlyph(\n\tbitmap: Bitmap,\n\tbearingX: number,\n\tbearingY: number,\n): { ascent: number; descent: number } {\n\tvoid bearingX;\n\tlet topRow = Infinity;\n\tlet bottomRow = -Infinity;\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tlet covered = false;\n\t\t\tswitch (bitmap.pixelMode) {\n\t\t\t\tcase PixelMode.Gray: {\n\t\t\t\t\tconst row = getRowOffset(bitmap, y);\n\t\t\t\t\tcovered = (bitmap.buffer[row + x] ?? 0) > 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PixelMode.Mono: {\n\t\t\t\t\tconst row = getRowOffset(bitmap, y);\n\t\t\t\t\tconst byteIdx = row + (x >> 3);\n\t\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\t\tconst bit = ((bitmap.buffer[byteIdx] ?? 0) >> bitIdx) & 1;\n\t\t\t\t\tcovered = bit === 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PixelMode.LCD:\n\t\t\t\tcase PixelMode.LCD_V: {\n\t\t\t\t\tconst row = getRowOffset(bitmap, y);\n\t\t\t\t\tconst idx = row + x * 3;\n\t\t\t\t\tcovered =\n\t\t\t\t\t\t(bitmap.buffer[idx] ?? 0) > 0 ||\n\t\t\t\t\t\t(bitmap.buffer[idx + 1] ?? 0) > 0 ||\n\t\t\t\t\t\t(bitmap.buffer[idx + 2] ?? 0) > 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PixelMode.RGBA: {\n\t\t\t\t\tconst row = getRowOffset(bitmap, y);\n\t\t\t\t\tconst idx = row + x * 4;\n\t\t\t\t\tcovered = (bitmap.buffer[idx + 3] ?? 0) > 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (covered) {\n\t\t\t\ttopRow = Math.min(topRow, y);\n\t\t\t\tbottomRow = Math.max(bottomRow, y);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!Number.isFinite(topRow) || !Number.isFinite(bottomRow)) {\n\t\treturn { ascent: 0, descent: 0 };\n\t}\n\n\tconst ascent = bearingY - topRow;\n\tconst descent = bottomRow + 1 - bearingY;\n\treturn { ascent, descent };\n}\n\n/**\n * Expand raster metrics to account for blur/border/shadow padding\n */\nexport function expandRasterMetrics(\n\tmetrics: RasterMetrics,\n\toptions: RasterEffectOptions,\n): RasterMetrics & {\n\tpadLeft: number;\n\tpadRight: number;\n\tpadTop: number;\n\tpadBottom: number;\n} {\n\tconst blur = options.blur ?? 0;\n\tconst be = options.be ?? 0;\n\tconst border = options.border ?? 0;\n\tconst shadowX = options.shadowX ?? 0;\n\tconst shadowY = options.shadowY ?? 0;\n\n\tconst basePad = Math.ceil(blur + be + border);\n\tconst padLeft = basePad + Math.max(0, -shadowX);\n\tconst padRight = basePad + Math.max(0, shadowX);\n\tconst padTop = basePad + Math.max(0, -shadowY);\n\tconst padBottom = basePad + Math.max(0, shadowY);\n\n\treturn {\n\t\twidth: metrics.width + padLeft + padRight,\n\t\theight: metrics.height + padTop + padBottom,\n\t\tbearingX: metrics.bearingX - padLeft,\n\t\tbearingY: metrics.bearingY + padTop,\n\t\tascent: metrics.ascent + padTop,\n\t\tdescent: metrics.descent + padBottom,\n\t\tpadLeft,\n\t\tpadRight,\n\t\tpadTop,\n\t\tpadBottom,\n\t};\n}\n\n/**\n * Embolden bitmap and adjust bearing by padding to avoid clipping\n */\nexport function emboldenBitmapWithBearing(\n\tbitmap: Bitmap,\n\tbearingX: number,\n\tbearingY: number,\n\txStrength: number,\n\tyStrength: number,\n): { bitmap: Bitmap; bearingX: number; bearingY: number } {\n\tconst padX = Math.max(0, Math.ceil(xStrength));\n\tconst padY = Math.max(0, Math.ceil(yStrength));\n\tconst padded = padBitmap(bitmap, padX, padY, padX, padY);\n\tconst emboldened = emboldenBitmap(padded, xStrength, yStrength);\n\treturn {\n\t\tbitmap: emboldened,\n\t\tbearingX: bearingX - padX,\n\t\tbearingY: bearingY + padY,\n\t};\n}\n\n/**\n * Transform bitmap using 2D affine matrix with bilinear resampling\n */\nexport function transformBitmap2D(\n\tbitmap: Bitmap,\n\tmatrix: Matrix2D,\n\toptions: BitmapTransformOptions = {},\n): { bitmap: Bitmap; bearingX: number; bearingY: number } {\n\tconst bearingX = options.bearingX ?? 0;\n\tconst bearingY = options.bearingY ?? 0;\n\tconst offsetX = (options.offsetX26 ?? 0) / 64;\n\tconst offsetY = (options.offsetY26 ?? 0) / 64;\n\tconst [a, b, c, d, e, f] = matrix;\n\tconst adjusted: Matrix2D = [a, b, c, d, e + offsetX, f + offsetY];\n\n\tconst left = bearingX;\n\tconst top = bearingY;\n\tconst right = left + bitmap.width;\n\tconst bottom = top - bitmap.rows;\n\n\tconst corners = [\n\t\t{\n\t\t\tx: adjusted[0] * left + adjusted[2] * top + adjusted[4],\n\t\t\ty: adjusted[1] * left + adjusted[3] * top + adjusted[5],\n\t\t},\n\t\t{\n\t\t\tx: adjusted[0] * right + adjusted[2] * top + adjusted[4],\n\t\t\ty: adjusted[1] * right + adjusted[3] * top + adjusted[5],\n\t\t},\n\t\t{\n\t\t\tx: adjusted[0] * left + adjusted[2] * bottom + adjusted[4],\n\t\t\ty: adjusted[1] * left + adjusted[3] * bottom + adjusted[5],\n\t\t},\n\t\t{\n\t\t\tx: adjusted[0] * right + adjusted[2] * bottom + adjusted[4],\n\t\t\ty: adjusted[1] * right + adjusted[3] * bottom + adjusted[5],\n\t\t},\n\t];\n\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\tfor (const p of corners) {\n\t\tminX = Math.min(minX, p.x);\n\t\tmaxX = Math.max(maxX, p.x);\n\t\tminY = Math.min(minY, p.y);\n\t\tmaxY = Math.max(maxY, p.y);\n\t}\n\n\tif (!Number.isFinite(minX) || !Number.isFinite(minY)) {\n\t\treturn {\n\t\t\tbitmap: createBitmap(1, 1, bitmap.pixelMode),\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t};\n\t}\n\n\tconst outMinX = Math.floor(minX);\n\tconst outMaxX = Math.ceil(maxX);\n\tconst outMinY = Math.floor(minY);\n\tconst outMaxY = Math.ceil(maxY);\n\n\tconst outWidth = Math.max(1, outMaxX - outMinX);\n\tconst outHeight = Math.max(1, outMaxY - outMinY);\n\n\tconst result = createBitmap(outWidth, outHeight, bitmap.pixelMode);\n\tconst inverse = invert2D(adjusted);\n\tif (!inverse) {\n\t\treturn { bitmap: result, bearingX: outMinX, bearingY: outMaxY };\n\t}\n\tconst inv = inverse.inv;\n\n\tconst channels =\n\t\tbitmap.pixelMode === PixelMode.LCD || bitmap.pixelMode === PixelMode.LCD_V\n\t\t\t? 3\n\t\t\t: bitmap.pixelMode === PixelMode.RGBA\n\t\t\t\t? 4\n\t\t\t\t: 1;\n\tconst sampleBuffer = new Array<number>(channels).fill(0);\n\n\tfor (let y = 0; y < outHeight; y++) {\n\t\tfor (let x = 0; x < outWidth; x++) {\n\t\t\tconst gx = outMinX + x + 0.5;\n\t\t\tconst gy = outMaxY - y - 0.5;\n\n\t\t\tconst sxg = inv[0] * gx + inv[2] * gy + inv[4];\n\t\t\tconst syg = inv[1] * gx + inv[3] * gy + inv[5];\n\n\t\t\tconst sx = sxg - bearingX - 0.5;\n\t\t\tconst sy = bearingY - syg - 0.5;\n\n\t\t\tsampleBilinear(bitmap, sx, sy, channels, sampleBuffer);\n\n\t\t\tif (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\t\tconst val = sampleBuffer[0] ?? 0;\n\t\t\t\tif (val >= 128) {\n\t\t\t\t\tconst byteIdx = y * result.pitch + (x >> 3);\n\t\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\t\tresult.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t\t}\n\t\t\t} else if (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t\tresult.buffer[y * result.pitch + x] = sampleBuffer[0] ?? 0;\n\t\t\t} else if (\n\t\t\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\t\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t\t\t) {\n\t\t\t\tconst idx = y * result.pitch + x * 3;\n\t\t\t\tresult.buffer[idx] = sampleBuffer[0] ?? 0;\n\t\t\t\tresult.buffer[idx + 1] = sampleBuffer[1] ?? 0;\n\t\t\t\tresult.buffer[idx + 2] = sampleBuffer[2] ?? 0;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\t\t\tconst idx = y * result.pitch + x * 4;\n\t\t\t\tresult.buffer[idx] = sampleBuffer[0] ?? 0;\n\t\t\t\tresult.buffer[idx + 1] = sampleBuffer[1] ?? 0;\n\t\t\t\tresult.buffer[idx + 2] = sampleBuffer[2] ?? 0;\n\t\t\t\tresult.buffer[idx + 3] = sampleBuffer[3] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { bitmap: result, bearingX: outMinX, bearingY: outMaxY };\n}\n\n/**\n * Transform bitmap using 3x3 matrix with perspective and bilinear resampling\n */\nexport function transformBitmap3D(\n\tbitmap: Bitmap,\n\tmatrix: Matrix3x3,\n\toptions: BitmapTransformOptions = {},\n): { bitmap: Bitmap; bearingX: number; bearingY: number } {\n\tconst bearingX = options.bearingX ?? 0;\n\tconst bearingY = options.bearingY ?? 0;\n\tconst offsetX = (options.offsetX26 ?? 0) / 64;\n\tconst offsetY = (options.offsetY26 ?? 0) / 64;\n\n\tconst adjusted: Matrix3x3 = [\n\t\t[matrix[0][0], matrix[0][1], matrix[0][2] + offsetX],\n\t\t[matrix[1][0], matrix[1][1], matrix[1][2] + offsetY],\n\t\t[matrix[2][0], matrix[2][1], matrix[2][2]],\n\t];\n\n\tconst left = bearingX;\n\tconst top = bearingY;\n\tconst right = left + bitmap.width;\n\tconst bottom = top - bitmap.rows;\n\n\tconst corners = [\n\t\ttransformPoint3x3Safe(left, top, adjusted),\n\t\ttransformPoint3x3Safe(right, top, adjusted),\n\t\ttransformPoint3x3Safe(left, bottom, adjusted),\n\t\ttransformPoint3x3Safe(right, bottom, adjusted),\n\t];\n\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\tfor (const p of corners) {\n\t\tminX = Math.min(minX, p.x);\n\t\tmaxX = Math.max(maxX, p.x);\n\t\tminY = Math.min(minY, p.y);\n\t\tmaxY = Math.max(maxY, p.y);\n\t}\n\n\tif (!Number.isFinite(minX) || !Number.isFinite(minY)) {\n\t\treturn {\n\t\t\tbitmap: createBitmap(1, 1, bitmap.pixelMode),\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t};\n\t}\n\n\tconst outMinX = Math.floor(minX);\n\tconst outMaxX = Math.ceil(maxX);\n\tconst outMinY = Math.floor(minY);\n\tconst outMaxY = Math.ceil(maxY);\n\n\tconst outWidth = Math.max(1, outMaxX - outMinX);\n\tconst outHeight = Math.max(1, outMaxY - outMinY);\n\tconst result = createBitmap(outWidth, outHeight, bitmap.pixelMode);\n\n\tconst inverse = invert3x3(adjusted);\n\tif (!inverse) {\n\t\treturn { bitmap: result, bearingX: outMinX, bearingY: outMaxY };\n\t}\n\n\tconst channels =\n\t\tbitmap.pixelMode === PixelMode.LCD || bitmap.pixelMode === PixelMode.LCD_V\n\t\t\t? 3\n\t\t\t: bitmap.pixelMode === PixelMode.RGBA\n\t\t\t\t? 4\n\t\t\t\t: 1;\n\tconst sampleBuffer = new Array<number>(channels).fill(0);\n\n\tfor (let y = 0; y < outHeight; y++) {\n\t\tfor (let x = 0; x < outWidth; x++) {\n\t\t\tconst gx = outMinX + x + 0.5;\n\t\t\tconst gy = outMaxY - y - 0.5;\n\n\t\t\tconst src = transformPoint3x3Safe(gx, gy, inverse);\n\t\t\tconst sx = src.x - bearingX - 0.5;\n\t\t\tconst sy = bearingY - src.y - 0.5;\n\n\t\t\tsampleBilinear(bitmap, sx, sy, channels, sampleBuffer);\n\n\t\t\tif (bitmap.pixelMode === PixelMode.Mono) {\n\t\t\t\tconst val = sampleBuffer[0] ?? 0;\n\t\t\t\tif (val >= 128) {\n\t\t\t\t\tconst byteIdx = y * result.pitch + (x >> 3);\n\t\t\t\t\tconst bitIdx = 7 - (x & 7);\n\t\t\t\t\tresult.buffer[byteIdx] |= 1 << bitIdx;\n\t\t\t\t}\n\t\t\t} else if (bitmap.pixelMode === PixelMode.Gray) {\n\t\t\t\tresult.buffer[y * result.pitch + x] = sampleBuffer[0] ?? 0;\n\t\t\t} else if (\n\t\t\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\t\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t\t\t) {\n\t\t\t\tconst idx = y * result.pitch + x * 3;\n\t\t\t\tresult.buffer[idx] = sampleBuffer[0] ?? 0;\n\t\t\t\tresult.buffer[idx + 1] = sampleBuffer[1] ?? 0;\n\t\t\t\tresult.buffer[idx + 2] = sampleBuffer[2] ?? 0;\n\t\t\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\t\t\tconst idx = y * result.pitch + x * 4;\n\t\t\t\tresult.buffer[idx] = sampleBuffer[0] ?? 0;\n\t\t\t\tresult.buffer[idx + 1] = sampleBuffer[1] ?? 0;\n\t\t\t\tresult.buffer[idx + 2] = sampleBuffer[2] ?? 0;\n\t\t\t\tresult.buffer[idx + 3] = sampleBuffer[3] ?? 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { bitmap: result, bearingX: outMinX, bearingY: outMaxY };\n}\n\n/**\n * Shear bitmap horizontally (synthetic italic)\n */\nexport function shearBitmapX(\n\tbitmap: Bitmap,\n\tamount: number,\n\toptions: BitmapTransformOptions = {},\n): { bitmap: Bitmap; bearingX: number; bearingY: number } {\n\treturn transformBitmap2D(bitmap, [1, 0, amount, 1, 0, 0], options);\n}\n\n/**\n * Shear bitmap vertically\n */\nexport function shearBitmapY(\n\tbitmap: Bitmap,\n\tamount: number,\n\toptions: BitmapTransformOptions = {},\n): { bitmap: Bitmap; bearingX: number; bearingY: number } {\n\treturn transformBitmap2D(bitmap, [1, amount, 0, 1, 0, 0], options);\n}\n",
    "import type { Font } from \"../font/font.ts\";\nimport type { FontSizeMode } from \"./types.ts\";\n\nexport function resolveFontSize(\n\tfont: Font,\n\tfontSize: number,\n\tsizeMode?: FontSizeMode,\n): number {\n\tif (sizeMode !== \"height\") return fontSize;\n\tif (!Number.isFinite(fontSize) || fontSize <= 0) return fontSize;\n\tconst baseHeight = font.ascender - font.descender;\n\tconst height = font.isCFF ? baseHeight : baseHeight + font.lineGap;\n\tif (!Number.isFinite(height) || height <= 0) return fontSize;\n\treturn (fontSize * font.unitsPerEm) / height;\n}\n\nexport function resolveFontScale(\n\tfont: Font,\n\tfontSize: number,\n\tsizeMode?: FontSizeMode,\n): number {\n\tconst effectiveSize = resolveFontSize(font, fontSize, sizeMode);\n\treturn effectiveSize / font.unitsPerEm;\n}\n",
    "/**\n * Exact bounding box calculation for paths with bezier curves\n *\n * Bezier curves can extend beyond their control points, so we need to find\n * the actual extrema by solving for where the derivative equals zero.\n */\n\nimport type { GlyphPath } from \"../render/path.ts\";\n\n/**\n * Bounding box in 2D space\n */\nexport interface BBox {\n\txMin: number;\n\tyMin: number;\n\txMax: number;\n\tyMax: number;\n}\n\n/**\n * Calculate exact bounding box for a path\n *\n * For line segments: min/max of endpoints\n * For quadratic bezier: find t where derivative = 0, evaluate curve at those t values\n * For cubic bezier: solve quadratic for extrema, evaluate curve at those t values\n *\n * @param path - Path to calculate bounds for\n * @returns Bounding box or null for empty path\n */\nexport function getExactBounds(path: GlyphPath): BBox | null {\n\tif (!path.commands || path.commands.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet xMin = Infinity;\n\tlet yMin = Infinity;\n\tlet xMax = -Infinity;\n\tlet yMax = -Infinity;\n\n\tlet currentX = 0;\n\tlet currentY = 0;\n\tlet hasPoints = false;\n\n\tconst updateBounds = (x: number, y: number) => {\n\t\txMin = Math.min(xMin, x);\n\t\tyMin = Math.min(yMin, y);\n\t\txMax = Math.max(xMax, x);\n\t\tyMax = Math.max(yMax, y);\n\t\thasPoints = true;\n\t};\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\": {\n\t\t\t\tcurrentX = cmd.x;\n\t\t\t\tcurrentY = cmd.y;\n\t\t\t\tupdateBounds(currentX, currentY);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"L\": {\n\t\t\t\tcurrentX = cmd.x;\n\t\t\t\tcurrentY = cmd.y;\n\t\t\t\tupdateBounds(currentX, currentY);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"Q\": {\n\t\t\t\t// Quadratic bezier from (currentX, currentY) to (cmd.x, cmd.y)\n\t\t\t\t// with control point (cmd.x1, cmd.y1)\n\n\t\t\t\t// Check start point (already in bounds from previous command)\n\t\t\t\t// Check end point\n\t\t\t\tupdateBounds(cmd.x, cmd.y);\n\n\t\t\t\t// Find extrema in X direction\n\t\t\t\tconst xExtrema = getQuadraticExtrema(currentX, cmd.x1, cmd.x);\n\t\t\t\tfor (let j = 0; j < xExtrema.length; j++) {\n\t\t\t\t\tconst t = xExtrema[j]!;\n\t\t\t\t\tconst x = evaluateQuadratic(currentX, cmd.x1, cmd.x, t);\n\t\t\t\t\tupdateBounds(x, currentY); // Use current Y temporarily\n\t\t\t\t}\n\n\t\t\t\t// Find extrema in Y direction\n\t\t\t\tconst yExtrema = getQuadraticExtrema(currentY, cmd.y1, cmd.y);\n\t\t\t\tfor (let j = 0; j < yExtrema.length; j++) {\n\t\t\t\t\tconst t = yExtrema[j]!;\n\t\t\t\t\tconst y = evaluateQuadratic(currentY, cmd.y1, cmd.y, t);\n\t\t\t\t\tupdateBounds(currentX, y); // Use current X temporarily\n\t\t\t\t}\n\n\t\t\t\t// Evaluate both X and Y at extrema points\n\t\t\t\tconst allExtrema = new Set([...xExtrema, ...yExtrema]);\n\t\t\t\tconst extremaArray = [...allExtrema];\n\t\t\t\tfor (let j = 0; j < extremaArray.length; j++) {\n\t\t\t\t\tconst t = extremaArray[j]!;\n\t\t\t\t\tconst x = evaluateQuadratic(currentX, cmd.x1, cmd.x, t);\n\t\t\t\t\tconst y = evaluateQuadratic(currentY, cmd.y1, cmd.y, t);\n\t\t\t\t\tupdateBounds(x, y);\n\t\t\t\t}\n\n\t\t\t\tcurrentX = cmd.x;\n\t\t\t\tcurrentY = cmd.y;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"C\": {\n\t\t\t\t// Cubic bezier from (currentX, currentY) to (cmd.x, cmd.y)\n\t\t\t\t// with control points (cmd.x1, cmd.y1) and (cmd.x2, cmd.y2)\n\n\t\t\t\t// Check end point\n\t\t\t\tupdateBounds(cmd.x, cmd.y);\n\n\t\t\t\t// Find extrema in X direction\n\t\t\t\tconst xExtrema = getCubicExtrema(currentX, cmd.x1, cmd.x2, cmd.x);\n\t\t\t\tfor (let j = 0; j < xExtrema.length; j++) {\n\t\t\t\t\tconst t = xExtrema[j]!;\n\t\t\t\t\tconst x = evaluateCubic(currentX, cmd.x1, cmd.x2, cmd.x, t);\n\t\t\t\t\tupdateBounds(x, currentY); // Use current Y temporarily\n\t\t\t\t}\n\n\t\t\t\t// Find extrema in Y direction\n\t\t\t\tconst yExtrema = getCubicExtrema(currentY, cmd.y1, cmd.y2, cmd.y);\n\t\t\t\tfor (let j = 0; j < yExtrema.length; j++) {\n\t\t\t\t\tconst t = yExtrema[j]!;\n\t\t\t\t\tconst y = evaluateCubic(currentY, cmd.y1, cmd.y2, cmd.y, t);\n\t\t\t\t\tupdateBounds(currentX, y); // Use current X temporarily\n\t\t\t\t}\n\n\t\t\t\t// Evaluate both X and Y at extrema points\n\t\t\t\tconst allExtrema = new Set([...xExtrema, ...yExtrema]);\n\t\t\t\tconst extremaArray = [...allExtrema];\n\t\t\t\tfor (let j = 0; j < extremaArray.length; j++) {\n\t\t\t\t\tconst t = extremaArray[j]!;\n\t\t\t\t\tconst x = evaluateCubic(currentX, cmd.x1, cmd.x2, cmd.x, t);\n\t\t\t\t\tconst y = evaluateCubic(currentY, cmd.y1, cmd.y2, cmd.y, t);\n\t\t\t\t\tupdateBounds(x, y);\n\t\t\t\t}\n\n\t\t\t\tcurrentX = cmd.x;\n\t\t\t\tcurrentY = cmd.y;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"Z\": {\n\t\t\t\t// Close path - no bounds update needed\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!hasPoints) {\n\t\treturn null;\n\t}\n\n\treturn { xMin, yMin, xMax, yMax };\n}\n\n/**\n * Find t values where a quadratic bezier has extrema\n *\n * For quadratic bezier B(t) = (1-t)p0 + 2(1-t)t*p1 + tp2\n * Derivative: B'(t) = 2(1-t)(p1-p0) + 2t(p2-p1)\n *                   = 2(p1-p0) + 2t(p0-2p1+p2)\n *                   = 2[(p1-p0) + t(p0-2p1+p2)]\n *\n * Set B'(t) = 0:\n * (p1-p0) + t(p0-2p1+p2) = 0\n * t = -(p1-p0)/(p0-2p1+p2)\n *   = (p0-p1)/(p0-2p1+p2)\n *\n * @param p0 - Start point\n * @param p1 - Control point\n * @param p2 - End point\n * @returns Array of t values in [0,1] where extrema occur\n */\nexport function getQuadraticExtrema(\n\tp0: number,\n\tp1: number,\n\tp2: number,\n): number[] {\n\tconst denominator = p0 - 2 * p1 + p2;\n\n\t// If denominator is zero, the curve is linear (no extrema)\n\tif (Math.abs(denominator) < 1e-10) {\n\t\treturn [];\n\t}\n\n\tconst t = (p0 - p1) / denominator;\n\n\t// Only include t values in the valid range [0, 1]\n\tif (t > 0 && t < 1) {\n\t\treturn [t];\n\t}\n\n\treturn [];\n}\n\n/**\n * Find t values where a cubic bezier has extrema\n *\n * For cubic bezier B(t) = (1-t)p0 + 3(1-t)t*p1 + 3(1-t)tp2 + tp3\n * Derivative: B'(t) = 3(1-t)(p1-p0) + 6(1-t)t(p2-p1) + 3t(p3-p2)\n *\n * Simplified: B'(t) = at + bt + c where:\n * a = 3(p3 - 3p2 + 3p1 - p0)\n * b = 6(p2 - 2p1 + p0)\n * c = 3(p1 - p0)\n *\n * Solve using quadratic formula: t = (-b  (b-4ac)) / 2a\n *\n * @param p0 - Start point\n * @param p1 - First control point\n * @param p2 - Second control point\n * @param p3 - End point\n * @returns Array of t values in [0,1] where extrema occur\n */\nexport function getCubicExtrema(\n\tp0: number,\n\tp1: number,\n\tp2: number,\n\tp3: number,\n): number[] {\n\tconst a = 3 * (p3 - 3 * p2 + 3 * p1 - p0);\n\tconst b = 6 * (p2 - 2 * p1 + p0);\n\tconst c = 3 * (p1 - p0);\n\n\tconst extrema: number[] = [];\n\n\t// If a is zero, we have a linear or quadratic equation\n\tif (Math.abs(a) < 1e-10) {\n\t\t// If b is also zero, there are no extrema (constant derivative)\n\t\tif (Math.abs(b) < 1e-10) {\n\t\t\treturn [];\n\t\t}\n\t\t// Linear equation: bt + c = 0 => t = -c/b\n\t\tconst t = -c / b;\n\t\tif (t > 0 && t < 1) {\n\t\t\textrema.push(t);\n\t\t}\n\t\treturn extrema;\n\t}\n\n\t// Quadratic formula\n\tconst discriminant = b * b - 4 * a * c;\n\n\t// No real solutions\n\tif (discriminant < 0) {\n\t\treturn [];\n\t}\n\n\t// One solution (discriminant = 0)\n\tif (Math.abs(discriminant) < 1e-10) {\n\t\tconst t = -b / (2 * a);\n\t\tif (t > 0 && t < 1) {\n\t\t\textrema.push(t);\n\t\t}\n\t\treturn extrema;\n\t}\n\n\t// Two solutions\n\tconst sqrtD = Math.sqrt(discriminant);\n\tconst t1 = (-b + sqrtD) / (2 * a);\n\tconst t2 = (-b - sqrtD) / (2 * a);\n\n\tif (t1 > 0 && t1 < 1) {\n\t\textrema.push(t1);\n\t}\n\tif (t2 > 0 && t2 < 1) {\n\t\textrema.push(t2);\n\t}\n\n\treturn extrema;\n}\n\n/**\n * Evaluate quadratic bezier at parameter t\n *\n * B(t) = (1-t)p0 + 2(1-t)t*p1 + tp2\n *\n * @param p0 - Start point\n * @param p1 - Control point\n * @param p2 - End point\n * @param t - Parameter in [0,1]\n * @returns Value at t\n */\nexport function evaluateQuadratic(\n\tp0: number,\n\tp1: number,\n\tp2: number,\n\tt: number,\n): number {\n\tconst oneMinusT = 1 - t;\n\treturn oneMinusT * oneMinusT * p0 + 2 * oneMinusT * t * p1 + t * t * p2;\n}\n\n/**\n * Evaluate cubic bezier at parameter t\n *\n * B(t) = (1-t)p0 + 3(1-t)t*p1 + 3(1-t)tp2 + tp3\n *\n * @param p0 - Start point\n * @param p1 - First control point\n * @param p2 - Second control point\n * @param p3 - End point\n * @param t - Parameter in [0,1]\n * @returns Value at t\n */\nexport function evaluateCubic(\n\tp0: number,\n\tp1: number,\n\tp2: number,\n\tp3: number,\n\tt: number,\n): number {\n\tconst oneMinusT = 1 - t;\n\tconst oneMinusT2 = oneMinusT * oneMinusT;\n\tconst t2 = t * t;\n\n\treturn (\n\t\toneMinusT2 * oneMinusT * p0 +\n\t\t3 * oneMinusT2 * t * p1 +\n\t\t3 * oneMinusT * t2 * p2 +\n\t\tt2 * t * p3\n\t);\n}\n",
    "/**\n * Bitmap blur filters - Gaussian and Box blur\n */\n\nimport { convertBitmap } from \"./bitmap-utils.ts\";\nimport { type Bitmap, PixelMode } from \"./types.ts\";\n\n/**\n * Generate 1D Gaussian kernel\n * Uses Gaussian function: exp(-x/(2))\n *\n * @param radius Blur radius (sigma value)\n * @returns Normalized Gaussian kernel weights\n */\nexport function createGaussianKernel(radius: number): Float32Array {\n\tif (radius <= 0) {\n\t\treturn new Float32Array([1.0]);\n\t}\n\n\t// sigma = radius, kernel extends to 3*sigma on each side\n\t// This captures >99% of the Gaussian\n\tconst sigma = radius;\n\tconst size = Math.ceil(radius * 2) * 2 + 1;\n\tconst kernel = new Float32Array(size);\n\tconst center = Math.floor(size / 2);\n\n\tlet sum = 0;\n\n\t// Calculate kernel weights\n\tfor (let i = 0; i < size; i++) {\n\t\tconst x = i - center;\n\t\tconst weight = Math.exp(-(x * x) / (2 * sigma * sigma));\n\t\tkernel[i] = weight;\n\t\tsum += weight;\n\t}\n\n\t// Normalize to sum to 1.0\n\tfor (let i = 0; i < size; i++) {\n\t\tkernel[i] /= sum;\n\t}\n\n\treturn kernel;\n}\n\n/**\n * Apply 1D convolution along a row (horizontal)\n */\nfunction convolveHorizontal(\n\tsrc: Uint8Array,\n\tdst: Uint8Array,\n\twidth: number,\n\theight: number,\n\tsrcPitch: number,\n\tdstPitch: number,\n\tkernel: Float32Array,\n\tchannels: number,\n): void {\n\tconst radius = Math.floor(kernel.length / 2);\n\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let c = 0; c < channels; c++) {\n\t\t\t\tlet sum = 0;\n\n\t\t\t\tfor (let k = 0; k < kernel.length; k++) {\n\t\t\t\t\tconst sx = x + k - radius;\n\n\t\t\t\t\t// Clamp to edges\n\t\t\t\t\tconst clampedX = Math.max(0, Math.min(width - 1, sx));\n\t\t\t\t\tconst srcIdx = y * srcPitch + clampedX * channels + c;\n\t\t\t\t\tsum += (src[srcIdx] ?? 0) * kernel[k];\n\t\t\t\t}\n\n\t\t\t\tconst dstIdx = y * dstPitch + x * channels + c;\n\t\t\t\tdst[dstIdx] = Math.min(255, Math.max(0, Math.round(sum)));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Apply 1D convolution along a column (vertical)\n */\nfunction convolveVertical(\n\tsrc: Uint8Array,\n\tdst: Uint8Array,\n\twidth: number,\n\theight: number,\n\tsrcPitch: number,\n\tdstPitch: number,\n\tkernel: Float32Array,\n\tchannels: number,\n): void {\n\tconst radius = Math.floor(kernel.length / 2);\n\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let c = 0; c < channels; c++) {\n\t\t\t\tlet sum = 0;\n\n\t\t\t\tfor (let k = 0; k < kernel.length; k++) {\n\t\t\t\t\tconst sy = y + k - radius;\n\n\t\t\t\t\t// Clamp to edges\n\t\t\t\t\tconst clampedY = Math.max(0, Math.min(height - 1, sy));\n\t\t\t\t\tconst srcIdx = clampedY * srcPitch + x * channels + c;\n\t\t\t\t\tsum += (src[srcIdx] ?? 0) * kernel[k];\n\t\t\t\t}\n\n\t\t\t\tconst dstIdx = y * dstPitch + x * channels + c;\n\t\t\t\tdst[dstIdx] = Math.min(255, Math.max(0, Math.round(sum)));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Gaussian blur implementation using separable 2-pass algorithm\n * Modifies bitmap in-place and returns it\n *\n * @param bitmap Bitmap to blur (modified in-place)\n * @param radius Blur radius in pixels\n * @returns The same bitmap after blur is applied\n */\nexport function gaussianBlur(bitmap: Bitmap, radius: number): Bitmap {\n\t// Handle Mono by converting to Gray first\n\tif (bitmap.pixelMode === PixelMode.Mono) {\n\t\tconst converted = convertBitmap(bitmap, PixelMode.Gray);\n\t\treturn gaussianBlur(converted, radius);\n\t}\n\n\tif (radius <= 0) {\n\t\treturn bitmap;\n\t}\n\n\tconst kernel = createGaussianKernel(radius);\n\n\t// Determine channels based on pixel mode\n\tlet channels = 1;\n\tif (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tchannels = 3;\n\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\tchannels = 4;\n\t}\n\n\t// Create temporary buffer for intermediate results\n\tconst temp = new Uint8Array(bitmap.buffer.length);\n\n\t// Pass 1: Horizontal blur (src -> temp)\n\tconvolveHorizontal(\n\t\tbitmap.buffer,\n\t\ttemp,\n\t\tbitmap.width,\n\t\tbitmap.rows,\n\t\tbitmap.pitch,\n\t\tbitmap.pitch,\n\t\tkernel,\n\t\tchannels,\n\t);\n\n\t// Pass 2: Vertical blur (temp -> bitmap.buffer)\n\tconvolveVertical(\n\t\ttemp,\n\t\tbitmap.buffer,\n\t\tbitmap.width,\n\t\tbitmap.rows,\n\t\tbitmap.pitch,\n\t\tbitmap.pitch,\n\t\tkernel,\n\t\tchannels,\n\t);\n\n\treturn bitmap;\n}\n\n/**\n * Box blur using running sum for O(1) per pixel\n * Modifies bitmap in-place and returns it\n *\n * @param bitmap Bitmap to blur (modified in-place)\n * @param radius Blur radius in pixels\n * @returns The same bitmap after blur is applied\n */\nexport function boxBlur(bitmap: Bitmap, radius: number): Bitmap {\n\t// Handle Mono by converting to Gray first\n\tif (bitmap.pixelMode === PixelMode.Mono) {\n\t\tconst converted = convertBitmap(bitmap, PixelMode.Gray);\n\t\treturn boxBlur(converted, radius);\n\t}\n\n\tif (radius <= 0) {\n\t\treturn bitmap;\n\t}\n\n\t// Determine channels based on pixel mode\n\tlet channels = 1;\n\tif (\n\t\tbitmap.pixelMode === PixelMode.LCD ||\n\t\tbitmap.pixelMode === PixelMode.LCD_V\n\t) {\n\t\tchannels = 3;\n\t} else if (bitmap.pixelMode === PixelMode.RGBA) {\n\t\tchannels = 4;\n\t}\n\n\tconst iRadius = Math.floor(radius);\n\tconst _kernelSize = iRadius * 2 + 1;\n\n\t// Create temporary buffer\n\tconst temp = new Uint8Array(bitmap.buffer.length);\n\n\t// Pass 1: Horizontal box blur using running sum\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\t// Initialize running sum\n\t\t\tlet sum = 0;\n\t\t\tlet count = 0;\n\n\t\t\t// Initialize sum with first window\n\t\t\tfor (let x = -iRadius; x <= iRadius; x++) {\n\t\t\t\tif (x >= 0 && x < bitmap.width) {\n\t\t\t\t\tconst idx = y * bitmap.pitch + x * channels + c;\n\t\t\t\t\tsum += bitmap.buffer[idx] ?? 0;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First pixel\n\t\t\tconst dstIdx0 = y * bitmap.pitch + 0 * channels + c;\n\t\t\ttemp[dstIdx0] = Math.round(sum / count);\n\n\t\t\t// Slide window across row\n\t\t\tfor (let x = 1; x < bitmap.width; x++) {\n\t\t\t\t// Remove left pixel from sum\n\t\t\t\tconst leftX = x - iRadius - 1;\n\t\t\t\tif (leftX >= 0) {\n\t\t\t\t\tconst leftIdx = y * bitmap.pitch + leftX * channels + c;\n\t\t\t\t\tsum -= bitmap.buffer[leftIdx] ?? 0;\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\t// Add right pixel to sum\n\t\t\t\tconst rightX = x + iRadius;\n\t\t\t\tif (rightX < bitmap.width) {\n\t\t\t\t\tconst rightIdx = y * bitmap.pitch + rightX * channels + c;\n\t\t\t\t\tsum += bitmap.buffer[rightIdx] ?? 0;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tconst dstIdx = y * bitmap.pitch + x * channels + c;\n\t\t\t\ttemp[dstIdx] = Math.round(sum / count);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pass 2: Vertical box blur using running sum\n\tfor (let x = 0; x < bitmap.width; x++) {\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\t// Initialize running sum\n\t\t\tlet sum = 0;\n\t\t\tlet count = 0;\n\n\t\t\t// Initialize sum with first window\n\t\t\tfor (let y = -iRadius; y <= iRadius; y++) {\n\t\t\t\tif (y >= 0 && y < bitmap.rows) {\n\t\t\t\t\tconst idx = y * bitmap.pitch + x * channels + c;\n\t\t\t\t\tsum += temp[idx] ?? 0;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First pixel\n\t\t\tconst dstIdx0 = 0 * bitmap.pitch + x * channels + c;\n\t\t\tbitmap.buffer[dstIdx0] = Math.round(sum / count);\n\n\t\t\t// Slide window down column\n\t\t\tfor (let y = 1; y < bitmap.rows; y++) {\n\t\t\t\t// Remove top pixel from sum\n\t\t\t\tconst topY = y - iRadius - 1;\n\t\t\t\tif (topY >= 0) {\n\t\t\t\t\tconst topIdx = topY * bitmap.pitch + x * channels + c;\n\t\t\t\t\tsum -= temp[topIdx] ?? 0;\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\t// Add bottom pixel to sum\n\t\t\t\tconst bottomY = y + iRadius;\n\t\t\t\tif (bottomY < bitmap.rows) {\n\t\t\t\t\tconst bottomIdx = bottomY * bitmap.pitch + x * channels + c;\n\t\t\t\t\tsum += temp[bottomIdx] ?? 0;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\tconst dstIdx = y * bitmap.pitch + x * channels + c;\n\t\t\t\tbitmap.buffer[dstIdx] = Math.round(sum / count);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Apply blur filter to a bitmap in-place\n * @param bitmap - Bitmap to blur (modified in-place)\n * @param radius - Blur radius in pixels (can be fractional)\n * @param type - Blur type: 'gaussian' (default) or 'box'\n * @returns The modified bitmap\n */\nexport function blurBitmap(\n\tbitmap: Bitmap,\n\tradius: number,\n\ttype: \"gaussian\" | \"box\" = \"gaussian\",\n): Bitmap {\n\tif (type === \"box\") {\n\t\treturn boxBlur(bitmap, radius);\n\t} else {\n\t\treturn gaussianBlur(bitmap, radius);\n\t}\n}\n",
    "/**\n * Gradient fill rendering for paths\n */\n\nimport type { GlyphPath } from \"../render/path.ts\";\nimport { rasterizePath } from \"./rasterize.ts\";\nimport {\n\ttype Bitmap,\n\tcreateBitmap,\n\tPixelMode,\n\ttype RasterizeOptions,\n} from \"./types.ts\";\n\n/**\n * Color stop in a gradient (RGBA, 0-255 each)\n */\nexport interface ColorStop {\n\t/** Position along gradient, 0.0 to 1.0 */\n\toffset: number;\n\t/** RGBA color values, 0-255 each */\n\tcolor: [number, number, number, number];\n}\n\n/**\n * Linear gradient from point (x0,y0) to (x1,y1)\n */\nexport interface LinearGradient {\n\ttype: \"linear\";\n\t/** Start X coordinate */\n\tx0: number;\n\t/** Start Y coordinate */\n\ty0: number;\n\t/** End X coordinate */\n\tx1: number;\n\t/** End Y coordinate */\n\ty1: number;\n\t/** Color stops */\n\tstops: ColorStop[];\n}\n\n/**\n * Radial gradient from center point with radius\n */\nexport interface RadialGradient {\n\ttype: \"radial\";\n\t/** Center X coordinate */\n\tcx: number;\n\t/** Center Y coordinate */\n\tcy: number;\n\t/** Gradient radius */\n\tradius: number;\n\t/** Color stops */\n\tstops: ColorStop[];\n}\n\n/**\n * Gradient type union\n */\nexport type Gradient = LinearGradient | RadialGradient;\n\n/**\n * Interpolate color between two stops\n */\nfunction lerpColor(\n\tcolor1: [number, number, number, number],\n\tcolor2: [number, number, number, number],\n\tt: number,\n): [number, number, number, number] {\n\treturn [\n\t\tMath.round(color1[0] + (color2[0] - color1[0]) * t),\n\t\tMath.round(color1[1] + (color2[1] - color1[1]) * t),\n\t\tMath.round(color1[2] + (color2[2] - color1[2]) * t),\n\t\tMath.round(color1[3] + (color2[3] - color1[3]) * t),\n\t];\n}\n\n/**\n * Get color at position in gradient\n *\n * @param gradient Linear or radial gradient definition\n * @param x X coordinate\n * @param y Y coordinate\n * @returns RGBA color at position (0-255 each)\n */\nexport function interpolateGradient(\n\tgradient: Gradient,\n\tx: number,\n\ty: number,\n): [number, number, number, number] {\n\tif (gradient.stops.length === 0) {\n\t\treturn [0, 0, 0, 0];\n\t}\n\n\tif (gradient.stops.length === 1) {\n\t\treturn gradient.stops[0].color;\n\t}\n\n\tlet t: number;\n\n\tif (gradient.type === \"linear\") {\n\t\tconst dx = gradient.x1 - gradient.x0;\n\t\tconst dy = gradient.y1 - gradient.y0;\n\t\tconst lengthSq = dx * dx + dy * dy;\n\n\t\tif (lengthSq === 0) {\n\t\t\treturn gradient.stops[0].color;\n\t\t}\n\n\t\tconst px = x - gradient.x0;\n\t\tconst py = y - gradient.y0;\n\t\tt = (px * dx + py * dy) / lengthSq;\n\t} else {\n\t\tconst dx = x - gradient.cx;\n\t\tconst dy = y - gradient.cy;\n\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\t\tt = gradient.radius > 0 ? distance / gradient.radius : 0;\n\t}\n\n\tt = Math.max(0, Math.min(1, t));\n\n\tconst sortedStops = [...gradient.stops].sort((a, b) => a.offset - b.offset);\n\n\tif (t <= sortedStops[0].offset) {\n\t\treturn sortedStops[0].color;\n\t}\n\n\tif (t >= sortedStops[sortedStops.length - 1].offset) {\n\t\treturn sortedStops[sortedStops.length - 1].color;\n\t}\n\n\tfor (let i = 0; i < sortedStops.length - 1; i++) {\n\t\tconst stop1 = sortedStops[i];\n\t\tconst stop2 = sortedStops[i + 1];\n\n\t\tif (t >= stop1.offset && t <= stop2.offset) {\n\t\t\tconst range = stop2.offset - stop1.offset;\n\t\t\tif (range === 0) {\n\t\t\t\treturn stop2.color;\n\t\t\t}\n\t\t\tconst localT = (t - stop1.offset) / range;\n\t\t\treturn lerpColor(stop1.color, stop2.color, localT);\n\t\t}\n\t}\n\n\treturn sortedStops[sortedStops.length - 1].color;\n}\n\n/**\n * Create a bitmap filled with gradient (no path)\n *\n * @param width Width in pixels\n * @param height Height in pixels\n * @param gradient Linear or radial gradient definition\n * @returns RGBA bitmap filled with gradient\n */\nexport function createGradientBitmap(\n\twidth: number,\n\theight: number,\n\tgradient: Gradient,\n): Bitmap {\n\tconst bitmap = createBitmap(width, height, PixelMode.RGBA);\n\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tconst color = interpolateGradient(gradient, x, y);\n\t\t\tconst idx = (y * width + x) * 4;\n\t\t\tbitmap.buffer[idx] = color[0];\n\t\t\tbitmap.buffer[idx + 1] = color[1];\n\t\t\tbitmap.buffer[idx + 2] = color[2];\n\t\t\tbitmap.buffer[idx + 3] = color[3];\n\t\t}\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Rasterize path with gradient fill\n * First rasterizes path to get coverage mask, then fills with gradient\n *\n * @param path Glyph path to rasterize\n * @param gradient Linear or radial gradient definition\n * @param options Rasterization options (width, height, scale, etc.)\n * @returns RGBA bitmap with gradient-filled path\n */\nexport function rasterizePathWithGradient(\n\tpath: GlyphPath,\n\tgradient: Gradient,\n\toptions: RasterizeOptions,\n): Bitmap {\n\tconst { width, height } = options;\n\n\tconst coverageBitmap = rasterizePath(path, {\n\t\t...options,\n\t\tpixelMode: PixelMode.Gray,\n\t\tflipY: options.flipY ?? false,\n\t});\n\n\tconst resultBitmap = createBitmap(width, height, PixelMode.RGBA);\n\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tconst coverage = coverageBitmap.buffer[y * coverageBitmap.pitch + x] ?? 0;\n\n\t\t\tif (coverage > 0) {\n\t\t\t\tconst color = interpolateGradient(gradient, x, y);\n\t\t\t\tconst idx = (y * width + x) * 4;\n\n\t\t\t\tconst alpha = (color[3] * coverage) / 255;\n\n\t\t\t\tresultBitmap.buffer[idx] = color[0];\n\t\t\t\tresultBitmap.buffer[idx + 1] = color[1];\n\t\t\t\tresultBitmap.buffer[idx + 2] = color[2];\n\t\t\t\tresultBitmap.buffer[idx + 3] = Math.round(alpha);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn resultBitmap;\n}\n",
    "/**\n * Signed Distance Field (SDF) rasterizer\n *\n * For each pixel, compute the shortest distance to the outline.\n * Positive values are inside the outline, negative are outside.\n * This allows GPU text rendering at any scale.\n *\n * Algorithm:\n * 1. For each pixel center, find the minimum distance to all outline edges\n * 2. Determine sign based on whether point is inside or outside the outline\n * 3. Normalize and encode to 0-255 (128 = on the edge)\n */\n\nimport type { GlyphPath } from \"../render/path.ts\";\nimport { type Bitmap, createBitmap, PixelMode } from \"./types.ts\";\n\n/**\n * Options for SDF rendering\n */\nexport interface SdfOptions {\n\t/** Width in pixels */\n\twidth: number;\n\t/** Height in pixels */\n\theight: number;\n\t/** Scale factor (font units to pixels) */\n\tscale: number;\n\t/** X offset in pixels */\n\toffsetX?: number;\n\t/** Y offset in pixels */\n\toffsetY?: number;\n\t/** Flip Y axis (font coords are Y-up, bitmap is Y-down) */\n\tflipY?: boolean;\n\t/** Spread/radius - how far the distance field extends in pixels (default: 8) */\n\tspread?: number;\n}\n\n/**\n * A point in 2D space\n */\ninterface Point {\n\tx: number;\n\ty: number;\n}\n\n/**\n * An edge in the outline (line segment or curve)\n */\ntype Edge =\n\t| { type: \"line\"; p0: Point; p1: Point }\n\t| { type: \"quadratic\"; p0: Point; p1: Point; p2: Point }\n\t| { type: \"cubic\"; p0: Point; p1: Point; p2: Point; p3: Point };\n\n/**\n * Render a glyph path as a signed distance field\n * @param path Glyph path to render\n * @param options SDF rendering options (dimensions, scale, spread)\n * @returns Grayscale bitmap with signed distance field (128 = on edge, 255 = inside, 0 = outside)\n */\nexport function renderSdf(path: GlyphPath, options: SdfOptions): Bitmap {\n\tconst {\n\t\twidth,\n\t\theight,\n\t\tscale,\n\t\toffsetX = 0,\n\t\toffsetY = 0,\n\t\tflipY = false,\n\t\tspread = 8,\n\t} = options;\n\n\t// Create bitmap\n\tconst bitmap = createBitmap(width, height, PixelMode.Gray);\n\n\t// Convert path commands to edges\n\tconst edges = extractEdges(path, scale, offsetX, offsetY, flipY);\n\n\t// If no edges, fill with 0 (maximum negative distance)\n\tif (edges.length === 0) {\n\t\tbitmap.buffer.fill(0);\n\t\treturn bitmap;\n\t}\n\n\t// For each pixel, compute signed distance\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\t// Pixel center\n\t\t\tconst px = x + 0.5;\n\t\t\tconst py = y + 0.5;\n\n\t\t\t// Find minimum distance to all edges\n\t\t\tlet minDist = Infinity;\n\t\t\tfor (let k = 0; k < edges.length; k++) {\n\t\t\t\tconst edge = edges[k]!;\n\t\t\t\tconst dist = distanceToEdge(px, py, edge);\n\t\t\t\tminDist = Math.min(minDist, dist);\n\t\t\t}\n\n\t\t\t// Determine if point is inside or outside\n\t\t\tconst inside = isPointInside(px, py, edges);\n\n\t\t\t// Sign: positive inside, negative outside\n\t\t\tconst signedDist = inside ? minDist : -minDist;\n\n\t\t\t// Normalize to 0-255 range\n\t\t\t// spread is the distance in pixels that maps to 0-128 or 128-255\n\t\t\t// 0 = -spread (far outside)\n\t\t\t// 128 = 0 (on edge)\n\t\t\t// 255 = +spread (far inside)\n\t\t\tconst normalized = 128 + (signedDist / spread) * 127;\n\t\t\tconst clamped = Math.max(0, Math.min(255, Math.round(normalized)));\n\n\t\t\tbitmap.buffer[y * bitmap.pitch + x] = clamped;\n\t\t}\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Extract edges from path commands\n */\nfunction extractEdges(\n\tpath: GlyphPath,\n\tscale: number,\n\toffsetX: number,\n\toffsetY: number,\n\tflipY: boolean,\n): Edge[] {\n\tconst edges: Edge[] = [];\n\tlet currentPoint: Point | null = null;\n\tlet firstPoint: Point | null = null;\n\n\tconst transform = (x: number, y: number): Point => ({\n\t\tx: x * scale + offsetX,\n\t\ty: flipY ? -(y * scale) + offsetY : y * scale + offsetY,\n\t});\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tcurrentPoint = transform(cmd.x, cmd.y);\n\t\t\t\tfirstPoint = currentPoint;\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tif (currentPoint) {\n\t\t\t\t\tconst p1 = transform(cmd.x, cmd.y);\n\t\t\t\t\tedges.push({ type: \"line\", p0: currentPoint, p1 });\n\t\t\t\t\tcurrentPoint = p1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Q\":\n\t\t\t\tif (currentPoint) {\n\t\t\t\t\tconst p1 = transform(cmd.x1, cmd.y1);\n\t\t\t\t\tconst p2 = transform(cmd.x, cmd.y);\n\t\t\t\t\tedges.push({ type: \"quadratic\", p0: currentPoint, p1, p2 });\n\t\t\t\t\tcurrentPoint = p2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"C\":\n\t\t\t\tif (currentPoint) {\n\t\t\t\t\tconst p1 = transform(cmd.x1, cmd.y1);\n\t\t\t\t\tconst p2 = transform(cmd.x2, cmd.y2);\n\t\t\t\t\tconst p3 = transform(cmd.x, cmd.y);\n\t\t\t\t\tedges.push({ type: \"cubic\", p0: currentPoint, p1, p2, p3 });\n\t\t\t\t\tcurrentPoint = p3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Z\":\n\t\t\t\t// Close path with a line back to start\n\t\t\t\tif (currentPoint && firstPoint) {\n\t\t\t\t\t// Only add closing edge if not already at start\n\t\t\t\t\tif (\n\t\t\t\t\t\tMath.abs(currentPoint.x - firstPoint.x) > 0.001 ||\n\t\t\t\t\t\tMath.abs(currentPoint.y - firstPoint.y) > 0.001\n\t\t\t\t\t) {\n\t\t\t\t\t\tedges.push({ type: \"line\", p0: currentPoint, p1: firstPoint });\n\t\t\t\t\t}\n\t\t\t\t\tcurrentPoint = firstPoint;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn edges;\n}\n\n/**\n * Compute distance from point to edge\n */\nfunction distanceToEdge(px: number, py: number, edge: Edge): number {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn distanceToLine(px, py, edge.p0, edge.p1);\n\t\tcase \"quadratic\":\n\t\t\treturn distanceToQuadratic(px, py, edge.p0, edge.p1, edge.p2);\n\t\tcase \"cubic\":\n\t\t\treturn distanceToCubic(px, py, edge.p0, edge.p1, edge.p2, edge.p3);\n\t}\n}\n\n/**\n * Distance from point to line segment\n */\nfunction distanceToLine(px: number, py: number, p0: Point, p1: Point): number {\n\tconst dx = p1.x - p0.x;\n\tconst dy = p1.y - p0.y;\n\tconst lenSq = dx * dx + dy * dy;\n\n\tif (lenSq < 0.0001) {\n\t\t// Degenerate segment - just distance to point\n\t\tconst dpx = px - p0.x;\n\t\tconst dpy = py - p0.y;\n\t\treturn Math.sqrt(dpx * dpx + dpy * dpy);\n\t}\n\n\t// Project point onto line\n\tlet t = ((px - p0.x) * dx + (py - p0.y) * dy) / lenSq;\n\tt = Math.max(0, Math.min(1, t)); // Clamp to segment\n\n\tconst closestX = p0.x + t * dx;\n\tconst closestY = p0.y + t * dy;\n\n\tconst distX = px - closestX;\n\tconst distY = py - closestY;\n\treturn Math.sqrt(distX * distX + distY * distY);\n}\n\n/**\n * Distance from point to quadratic bezier curve\n * Uses sampling approximation for simplicity\n */\nfunction distanceToQuadratic(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n): number {\n\tlet minDist = Infinity;\n\n\t// Sample the curve at multiple points\n\tconst samples = 32;\n\tfor (let i = 0; i <= samples; i++) {\n\t\tconst t = i / samples;\n\t\tconst ti = 1 - t;\n\n\t\t// Quadratic bezier: B(t) = (1-t)P0 + 2(1-t)tP1 + tP2\n\t\tconst x = ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x;\n\t\tconst y = ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y;\n\n\t\tconst dx = px - x;\n\t\tconst dy = py - y;\n\t\tconst dist = Math.sqrt(dx * dx + dy * dy);\n\t\tminDist = Math.min(minDist, dist);\n\t}\n\n\treturn minDist;\n}\n\n/**\n * Distance from point to cubic bezier curve\n * Uses sampling approximation for simplicity\n */\nfunction distanceToCubic(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n\tp3: Point,\n): number {\n\tlet minDist = Infinity;\n\n\t// Sample the curve at multiple points\n\tconst samples = 32;\n\tfor (let i = 0; i <= samples; i++) {\n\t\tconst t = i / samples;\n\t\tconst ti = 1 - t;\n\n\t\t// Cubic bezier: B(t) = (1-t)P0 + 3(1-t)tP1 + 3(1-t)tP2 + tP3\n\t\tconst x =\n\t\t\tti * ti * ti * p0.x +\n\t\t\t3 * ti * ti * t * p1.x +\n\t\t\t3 * ti * t * t * p2.x +\n\t\t\tt * t * t * p3.x;\n\t\tconst y =\n\t\t\tti * ti * ti * p0.y +\n\t\t\t3 * ti * ti * t * p1.y +\n\t\t\t3 * ti * t * t * p2.y +\n\t\t\tt * t * t * p3.y;\n\n\t\tconst dx = px - x;\n\t\tconst dy = py - y;\n\t\tconst dist = Math.sqrt(dx * dx + dy * dy);\n\t\tminDist = Math.min(minDist, dist);\n\t}\n\n\treturn minDist;\n}\n\n/**\n * Determine if a point is inside the outline using ray casting\n * (even-odd rule)\n */\nfunction isPointInside(px: number, py: number, edges: Edge[]): boolean {\n\tlet crossings = 0;\n\n\tfor (let i = 0; i < edges.length; i++) {\n\t\tconst edge = edges[i]!;\n\t\t// Flatten curves to line segments for inside test\n\t\tconst points = flattenEdge(edge);\n\n\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\tconst p0 = points[j];\n\t\t\tconst p1 = points[j + 1];\n\t\t\tif (!p0 || !p1) continue;\n\n\t\t\t// Ray casting: cast horizontal ray to the right from (px, py)\n\t\t\t// Check if it crosses this edge\n\t\t\tif (p0.y > py !== p1.y > py) {\n\t\t\t\t// Edge crosses the horizontal line at y = py\n\t\t\t\tconst slope = (p1.x - p0.x) / (p1.y - p0.y);\n\t\t\t\tconst x = p0.x + slope * (py - p0.y);\n\n\t\t\t\tif (px < x) {\n\t\t\t\t\tcrossings++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Odd number of crossings = inside\n\treturn (crossings & 1) === 1;\n}\n\n/**\n * Flatten an edge to a sequence of points for inside testing\n */\nfunction flattenEdge(edge: Edge): Point[] {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn [edge.p0, edge.p1];\n\n\t\tcase \"quadratic\": {\n\t\t\tconst points: Point[] = [edge.p0];\n\t\t\tconst samples = 16;\n\t\t\tfor (let i = 1; i <= samples; i++) {\n\t\t\t\tconst t = i / samples;\n\t\t\t\tconst ti = 1 - t;\n\t\t\t\tpoints.push({\n\t\t\t\t\tx: ti * ti * edge.p0.x + 2 * ti * t * edge.p1.x + t * t * edge.p2.x,\n\t\t\t\t\ty: ti * ti * edge.p0.y + 2 * ti * t * edge.p1.y + t * t * edge.p2.y,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn points;\n\t\t}\n\n\t\tcase \"cubic\": {\n\t\t\tconst points: Point[] = [edge.p0];\n\t\t\tconst samples = 16;\n\t\t\tfor (let i = 1; i <= samples; i++) {\n\t\t\t\tconst t = i / samples;\n\t\t\t\tconst ti = 1 - t;\n\t\t\t\tpoints.push({\n\t\t\t\t\tx:\n\t\t\t\t\t\tti * ti * ti * edge.p0.x +\n\t\t\t\t\t\t3 * ti * ti * t * edge.p1.x +\n\t\t\t\t\t\t3 * ti * t * t * edge.p2.x +\n\t\t\t\t\t\tt * t * t * edge.p3.x,\n\t\t\t\t\ty:\n\t\t\t\t\t\tti * ti * ti * edge.p0.y +\n\t\t\t\t\t\t3 * ti * ti * t * edge.p1.y +\n\t\t\t\t\t\t3 * ti * t * t * edge.p2.y +\n\t\t\t\t\t\tt * t * t * edge.p3.y,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn points;\n\t\t}\n\t}\n}\n",
    "/**\n * Path Stroker\n *\n * Converts a path outline into a stroked outline that can be filled.\n * Based on FreeType's ftstroke.c algorithm.\n *\n * The stroker generates two borders (inside and outside) by offsetting\n * the original path by half the stroke width in both directions.\n */\n\nimport type { GlyphPath, PathCommand } from \"../render/path.ts\";\n\n/** Line cap styles */\nexport type LineCap = \"butt\" | \"round\" | \"square\";\n\n/** Line join styles */\nexport type LineJoin = \"miter\" | \"round\" | \"bevel\";\n\n/** Stroker options */\nexport interface StrokerOptions {\n\t/** Stroke width in font units */\n\twidth: number;\n\t/** Line cap style (default: \"butt\") */\n\tlineCap?: LineCap;\n\t/** Line join style (default: \"miter\") */\n\tlineJoin?: LineJoin;\n\t/** Miter limit for miter joins (default: 4) */\n\tmiterLimit?: number;\n}\n\ninterface Point {\n\tx: number;\n\ty: number;\n}\n\ninterface Vector {\n\tx: number;\n\ty: number;\n}\n\n/**\n * Normalize a vector to unit length\n */\nfunction normalize(v: Vector): Vector {\n\tconst len = Math.sqrt(v.x * v.x + v.y * v.y);\n\tif (len === 0) return { x: 0, y: 0 };\n\treturn { x: v.x / len, y: v.y / len };\n}\n\n/**\n * Get perpendicular vector (rotate 90 degrees counter-clockwise)\n */\nfunction perp(v: Vector): Vector {\n\treturn { x: -v.y, y: v.x };\n}\n\n/**\n * Compute angle between two vectors (in radians)\n */\nfunction angleBetween(v1: Vector, v2: Vector): number {\n\tconst dot = v1.x * v2.x + v1.y * v2.y;\n\tconst cross = v1.x * v2.y - v1.y * v2.x;\n\treturn Math.atan2(cross, dot);\n}\n\n/**\n * Add round cap at a point\n */\nfunction addRoundCap(\n\tcommands: PathCommand[],\n\tcenter: Point,\n\tdirection: Vector,\n\tradius: number,\n\tclockwise: boolean,\n): void {\n\t// Perpendicular direction\n\tconst perpDir = perp(direction);\n\n\t// Start and end points of the arc\n\tconst start: Point = {\n\t\tx: center.x + perpDir.x * radius * (clockwise ? 1 : -1),\n\t\ty: center.y + perpDir.y * radius * (clockwise ? 1 : -1),\n\t};\n\tconst end: Point = {\n\t\tx: center.x - perpDir.x * radius * (clockwise ? 1 : -1),\n\t\ty: center.y - perpDir.y * radius * (clockwise ? 1 : -1),\n\t};\n\n\t// Approximate semicircle with two quadratic curves\n\tconst mid: Point = {\n\t\tx: center.x + direction.x * radius,\n\t\ty: center.y + direction.y * radius,\n\t};\n\n\t// Control points for the two quadratic curves\n\tconst ctrl1: Point = {\n\t\tx: start.x + direction.x * radius * 0.5523,\n\t\ty: start.y + direction.y * radius * 0.5523,\n\t};\n\tconst ctrl2: Point = {\n\t\tx: end.x + direction.x * radius * 0.5523,\n\t\ty: end.y + direction.y * radius * 0.5523,\n\t};\n\n\tcommands.push({ type: \"Q\", x1: ctrl1.x, y1: ctrl1.y, x: mid.x, y: mid.y });\n\tcommands.push({ type: \"Q\", x1: ctrl2.x, y1: ctrl2.y, x: end.x, y: end.y });\n}\n\n/**\n * Add square cap at a point\n */\nfunction addSquareCap(\n\tcommands: PathCommand[],\n\tcenter: Point,\n\tdirection: Vector,\n\tradius: number,\n): void {\n\tconst perpDir = perp(direction);\n\n\t// Extend by half width in the direction\n\tconst extended: Point = {\n\t\tx: center.x + direction.x * radius,\n\t\ty: center.y + direction.y * radius,\n\t};\n\n\t// Corner points\n\tconst corner1: Point = {\n\t\tx: extended.x + perpDir.x * radius,\n\t\ty: extended.y + perpDir.y * radius,\n\t};\n\tconst corner2: Point = {\n\t\tx: extended.x - perpDir.x * radius,\n\t\ty: extended.y - perpDir.y * radius,\n\t};\n\n\tcommands.push({ type: \"L\", x: corner1.x, y: corner1.y });\n\tcommands.push({ type: \"L\", x: corner2.x, y: corner2.y });\n}\n\n/**\n * Add a line join between two segments\n */\nfunction addJoin(\n\tcommands: PathCommand[],\n\tpoint: Point,\n\tprevDir: Vector,\n\tnextDir: Vector,\n\tradius: number,\n\tlineJoin: LineJoin,\n\tmiterLimit: number,\n\touter: boolean,\n): void {\n\tconst angle = angleBetween(prevDir, nextDir);\n\tconst isConvex = outer ? angle < 0 : angle > 0;\n\n\tif (Math.abs(angle) < 0.01) {\n\t\t// Nearly straight - just continue\n\t\treturn;\n\t}\n\n\tconst prevPerp = perp(prevDir);\n\tconst nextPerp = perp(nextDir);\n\tconst sign = outer ? 1 : -1;\n\n\tconst _prevOffset: Point = {\n\t\tx: point.x + prevPerp.x * radius * sign,\n\t\ty: point.y + prevPerp.y * radius * sign,\n\t};\n\tconst nextOffset: Point = {\n\t\tx: point.x + nextPerp.x * radius * sign,\n\t\ty: point.y + nextPerp.y * radius * sign,\n\t};\n\n\tif (!isConvex) {\n\t\t// Inner join - just connect with line\n\t\tcommands.push({ type: \"L\", x: nextOffset.x, y: nextOffset.y });\n\t\treturn;\n\t}\n\n\t// Outer join\n\tswitch (lineJoin) {\n\t\tcase \"round\": {\n\t\t\t// Arc from prevOffset to nextOffset\n\t\t\tconst arcAngle = Math.abs(angle);\n\t\t\tconst numSegments = Math.max(2, Math.ceil(arcAngle / (Math.PI / 4)));\n\n\t\t\tfor (let i = 1; i <= numSegments; i++) {\n\t\t\t\tconst t = i / numSegments;\n\t\t\t\tconst currentAngle =\n\t\t\t\t\tMath.atan2(prevPerp.y, prevPerp.x) + angle * t * sign;\n\t\t\t\tconst px = point.x + Math.cos(currentAngle) * radius * sign;\n\t\t\t\tconst py = point.y + Math.sin(currentAngle) * radius * sign;\n\t\t\t\tcommands.push({ type: \"L\", x: px, y: py });\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"miter\": {\n\t\t\t// Check miter limit\n\t\t\tconst miterLength = 1 / Math.sin(Math.abs(angle) / 2);\n\t\t\tif (miterLength <= miterLimit) {\n\t\t\t\t// Compute miter point\n\t\t\t\tconst halfAngle = angle / 2;\n\t\t\t\tconst miterDir = normalize({\n\t\t\t\t\tx: prevDir.x + nextDir.x,\n\t\t\t\t\ty: prevDir.y + nextDir.y,\n\t\t\t\t});\n\t\t\t\tconst miterDist = radius / Math.cos(halfAngle);\n\t\t\t\tconst miterPoint: Point = {\n\t\t\t\t\tx: point.x + miterDir.x * miterDist * sign,\n\t\t\t\t\ty: point.y + miterDir.y * miterDist * sign,\n\t\t\t\t};\n\t\t\t\tcommands.push({ type: \"L\", x: miterPoint.x, y: miterPoint.y });\n\t\t\t\tcommands.push({ type: \"L\", x: nextOffset.x, y: nextOffset.y });\n\t\t\t} else {\n\t\t\t\t// Fall back to bevel\n\t\t\t\tcommands.push({ type: \"L\", x: nextOffset.x, y: nextOffset.y });\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcommands.push({ type: \"L\", x: nextOffset.x, y: nextOffset.y });\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Stroke a single contour (closed path)\n */\nfunction strokeContour(\n\tpoints: Point[],\n\toptions: Required<StrokerOptions>,\n): PathCommand[] {\n\tif (points.length < 2) return [];\n\n\tconst { width, lineJoin, miterLimit } = options;\n\tconst radius = width / 2;\n\n\tconst commands: PathCommand[] = [];\n\tconst n = points.length;\n\n\t// Compute directions for each segment\n\tconst directions: Vector[] = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tconst p1 = points[i];\n\t\tconst p2 = points[(i + 1) % n];\n\t\tif (!p1 || !p2) continue;\n\t\tdirections.push(normalize({ x: p2.x - p1.x, y: p2.y - p1.y }));\n\t}\n\n\t// Generate outer border (going forward)\n\tconst firstDir = directions[0];\n\tconst firstPoint = points[0];\n\tif (!firstDir || !firstPoint) return [];\n\n\tconst firstPerp = perp(firstDir);\n\tcommands.push({\n\t\ttype: \"M\",\n\t\tx: firstPoint.x + firstPerp.x * radius,\n\t\ty: firstPoint.y + firstPerp.y * radius,\n\t});\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst p1 = points[i];\n\t\tconst p2 = points[(i + 1) % n];\n\t\tconst dir = directions[i];\n\t\tconst nextDir = directions[(i + 1) % n];\n\t\tif (!p1 || !p2 || !dir || !nextDir) continue;\n\n\t\tconst perpDir = perp(dir);\n\n\t\t// Line to end of current segment\n\t\tcommands.push({\n\t\t\ttype: \"L\",\n\t\t\tx: p2.x + perpDir.x * radius,\n\t\t\ty: p2.y + perpDir.y * radius,\n\t\t});\n\n\t\t// Add join\n\t\taddJoin(commands, p2, dir, nextDir, radius, lineJoin, miterLimit, true);\n\t}\n\n\tcommands.push({ type: \"Z\" });\n\n\t// Generate inner border (going backward)\n\tconst lastIdx = n - 1;\n\tconst lastDir = directions[lastIdx];\n\tconst lastPoint = points[0];\n\tif (!lastDir || !lastPoint) return commands;\n\n\tconst lastPerp = perp(firstDir);\n\tcommands.push({\n\t\ttype: \"M\",\n\t\tx: firstPoint.x - lastPerp.x * radius,\n\t\ty: firstPoint.y - lastPerp.y * radius,\n\t});\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst p1 = points[i];\n\t\tconst p2 = points[(i + 1) % n];\n\t\tconst dir = directions[i];\n\t\tconst nextDir = directions[(i + 1) % n];\n\t\tif (!p1 || !p2 || !dir || !nextDir) continue;\n\n\t\tconst perpDir = perp(dir);\n\n\t\t// Line to end of current segment (inner side)\n\t\tcommands.push({\n\t\t\ttype: \"L\",\n\t\t\tx: p2.x - perpDir.x * radius,\n\t\t\ty: p2.y - perpDir.y * radius,\n\t\t});\n\n\t\t// Add join (inner)\n\t\taddJoin(commands, p2, dir, nextDir, radius, lineJoin, miterLimit, false);\n\t}\n\n\tcommands.push({ type: \"Z\" });\n\n\treturn commands;\n}\n\n/**\n * Stroke an open path (with caps)\n */\nfunction strokeOpenPath(\n\tpoints: Point[],\n\toptions: Required<StrokerOptions>,\n): PathCommand[] {\n\tif (points.length < 2) return [];\n\n\tconst { width, lineCap, lineJoin, miterLimit } = options;\n\tconst radius = width / 2;\n\n\tconst commands: PathCommand[] = [];\n\tconst n = points.length;\n\n\t// Compute directions for each segment\n\tconst directions: Vector[] = [];\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tconst p1 = points[i];\n\t\tconst p2 = points[i + 1];\n\t\tif (!p1 || !p2) continue;\n\t\tdirections.push(normalize({ x: p2.x - p1.x, y: p2.y - p1.y }));\n\t}\n\n\tconst firstPoint = points[0];\n\tconst lastPoint = points[n - 1];\n\tconst firstDir = directions[0];\n\tconst lastDir = directions[directions.length - 1];\n\tif (!firstPoint || !lastPoint || !firstDir || !lastDir) return [];\n\n\t// Start with cap at beginning\n\tconst firstPerp = perp(firstDir);\n\n\t// Start at the right side of the first point\n\tcommands.push({\n\t\ttype: \"M\",\n\t\tx: firstPoint.x + firstPerp.x * radius,\n\t\ty: firstPoint.y + firstPerp.y * radius,\n\t});\n\n\t// Forward pass (right side)\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tconst p2 = points[i + 1];\n\t\tconst dir = directions[i];\n\t\tconst nextDir = directions[i + 1];\n\t\tif (!p2 || !dir) continue;\n\n\t\tconst perpDir = perp(dir);\n\t\tcommands.push({\n\t\t\ttype: \"L\",\n\t\t\tx: p2.x + perpDir.x * radius,\n\t\t\ty: p2.y + perpDir.y * radius,\n\t\t});\n\n\t\tif (nextDir) {\n\t\t\taddJoin(commands, p2, dir, nextDir, radius, lineJoin, miterLimit, true);\n\t\t}\n\t}\n\n\t// End cap\n\tconst _negLastDir: Vector = { x: -lastDir.x, y: -lastDir.y };\n\tswitch (lineCap) {\n\t\tcase \"round\":\n\t\t\taddRoundCap(commands, lastPoint, lastDir, radius, true);\n\t\t\tbreak;\n\t\tcase \"square\":\n\t\t\taddSquareCap(commands, lastPoint, lastDir, radius);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tconst lastPerp = perp(lastDir);\n\t\t\tcommands.push({\n\t\t\t\ttype: \"L\",\n\t\t\t\tx: lastPoint.x - lastPerp.x * radius,\n\t\t\t\ty: lastPoint.y - lastPerp.y * radius,\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Backward pass (left side)\n\tfor (let i = n - 2; i >= 0; i--) {\n\t\tconst p1 = points[i];\n\t\tconst dir = directions[i];\n\t\tconst prevDir = directions[i - 1];\n\t\tif (!p1 || !dir) continue;\n\n\t\tconst perpDir = perp(dir);\n\t\tcommands.push({\n\t\t\ttype: \"L\",\n\t\t\tx: p1.x - perpDir.x * radius,\n\t\t\ty: p1.y - perpDir.y * radius,\n\t\t});\n\n\t\tif (prevDir) {\n\t\t\taddJoin(\n\t\t\t\tcommands,\n\t\t\t\tp1,\n\t\t\t\t{ x: -dir.x, y: -dir.y },\n\t\t\t\t{ x: -prevDir.x, y: -prevDir.y },\n\t\t\t\tradius,\n\t\t\t\tlineJoin,\n\t\t\t\tmiterLimit,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t}\n\n\t// Start cap\n\tconst negFirstDir: Vector = { x: -firstDir.x, y: -firstDir.y };\n\tswitch (lineCap) {\n\t\tcase \"round\":\n\t\t\taddRoundCap(commands, firstPoint, negFirstDir, radius, true);\n\t\t\tbreak;\n\t\tcase \"square\":\n\t\t\taddSquareCap(commands, firstPoint, negFirstDir, radius);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Already at the right position, close the path\n\t\t\tbreak;\n\t}\n\n\tcommands.push({ type: \"Z\" });\n\n\treturn commands;\n}\n\n/**\n * Extract points from path commands\n * Returns an array of contours, each contour is an array of points\n */\nfunction extractContours(\n\tpath: GlyphPath,\n): { points: Point[]; closed: boolean }[] {\n\tconst contours: { points: Point[]; closed: boolean }[] = [];\n\tlet currentContour: Point[] = [];\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tif (currentContour.length > 0) {\n\t\t\t\t\tcontours.push({ points: currentContour, closed: false });\n\t\t\t\t}\n\t\t\t\tcurrentContour = [{ x: cmd.x, y: cmd.y }];\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tcurrentContour.push({ x: cmd.x, y: cmd.y });\n\t\t\t\tbreak;\n\t\t\tcase \"Q\": {\n\t\t\t\t// Flatten quadratic bezier\n\t\t\t\tconst last = currentContour[currentContour.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tconst steps = 8;\n\t\t\t\t\tfor (let j = 1; j <= steps; j++) {\n\t\t\t\t\t\tconst t = j / steps;\n\t\t\t\t\t\tconst ti = 1 - t;\n\t\t\t\t\t\tconst x = ti * ti * last.x + 2 * ti * t * cmd.x1 + t * t * cmd.x;\n\t\t\t\t\t\tconst y = ti * ti * last.y + 2 * ti * t * cmd.y1 + t * t * cmd.y;\n\t\t\t\t\t\tcurrentContour.push({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\t// Flatten cubic bezier\n\t\t\t\tconst last = currentContour[currentContour.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tconst steps = 12;\n\t\t\t\t\tfor (let j = 1; j <= steps; j++) {\n\t\t\t\t\t\tconst t = j / steps;\n\t\t\t\t\t\tconst ti = 1 - t;\n\t\t\t\t\t\tconst x =\n\t\t\t\t\t\t\tti * ti * ti * last.x +\n\t\t\t\t\t\t\t3 * ti * ti * t * cmd.x1 +\n\t\t\t\t\t\t\t3 * ti * t * t * cmd.x2 +\n\t\t\t\t\t\t\tt * t * t * cmd.x;\n\t\t\t\t\t\tconst y =\n\t\t\t\t\t\t\tti * ti * ti * last.y +\n\t\t\t\t\t\t\t3 * ti * ti * t * cmd.y1 +\n\t\t\t\t\t\t\t3 * ti * t * t * cmd.y2 +\n\t\t\t\t\t\t\tt * t * t * cmd.y;\n\t\t\t\t\t\tcurrentContour.push({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tif (currentContour.length > 0) {\n\t\t\t\t\tcontours.push({ points: currentContour, closed: true });\n\t\t\t\t\tcurrentContour = [];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (currentContour.length > 0) {\n\t\tcontours.push({ points: currentContour, closed: false });\n\t}\n\n\treturn contours;\n}\n\n/**\n * Stroke a glyph path, producing a new path that represents the stroked outline\n * @param path Input glyph path to stroke\n * @param options Stroke parameters (width, cap style, join style, miter limit)\n * @returns New path representing the stroked outline that can be filled\n */\nexport function strokePath(\n\tpath: GlyphPath,\n\toptions: StrokerOptions,\n): GlyphPath {\n\tconst opts: Required<StrokerOptions> = {\n\t\twidth: options.width,\n\t\tlineCap: options.lineCap ?? \"butt\",\n\t\tlineJoin: options.lineJoin ?? \"miter\",\n\t\tmiterLimit: options.miterLimit ?? 4,\n\t};\n\n\tconst contours = extractContours(path);\n\tconst commands: PathCommand[] = [];\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tif (contour.points.length < 2) continue;\n\n\t\tconst contourCommands = contour.closed\n\t\t\t? strokeContour(contour.points, opts)\n\t\t\t: strokeOpenPath(contour.points, opts);\n\n\t\tcommands.push(...contourCommands);\n\t}\n\n\t// Calculate new bounds (original bounds + stroke width)\n\tlet bounds = path.bounds;\n\tif (bounds) {\n\t\tconst padding = opts.width / 2;\n\t\tbounds = {\n\t\t\txMin: bounds.xMin - padding,\n\t\t\tyMin: bounds.yMin - padding,\n\t\t\txMax: bounds.xMax + padding,\n\t\t\tyMax: bounds.yMax + padding,\n\t\t};\n\t}\n\n\treturn { commands, bounds };\n}\n",
    "/**\n * Asymmetric Stroke\n *\n * Generates stroked outlines with independent X and Y border widths.\n * This enables effects like directional shadows, stretched borders,\n * and other asymmetric outline effects.\n *\n * The algorithm:\n * 1. Flatten curves to polylines with configurable precision\n * 2. For each segment, compute offset vectors scaled by (xBorder, yBorder)\n * 3. Handle line joins (miter, round, bevel)\n * 4. Generate both inner and outer contours for closed paths\n * 5. Handle caps for open paths\n */\n\nimport type { GlyphPath, PathCommand } from \"../render/path.ts\";\n\n/**\n * Options for asymmetric stroking\n */\nexport interface AsymmetricStrokeOptions {\n\t/** X-axis border width (in font units) */\n\txBorder: number;\n\t/** Y-axis border width (in font units) */\n\tyBorder: number;\n\t/** Precision for curve flattening (smaller = more accurate, default: 1) */\n\teps?: number;\n\t/** Line join style (default: \"round\") */\n\tlineJoin?: \"miter\" | \"round\" | \"bevel\";\n\t/** Miter limit for miter joins (default: 4) */\n\tmiterLimit?: number;\n}\n\ninterface Point {\n\tx: number;\n\ty: number;\n}\n\ninterface Normal {\n\tx: number;\n\ty: number;\n\tlen: number;\n}\n\n/**\n * Compute the asymmetric offset for a direction vector\n * The offset is perpendicular to the direction, scaled by (xBorder, yBorder)\n */\nfunction computeAsymmetricOffset(\n\tdx: number,\n\tdy: number,\n\txBorder: number,\n\tyBorder: number,\n): Normal {\n\t// Perpendicular direction (rotated 90 CCW): (-dy, dx)\n\t// Scale by border widths\n\tconst px = -dy * yBorder;\n\tconst py = dx * xBorder;\n\n\t// Length of scaled perpendicular\n\tconst len = Math.sqrt(px * px + py * py);\n\tif (len < 1e-10) {\n\t\treturn { x: 0, y: 0, len: 0 };\n\t}\n\n\t// Normalize\n\treturn {\n\t\tx: px / len,\n\t\ty: py / len,\n\t\tlen,\n\t};\n}\n\n/**\n * Flatten a quadratic Bzier curve to line segments\n */\nfunction flattenQuadratic(\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n\teps: number,\n\tresult: Point[],\n): void {\n\t// Check if flat enough using distance from control point to line\n\tconst dx = p2.x - p0.x;\n\tconst dy = p2.y - p0.y;\n\tconst d =\n\t\tMath.abs((p1.x - p0.x) * dy - (p1.y - p0.y) * dx) /\n\t\tMath.sqrt(dx * dx + dy * dy + 1e-10);\n\n\tif (d <= eps) {\n\t\tresult.push(p2);\n\t\treturn;\n\t}\n\n\t// Subdivide using de Casteljau\n\tconst p01: Point = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };\n\tconst p12: Point = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n\tconst p012: Point = { x: (p01.x + p12.x) / 2, y: (p01.y + p12.y) / 2 };\n\n\tflattenQuadratic(p0, p01, p012, eps, result);\n\tflattenQuadratic(p012, p12, p2, eps, result);\n}\n\n/**\n * Flatten a cubic Bzier curve to line segments\n */\nfunction flattenCubic(\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n\tp3: Point,\n\teps: number,\n\tresult: Point[],\n): void {\n\t// Check flatness using max distance of control points from line\n\tconst dx = p3.x - p0.x;\n\tconst dy = p3.y - p0.y;\n\tconst lenSq = dx * dx + dy * dy + 1e-10;\n\tconst d1 =\n\t\tMath.abs((p1.x - p0.x) * dy - (p1.y - p0.y) * dx) / Math.sqrt(lenSq);\n\tconst d2 =\n\t\tMath.abs((p2.x - p0.x) * dy - (p2.y - p0.y) * dx) / Math.sqrt(lenSq);\n\n\tif (d1 <= eps && d2 <= eps) {\n\t\tresult.push(p3);\n\t\treturn;\n\t}\n\n\t// Subdivide using de Casteljau\n\tconst p01: Point = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };\n\tconst p12: Point = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n\tconst p23: Point = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };\n\tconst p012: Point = { x: (p01.x + p12.x) / 2, y: (p01.y + p12.y) / 2 };\n\tconst p123: Point = { x: (p12.x + p23.x) / 2, y: (p12.y + p23.y) / 2 };\n\tconst p0123: Point = { x: (p012.x + p123.x) / 2, y: (p012.y + p123.y) / 2 };\n\n\tflattenCubic(p0, p01, p012, p0123, eps, result);\n\tflattenCubic(p0123, p123, p23, p3, eps, result);\n}\n\n/**\n * Convert path commands to polyline contours\n */\nfunction pathToContours(\n\tpath: GlyphPath,\n\teps: number,\n): { points: Point[]; closed: boolean }[] {\n\tconst contours: { points: Point[]; closed: boolean }[] = [];\n\tlet current: Point[] = [];\n\tlet curPoint: Point = { x: 0, y: 0 };\n\tlet startPoint: Point = { x: 0, y: 0 };\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tif (current.length > 1) {\n\t\t\t\t\tcontours.push({ points: current, closed: false });\n\t\t\t\t}\n\t\t\t\tcurPoint = { x: cmd.x, y: cmd.y };\n\t\t\t\tstartPoint = curPoint;\n\t\t\t\tcurrent = [curPoint];\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tcurPoint = { x: cmd.x, y: cmd.y };\n\t\t\t\tcurrent.push(curPoint);\n\t\t\t\tbreak;\n\n\t\t\tcase \"Q\":\n\t\t\t\tflattenQuadratic(\n\t\t\t\t\tcurPoint,\n\t\t\t\t\t{ x: cmd.x1, y: cmd.y1 },\n\t\t\t\t\t{ x: cmd.x, y: cmd.y },\n\t\t\t\t\teps,\n\t\t\t\t\tcurrent,\n\t\t\t\t);\n\t\t\t\tcurPoint = { x: cmd.x, y: cmd.y };\n\t\t\t\tbreak;\n\n\t\t\tcase \"C\":\n\t\t\t\tflattenCubic(\n\t\t\t\t\tcurPoint,\n\t\t\t\t\t{ x: cmd.x1, y: cmd.y1 },\n\t\t\t\t\t{ x: cmd.x2, y: cmd.y2 },\n\t\t\t\t\t{ x: cmd.x, y: cmd.y },\n\t\t\t\t\teps,\n\t\t\t\t\tcurrent,\n\t\t\t\t);\n\t\t\t\tcurPoint = { x: cmd.x, y: cmd.y };\n\t\t\t\tbreak;\n\n\t\t\tcase \"Z\":\n\t\t\t\t// Close path - connect back to start if needed\n\t\t\t\tif (current.length > 1) {\n\t\t\t\t\t// Check if already closed\n\t\t\t\t\tconst first = current[0];\n\t\t\t\t\tconst last = current[current.length - 1];\n\t\t\t\t\tif (first && last) {\n\t\t\t\t\t\tconst dx = last.x - first.x;\n\t\t\t\t\t\tconst dy = last.y - first.y;\n\t\t\t\t\t\tif (dx * dx + dy * dy > eps * eps) {\n\t\t\t\t\t\t\tcurrent.push({ ...first });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontours.push({ points: current, closed: true });\n\t\t\t\t}\n\t\t\t\tcurrent = [];\n\t\t\t\tcurPoint = startPoint;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Handle unclosed path\n\tif (current.length > 1) {\n\t\tcontours.push({ points: current, closed: false });\n\t}\n\n\treturn contours;\n}\n\nfunction contourSignedArea(points: Point[]): number {\n\tif (points.length < 3) return 0;\n\tlet end = points.length;\n\tconst first = points[0];\n\tconst last = points[end - 1];\n\tif (first && last) {\n\t\tconst dx = last.x - first.x;\n\t\tconst dy = last.y - first.y;\n\t\tif (dx * dx + dy * dy < 1) end -= 1;\n\t}\n\tif (end < 3) return 0;\n\tlet area = 0;\n\tfor (let i = 0; i < end; i++) {\n\t\tconst p0 = points[i];\n\t\tconst p1 = points[(i + 1) % end];\n\t\tif (!p0 || !p1) continue;\n\t\tarea += p0.x * p1.y - p1.x * p0.y;\n\t}\n\treturn area;\n}\n\n/**\n * Add a round join between two segments\n */\nfunction addRoundJoin(\n\tresult: Point[],\n\tcenter: Point,\n\tnormal0: Normal,\n\tnormal1: Normal,\n\txBorder: number,\n\tyBorder: number,\n\touter: boolean,\n): void {\n\t// Compute angle between normals\n\tconst dot = normal0.x * normal1.x + normal0.y * normal1.y;\n\tconst cross = normal0.x * normal1.y - normal0.y * normal1.x;\n\tconst angle = Math.atan2(cross, dot);\n\n\t// Number of segments for the arc\n\tconst numSegments = Math.max(2, Math.ceil(Math.abs(angle) / (Math.PI / 8)));\n\n\tconst sign = outer ? 1 : -1;\n\tconst startAngle = Math.atan2(normal0.y, normal0.x);\n\n\tfor (let i = 1; i <= numSegments; i++) {\n\t\tconst t = i / numSegments;\n\t\tconst currentAngle = startAngle + angle * t;\n\t\tconst nx = Math.cos(currentAngle);\n\t\tconst ny = Math.sin(currentAngle);\n\t\tresult.push({\n\t\t\tx: center.x + nx * xBorder * sign,\n\t\t\ty: center.y + ny * yBorder * sign,\n\t\t});\n\t}\n}\n\n/**\n * Add a miter join between two segments\n */\nfunction addMiterJoin(\n\tresult: Point[],\n\tcenter: Point,\n\tnormal0: Normal,\n\tnormal1: Normal,\n\txBorder: number,\n\tyBorder: number,\n\tmiterLimit: number,\n\touter: boolean,\n): boolean {\n\tconst sign = outer ? 1 : -1;\n\n\t// Compute miter point\n\tconst dot = normal0.x * normal1.x + normal0.y * normal1.y;\n\tconst sinHalfAngle = Math.sqrt((1 - dot) / 2);\n\n\tif (sinHalfAngle < 1e-10) {\n\t\treturn false; // Nearly parallel\n\t}\n\n\tconst miterLength = 1 / sinHalfAngle;\n\n\tif (miterLength > miterLimit) {\n\t\treturn false; // Exceeds miter limit, use bevel\n\t}\n\n\t// Miter direction (bisector)\n\tconst mx = normal0.x + normal1.x;\n\tconst my = normal0.y + normal1.y;\n\tconst mlen = Math.sqrt(mx * mx + my * my);\n\n\tif (mlen < 1e-10) {\n\t\treturn false;\n\t}\n\n\tconst miterDist =\n\t\t(miterLength * Math.sqrt(xBorder * xBorder + yBorder * yBorder)) / 2;\n\n\tresult.push({\n\t\tx: center.x + (mx / mlen) * miterDist * sign,\n\t\ty: center.y + (my / mlen) * miterDist * sign,\n\t});\n\n\treturn true;\n}\n\n/**\n * Stroke a single closed contour with asymmetric borders\n * Returns both outer and inner contours\n */\nfunction strokeClosedContour(\n\tpoints: Point[],\n\txBorder: number,\n\tyBorder: number,\n\tlineJoin: \"miter\" | \"round\" | \"bevel\",\n\tmiterLimit: number,\n\toutwardIsLeft: boolean,\n): { outer: Point[]; inner: Point[] } {\n\tconst n = points.length;\n\tif (n < 3) {\n\t\treturn { outer: [], inner: [] };\n\t}\n\n\t// Remove duplicate closing point if present\n\tconst lastIdx = n - 1;\n\tconst first = points[0];\n\tconst last = points[lastIdx];\n\tlet effectiveN = n;\n\tif (first && last) {\n\t\tconst dx = last.x - first.x;\n\t\tconst dy = last.y - first.y;\n\t\tif (dx * dx + dy * dy < 1) {\n\t\t\teffectiveN = n - 1;\n\t\t}\n\t}\n\n\tif (effectiveN < 3) {\n\t\treturn { outer: [], inner: [] };\n\t}\n\n\t// computeAsymmetricOffset() returns the left normal.\n\t// Flip when we want right-side (outward) normals.\n\tconst normalFlip = outwardIsLeft ? 1 : -1;\n\n\t// Compute normals for each segment\n\tconst normals: Normal[] = [];\n\tfor (let i = 0; i < effectiveN; i++) {\n\t\tconst p0 = points[i];\n\t\tconst p1 = points[(i + 1) % effectiveN];\n\t\tif (!p0 || !p1) continue;\n\n\t\tconst dx = p1.x - p0.x;\n\t\tconst dy = p1.y - p0.y;\n\t\tconst len = Math.sqrt(dx * dx + dy * dy);\n\n\t\tif (len < 1e-10) {\n\t\t\tnormals.push({ x: 0, y: 0, len: 0 });\n\t\t} else {\n\t\t\tconst nrm = computeAsymmetricOffset(\n\t\t\t\tdx / len,\n\t\t\t\tdy / len,\n\t\t\t\txBorder,\n\t\t\t\tyBorder,\n\t\t\t);\n\t\t\tif (normalFlip < 0) {\n\t\t\t\tnrm.x = -nrm.x;\n\t\t\t\tnrm.y = -nrm.y;\n\t\t\t}\n\t\t\tnormals.push(nrm);\n\t\t}\n\t}\n\n\tconst outer: Point[] = [];\n\tconst inner: Point[] = [];\n\n\t// Generate outer contour\n\tfor (let i = 0; i < effectiveN; i++) {\n\t\tconst pt = points[i];\n\t\tconst prevNormal = normals[(i - 1 + effectiveN) % effectiveN];\n\t\tconst nextNormal = normals[i];\n\t\tif (!pt || !prevNormal || !nextNormal) continue;\n\n\t\t// Skip zero-length segments\n\t\tif (prevNormal.len < 1e-10 || nextNormal.len < 1e-10) {\n\t\t\touter.push({\n\t\t\t\tx: pt.x + (nextNormal.len > 0 ? nextNormal.x * xBorder : 0),\n\t\t\t\ty: pt.y + (nextNormal.len > 0 ? nextNormal.y * yBorder : 0),\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\n\t\t// First point of segment\n\t\tconst offsetPt: Point = {\n\t\t\tx: pt.x + nextNormal.x * xBorder,\n\t\t\ty: pt.y + nextNormal.y * yBorder,\n\t\t};\n\n\t\t// Check if we need a join\n\t\tconst cross = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;\n\t\tconst isConvex = cross > 0;\n\n\t\tif (Math.abs(cross) < 0.01) {\n\t\t\t// Nearly parallel\n\t\t\touter.push(offsetPt);\n\t\t} else if (isConvex) {\n\t\t\t// Convex corner - add join\n\t\t\tswitch (lineJoin) {\n\t\t\t\tcase \"round\":\n\t\t\t\t\taddRoundJoin(\n\t\t\t\t\t\touter,\n\t\t\t\t\t\tpt,\n\t\t\t\t\t\tprevNormal,\n\t\t\t\t\t\tnextNormal,\n\t\t\t\t\t\txBorder,\n\t\t\t\t\t\tyBorder,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"miter\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!addMiterJoin(\n\t\t\t\t\t\t\touter,\n\t\t\t\t\t\t\tpt,\n\t\t\t\t\t\t\tprevNormal,\n\t\t\t\t\t\t\tnextNormal,\n\t\t\t\t\t\t\txBorder,\n\t\t\t\t\t\t\tyBorder,\n\t\t\t\t\t\t\tmiterLimit,\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\touter.push(offsetPt);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\touter.push(offsetPt);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t// Concave corner - just add the point\n\t\t\touter.push(offsetPt);\n\t\t}\n\t}\n\n\t// Generate inner contour (reverse direction)\n\tfor (let i = 0; i < effectiveN; i++) {\n\t\tconst pt = points[i];\n\t\tconst prevNormal = normals[(i - 1 + effectiveN) % effectiveN];\n\t\tconst nextNormal = normals[i];\n\t\tif (!pt || !prevNormal || !nextNormal) continue;\n\n\t\tif (prevNormal.len < 1e-10 || nextNormal.len < 1e-10) {\n\t\t\tinner.push({\n\t\t\t\tx: pt.x - (nextNormal.len > 0 ? nextNormal.x * xBorder : 0),\n\t\t\t\ty: pt.y - (nextNormal.len > 0 ? nextNormal.y * yBorder : 0),\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst offsetPt: Point = {\n\t\t\tx: pt.x - nextNormal.x * xBorder,\n\t\t\ty: pt.y - nextNormal.y * yBorder,\n\t\t};\n\n\t\tconst cross = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;\n\t\tconst isConvex = cross < 0; // Reversed for inner\n\n\t\tif (Math.abs(cross) < 0.01) {\n\t\t\tinner.push(offsetPt);\n\t\t} else if (isConvex) {\n\t\t\tswitch (lineJoin) {\n\t\t\t\tcase \"round\":\n\t\t\t\t\taddRoundJoin(\n\t\t\t\t\t\tinner,\n\t\t\t\t\t\tpt,\n\t\t\t\t\t\tprevNormal,\n\t\t\t\t\t\tnextNormal,\n\t\t\t\t\t\txBorder,\n\t\t\t\t\t\tyBorder,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"miter\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!addMiterJoin(\n\t\t\t\t\t\t\tinner,\n\t\t\t\t\t\t\tpt,\n\t\t\t\t\t\t\tprevNormal,\n\t\t\t\t\t\t\tnextNormal,\n\t\t\t\t\t\t\txBorder,\n\t\t\t\t\t\t\tyBorder,\n\t\t\t\t\t\t\tmiterLimit,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tinner.push(offsetPt);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tinner.push(offsetPt);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tinner.push(offsetPt);\n\t\t}\n\t}\n\n\treturn { outer, inner };\n}\n\n/**\n * Convert points back to path commands\n */\nfunction pointsToPath(points: Point[], closed: boolean): PathCommand[] {\n\tif (points.length === 0) return [];\n\n\tconst commands: PathCommand[] = [];\n\tconst first = points[0];\n\tif (!first) return [];\n\n\tcommands.push({ type: \"M\", x: first.x, y: first.y });\n\n\tfor (let i = 1; i < points.length; i++) {\n\t\tconst pt = points[i];\n\t\tif (!pt) continue;\n\t\tcommands.push({ type: \"L\", x: pt.x, y: pt.y });\n\t}\n\n\tif (closed) {\n\t\tcommands.push({ type: \"Z\" });\n\t}\n\n\treturn commands;\n}\n\n/**\n * Stroke a path with asymmetric X/Y borders\n * For filled text with border: combine outer outline with original fill,\n * or use outer outline alone for hollow border effect\n * @param path Input path to stroke\n * @param options Stroke options including xBorder and yBorder\n * @returns Two paths: outer (positive offset) and inner (negative offset)\n */\nexport function strokeAsymmetric(\n\tpath: GlyphPath,\n\toptions: AsymmetricStrokeOptions,\n): { outer: GlyphPath; inner: GlyphPath } {\n\tconst {\n\t\txBorder,\n\t\tyBorder,\n\t\teps = 1,\n\t\tlineJoin = \"round\",\n\t\tmiterLimit = 4,\n\t} = options;\n\n\tif (xBorder <= 0 && yBorder <= 0) {\n\t\treturn {\n\t\t\touter: { commands: [], bounds: null },\n\t\t\tinner: { commands: [], bounds: null },\n\t\t};\n\t}\n\n\t// Flatten path to polylines\n\tconst contours = pathToContours(path, eps);\n\n\tconst outerCommands: PathCommand[] = [];\n\tconst innerCommands: PathCommand[] = [];\n\n\tconst areas: number[] = [];\n\tlet outerSign = 1;\n\tlet maxAbs = 0;\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tconst area = contourSignedArea(contour.points);\n\t\tareas[i] = area;\n\t\tconst abs = Math.abs(area);\n\t\tif (abs > maxAbs) {\n\t\t\tmaxAbs = abs;\n\t\t\touterSign = area >= 0 ? 1 : -1;\n\t\t}\n\t}\n\tif (maxAbs === 0) outerSign = 1;\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tif (!contour.closed) {\n\t\t\t// For open paths, we'd need to handle caps\n\t\t\t// For now, treat as closed by connecting ends\n\t\t\tconst firstPoint = contour.points[0];\n\t\t\tif (firstPoint) contour.points.push(firstPoint);\n\t\t\tcontour.closed = true;\n\t\t}\n\n\t\tconst area = areas[i] ?? 0;\n\t\tconst contourSign = area >= 0 ? 1 : -1;\n\t\tconst interiorIsLeft = contourSign > 0;\n\t\tconst isOuter = contourSign === outerSign;\n\t\t// Outward relative to fill: outer contours go outside the fill,\n\t\t// hole contours go toward the hole interior.\n\t\tconst outwardIsLeft = isOuter ? !interiorIsLeft : interiorIsLeft;\n\n\t\tconst { outer, inner } = strokeClosedContour(\n\t\t\tcontour.points,\n\t\t\txBorder,\n\t\t\tyBorder,\n\t\t\tlineJoin,\n\t\t\tmiterLimit,\n\t\t\toutwardIsLeft,\n\t\t);\n\t\t// Ensure opposite winding to form a proper ring when combined.\n\t\tinner.reverse();\n\n\t\touterCommands.push(...pointsToPath(outer, true));\n\t\tinnerCommands.push(...pointsToPath(inner, true));\n\t}\n\n\t// Compute bounds\n\tlet outerBounds = null;\n\tlet innerBounds = null;\n\n\tif (path.bounds) {\n\t\touterBounds = {\n\t\t\txMin: path.bounds.xMin - xBorder,\n\t\t\tyMin: path.bounds.yMin - yBorder,\n\t\t\txMax: path.bounds.xMax + xBorder,\n\t\t\tyMax: path.bounds.yMax + yBorder,\n\t\t};\n\t\tinnerBounds = {\n\t\t\txMin: path.bounds.xMin + xBorder,\n\t\t\tyMin: path.bounds.yMin + yBorder,\n\t\t\txMax: path.bounds.xMax - xBorder,\n\t\t\tyMax: path.bounds.yMax - yBorder,\n\t\t};\n\t}\n\n\treturn {\n\t\touter: { commands: outerCommands, bounds: outerBounds, flags: path.flags },\n\t\tinner: { commands: innerCommands, bounds: innerBounds, flags: path.flags },\n\t};\n}\n\n/**\n * Create a combined stroke path (both inner and outer as single path)\n * This creates a ring/donut shape that can be filled\n * @param path Input path to stroke\n * @param options Stroke options including xBorder and yBorder\n * @returns Single path containing both outer and inner borders as a fillable ring\n */\nexport function strokeAsymmetricCombined(\n\tpath: GlyphPath,\n\toptions: AsymmetricStrokeOptions,\n): GlyphPath {\n\tconst { outer, inner } = strokeAsymmetric(path, options);\n\n\t// Combine both paths - outer goes clockwise, inner goes counter-clockwise\n\t// This creates a fillable ring shape\n\tconst commands: PathCommand[] = [...outer.commands, ...inner.commands];\n\n\tconst bounds = outer.bounds;\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Stroke with uniform border (convenience function)\n * @param path Input path to stroke\n * @param border Border width in font units (applied to both X and Y)\n * @param options Additional stroke options (precision, line join, miter limit)\n * @returns Two paths: outer and inner borders\n */\nexport function strokeUniform(\n\tpath: GlyphPath,\n\tborder: number,\n\toptions?: Omit<AsymmetricStrokeOptions, \"xBorder\" | \"yBorder\">,\n): { outer: GlyphPath; inner: GlyphPath } {\n\treturn strokeAsymmetric(path, {\n\t\txBorder: border,\n\t\tyBorder: border,\n\t\t...options,\n\t});\n}\n",
    "/**\n * Synthetic Font Effects\n *\n * Provides transformations for creating synthetic bold, italic, and other effects\n * on glyph outlines. These are useful for fonts that don't have native bold/italic\n * variants.\n */\n\nimport type { GlyphPath, PathCommand } from \"../render/path.ts\";\nimport { strokeAsymmetric } from \"./asymmetric-stroke.ts\";\n\nfunction computeBounds(commands: PathCommand[]): {\n\txMin: number;\n\tyMin: number;\n\txMax: number;\n\tyMax: number;\n} | null {\n\tlet xMin = Infinity;\n\tlet yMin = Infinity;\n\tlet xMax = -Infinity;\n\tlet yMax = -Infinity;\n\n\tfor (let i = 0; i < commands.length; i++) {\n\t\tconst cmd = commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\txMin = Math.min(xMin, cmd.x);\n\t\t\t\txMax = Math.max(xMax, cmd.x);\n\t\t\t\tyMin = Math.min(yMin, cmd.y);\n\t\t\t\tyMax = Math.max(yMax, cmd.y);\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\txMin = Math.min(xMin, cmd.x, cmd.x1);\n\t\t\t\txMax = Math.max(xMax, cmd.x, cmd.x1);\n\t\t\t\tyMin = Math.min(yMin, cmd.y, cmd.y1);\n\t\t\t\tyMax = Math.max(yMax, cmd.y, cmd.y1);\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\txMin = Math.min(xMin, cmd.x, cmd.x1, cmd.x2);\n\t\t\t\txMax = Math.max(xMax, cmd.x, cmd.x1, cmd.x2);\n\t\t\t\tyMin = Math.min(yMin, cmd.y, cmd.y1, cmd.y2);\n\t\t\t\tyMax = Math.max(yMax, cmd.y, cmd.y1, cmd.y2);\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!Number.isFinite(xMin)) return null;\n\treturn { xMin, yMin, xMax, yMax };\n}\n\n/**\n * Apply oblique (slant/italic) transformation to a path\n *\n * @param path - The glyph path to transform\n * @param slant - Tangent of the slant angle (0.2 = ~12 degrees, typical italic)\n * @returns New path with slant applied\n *\n * Transform: x' = x + y * slant, y' = y\n */\nexport function obliquePath(path: GlyphPath, slant: number): GlyphPath {\n\tconst commands: PathCommand[] = [];\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\tx: cmd.x + cmd.y * slant,\n\t\t\t\t\ty: cmd.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\tx1: cmd.x1 + cmd.y1 * slant,\n\t\t\t\t\ty1: cmd.y1,\n\t\t\t\t\tx: cmd.x + cmd.y * slant,\n\t\t\t\t\ty: cmd.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: cmd.x1 + cmd.y1 * slant,\n\t\t\t\t\ty1: cmd.y1,\n\t\t\t\t\tx2: cmd.x2 + cmd.y2 * slant,\n\t\t\t\t\ty2: cmd.y2,\n\t\t\t\t\tx: cmd.x + cmd.y * slant,\n\t\t\t\t\ty: cmd.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tcommands.push({ type: \"Z\" });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Update bounds\n\tconst bounds = computeBounds(commands);\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Apply general 2D affine transformation to a path\n *\n * @param path - The glyph path to transform\n * @param matrix - 2D transformation matrix [a, b, c, d, e, f]\n * @returns New path with transformation applied\n *\n * Transform: x' = a*x + c*y + e, y' = b*x + d*y + f\n */\nexport function transformPath(\n\tpath: GlyphPath,\n\tmatrix: [number, number, number, number, number, number],\n): GlyphPath {\n\tconst [a, b, c, d, e, f] = matrix;\n\n\tconst transformPoint = (x: number, y: number) => ({\n\t\tx: a * x + c * y + e,\n\t\ty: b * x + d * y + f,\n\t});\n\n\tconst commands: PathCommand[] = [];\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\": {\n\t\t\t\tconst p = transformPoint(cmd.x, cmd.y);\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\tx: p.x,\n\t\t\t\t\ty: p.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Q\": {\n\t\t\t\tconst p1 = transformPoint(cmd.x1, cmd.y1);\n\t\t\t\tconst p = transformPoint(cmd.x, cmd.y);\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\tx1: p1.x,\n\t\t\t\t\ty1: p1.y,\n\t\t\t\t\tx: p.x,\n\t\t\t\t\ty: p.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\tconst p1 = transformPoint(cmd.x1, cmd.y1);\n\t\t\t\tconst p2 = transformPoint(cmd.x2, cmd.y2);\n\t\t\t\tconst p = transformPoint(cmd.x, cmd.y);\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: p1.x,\n\t\t\t\t\ty1: p1.y,\n\t\t\t\t\tx2: p2.x,\n\t\t\t\t\ty2: p2.y,\n\t\t\t\t\tx: p.x,\n\t\t\t\t\ty: p.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tcommands.push({ type: \"Z\" });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Update bounds\n\tconst bounds = computeBounds(commands);\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Apply horizontal scaling (condensing/expanding) to a path\n *\n * @param path - The glyph path to transform\n * @param factor - Horizontal scale factor (< 1 = narrower, > 1 = wider)\n * @returns New path with horizontal scaling applied\n *\n * Transform: x' = x * factor, y' = y\n */\nexport function condensePath(path: GlyphPath, factor: number): GlyphPath {\n\tconst commands: PathCommand[] = [];\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: cmd.type,\n\t\t\t\t\tx: cmd.x * factor,\n\t\t\t\t\ty: cmd.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"Q\":\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"Q\",\n\t\t\t\t\tx1: cmd.x1 * factor,\n\t\t\t\t\ty1: cmd.y1,\n\t\t\t\t\tx: cmd.x * factor,\n\t\t\t\t\ty: cmd.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"C\",\n\t\t\t\t\tx1: cmd.x1 * factor,\n\t\t\t\t\ty1: cmd.y1,\n\t\t\t\t\tx2: cmd.x2 * factor,\n\t\t\t\t\ty2: cmd.y2,\n\t\t\t\t\tx: cmd.x * factor,\n\t\t\t\t\ty: cmd.y,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"Z\":\n\t\t\t\tcommands.push({ type: \"Z\" });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Update bounds\n\tlet bounds = path.bounds;\n\tif (bounds) {\n\t\tbounds = {\n\t\t\txMin: bounds.xMin * factor,\n\t\t\tyMin: bounds.yMin,\n\t\t\txMax: bounds.xMax * factor,\n\t\t\tyMax: bounds.yMax,\n\t\t};\n\t}\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Embolden (make bolder) a path by offsetting the outline\n *\n * This implementation uses a simplified approach that offsets each contour\n * outward by moving points along the normal direction. For production use,\n * a proper stroking algorithm would be more accurate.\n *\n * @param path - The glyph path to embolden\n * @param strength - Offset strength in font units (positive = bolder, negative = thinner)\n * @returns New path with emboldening applied\n */\nexport function emboldenPath(path: GlyphPath, strength: number): GlyphPath {\n\tif (strength === 0) {\n\t\t// Just return a copy with slightly processed structure\n\t\treturn { ...path, commands: [...path.commands] };\n\t}\n\n\tif (strength > 0) {\n\t\t// Approximate FT_Outline_Embolden by offsetting contours outward.\n\t\t// Outer contours expand; holes shrink.\n\t\tconst { outer } = strokeAsymmetric(path, {\n\t\t\txBorder: strength,\n\t\t\tyBorder: strength,\n\t\t\teps: 0.25,\n\t\t\tlineJoin: \"round\",\n\t\t});\n\t\treturn {\n\t\t\tcommands: outer.commands,\n\t\t\tbounds: outer.bounds ?? computeBounds(outer.commands),\n\t\t\tflags: path.flags,\n\t\t};\n\t}\n\n\t// Extract contours from path\n\tconst contours = extractContours(path);\n\tconst commands: PathCommand[] = [];\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tif (contour.length < 3) continue;\n\n\t\t// Offset the contour\n\t\tconst offsetContour = offsetPolygon(contour, strength);\n\n\t\t// Convert back to commands\n\t\tif (offsetContour.length > 0) {\n\t\t\tcommands.push({\n\t\t\t\ttype: \"M\",\n\t\t\t\tx: offsetContour[0].x,\n\t\t\t\ty: offsetContour[0].y,\n\t\t\t});\n\t\t\tfor (let j = 1; j < offsetContour.length; j++) {\n\t\t\t\tcommands.push({\n\t\t\t\t\ttype: \"L\",\n\t\t\t\t\tx: offsetContour[j].x,\n\t\t\t\t\ty: offsetContour[j].y,\n\t\t\t\t});\n\t\t\t}\n\t\t\tcommands.push({ type: \"Z\" });\n\t\t}\n\t}\n\n\t// Calculate new bounds\n\tlet bounds = null;\n\tif (commands.length > 0) {\n\t\tlet minX = Infinity,\n\t\t\tminY = Infinity,\n\t\t\tmaxX = -Infinity,\n\t\t\tmaxY = -Infinity;\n\n\t\tfor (let i = 0; i < commands.length; i++) {\n\t\t\tconst cmd = commands[i]!;\n\t\t\tif (cmd.type === \"M\" || cmd.type === \"L\") {\n\t\t\t\tminX = Math.min(minX, cmd.x);\n\t\t\t\tminY = Math.min(minY, cmd.y);\n\t\t\t\tmaxX = Math.max(maxX, cmd.x);\n\t\t\t\tmaxY = Math.max(maxY, cmd.y);\n\t\t\t}\n\t\t}\n\n\t\tif (Number.isFinite(minX)) {\n\t\t\tbounds = { xMin: minX, yMin: minY, xMax: maxX, yMax: maxY };\n\t\t}\n\t}\n\n\treturn { commands, bounds, flags: path.flags };\n}\n\n/**\n * Point structure for contour processing\n */\ninterface Point {\n\tx: number;\n\ty: number;\n}\n\n/**\n * Extract contours from a path as arrays of points\n */\nfunction extractContours(path: GlyphPath): Point[][] {\n\tconst contours: Point[][] = [];\n\tlet currentContour: Point[] = [];\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\tif (currentContour.length > 0) {\n\t\t\t\t\tcontours.push(currentContour);\n\t\t\t\t}\n\t\t\t\tcurrentContour = [{ x: cmd.x, y: cmd.y }];\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tcurrentContour.push({ x: cmd.x, y: cmd.y });\n\t\t\t\tbreak;\n\t\t\tcase \"Q\": {\n\t\t\t\t// Flatten quadratic bezier\n\t\t\t\tconst last = currentContour[currentContour.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tconst steps = 8;\n\t\t\t\t\tfor (let j = 1; j <= steps; j++) {\n\t\t\t\t\t\tconst t = j / steps;\n\t\t\t\t\t\tconst ti = 1 - t;\n\t\t\t\t\t\tconst x = ti * ti * last.x + 2 * ti * t * cmd.x1 + t * t * cmd.x;\n\t\t\t\t\t\tconst y = ti * ti * last.y + 2 * ti * t * cmd.y1 + t * t * cmd.y;\n\t\t\t\t\t\tcurrentContour.push({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"C\": {\n\t\t\t\t// Flatten cubic bezier\n\t\t\t\tconst last = currentContour[currentContour.length - 1];\n\t\t\t\tif (last) {\n\t\t\t\t\tconst steps = 12;\n\t\t\t\t\tfor (let j = 1; j <= steps; j++) {\n\t\t\t\t\t\tconst t = j / steps;\n\t\t\t\t\t\tconst ti = 1 - t;\n\t\t\t\t\t\tconst x =\n\t\t\t\t\t\t\tti * ti * ti * last.x +\n\t\t\t\t\t\t\t3 * ti * ti * t * cmd.x1 +\n\t\t\t\t\t\t\t3 * ti * t * t * cmd.x2 +\n\t\t\t\t\t\t\tt * t * t * cmd.x;\n\t\t\t\t\t\tconst y =\n\t\t\t\t\t\t\tti * ti * ti * last.y +\n\t\t\t\t\t\t\t3 * ti * ti * t * cmd.y1 +\n\t\t\t\t\t\t\t3 * ti * t * t * cmd.y2 +\n\t\t\t\t\t\t\tt * t * t * cmd.y;\n\t\t\t\t\t\tcurrentContour.push({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Z\":\n\t\t\t\tif (currentContour.length > 0) {\n\t\t\t\t\tcontours.push(currentContour);\n\t\t\t\t\tcurrentContour = [];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (currentContour.length > 0) {\n\t\tcontours.push(currentContour);\n\t}\n\n\treturn contours;\n}\n\n/**\n * Offset a polygon (contour) by a given distance\n *\n * This uses a simple approach of moving each point along the average\n * normal of its adjacent edges. For better quality, a proper polygon\n * offsetting algorithm should be used (e.g., Clipper library approach).\n */\nfunction offsetPolygon(points: Point[], offset: number): Point[] {\n\tconst n = points.length;\n\tif (n < 3) return points;\n\n\t// Determine winding order (clockwise or counter-clockwise)\n\tlet area = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tconst j = (i + 1) % n;\n\t\tconst p1 = points[i];\n\t\tconst p2 = points[j];\n\t\tif (p1 && p2) {\n\t\t\tarea += (p2.x - p1.x) * (p2.y + p1.y);\n\t\t}\n\t}\n\n\t// For counter-clockwise (positive area), positive offset expands\n\t// For clockwise (negative area), we need to flip the offset\n\tconst sign = area < 0 ? -1 : 1;\n\tconst actualOffset = offset * sign;\n\n\tconst result: Point[] = [];\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst prev = points[(i - 1 + n) % n];\n\t\tconst curr = points[i];\n\t\tconst next = points[(i + 1) % n];\n\n\t\tif (!prev || !curr || !next) continue;\n\n\t\t// Compute edge vectors\n\t\tconst edge1 = { x: curr.x - prev.x, y: curr.y - prev.y };\n\t\tconst edge2 = { x: next.x - curr.x, y: next.y - curr.y };\n\n\t\t// Normalize edges\n\t\tconst len1 = Math.sqrt(edge1.x * edge1.x + edge1.y * edge1.y);\n\t\tconst len2 = Math.sqrt(edge2.x * edge2.x + edge2.y * edge2.y);\n\n\t\tif (len1 === 0 || len2 === 0) {\n\t\t\tresult.push(curr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tedge1.x /= len1;\n\t\tedge1.y /= len1;\n\t\tedge2.x /= len2;\n\t\tedge2.y /= len2;\n\n\t\t// Compute normals (perpendicular, pointing outward for CCW)\n\t\tconst normal1 = { x: -edge1.y, y: edge1.x };\n\t\tconst normal2 = { x: -edge2.y, y: edge2.x };\n\n\t\t// Average normal\n\t\tlet normalX = (normal1.x + normal2.x) / 2;\n\t\tlet normalY = (normal1.y + normal2.y) / 2;\n\n\t\t// Normalize the average normal\n\t\tconst normalLen = Math.sqrt(normalX * normalX + normalY * normalY);\n\t\tif (normalLen > 0.001) {\n\t\t\tnormalX /= normalLen;\n\t\t\tnormalY /= normalLen;\n\n\t\t\t// Compute the offset scaling factor based on the angle\n\t\t\t// For sharp angles, we need to extend the offset\n\t\t\tconst dot = normal1.x * normal2.x + normal1.y * normal2.y;\n\t\t\tconst scale = dot > -0.999 ? 1 / Math.sqrt((1 + dot) / 2) : 1;\n\n\t\t\t// Limit the scale to prevent extreme offsets at very sharp angles\n\t\t\tconst limitedScale = Math.min(scale, 3);\n\n\t\t\tresult.push({\n\t\t\t\tx: curr.x + normalX * actualOffset * limitedScale,\n\t\t\t\ty: curr.y + normalY * actualOffset * limitedScale,\n\t\t\t});\n\t\t} else {\n\t\t\tresult.push(curr);\n\t\t}\n\t}\n\n\treturn result;\n}\n",
    "/**\n * Texture atlas generator for GPU font rendering\n *\n * Packs multiple glyph bitmaps into a single texture atlas\n * using shelf/skyline bin packing algorithm.\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport { rasterizeGlyph } from \"./rasterize.ts\";\nimport {\n\ttype AtlasOptions,\n\ttype Bitmap,\n\tcreateBitmap,\n\ttype GlyphAtlas,\n\ttype GlyphMetrics,\n\tPixelMode,\n} from \"./types.ts\";\nimport { resolveFontScale } from \"./size.ts\";\n\n/**\n * Shelf packing node\n */\ninterface Shelf {\n\ty: number;\n\theight: number;\n\twidth: number;\n}\n\n/**\n * Build a texture atlas from a set of glyphs\n */\nexport function buildAtlas(\n\tfont: Font,\n\tglyphIds: number[],\n\toptions: AtlasOptions,\n): GlyphAtlas {\n\tconst {\n\t\tfontSize,\n\t\tsizeMode,\n\t\tpadding = 1,\n\t\tmaxWidth = 2048,\n\t\tmaxHeight = 2048,\n\t\tpixelMode = PixelMode.Gray,\n\t} = options;\n\n\t// First pass: rasterize all glyphs and collect sizes\n\tconst glyphData: Array<{\n\t\tglyphId: number;\n\t\tbitmap: Bitmap;\n\t\tbearingX: number;\n\t\tbearingY: number;\n\t\tadvance: number;\n\t}> = [];\n\n\tconst scale = resolveFontScale(font, fontSize, sizeMode);\n\n\tfor (let i = 0; i < glyphIds.length; i++) {\n\t\tconst glyphId = glyphIds[i]!;\n\t\tconst result = rasterizeGlyph(font, glyphId, fontSize, {\n\t\t\tpadding: 0,\n\t\t\tpixelMode,\n\t\t\tsizeMode,\n\t\t});\n\t\tif (!result) continue;\n\n\t\tconst advance = font.advanceWidth(glyphId) * scale;\n\n\t\tglyphData.push({\n\t\t\tglyphId,\n\t\t\tbitmap: result.bitmap,\n\t\t\tbearingX: result.bearingX,\n\t\t\tbearingY: result.bearingY,\n\t\t\tadvance,\n\t\t});\n\t}\n\n\t// Sort by height (descending) for better packing\n\tglyphData.sort((a, b) => b.bitmap.rows - a.bitmap.rows);\n\n\t// Calculate required atlas size\n\tconst {\n\t\twidth: atlasWidth,\n\t\theight: atlasHeight,\n\t\tplacements,\n\t} = packGlyphs(\n\t\tglyphData.map((g) => ({\n\t\t\twidth: g.bitmap.width + padding * 2,\n\t\t\theight: g.bitmap.rows + padding * 2,\n\t\t})),\n\t\tmaxWidth,\n\t\tmaxHeight,\n\t);\n\n\t// Create atlas bitmap\n\tconst atlas = createBitmap(atlasWidth, atlasHeight, pixelMode);\n\n\t// Copy glyphs into atlas and build metrics map\n\tconst glyphMetrics = new Map<number, GlyphMetrics>();\n\n\tfor (let i = 0; i < glyphData.length; i++) {\n\t\tconst glyph = glyphData[i];\n\t\tconst placement = placements[i];\n\n\t\tif (!placement.placed) continue;\n\n\t\t// Copy glyph bitmap into atlas\n\t\tcopyBitmap(\n\t\t\tglyph.bitmap,\n\t\t\tatlas,\n\t\t\tplacement.x + padding,\n\t\t\tplacement.y + padding,\n\t\t);\n\n\t\t// Store metrics\n\t\tglyphMetrics.set(glyph.glyphId, {\n\t\t\tglyphId: glyph.glyphId,\n\t\t\tatlasX: placement.x + padding,\n\t\t\tatlasY: placement.y + padding,\n\t\t\twidth: glyph.bitmap.width,\n\t\t\theight: glyph.bitmap.rows,\n\t\t\tbearingX: glyph.bearingX,\n\t\t\tbearingY: glyph.bearingY,\n\t\t\tadvance: glyph.advance,\n\t\t});\n\t}\n\n\treturn {\n\t\tbitmap: atlas,\n\t\tglyphs: glyphMetrics,\n\t\tfontSize,\n\t};\n}\n\n/**\n * Build atlas for ASCII printable characters (32-126)\n */\nexport function buildAsciiAtlas(font: Font, options: AtlasOptions): GlyphAtlas {\n\tconst glyphIds: number[] = [];\n\n\tfor (let codepoint = 32; codepoint <= 126; codepoint++) {\n\t\tconst glyphId = font.glyphId(codepoint);\n\t\tif (glyphId !== undefined && glyphId !== 0) {\n\t\t\tglyphIds.push(glyphId);\n\t\t}\n\t}\n\n\treturn buildAtlas(font, glyphIds, options);\n}\n\n/**\n * Build atlas for a specific string (including all unique glyphs)\n */\nexport function buildStringAtlas(\n\tfont: Font,\n\ttext: string,\n\toptions: AtlasOptions,\n): GlyphAtlas {\n\tconst glyphIdSet = new Set<number>();\n\n\tconst textArray = [...text];\n\tfor (let i = 0; i < textArray.length; i++) {\n\t\tconst char = textArray[i]!;\n\t\tconst codepoint = char.codePointAt(0);\n\t\tif (codepoint === undefined) continue;\n\n\t\tconst glyphId = font.glyphId(codepoint);\n\t\tif (glyphId !== undefined && glyphId !== 0) {\n\t\t\tglyphIdSet.add(glyphId);\n\t\t}\n\t}\n\n\treturn buildAtlas(font, [...glyphIdSet], options);\n}\n\n/**\n * Placement result for a glyph\n */\ninterface Placement {\n\tx: number;\n\ty: number;\n\tplaced: boolean;\n}\n\n/**\n * Pack rectangles using shelf algorithm\n */\nfunction packGlyphs(\n\tsizes: Array<{ width: number; height: number }>,\n\tmaxWidth: number,\n\tmaxHeight: number,\n): { width: number; height: number; placements: Placement[] } {\n\tconst shelves: Shelf[] = [];\n\tconst placements: Placement[] = [];\n\n\tlet atlasWidth = 0;\n\tlet atlasHeight = 0;\n\n\tfor (let i = 0; i < sizes.length; i++) {\n\t\tconst size = sizes[i]!;\n\t\tlet placed = false;\n\t\tlet bestShelf = -1;\n\t\tlet bestY = maxHeight;\n\n\t\t// Try to find an existing shelf\n\t\tfor (let j = 0; j < shelves.length; j++) {\n\t\t\tconst shelf = shelves[j]!;\n\n\t\t\t// Check if glyph fits in this shelf\n\t\t\tif (shelf.width + size.width <= maxWidth && size.height <= shelf.height) {\n\t\t\t\tif (shelf.y < bestY) {\n\t\t\t\t\tbestShelf = j;\n\t\t\t\t\tbestY = shelf.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bestShelf >= 0) {\n\t\t\t// Place in existing shelf\n\t\t\tconst shelf = shelves[bestShelf]!;\n\t\t\tplacements.push({\n\t\t\t\tx: shelf.width,\n\t\t\t\ty: shelf.y,\n\t\t\t\tplaced: true,\n\t\t\t});\n\t\t\tshelf.width += size.width;\n\t\t\tatlasWidth = Math.max(atlasWidth, shelf.width);\n\t\t\tplaced = true;\n\t\t} else {\n\t\t\t// Create new shelf\n\t\t\tconst newY = atlasHeight;\n\n\t\t\tif (newY + size.height <= maxHeight && size.width <= maxWidth) {\n\t\t\t\tshelves.push({\n\t\t\t\t\ty: newY,\n\t\t\t\t\theight: size.height,\n\t\t\t\t\twidth: size.width,\n\t\t\t\t});\n\t\t\t\tplacements.push({\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: newY,\n\t\t\t\t\tplaced: true,\n\t\t\t\t});\n\t\t\t\tatlasHeight = newY + size.height;\n\t\t\t\tatlasWidth = Math.max(atlasWidth, size.width);\n\t\t\t\tplaced = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!placed) {\n\t\t\tplacements.push({ x: 0, y: 0, placed: false });\n\t\t}\n\t}\n\n\t// Round up to power of 2 for GPU compatibility\n\tconst finalWidth = nextPowerOf2(atlasWidth);\n\tconst finalHeight = nextPowerOf2(atlasHeight);\n\n\treturn {\n\t\twidth: Math.min(finalWidth, maxWidth),\n\t\theight: Math.min(finalHeight, maxHeight),\n\t\tplacements,\n\t};\n}\n\n/**\n * Copy source bitmap into destination at specified position\n */\nfunction copyBitmap(\n\tsrc: Bitmap,\n\tdst: Bitmap,\n\tdstX: number,\n\tdstY: number,\n): void {\n\tconst bytesPerPixel = src.pixelMode === PixelMode.LCD ? 3 : 1;\n\n\tfor (let y = 0; y < src.rows; y++) {\n\t\tconst srcRow = y * src.pitch;\n\t\tconst dstRow = (dstY + y) * dst.pitch + dstX * bytesPerPixel;\n\n\t\tfor (let x = 0; x < src.width * bytesPerPixel; x++) {\n\t\t\tdst.buffer[dstRow + x] = src.buffer[srcRow + x];\n\t\t}\n\t}\n}\n\n/**\n * Get next power of 2 >= n\n */\nfunction nextPowerOf2(n: number): number {\n\tif (n <= 0) return 1;\n\tn--;\n\tn |= n >> 1;\n\tn |= n >> 2;\n\tn |= n >> 4;\n\tn |= n >> 8;\n\tn |= n >> 16;\n\treturn n + 1;\n}\n\n/**\n * Export atlas to formats suitable for GPU upload\n */\nexport function atlasToRGBA(atlas: GlyphAtlas): Uint8Array {\n\tconst { bitmap } = atlas;\n\tconst rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tconst srcIdx = y * bitmap.pitch + x;\n\t\t\tconst dstIdx = (y * bitmap.width + x) * 4;\n\n\t\t\tconst alpha = bitmap.buffer[srcIdx] ?? 0;\n\n\t\t\t// White text on transparent background\n\t\t\trgba[dstIdx] = 255;\n\t\t\trgba[dstIdx + 1] = 255;\n\t\t\trgba[dstIdx + 2] = 255;\n\t\t\trgba[dstIdx + 3] = alpha;\n\t\t}\n\t}\n\n\treturn rgba;\n}\n\n/**\n * Export atlas as single-channel alpha texture\n */\nexport function atlasToAlpha(atlas: GlyphAtlas): Uint8Array {\n\tconst { bitmap } = atlas;\n\n\tif (bitmap.pitch === bitmap.width) {\n\t\treturn bitmap.buffer;\n\t}\n\n\t// Copy without padding\n\tconst alpha = new Uint8Array(bitmap.width * bitmap.rows);\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\talpha[y * bitmap.width + x] = bitmap.buffer[y * bitmap.pitch + x];\n\t\t}\n\t}\n\n\treturn alpha;\n}\n\n/**\n * Get UV coordinates for a glyph in the atlas\n */\nexport function getGlyphUV(\n\tatlas: GlyphAtlas,\n\tglyphId: number,\n): { u0: number; v0: number; u1: number; v1: number } | null {\n\tconst metrics = atlas.glyphs.get(glyphId);\n\tif (!metrics) return null;\n\n\tconst { bitmap } = atlas;\n\n\treturn {\n\t\tu0: metrics.atlasX / bitmap.width,\n\t\tv0: metrics.atlasY / bitmap.rows,\n\t\tu1: (metrics.atlasX + metrics.width) / bitmap.width,\n\t\tv1: (metrics.atlasY + metrics.height) / bitmap.rows,\n\t};\n}\n",
    "/**\n * Multi-channel Signed Distance Field (MSDF) rasterizer\n *\n * MSDF uses three channels (RGB) to encode distance information,\n * allowing sharp corners to be preserved when scaling.\n *\n * Algorithm:\n * 1. Decompose glyph outline into edges (lines, quadratics, cubics)\n * 2. Color edges so adjacent edges at sharp corners have different colors\n * 3. For each pixel, compute signed distance to nearest edge of each color\n * 4. Store R, G, B distances in output bitmap\n * 5. Shader reconstructs using: median(r, g, b)\n *\n * Reference: https://github.com/Chlumsky/msdfgen\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport type { GlyphPath } from \"../render/path.ts\";\nimport { getGlyphPath } from \"../render/path.ts\";\nimport {\n\ttype Bitmap,\n\tcreateBitmap,\n\ttype GlyphAtlas,\n\ttype GlyphMetrics,\n\ttype MsdfAtlasOptions,\n\tPixelMode,\n} from \"./types.ts\";\nimport { resolveFontScale } from \"./size.ts\";\n\n/**\n * A 2D point\n */\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\n/**\n * Edge color channels for MSDF\n * 0 = red, 1 = green, 2 = blue\n */\nexport type EdgeColor = 0 | 1 | 2;\n\n/**\n * Bounding box for edge culling\n */\ninterface EdgeBounds {\n\tminX: number;\n\tmaxX: number;\n\tminY: number;\n\tmaxY: number;\n}\n\n/**\n * An edge with color assignment and bounding box\n */\nexport type MsdfEdge =\n\t| ({ type: \"line\"; p0: Point; p1: Point; color: EdgeColor } & EdgeBounds)\n\t| ({\n\t\t\ttype: \"quadratic\";\n\t\t\tp0: Point;\n\t\t\tp1: Point;\n\t\t\tp2: Point;\n\t\t\tcolor: EdgeColor;\n\t  } & EdgeBounds)\n\t| ({\n\t\t\ttype: \"cubic\";\n\t\t\tp0: Point;\n\t\t\tp1: Point;\n\t\t\tp2: Point;\n\t\t\tp3: Point;\n\t\t\tcolor: EdgeColor;\n\t  } & EdgeBounds);\n\n/**\n * Signed distance result with parameter t\n */\nexport interface SignedDistanceResult {\n\tdistance: number;\n\tt: number; // Parameter on curve [0, 1] of closest point\n}\n\n/**\n * Options for MSDF rendering\n */\nexport interface MsdfOptions {\n\t/** Width in pixels */\n\twidth: number;\n\t/** Height in pixels */\n\theight: number;\n\t/** Scale factor (font units to pixels) */\n\tscale: number;\n\t/** X offset in pixels */\n\toffsetX?: number;\n\t/** Y offset in pixels */\n\toffsetY?: number;\n\t/** Flip Y axis (font coords are Y-up, bitmap is Y-down) */\n\tflipY?: boolean;\n\t/** Spread/radius - how far the distance field extends in pixels (default: 8) */\n\tspread?: number;\n}\n\n/**\n * Return the median of three numbers\n */\nexport function median(a: number, b: number, c: number): number {\n\treturn Math.max(Math.min(a, b), Math.min(Math.max(a, b), c));\n}\n\n/**\n * Compute signed distance from point to line segment\n */\nexport function signedDistanceToLine(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n): SignedDistanceResult {\n\tconst dx = p1.x - p0.x;\n\tconst dy = p1.y - p0.y;\n\tconst lenSq = dx * dx + dy * dy;\n\n\tif (lenSq < 1e-10) {\n\t\t// Degenerate segment\n\t\tconst dist = Math.sqrt((px - p0.x) ** 2 + (py - p0.y) ** 2);\n\t\treturn { distance: dist, t: 0 };\n\t}\n\n\t// Project point onto line\n\tlet t = ((px - p0.x) * dx + (py - p0.y) * dy) / lenSq;\n\tt = Math.max(0, Math.min(1, t));\n\n\t// Unsigned distance\n\tconst dist = Math.sqrt((px - p0.x - t * dx) ** 2 + (py - p0.y - t * dy) ** 2);\n\n\t// Sign: use cross product to determine which side of line\n\t// Cross product: (p1 - p0) x (point - p0) = dx * (py - p0.y) - dy * (px - p0.x)\n\tconst cross = dx * (py - p0.y) - dy * (px - p0.x);\n\tconst sign = cross >= 0 ? 1 : -1;\n\n\treturn { distance: sign * dist, t };\n}\n\n/**\n * Compute unsigned distance from point to line segment (faster version)\n */\nfunction unsignedDistanceToLine(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n): number {\n\tconst dx = p1.x - p0.x;\n\tconst dy = p1.y - p0.y;\n\tconst lenSq = dx * dx + dy * dy;\n\tif (lenSq < 1e-10) return Math.sqrt((px - p0.x) ** 2 + (py - p0.y) ** 2);\n\tlet t = ((px - p0.x) * dx + (py - p0.y) * dy) / lenSq;\n\tt = Math.max(0, Math.min(1, t));\n\treturn Math.sqrt((px - p0.x - t * dx) ** 2 + (py - p0.y - t * dy) ** 2);\n}\n\n/**\n * Compute signed distance from point to quadratic bezier curve\n * Uses Newton-Raphson iteration to find closest point\n */\nexport function signedDistanceToQuadratic(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n): SignedDistanceResult {\n\t// Quadratic bezier: B(t) = (1-t)P0 + 2(1-t)tP1 + tP2\n\t// We need to find t that minimizes |B(t) - P|\n\n\t// Coefficients for the quadratic bezier\n\tconst ax = p0.x - 2 * p1.x + p2.x;\n\tconst ay = p0.y - 2 * p1.y + p2.y;\n\n\tlet minDist = Math.min(\n\t\tMath.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2),\n\t\tMath.sqrt((p2.x - px) ** 2 + (p2.y - py) ** 2),\n\t);\n\tlet minT = minDist === Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2) ? 0 : 1;\n\n\t// Sample and refine with Newton-Raphson (reduced samples and iterations)\n\tfor (let i = 1; i < 6; i++) {\n\t\tlet t = i / 6;\n\n\t\t// Newton-Raphson iterations\n\t\tfor (let iter = 0; iter < 3; iter++) {\n\t\t\tconst ti = 1 - t;\n\n\t\t\t// B(t)\n\t\t\tconst bx_t = ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x;\n\t\t\tconst by_t = ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y;\n\n\t\t\t// B'(t) = 2(1-t)(P1-P0) + 2t(P2-P1) = 2((1-t)(P1-P0) + t(P2-P1))\n\t\t\tconst dx = 2 * (ti * (p1.x - p0.x) + t * (p2.x - p1.x));\n\t\t\tconst dy = 2 * (ti * (p1.y - p0.y) + t * (p2.y - p1.y));\n\n\t\t\t// f(t) = (B(t) - P)  B'(t)\n\t\t\tconst vx = bx_t - px;\n\t\t\tconst vy = by_t - py;\n\t\t\tconst f = vx * dx + vy * dy;\n\n\t\t\t// f'(t) = B'(t)  B'(t) + (B(t) - P)  B''(t)\n\t\t\tconst df = dx * dx + dy * dy + vx * 2 * ax + vy * 2 * ay;\n\n\t\t\tif (Math.abs(df) < 1e-10) break;\n\n\t\t\tt = Math.max(0, Math.min(1, t - f / df));\n\t\t}\n\n\t\t// Evaluate distance at this t\n\t\tconst ti = 1 - t;\n\t\tconst bx_t = ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x;\n\t\tconst by_t = ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y;\n\t\tconst dist = Math.sqrt((bx_t - px) ** 2 + (by_t - py) ** 2);\n\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tminT = t;\n\t\t}\n\t}\n\n\t// Compute sign using the tangent at closest point\n\tconst ti = 1 - minT;\n\tconst tangentX = 2 * (ti * (p1.x - p0.x) + minT * (p2.x - p1.x));\n\tconst tangentY = 2 * (ti * (p1.y - p0.y) + minT * (p2.y - p1.y));\n\n\tconst bx_t = ti * ti * p0.x + 2 * ti * minT * p1.x + minT * minT * p2.x;\n\tconst by_t = ti * ti * p0.y + 2 * ti * minT * p1.y + minT * minT * p2.y;\n\n\t// Cross product of tangent and (point - curve)\n\tconst cross = tangentX * (py - by_t) - tangentY * (px - bx_t);\n\tconst minSign = cross >= 0 ? 1 : -1;\n\n\treturn { distance: minSign * minDist, t: minT };\n}\n\n/**\n * Compute unsigned distance from point to quadratic bezier curve (faster version)\n */\nfunction unsignedDistanceToQuadratic(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n): number {\n\tconst ax = p0.x - 2 * p1.x + p2.x;\n\tconst ay = p0.y - 2 * p1.y + p2.y;\n\n\tlet minDist = Math.min(\n\t\tMath.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2),\n\t\tMath.sqrt((p2.x - px) ** 2 + (p2.y - py) ** 2),\n\t);\n\n\tfor (let i = 1; i < 6; i++) {\n\t\tlet t = i / 6;\n\t\tfor (let iter = 0; iter < 3; iter++) {\n\t\t\tconst ti = 1 - t;\n\t\t\tconst bx = ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x;\n\t\t\tconst by = ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y;\n\t\t\tconst dx = 2 * (ti * (p1.x - p0.x) + t * (p2.x - p1.x));\n\t\t\tconst dy = 2 * (ti * (p1.y - p0.y) + t * (p2.y - p1.y));\n\t\t\tconst vx = bx - px;\n\t\t\tconst vy = by - py;\n\t\t\tconst df = dx * dx + dy * dy + vx * 2 * ax + vy * 2 * ay;\n\t\t\tif (Math.abs(df) < 1e-10) break;\n\t\t\tt = Math.max(0, Math.min(1, t - (vx * dx + vy * dy) / df));\n\t\t}\n\t\tconst ti = 1 - t;\n\t\tconst dist = Math.sqrt(\n\t\t\t(ti * ti * p0.x + 2 * ti * t * p1.x + t * t * p2.x - px) ** 2 +\n\t\t\t\t(ti * ti * p0.y + 2 * ti * t * p1.y + t * t * p2.y - py) ** 2,\n\t\t);\n\t\tif (dist < minDist) minDist = dist;\n\t}\n\treturn minDist;\n}\n\n/**\n * Compute signed distance from point to cubic bezier curve\n * Uses Newton-Raphson iteration with multiple starting points\n */\nexport function signedDistanceToCubic(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n\tp3: Point,\n): SignedDistanceResult {\n\t// Cubic bezier: B(t) = (1-t)P0 + 3(1-t)tP1 + 3(1-t)tP2 + tP3\n\n\tlet minDist = Math.min(\n\t\tMath.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2),\n\t\tMath.sqrt((p3.x - px) ** 2 + (p3.y - py) ** 2),\n\t);\n\tlet minT = minDist === Math.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2) ? 0 : 1;\n\n\t// Sample and refine with Newton-Raphson (reduced samples and iterations)\n\tfor (let i = 1; i < 6; i++) {\n\t\tlet t = i / 6;\n\n\t\t// Newton-Raphson iterations\n\t\tfor (let iter = 0; iter < 3; iter++) {\n\t\t\tconst ti = 1 - t;\n\t\t\tconst ti2 = ti * ti;\n\t\t\tconst ti3 = ti2 * ti;\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\n\t\t\t// B(t)\n\t\t\tconst bx_t =\n\t\t\t\tti3 * p0.x + 3 * ti2 * t * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x;\n\t\t\tconst by_t =\n\t\t\t\tti3 * p0.y + 3 * ti2 * t * p1.y + 3 * ti * t2 * p2.y + t3 * p3.y;\n\n\t\t\t// B'(t) = 3(1-t)(P1-P0) + 6(1-t)t(P2-P1) + 3t(P3-P2)\n\t\t\tconst dx =\n\t\t\t\t3 * ti2 * (p1.x - p0.x) +\n\t\t\t\t6 * ti * t * (p2.x - p1.x) +\n\t\t\t\t3 * t2 * (p3.x - p2.x);\n\t\t\tconst dy =\n\t\t\t\t3 * ti2 * (p1.y - p0.y) +\n\t\t\t\t6 * ti * t * (p2.y - p1.y) +\n\t\t\t\t3 * t2 * (p3.y - p2.y);\n\n\t\t\t// B''(t) = 6(1-t)(P2-2P1+P0) + 6t(P3-2P2+P1)\n\t\t\tconst ddx =\n\t\t\t\t6 * ti * (p2.x - 2 * p1.x + p0.x) + 6 * t * (p3.x - 2 * p2.x + p1.x);\n\t\t\tconst ddy =\n\t\t\t\t6 * ti * (p2.y - 2 * p1.y + p0.y) + 6 * t * (p3.y - 2 * p2.y + p1.y);\n\n\t\t\t// f(t) = (B(t) - P)  B'(t)\n\t\t\tconst vx = bx_t - px;\n\t\t\tconst vy = by_t - py;\n\t\t\tconst f = vx * dx + vy * dy;\n\n\t\t\t// f'(t) = B'(t)  B'(t) + (B(t) - P)  B''(t)\n\t\t\tconst df = dx * dx + dy * dy + vx * ddx + vy * ddy;\n\n\t\t\tif (Math.abs(df) < 1e-10) break;\n\n\t\t\tt = Math.max(0, Math.min(1, t - f / df));\n\t\t}\n\n\t\t// Evaluate distance at this t\n\t\tconst ti = 1 - t;\n\t\tconst ti2 = ti * ti;\n\t\tconst ti3 = ti2 * ti;\n\t\tconst t2 = t * t;\n\t\tconst t3 = t2 * t;\n\n\t\tconst bx_t =\n\t\t\tti3 * p0.x + 3 * ti2 * t * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x;\n\t\tconst by_t =\n\t\t\tti3 * p0.y + 3 * ti2 * t * p1.y + 3 * ti * t2 * p2.y + t3 * p3.y;\n\t\tconst dist = Math.sqrt((bx_t - px) ** 2 + (by_t - py) ** 2);\n\n\t\tif (dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tminT = t;\n\t\t}\n\t}\n\n\t// Compute sign using the tangent at closest point\n\tconst ti = 1 - minT;\n\tconst ti2 = ti * ti;\n\tconst t2 = minT * minT;\n\n\tconst tangentX =\n\t\t3 * ti2 * (p1.x - p0.x) +\n\t\t6 * ti * minT * (p2.x - p1.x) +\n\t\t3 * t2 * (p3.x - p2.x);\n\tconst tangentY =\n\t\t3 * ti2 * (p1.y - p0.y) +\n\t\t6 * ti * minT * (p2.y - p1.y) +\n\t\t3 * t2 * (p3.y - p2.y);\n\n\tconst ti3 = ti2 * ti;\n\tconst t3 = t2 * minT;\n\tconst bx_t =\n\t\tti3 * p0.x + 3 * ti2 * minT * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x;\n\tconst by_t =\n\t\tti3 * p0.y + 3 * ti2 * minT * p1.y + 3 * ti * t2 * p2.y + t3 * p3.y;\n\n\t// Cross product of tangent and (point - curve)\n\tconst cross = tangentX * (py - by_t) - tangentY * (px - bx_t);\n\tconst minSign = cross >= 0 ? 1 : -1;\n\n\treturn { distance: minSign * minDist, t: minT };\n}\n\n/**\n * Compute unsigned distance from point to cubic bezier curve (faster version)\n */\nfunction unsignedDistanceToCubic(\n\tpx: number,\n\tpy: number,\n\tp0: Point,\n\tp1: Point,\n\tp2: Point,\n\tp3: Point,\n): number {\n\tlet minDist = Math.min(\n\t\tMath.sqrt((p0.x - px) ** 2 + (p0.y - py) ** 2),\n\t\tMath.sqrt((p3.x - px) ** 2 + (p3.y - py) ** 2),\n\t);\n\n\tfor (let i = 1; i < 6; i++) {\n\t\tlet t = i / 6;\n\t\tfor (let iter = 0; iter < 3; iter++) {\n\t\t\tconst ti = 1 - t;\n\t\t\tconst ti2 = ti * ti;\n\t\t\tconst ti3 = ti2 * ti;\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\tconst bx =\n\t\t\t\tti3 * p0.x + 3 * ti2 * t * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x;\n\t\t\tconst by =\n\t\t\t\tti3 * p0.y + 3 * ti2 * t * p1.y + 3 * ti * t2 * p2.y + t3 * p3.y;\n\t\t\tconst dx =\n\t\t\t\t3 * ti2 * (p1.x - p0.x) +\n\t\t\t\t6 * ti * t * (p2.x - p1.x) +\n\t\t\t\t3 * t2 * (p3.x - p2.x);\n\t\t\tconst dy =\n\t\t\t\t3 * ti2 * (p1.y - p0.y) +\n\t\t\t\t6 * ti * t * (p2.y - p1.y) +\n\t\t\t\t3 * t2 * (p3.y - p2.y);\n\t\t\tconst ddx =\n\t\t\t\t6 * ti * (p2.x - 2 * p1.x + p0.x) + 6 * t * (p3.x - 2 * p2.x + p1.x);\n\t\t\tconst ddy =\n\t\t\t\t6 * ti * (p2.y - 2 * p1.y + p0.y) + 6 * t * (p3.y - 2 * p2.y + p1.y);\n\t\t\tconst vx = bx - px;\n\t\t\tconst vy = by - py;\n\t\t\tconst df = dx * dx + dy * dy + vx * ddx + vy * ddy;\n\t\t\tif (Math.abs(df) < 1e-10) break;\n\t\t\tt = Math.max(0, Math.min(1, t - (vx * dx + vy * dy) / df));\n\t\t}\n\t\tconst ti = 1 - t;\n\t\tconst ti2 = ti * ti;\n\t\tconst ti3 = ti2 * ti;\n\t\tconst t2 = t * t;\n\t\tconst t3 = t2 * t;\n\t\tconst dist = Math.sqrt(\n\t\t\t(ti3 * p0.x + 3 * ti2 * t * p1.x + 3 * ti * t2 * p2.x + t3 * p3.x - px) **\n\t\t\t\t2 +\n\t\t\t\t(ti3 * p0.y +\n\t\t\t\t\t3 * ti2 * t * p1.y +\n\t\t\t\t\t3 * ti * t2 * p2.y +\n\t\t\t\t\tt3 * p3.y -\n\t\t\t\t\tpy) **\n\t\t\t\t\t2,\n\t\t);\n\t\tif (dist < minDist) minDist = dist;\n\t}\n\treturn minDist;\n}\n\n/**\n * Get the direction vector at the start of an edge\n */\nfunction getEdgeStartDirection(edge: MsdfEdge): Point {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn { x: edge.p1.x - edge.p0.x, y: edge.p1.y - edge.p0.y };\n\t\tcase \"quadratic\":\n\t\t\t// Tangent at t=0: 2(P1 - P0)\n\t\t\treturn { x: 2 * (edge.p1.x - edge.p0.x), y: 2 * (edge.p1.y - edge.p0.y) };\n\t\tcase \"cubic\":\n\t\t\t// Tangent at t=0: 3(P1 - P0)\n\t\t\treturn { x: 3 * (edge.p1.x - edge.p0.x), y: 3 * (edge.p1.y - edge.p0.y) };\n\t}\n}\n\n/**\n * Get the direction vector at the end of an edge\n */\nfunction getEdgeEndDirection(edge: MsdfEdge): Point {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn { x: edge.p1.x - edge.p0.x, y: edge.p1.y - edge.p0.y };\n\t\tcase \"quadratic\":\n\t\t\t// Tangent at t=1: 2(P2 - P1)\n\t\t\treturn { x: 2 * (edge.p2.x - edge.p1.x), y: 2 * (edge.p2.y - edge.p1.y) };\n\t\tcase \"cubic\":\n\t\t\t// Tangent at t=1: 3(P3 - P2)\n\t\t\treturn { x: 3 * (edge.p3.x - edge.p2.x), y: 3 * (edge.p3.y - edge.p2.y) };\n\t}\n}\n\n/**\n * Normalize a vector\n */\nfunction normalize(v: Point): Point {\n\tconst len = Math.sqrt(v.x * v.x + v.y * v.y);\n\tif (len < 1e-10) return { x: 0, y: 0 };\n\treturn { x: v.x / len, y: v.y / len };\n}\n\n/**\n * Dot product\n */\nfunction dot(a: Point, b: Point): number {\n\treturn a.x * b.x + a.y * b.y;\n}\n\n/**\n * Check if the angle between two vectors is sharp (< threshold)\n */\nfunction isSharpCorner(\n\tdir1: Point,\n\tdir2: Point,\n\tthreshold = Math.PI / 3,\n): boolean {\n\tconst n1 = normalize(dir1);\n\tconst n2 = normalize(dir2);\n\tconst cosAngle = dot(n1, n2);\n\t// Angle between directions\n\tconst angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));\n\t// If directions are similar (angle near 0 or PI), it's smooth\n\t// If they're different, it's sharp\n\treturn angle > threshold && angle < Math.PI - threshold;\n}\n\n/**\n * Assign colors to edges based on corner angles\n * At sharp corners, adjacent edges get different colors\n */\nexport function assignEdgeColors(contours: MsdfEdge[][]): void {\n\tconst CORNER_THRESHOLD = Math.PI / 4; // 45 degrees\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tif (contour.length === 0) continue;\n\n\t\tif (contour.length === 1) {\n\t\t\t// Single edge gets any color\n\t\t\tcontour[0]!.color = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Start with color 0\n\t\tlet currentColor: EdgeColor = 0;\n\n\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\tconst edge = contour[j]!;\n\t\t\tconst prevEdge = contour[(j - 1 + contour.length) % contour.length]!;\n\n\t\t\tif (j === 0) {\n\t\t\t\t// First edge starts with color 0\n\t\t\t\tedge.color = currentColor;\n\t\t\t} else {\n\t\t\t\t// Check angle between previous edge's end and this edge's start\n\t\t\t\tconst prevDir = getEdgeEndDirection(prevEdge);\n\t\t\t\tconst currDir = getEdgeStartDirection(edge);\n\n\t\t\t\tif (isSharpCorner(prevDir, currDir, CORNER_THRESHOLD)) {\n\t\t\t\t\t// Sharp corner - switch to different color\n\t\t\t\t\tcurrentColor = ((currentColor + 1) % 3) as EdgeColor;\n\t\t\t\t}\n\n\t\t\t\tedge.color = currentColor;\n\t\t\t}\n\t\t}\n\n\t\t// Check if last-to-first transition needs different colors\n\t\tif (contour.length >= 2) {\n\t\t\tconst lastEdge = contour[contour.length - 1]!;\n\t\t\tconst firstEdge = contour[0]!;\n\n\t\t\tconst lastDir = getEdgeEndDirection(lastEdge);\n\t\t\tconst firstDir = getEdgeStartDirection(firstEdge);\n\n\t\t\tif (isSharpCorner(lastDir, firstDir, CORNER_THRESHOLD)) {\n\t\t\t\t// Need different colors at this corner\n\t\t\t\tif (lastEdge.color === firstEdge.color) {\n\t\t\t\t\t// Reassign colors to ensure difference\n\t\t\t\t\t// Try to find a color different from both neighbors\n\t\t\t\t\tconst prevColor = contour[contour.length - 2]?.color ?? 0;\n\t\t\t\t\tconst _nextColor = contour[1]?.color ?? 0;\n\n\t\t\t\t\t// Find a color different from prevColor for lastEdge\n\t\t\t\t\tfor (let c = 0; c < 3; c++) {\n\t\t\t\t\t\tif (c !== firstEdge.color && c !== prevColor) {\n\t\t\t\t\t\t\tlastEdge.color = c as EdgeColor;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extract edges from path commands\n */\nfunction extractEdges(\n\tpath: GlyphPath,\n\tscale: number,\n\toffsetX: number,\n\toffsetY: number,\n\tflipY: boolean,\n): MsdfEdge[][] {\n\tconst contours: MsdfEdge[][] = [];\n\tlet currentContour: MsdfEdge[] = [];\n\tlet currentPoint: Point | null = null;\n\tlet firstPoint: Point | null = null;\n\n\tconst transform = (x: number, y: number): Point => ({\n\t\tx: x * scale + offsetX,\n\t\ty: flipY ? -(y * scale) + offsetY : y * scale + offsetY,\n\t});\n\n\tfor (let i = 0; i < path.commands.length; i++) {\n\t\tconst cmd = path.commands[i]!;\n\t\tswitch (cmd.type) {\n\t\t\tcase \"M\":\n\t\t\t\t// Start new contour\n\t\t\t\tif (currentContour.length > 0) {\n\t\t\t\t\tcontours.push(currentContour);\n\t\t\t\t\tcurrentContour = [];\n\t\t\t\t}\n\t\t\t\tcurrentPoint = transform(cmd.x, cmd.y);\n\t\t\t\tfirstPoint = currentPoint;\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tif (currentPoint) {\n\t\t\t\t\tconst p1 = transform(cmd.x, cmd.y);\n\t\t\t\t\t// Skip degenerate edges\n\t\t\t\t\tif (\n\t\t\t\t\t\tMath.abs(p1.x - currentPoint.x) > 1e-6 ||\n\t\t\t\t\t\tMath.abs(p1.y - currentPoint.y) > 1e-6\n\t\t\t\t\t) {\n\t\t\t\t\t\tcurrentContour.push({\n\t\t\t\t\t\t\ttype: \"line\",\n\t\t\t\t\t\t\tp0: currentPoint,\n\t\t\t\t\t\t\tp1,\n\t\t\t\t\t\t\tcolor: 0,\n\t\t\t\t\t\t\tminX: Math.min(currentPoint.x, p1.x),\n\t\t\t\t\t\t\tmaxX: Math.max(currentPoint.x, p1.x),\n\t\t\t\t\t\t\tminY: Math.min(currentPoint.y, p1.y),\n\t\t\t\t\t\t\tmaxY: Math.max(currentPoint.y, p1.y),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcurrentPoint = p1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Q\":\n\t\t\t\tif (currentPoint) {\n\t\t\t\t\tconst p1 = transform(cmd.x1, cmd.y1);\n\t\t\t\t\tconst p2 = transform(cmd.x, cmd.y);\n\t\t\t\t\tcurrentContour.push({\n\t\t\t\t\t\ttype: \"quadratic\",\n\t\t\t\t\t\tp0: currentPoint,\n\t\t\t\t\t\tp1,\n\t\t\t\t\t\tp2,\n\t\t\t\t\t\tcolor: 0,\n\t\t\t\t\t\tminX: Math.min(currentPoint.x, p1.x, p2.x),\n\t\t\t\t\t\tmaxX: Math.max(currentPoint.x, p1.x, p2.x),\n\t\t\t\t\t\tminY: Math.min(currentPoint.y, p1.y, p2.y),\n\t\t\t\t\t\tmaxY: Math.max(currentPoint.y, p1.y, p2.y),\n\t\t\t\t\t});\n\t\t\t\t\tcurrentPoint = p2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"C\":\n\t\t\t\tif (currentPoint) {\n\t\t\t\t\tconst p1 = transform(cmd.x1, cmd.y1);\n\t\t\t\t\tconst p2 = transform(cmd.x2, cmd.y2);\n\t\t\t\t\tconst p3 = transform(cmd.x, cmd.y);\n\t\t\t\t\tcurrentContour.push({\n\t\t\t\t\t\ttype: \"cubic\",\n\t\t\t\t\t\tp0: currentPoint,\n\t\t\t\t\t\tp1,\n\t\t\t\t\t\tp2,\n\t\t\t\t\t\tp3,\n\t\t\t\t\t\tcolor: 0,\n\t\t\t\t\t\tminX: Math.min(currentPoint.x, p1.x, p2.x, p3.x),\n\t\t\t\t\t\tmaxX: Math.max(currentPoint.x, p1.x, p2.x, p3.x),\n\t\t\t\t\t\tminY: Math.min(currentPoint.y, p1.y, p2.y, p3.y),\n\t\t\t\t\t\tmaxY: Math.max(currentPoint.y, p1.y, p2.y, p3.y),\n\t\t\t\t\t});\n\t\t\t\t\tcurrentPoint = p3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Z\":\n\t\t\t\tif (currentPoint && firstPoint) {\n\t\t\t\t\t// Close with line if needed\n\t\t\t\t\tif (\n\t\t\t\t\t\tMath.abs(currentPoint.x - firstPoint.x) > 1e-6 ||\n\t\t\t\t\t\tMath.abs(currentPoint.y - firstPoint.y) > 1e-6\n\t\t\t\t\t) {\n\t\t\t\t\t\tcurrentContour.push({\n\t\t\t\t\t\t\ttype: \"line\",\n\t\t\t\t\t\t\tp0: currentPoint,\n\t\t\t\t\t\t\tp1: firstPoint,\n\t\t\t\t\t\t\tcolor: 0,\n\t\t\t\t\t\t\tminX: Math.min(currentPoint.x, firstPoint.x),\n\t\t\t\t\t\t\tmaxX: Math.max(currentPoint.x, firstPoint.x),\n\t\t\t\t\t\t\tminY: Math.min(currentPoint.y, firstPoint.y),\n\t\t\t\t\t\t\tmaxY: Math.max(currentPoint.y, firstPoint.y),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcurrentPoint = firstPoint;\n\t\t\t\t}\n\t\t\t\tif (currentContour.length > 0) {\n\t\t\t\t\tcontours.push(currentContour);\n\t\t\t\t\tcurrentContour = [];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Push any remaining contour\n\tif (currentContour.length > 0) {\n\t\tcontours.push(currentContour);\n\t}\n\n\treturn contours;\n}\n\n/**\n * Compute signed distance from point to edge\n */\nexport function signedDistanceToEdge(\n\tpx: number,\n\tpy: number,\n\tedge: MsdfEdge,\n): SignedDistanceResult {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn signedDistanceToLine(px, py, edge.p0, edge.p1);\n\t\tcase \"quadratic\":\n\t\t\treturn signedDistanceToQuadratic(px, py, edge.p0, edge.p1, edge.p2);\n\t\tcase \"cubic\":\n\t\t\treturn signedDistanceToCubic(px, py, edge.p0, edge.p1, edge.p2, edge.p3);\n\t}\n}\n\n/**\n * Compute unsigned distance from point to edge (faster version for rendering)\n */\nfunction unsignedDistanceToEdge(\n\tpx: number,\n\tpy: number,\n\tedge: MsdfEdge,\n): number {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn unsignedDistanceToLine(px, py, edge.p0, edge.p1);\n\t\tcase \"quadratic\":\n\t\t\treturn unsignedDistanceToQuadratic(px, py, edge.p0, edge.p1, edge.p2);\n\t\tcase \"cubic\":\n\t\t\treturn unsignedDistanceToCubic(\n\t\t\t\tpx,\n\t\t\t\tpy,\n\t\t\t\tedge.p0,\n\t\t\t\tedge.p1,\n\t\t\t\tedge.p2,\n\t\t\t\tedge.p3,\n\t\t\t);\n\t}\n}\n\n/**\n * Pre-flattened contour segments for fast inside testing\n */\ntype FlatSegment = [Point, Point];\n\n/**\n * Pre-flatten contours once for reuse in inside testing\n */\nfunction preFlattenContours(contours: MsdfEdge[][]): FlatSegment[][] {\n\tconst result: FlatSegment[][] = [];\n\tfor (let ci = 0; ci < contours.length; ci++) {\n\t\tconst contour = contours[ci];\n\t\tconst segments: FlatSegment[] = [];\n\t\tfor (let ei = 0; ei < contour.length; ei++) {\n\t\t\tconst edge = contour[ei];\n\t\t\tif (edge.type === \"line\") {\n\t\t\t\tsegments.push([edge.p0, edge.p1]);\n\t\t\t} else if (edge.type === \"quadratic\") {\n\t\t\t\tlet prev = edge.p0;\n\t\t\t\tfor (let i = 1; i <= 4; i++) {\n\t\t\t\t\tconst t = i / 4;\n\t\t\t\t\tconst ti = 1 - t;\n\t\t\t\t\tconst p = {\n\t\t\t\t\t\tx: ti * ti * edge.p0.x + 2 * ti * t * edge.p1.x + t * t * edge.p2.x,\n\t\t\t\t\t\ty: ti * ti * edge.p0.y + 2 * ti * t * edge.p1.y + t * t * edge.p2.y,\n\t\t\t\t\t};\n\t\t\t\t\tsegments.push([prev, p]);\n\t\t\t\t\tprev = p;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet prev = edge.p0;\n\t\t\t\tfor (let i = 1; i <= 4; i++) {\n\t\t\t\t\tconst t = i / 4;\n\t\t\t\t\tconst ti = 1 - t;\n\t\t\t\t\tconst ti2 = ti * ti;\n\t\t\t\t\tconst ti3 = ti2 * ti;\n\t\t\t\t\tconst t2 = t * t;\n\t\t\t\t\tconst t3 = t2 * t;\n\t\t\t\t\tconst p = {\n\t\t\t\t\t\tx:\n\t\t\t\t\t\t\tti3 * edge.p0.x +\n\t\t\t\t\t\t\t3 * ti2 * t * edge.p1.x +\n\t\t\t\t\t\t\t3 * ti * t2 * edge.p2.x +\n\t\t\t\t\t\t\tt3 * edge.p3.x,\n\t\t\t\t\t\ty:\n\t\t\t\t\t\t\tti3 * edge.p0.y +\n\t\t\t\t\t\t\t3 * ti2 * t * edge.p1.y +\n\t\t\t\t\t\t\t3 * ti * t2 * edge.p2.y +\n\t\t\t\t\t\t\tt3 * edge.p3.y,\n\t\t\t\t\t};\n\t\t\t\t\tsegments.push([prev, p]);\n\t\t\t\t\tprev = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult.push(segments);\n\t}\n\treturn result;\n}\n\n/**\n * Determine if a point is inside using pre-flattened contours (fast version)\n */\nfunction isPointInsideFast(\n\tpx: number,\n\tpy: number,\n\tflatContours: FlatSegment[][],\n): boolean {\n\tlet crossings = 0;\n\tfor (let i = 0; i < flatContours.length; i++) {\n\t\tconst segments = flatContours[i];\n\t\tfor (let j = 0; j < segments.length; j++) {\n\t\t\tconst [p0, p1] = segments[j];\n\t\t\tif (p0.y > py !== p1.y > py) {\n\t\t\t\tconst x = p0.x + ((p1.x - p0.x) * (py - p0.y)) / (p1.y - p0.y);\n\t\t\t\tif (px < x) crossings++;\n\t\t\t}\n\t\t}\n\t}\n\treturn (crossings & 1) === 1;\n}\n\n/**\n * Find minimum unsigned distance to edges with bounding box culling and early exit\n */\nfunction findMinDistance(px: number, py: number, edges: MsdfEdge[]): number {\n\tlet minDist = Infinity;\n\tfor (let i = 0; i < edges.length; i++) {\n\t\tconst edge = edges[i];\n\t\t// Bounding box culling - compute distance to bbox\n\t\tconst dx =\n\t\t\tpx < edge.minX ? edge.minX - px : px > edge.maxX ? px - edge.maxX : 0;\n\t\tconst dy =\n\t\t\tpy < edge.minY ? edge.minY - py : py > edge.maxY ? py - edge.maxY : 0;\n\t\tif (dx * dx + dy * dy >= minDist * minDist) continue;\n\n\t\tconst d = unsignedDistanceToEdge(px, py, edge);\n\t\tif (d < minDist) {\n\t\t\tminDist = d;\n\t\t\tif (d < 0.5) break; // Early exit for very close points\n\t\t}\n\t}\n\treturn minDist;\n}\n\n/**\n * Determine if a point is inside using ray casting (even-odd rule)\n */\nexport function isPointInside(\n\tpx: number,\n\tpy: number,\n\tcontours: MsdfEdge[][],\n): boolean {\n\tlet crossings = 0;\n\n\tfor (let i = 0; i < contours.length; i++) {\n\t\tconst contour = contours[i]!;\n\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\tconst edge = contour[j]!;\n\t\t\t// Flatten curves to line segments for inside test\n\t\t\tconst points = flattenEdge(edge);\n\n\t\t\tfor (let k = 0; k < points.length - 1; k++) {\n\t\t\t\tconst p0 = points[k]!;\n\t\t\t\tconst p1 = points[k + 1]!;\n\n\t\t\t\t// Ray casting: horizontal ray to the right\n\t\t\t\tif (p0.y > py !== p1.y > py) {\n\t\t\t\t\tconst slope = (p1.x - p0.x) / (p1.y - p0.y);\n\t\t\t\t\tconst x = p0.x + slope * (py - p0.y);\n\n\t\t\t\t\tif (px < x) {\n\t\t\t\t\t\tcrossings++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (crossings & 1) === 1;\n}\n\n/**\n * Flatten an edge to points for inside testing\n */\nexport function flattenEdge(edge: MsdfEdge): Point[] {\n\tswitch (edge.type) {\n\t\tcase \"line\":\n\t\t\treturn [edge.p0, edge.p1];\n\n\t\tcase \"quadratic\": {\n\t\t\tconst points: Point[] = [edge.p0];\n\t\t\tconst samples = 8;\n\t\t\tfor (let i = 1; i <= samples; i++) {\n\t\t\t\tconst t = i / samples;\n\t\t\t\tconst ti = 1 - t;\n\t\t\t\tpoints.push({\n\t\t\t\t\tx: ti * ti * edge.p0.x + 2 * ti * t * edge.p1.x + t * t * edge.p2.x,\n\t\t\t\t\ty: ti * ti * edge.p0.y + 2 * ti * t * edge.p1.y + t * t * edge.p2.y,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn points;\n\t\t}\n\n\t\tcase \"cubic\": {\n\t\t\tconst points: Point[] = [edge.p0];\n\t\t\tconst samples = 8;\n\t\t\tfor (let i = 1; i <= samples; i++) {\n\t\t\t\tconst t = i / samples;\n\t\t\t\tconst ti = 1 - t;\n\t\t\t\tconst ti2 = ti * ti;\n\t\t\t\tconst ti3 = ti2 * ti;\n\t\t\t\tconst t2 = t * t;\n\t\t\t\tconst t3 = t2 * t;\n\t\t\t\tpoints.push({\n\t\t\t\t\tx:\n\t\t\t\t\t\tti3 * edge.p0.x +\n\t\t\t\t\t\t3 * ti2 * t * edge.p1.x +\n\t\t\t\t\t\t3 * ti * t2 * edge.p2.x +\n\t\t\t\t\t\tt3 * edge.p3.x,\n\t\t\t\t\ty:\n\t\t\t\t\t\tti3 * edge.p0.y +\n\t\t\t\t\t\t3 * ti2 * t * edge.p1.y +\n\t\t\t\t\t\t3 * ti * t2 * edge.p2.y +\n\t\t\t\t\t\tt3 * edge.p3.y,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn points;\n\t\t}\n\t}\n}\n\n/**\n * Render a glyph path as a multi-channel signed distance field\n */\nexport function renderMsdf(path: GlyphPath, options: MsdfOptions): Bitmap {\n\tconst {\n\t\twidth,\n\t\theight,\n\t\tscale,\n\t\toffsetX = 0,\n\t\toffsetY = 0,\n\t\tflipY = false,\n\t\tspread = 8,\n\t} = options;\n\n\t// Create RGB bitmap (3 bytes per pixel)\n\tconst bitmap = createBitmap(width, height, PixelMode.LCD);\n\n\t// Extract and color edges\n\tconst contours = extractEdges(path, scale, offsetX, offsetY, flipY);\n\n\t// If no edges, fill with minimum distance\n\tif (contours.length === 0 || contours.every((c) => c.length === 0)) {\n\t\tbitmap.buffer.fill(0);\n\t\treturn bitmap;\n\t}\n\n\t// Assign colors to edges\n\tassignEdgeColors(contours);\n\n\t// Pre-flatten contours once for fast inside testing\n\tconst flatContours = preFlattenContours(contours);\n\n\t// Flatten all edges for quick access\n\tconst allEdges: MsdfEdge[] = contours.flat();\n\n\t// Group edges by color\n\tconst redEdges = allEdges.filter((e) => e.color === 0);\n\tconst greenEdges = allEdges.filter((e) => e.color === 1);\n\tconst blueEdges = allEdges.filter((e) => e.color === 2);\n\n\t// If any color has no edges, duplicate from another\n\tconst rEdges = redEdges.length > 0 ? redEdges : allEdges;\n\tconst gEdges = greenEdges.length > 0 ? greenEdges : allEdges;\n\tconst bEdges = blueEdges.length > 0 ? blueEdges : allEdges;\n\n\t// For each pixel\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tconst px = x + 0.5;\n\t\t\tconst py = y + 0.5;\n\n\t\t\t// Find minimum distance to each color channel with bbox culling\n\t\t\tconst minR = findMinDistance(px, py, rEdges);\n\t\t\tconst minG = findMinDistance(px, py, gEdges);\n\t\t\tconst minB = findMinDistance(px, py, bEdges);\n\n\t\t\t// Determine inside/outside using pre-flattened contours\n\t\t\tconst inside = isPointInsideFast(px, py, flatContours);\n\n\t\t\t// Correct signs based on inside/outside\n\t\t\t// All distances should be positive inside, negative outside\n\t\t\tconst signCorrection = inside ? 1 : -1;\n\t\t\tconst rDist = minR * signCorrection;\n\t\t\tconst gDist = minG * signCorrection;\n\t\t\tconst bDist = minB * signCorrection;\n\n\t\t\t// Encode to 0-255\n\t\t\tconst encode = (d: number): number => {\n\t\t\t\tconst normalized = 128 + (d / spread) * 127;\n\t\t\t\treturn Math.max(0, Math.min(255, Math.round(normalized)));\n\t\t\t};\n\n\t\t\tconst idx = y * bitmap.pitch + x * 3;\n\t\t\tbitmap.buffer[idx] = encode(rDist);\n\t\t\tbitmap.buffer[idx + 1] = encode(gDist);\n\t\t\tbitmap.buffer[idx + 2] = encode(bDist);\n\t\t}\n\t}\n\n\treturn bitmap;\n}\n\n/**\n * Shelf packing node for atlas building\n */\ninterface Shelf {\n\ty: number;\n\theight: number;\n\twidth: number;\n}\n\n/**\n * Placement result for a glyph\n */\ninterface Placement {\n\tx: number;\n\ty: number;\n\tplaced: boolean;\n}\n\n/**\n * Pack rectangles using shelf algorithm\n */\nfunction packGlyphs(\n\tsizes: Array<{ width: number; height: number }>,\n\tmaxWidth: number,\n\tmaxHeight: number,\n): { width: number; height: number; placements: Placement[] } {\n\tconst shelves: Shelf[] = [];\n\tconst placements: Placement[] = [];\n\n\tlet atlasWidth = 0;\n\tlet atlasHeight = 0;\n\n\tfor (let i = 0; i < sizes.length; i++) {\n\t\tconst size = sizes[i]!;\n\t\tlet placed = false;\n\t\tlet bestShelf = -1;\n\t\tlet bestY = maxHeight;\n\n\t\t// Try to find an existing shelf\n\t\tfor (let j = 0; j < shelves.length; j++) {\n\t\t\tconst shelf = shelves[j]!;\n\n\t\t\t// Check if glyph fits in this shelf\n\t\t\tif (shelf.width + size.width <= maxWidth && size.height <= shelf.height) {\n\t\t\t\tif (shelf.y < bestY) {\n\t\t\t\t\tbestShelf = j;\n\t\t\t\t\tbestY = shelf.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bestShelf >= 0) {\n\t\t\t// Place in existing shelf\n\t\t\tconst shelf = shelves[bestShelf]!;\n\t\t\tplacements.push({\n\t\t\t\tx: shelf.width,\n\t\t\t\ty: shelf.y,\n\t\t\t\tplaced: true,\n\t\t\t});\n\t\t\tshelf.width += size.width;\n\t\t\tatlasWidth = Math.max(atlasWidth, shelf.width);\n\t\t\tplaced = true;\n\t\t} else {\n\t\t\t// Create new shelf\n\t\t\tconst newY = atlasHeight;\n\n\t\t\tif (newY + size.height <= maxHeight && size.width <= maxWidth) {\n\t\t\t\tshelves.push({\n\t\t\t\t\ty: newY,\n\t\t\t\t\theight: size.height,\n\t\t\t\t\twidth: size.width,\n\t\t\t\t});\n\t\t\t\tplacements.push({\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: newY,\n\t\t\t\t\tplaced: true,\n\t\t\t\t});\n\t\t\t\tatlasHeight = newY + size.height;\n\t\t\t\tatlasWidth = Math.max(atlasWidth, size.width);\n\t\t\t\tplaced = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!placed) {\n\t\t\tplacements.push({ x: 0, y: 0, placed: false });\n\t\t}\n\t}\n\n\t// Round up to power of 2 for GPU compatibility\n\tconst finalWidth = nextPowerOf2(atlasWidth);\n\tconst finalHeight = nextPowerOf2(atlasHeight);\n\n\treturn {\n\t\twidth: Math.min(finalWidth, maxWidth),\n\t\theight: Math.min(finalHeight, maxHeight),\n\t\tplacements,\n\t};\n}\n\n/**\n * Get next power of 2 >= n\n */\nfunction nextPowerOf2(n: number): number {\n\tif (n <= 0) return 1;\n\tn--;\n\tn |= n >> 1;\n\tn |= n >> 2;\n\tn |= n >> 4;\n\tn |= n >> 8;\n\tn |= n >> 16;\n\treturn n + 1;\n}\n\n/**\n * Copy source bitmap into destination at specified position\n */\nfunction copyBitmapRgb(\n\tsrc: Bitmap,\n\tdst: Bitmap,\n\tdstX: number,\n\tdstY: number,\n): void {\n\tfor (let y = 0; y < src.rows; y++) {\n\t\tconst srcRow = y * src.pitch;\n\t\tconst dstRow = (dstY + y) * dst.pitch + dstX * 3;\n\n\t\tfor (let x = 0; x < src.width * 3; x++) {\n\t\t\tdst.buffer[dstRow + x] = src.buffer[srcRow + x];\n\t\t}\n\t}\n}\n\n/**\n * Build an MSDF texture atlas from a set of glyphs\n */\nexport function buildMsdfAtlas(\n\tfont: Font,\n\tglyphIds: number[],\n\toptions: MsdfAtlasOptions,\n): GlyphAtlas {\n\tconst {\n\t\tfontSize,\n\t\tsizeMode,\n\t\tpadding = 2,\n\t\tmaxWidth = 2048,\n\t\tmaxHeight = 2048,\n\t\tspread = 4,\n\t} = options;\n\n\tconst scale = resolveFontScale(font, fontSize, sizeMode);\n\n\t// First pass: render all MSDF glyphs and collect sizes\n\tconst glyphData: Array<{\n\t\tglyphId: number;\n\t\tbitmap: Bitmap;\n\t\tbearingX: number;\n\t\tbearingY: number;\n\t\tadvance: number;\n\t}> = [];\n\n\tfor (let i = 0; i < glyphIds.length; i++) {\n\t\tconst glyphId = glyphIds[i]!;\n\t\tconst path = getGlyphPath(font, glyphId);\n\t\tif (!path || !path.bounds) continue;\n\n\t\tconst bounds = path.bounds;\n\n\t\t// Calculate bitmap size with spread padding\n\t\tconst glyphWidth =\n\t\t\tMath.ceil((bounds.xMax - bounds.xMin) * scale) + spread * 2;\n\t\tconst glyphHeight =\n\t\t\tMath.ceil((bounds.yMax - bounds.yMin) * scale) + spread * 2;\n\n\t\tif (glyphWidth <= 0 || glyphHeight <= 0) continue;\n\n\t\t// Render MSDF\n\t\tconst bitmap = renderMsdf(path, {\n\t\t\twidth: glyphWidth,\n\t\t\theight: glyphHeight,\n\t\t\tscale,\n\t\t\toffsetX: -bounds.xMin * scale + spread,\n\t\t\toffsetY: bounds.yMax * scale + spread,\n\t\t\tflipY: true,\n\t\t\tspread,\n\t\t});\n\n\t\tconst advance = font.advanceWidth(glyphId) * scale;\n\t\tconst bearingX = bounds.xMin * scale - spread;\n\t\tconst bearingY = bounds.yMax * scale + spread;\n\n\t\tglyphData.push({\n\t\t\tglyphId,\n\t\t\tbitmap,\n\t\t\tbearingX,\n\t\t\tbearingY,\n\t\t\tadvance,\n\t\t});\n\t}\n\n\t// Sort by height (descending) for better packing\n\tglyphData.sort((a, b) => b.bitmap.rows - a.bitmap.rows);\n\n\t// Calculate required atlas size\n\tconst {\n\t\twidth: atlasWidth,\n\t\theight: atlasHeight,\n\t\tplacements,\n\t} = packGlyphs(\n\t\tglyphData.map((g) => ({\n\t\t\twidth: g.bitmap.width + padding * 2,\n\t\t\theight: g.bitmap.rows + padding * 2,\n\t\t})),\n\t\tmaxWidth,\n\t\tmaxHeight,\n\t);\n\n\t// Create atlas bitmap (RGB for MSDF)\n\tconst atlas = createBitmap(atlasWidth, atlasHeight, PixelMode.LCD);\n\n\t// Copy glyphs into atlas and build metrics map\n\tconst glyphMetrics = new Map<number, GlyphMetrics>();\n\n\tfor (let i = 0; i < glyphData.length; i++) {\n\t\tconst glyph = glyphData[i];\n\t\tconst placement = placements[i];\n\n\t\tif (!placement.placed) continue;\n\n\t\t// Copy glyph bitmap into atlas\n\t\tcopyBitmapRgb(\n\t\t\tglyph.bitmap,\n\t\t\tatlas,\n\t\t\tplacement.x + padding,\n\t\t\tplacement.y + padding,\n\t\t);\n\n\t\t// Store metrics\n\t\tglyphMetrics.set(glyph.glyphId, {\n\t\t\tglyphId: glyph.glyphId,\n\t\t\tatlasX: placement.x + padding,\n\t\t\tatlasY: placement.y + padding,\n\t\t\twidth: glyph.bitmap.width,\n\t\t\theight: glyph.bitmap.rows,\n\t\t\tbearingX: glyph.bearingX,\n\t\t\tbearingY: glyph.bearingY,\n\t\t\tadvance: glyph.advance,\n\t\t});\n\t}\n\n\treturn {\n\t\tbitmap: atlas,\n\t\tglyphs: glyphMetrics,\n\t\tfontSize,\n\t};\n}\n\n/**\n * Build MSDF atlas for ASCII printable characters (32-126)\n */\nexport function buildMsdfAsciiAtlas(\n\tfont: Font,\n\toptions: MsdfAtlasOptions,\n): GlyphAtlas {\n\tconst glyphIds: number[] = [];\n\n\tfor (let codepoint = 32; codepoint <= 126; codepoint++) {\n\t\tconst glyphId = font.glyphId(codepoint);\n\t\tif (glyphId !== undefined && glyphId !== 0) {\n\t\t\tglyphIds.push(glyphId);\n\t\t}\n\t}\n\n\treturn buildMsdfAtlas(font, glyphIds, options);\n}\n\n/**\n * Build MSDF atlas for a specific string (including all unique glyphs)\n */\nexport function buildMsdfStringAtlas(\n\tfont: Font,\n\ttext: string,\n\toptions: MsdfAtlasOptions,\n): GlyphAtlas {\n\tconst glyphIdSet = new Set<number>();\n\n\tconst textArray = Array.from(text);\n\tfor (let i = 0; i < textArray.length; i++) {\n\t\tconst char = textArray[i]!;\n\t\tconst codepoint = char.codePointAt(0);\n\t\tif (codepoint === undefined) continue;\n\n\t\tconst glyphId = font.glyphId(codepoint);\n\t\tif (glyphId !== undefined && glyphId !== 0) {\n\t\t\tglyphIdSet.add(glyphId);\n\t\t}\n\t}\n\n\treturn buildMsdfAtlas(font, [...glyphIdSet], options);\n}\n\n/**\n * Export MSDF atlas as RGB texture data\n */\nexport function msdfAtlasToRGB(atlas: GlyphAtlas): Uint8Array {\n\tconst { bitmap } = atlas;\n\n\tif (bitmap.pitch === bitmap.width * 3) {\n\t\treturn bitmap.buffer;\n\t}\n\n\t// Copy without row padding\n\tconst rgb = new Uint8Array(bitmap.width * bitmap.rows * 3);\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width * 3; x++) {\n\t\t\trgb[y * bitmap.width * 3 + x] = bitmap.buffer[y * bitmap.pitch + x];\n\t\t}\n\t}\n\n\treturn rgb;\n}\n\n/**\n * Export MSDF atlas as RGBA texture data\n */\nexport function msdfAtlasToRGBA(atlas: GlyphAtlas): Uint8Array {\n\tconst { bitmap } = atlas;\n\tconst rgba = new Uint8Array(bitmap.width * bitmap.rows * 4);\n\n\tfor (let y = 0; y < bitmap.rows; y++) {\n\t\tfor (let x = 0; x < bitmap.width; x++) {\n\t\t\tconst srcIdx = y * bitmap.pitch + x * 3;\n\t\t\tconst dstIdx = (y * bitmap.width + x) * 4;\n\n\t\t\trgba[dstIdx] = bitmap.buffer[srcIdx];\n\t\t\trgba[dstIdx + 1] = bitmap.buffer[srcIdx + 1];\n\t\t\trgba[dstIdx + 2] = bitmap.buffer[srcIdx + 2];\n\t\t\trgba[dstIdx + 3] = 255; // Full alpha\n\t\t}\n\t}\n\n\treturn rgba;\n}\n",
    "/**\n * Cascade Blur Algorithm\n *\n * High-performance Gaussian blur for large radii using pyramid scaling.\n *\n * The key insight: to blur with large radius efficiently:\n * 1. Scale down the image by factor of 2 (with smooth kernel)\n * 2. Apply blur with smaller kernel on reduced image\n * 3. Scale back up (with smooth kernel)\n *\n * The shrink/expand kernels [1, 5, 10, 10, 5, 1]/32 provide sufficient\n * smoothness to maintain 8-bit precision through multiple cascade levels.\n *\n * Performance: O(n) per pixel regardless of blur radius\n * Traditional Gaussian: O(r) per pixel where r is radius\n */\n\nimport { gaussianBlur } from \"./blur.ts\";\nimport { type Bitmap, PixelMode } from \"./types.ts\";\n\nconst PI = Math.PI;\n\n/**\n * Blur method parameters\n */\ninterface BlurMethod {\n\tlevel: number; // Number of cascade levels (shrink/expand)\n\tradius: number; // Blur kernel radius (4-8)\n\tcoeff: Float32Array; // Kernel coefficients\n}\n\n/**\n * Calculate Gaussian distribution values\n */\nfunction calcGauss(res: Float64Array, n: number, r2: number): void {\n\tconst alpha = 0.5 / r2;\n\tlet mul = Math.exp(-alpha);\n\tconst mul2 = mul * mul;\n\tlet cur = Math.sqrt(alpha / PI);\n\n\tres[0] = cur;\n\tcur *= mul;\n\tres[1] = cur;\n\tfor (let i = 2; i < n; i++) {\n\t\tmul *= mul2;\n\t\tcur *= mul;\n\t\tres[i] = cur;\n\t}\n}\n\n/**\n * Apply coefficient filter (for frequency domain calculations)\n */\nfunction coeffFilter(coeff: Float64Array, n: number, kernel: number[]): void {\n\tlet prev1 = coeff[1];\n\tlet prev2 = coeff[2];\n\tlet prev3 = coeff[3];\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst res =\n\t\t\tcoeff[i] * kernel[0] +\n\t\t\t(prev1 + coeff[i + 1]) * kernel[1] +\n\t\t\t(prev2 + coeff[i + 2]) * kernel[2] +\n\t\t\t(prev3 + coeff[i + 3]) * kernel[3];\n\t\tprev3 = prev2;\n\t\tprev2 = prev1;\n\t\tprev1 = coeff[i];\n\t\tcoeff[i] = res;\n\t}\n}\n\n/**\n * Calculate and invert matrix for least-squares solution\n */\nfunction calcMatrix(\n\tmat: Float64Array[],\n\tmatFreq: Float64Array,\n\tn: number,\n): void {\n\t// Build symmetric matrix\n\tfor (let i = 0; i < n; i++) {\n\t\tmat[i][i] = matFreq[2 * i + 2] + 3 * matFreq[0] - 4 * matFreq[i + 1];\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tmat[i][j] = mat[j][i] =\n\t\t\t\tmatFreq[i + j + 2] +\n\t\t\t\tmatFreq[j - i] +\n\t\t\t\t2 * (matFreq[0] - matFreq[i + 1] - matFreq[j + 1]);\n\t\t}\n\t}\n\n\t// Invert using Gauss-Jordan elimination\n\tfor (let k = 0; k < n; k++) {\n\t\tconst z = 1 / mat[k][k];\n\t\tmat[k][k] = 1;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (i === k) continue;\n\t\t\tconst mul = mat[i][k] * z;\n\t\t\tmat[i][k] = 0;\n\t\t\tfor (let j = 0; j < n; j++) {\n\t\t\t\tmat[i][j] -= mat[k][j] * mul;\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tmat[k][j] *= z;\n\t\t}\n\t}\n}\n\n/**\n * Calculate optimal blur kernel coefficients\n * Uses least-squares fitting to match desired Gaussian\n */\nfunction calcCoeff(mu: Float64Array, n: number, r2: number, mul: number): void {\n\tconst w = 12096;\n\tconst kernel = [\n\t\t(((+3280 / w) * mul + 1092 / w) * mul + 2520 / w) * mul + 5204 / w,\n\t\t(((-2460 / w) * mul - 273 / w) * mul - 210 / w) * mul + 2943 / w,\n\t\t(((+984 / w) * mul - 546 / w) * mul - 924 / w) * mul + 486 / w,\n\t\t(((-164 / w) * mul + 273 / w) * mul - 126 / w) * mul + 17 / w,\n\t];\n\n\tconst matFreq = new Float64Array(17);\n\tmatFreq[0] = kernel[0];\n\tmatFreq[1] = kernel[1];\n\tmatFreq[2] = kernel[2];\n\tmatFreq[3] = kernel[3];\n\tcoeffFilter(matFreq, 7, kernel);\n\n\tconst vecFreq = new Float64Array(12);\n\tcalcGauss(vecFreq, n + 4, r2 * mul);\n\tcoeffFilter(vecFreq, n + 1, kernel);\n\n\tconst mat: Float64Array[] = [];\n\tfor (let i = 0; i < 8; i++) {\n\t\tmat.push(new Float64Array(8));\n\t}\n\tcalcMatrix(mat, matFreq, n);\n\n\tconst vec = new Float64Array(8);\n\tfor (let i = 0; i < n; i++) {\n\t\tvec[i] = matFreq[0] - matFreq[i + 1] - vecFreq[0] + vecFreq[i + 1];\n\t}\n\n\tfor (let i = 0; i < n; i++) {\n\t\tlet res = 0;\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tres += mat[i][j] * vec[j];\n\t\t}\n\t\tmu[i] = Math.max(0, res);\n\t}\n}\n\n/**\n * Find best blur method for given variance\n */\nfunction findBestMethod(r2: number): BlurMethod {\n\tconst mu = new Float64Array(8);\n\tlet level: number;\n\tlet radius: number;\n\n\tif (r2 < 0.5) {\n\t\tlevel = 0;\n\t\tradius = 4;\n\t\tmu[1] = 0.085 * r2 * r2 * r2;\n\t\tmu[0] = 0.5 * r2 - 4 * mu[1];\n\t\tmu[2] = mu[3] = 0;\n\t} else {\n\t\t// frexp equivalent: extract exponent\n\t\tconst sqrtVal = Math.sqrt(0.11569 * r2 + 0.20591047);\n\t\tlevel = Math.floor(Math.log2(sqrtVal)) + 1;\n\t\tconst frac = sqrtVal / 2 ** (level - 1) - 1; // Fractional part [0, 1)\n\n\t\tconst mul = 0.25 ** level;\n\t\tradius = 8 - Math.floor((10.1525 + 0.8335 * mul) * (1 - frac));\n\t\tradius = Math.max(radius, 4);\n\t\tradius = Math.min(radius, 8);\n\t\tcalcCoeff(mu, radius, r2, mul);\n\t}\n\n\tconst coeff = new Float32Array(8);\n\tfor (let i = 0; i < radius; i++) {\n\t\tcoeff[i] = mu[i];\n\t}\n\n\treturn { level, radius, coeff };\n}\n\n/**\n * Shrink image horizontally by factor of 2\n * Uses smooth kernel [1, 5, 10, 10, 5, 1]/32\n */\nfunction shrinkHorz(\n\tdst: Float32Array,\n\tsrc: Float32Array,\n\tw: number,\n\th: number,\n\tsrcStride: number,\n\tdstStride: number,\n): void {\n\tconst newW = Math.floor((w + 5) / 2);\n\n\tfor (let y = 0; y < h; y++) {\n\t\tconst srcRow = y * srcStride;\n\t\tconst dstRow = y * dstStride;\n\n\t\tfor (let x = 0; x < newW; x++) {\n\t\t\tconst sx = x * 2;\n\n\t\t\t// Kernel: [1, 5, 10, 10, 5, 1]/32\n\t\t\tlet sum = 0;\n\t\t\tsum += (src[srcRow + Math.max(0, sx - 2)] ?? 0) * 1;\n\t\t\tsum += (src[srcRow + Math.max(0, sx - 1)] ?? 0) * 5;\n\t\t\tsum += (src[srcRow + Math.min(w - 1, sx)] ?? 0) * 10;\n\t\t\tsum += (src[srcRow + Math.min(w - 1, sx + 1)] ?? 0) * 10;\n\t\t\tsum += (src[srcRow + Math.min(w - 1, sx + 2)] ?? 0) * 5;\n\t\t\tsum += (src[srcRow + Math.min(w - 1, sx + 3)] ?? 0) * 1;\n\n\t\t\tdst[dstRow + x] = sum / 32;\n\t\t}\n\t}\n}\n\n/**\n * Shrink image vertically by factor of 2\n */\nfunction shrinkVert(\n\tdst: Float32Array,\n\tsrc: Float32Array,\n\tw: number,\n\th: number,\n\tsrcStride: number,\n\tdstStride: number,\n): void {\n\tconst newH = Math.floor((h + 5) / 2);\n\n\tfor (let x = 0; x < w; x++) {\n\t\tfor (let y = 0; y < newH; y++) {\n\t\t\tconst sy = y * 2;\n\n\t\t\tlet sum = 0;\n\t\t\tsum += (src[Math.max(0, sy - 2) * srcStride + x] ?? 0) * 1;\n\t\t\tsum += (src[Math.max(0, sy - 1) * srcStride + x] ?? 0) * 5;\n\t\t\tsum += (src[Math.min(h - 1, sy) * srcStride + x] ?? 0) * 10;\n\t\t\tsum += (src[Math.min(h - 1, sy + 1) * srcStride + x] ?? 0) * 10;\n\t\t\tsum += (src[Math.min(h - 1, sy + 2) * srcStride + x] ?? 0) * 5;\n\t\t\tsum += (src[Math.min(h - 1, sy + 3) * srcStride + x] ?? 0) * 1;\n\n\t\t\tdst[y * dstStride + x] = sum / 32;\n\t\t}\n\t}\n}\n\n/**\n * Expand image horizontally by factor of 2\n */\nfunction expandHorz(\n\tdst: Float32Array,\n\tsrc: Float32Array,\n\tw: number,\n\th: number,\n\tsrcStride: number,\n\tdstStride: number,\n): void {\n\tconst newW = w * 2 + 4;\n\n\tfor (let y = 0; y < h; y++) {\n\t\tconst srcRow = y * srcStride;\n\t\tconst dstRow = y * dstStride;\n\n\t\tfor (let x = 0; x < newW; x++) {\n\t\t\tconst sx = Math.floor((x - 2) / 2);\n\t\t\tconst odd = (x - 2) & 1;\n\n\t\t\tlet sum = 0;\n\t\t\tif (odd === 0) {\n\t\t\t\t// Even position: [1, 10, 5]/16 from left neighbor, [5, 10, 1]/16 from right\n\t\t\t\tsum += (src[srcRow + Math.max(0, Math.min(w - 1, sx - 1))] ?? 0) * 1;\n\t\t\t\tsum += (src[srcRow + Math.max(0, Math.min(w - 1, sx))] ?? 0) * 30;\n\t\t\t\tsum += (src[srcRow + Math.max(0, Math.min(w - 1, sx + 1))] ?? 0) * 1;\n\t\t\t} else {\n\t\t\t\t// Odd position: interpolate between neighbors\n\t\t\t\tsum += (src[srcRow + Math.max(0, Math.min(w - 1, sx))] ?? 0) * 16;\n\t\t\t\tsum += (src[srcRow + Math.max(0, Math.min(w - 1, sx + 1))] ?? 0) * 16;\n\t\t\t}\n\n\t\t\tdst[dstRow + x] = sum / 32;\n\t\t}\n\t}\n}\n\n/**\n * Expand image vertically by factor of 2\n */\nfunction expandVert(\n\tdst: Float32Array,\n\tsrc: Float32Array,\n\tw: number,\n\th: number,\n\tsrcStride: number,\n\tdstStride: number,\n): void {\n\tconst newH = h * 2 + 4;\n\n\tfor (let x = 0; x < w; x++) {\n\t\tfor (let y = 0; y < newH; y++) {\n\t\t\tconst sy = Math.floor((y - 2) / 2);\n\t\t\tconst odd = (y - 2) & 1;\n\n\t\t\tlet sum = 0;\n\t\t\tif (odd === 0) {\n\t\t\t\tsum +=\n\t\t\t\t\t(src[Math.max(0, Math.min(h - 1, sy - 1)) * srcStride + x] ?? 0) * 1;\n\t\t\t\tsum +=\n\t\t\t\t\t(src[Math.max(0, Math.min(h - 1, sy)) * srcStride + x] ?? 0) * 30;\n\t\t\t\tsum +=\n\t\t\t\t\t(src[Math.max(0, Math.min(h - 1, sy + 1)) * srcStride + x] ?? 0) * 1;\n\t\t\t} else {\n\t\t\t\tsum +=\n\t\t\t\t\t(src[Math.max(0, Math.min(h - 1, sy)) * srcStride + x] ?? 0) * 16;\n\t\t\t\tsum +=\n\t\t\t\t\t(src[Math.max(0, Math.min(h - 1, sy + 1)) * srcStride + x] ?? 0) * 16;\n\t\t\t}\n\n\t\t\tdst[y * dstStride + x] = sum / 32;\n\t\t}\n\t}\n}\n\n/**\n * Apply 1D blur horizontally with computed coefficients\n */\nfunction blurHorz(\n\tdst: Float32Array,\n\tsrc: Float32Array,\n\tw: number,\n\th: number,\n\tsrcStride: number,\n\tdstStride: number,\n\tradius: number,\n\tcoeff: Float32Array,\n): void {\n\tconst newW = w + 2 * radius;\n\n\tfor (let y = 0; y < h; y++) {\n\t\tconst srcRow = y * srcStride;\n\t\tconst dstRow = y * dstStride;\n\n\t\tfor (let x = 0; x < newW; x++) {\n\t\t\tconst cx = x - radius;\n\t\t\tlet sum = 0;\n\n\t\t\t// Apply symmetric kernel\n\t\t\tfor (let i = 0; i < radius; i++) {\n\t\t\t\tconst left = Math.max(0, Math.min(w - 1, cx - i - 1));\n\t\t\t\tconst right = Math.max(0, Math.min(w - 1, cx + i));\n\t\t\t\tsum +=\n\t\t\t\t\t((src[srcRow + left] ?? 0) + (src[srcRow + right] ?? 0)) * coeff[i];\n\t\t\t}\n\n\t\t\tdst[dstRow + x] = sum;\n\t\t}\n\t}\n}\n\n/**\n * Apply 1D blur vertically with computed coefficients\n */\nfunction blurVert(\n\tdst: Float32Array,\n\tsrc: Float32Array,\n\tw: number,\n\th: number,\n\tsrcStride: number,\n\tdstStride: number,\n\tradius: number,\n\tcoeff: Float32Array,\n): void {\n\tconst newH = h + 2 * radius;\n\n\tfor (let x = 0; x < w; x++) {\n\t\tfor (let y = 0; y < newH; y++) {\n\t\t\tconst cy = y - radius;\n\t\t\tlet sum = 0;\n\n\t\t\tfor (let i = 0; i < radius; i++) {\n\t\t\t\tconst top = Math.max(0, Math.min(h - 1, cy - i - 1));\n\t\t\t\tconst bottom = Math.max(0, Math.min(h - 1, cy + i));\n\t\t\t\tsum +=\n\t\t\t\t\t((src[top * srcStride + x] ?? 0) +\n\t\t\t\t\t\t(src[bottom * srcStride + x] ?? 0)) *\n\t\t\t\t\tcoeff[i];\n\t\t\t}\n\n\t\t\tdst[y * dstStride + x] = sum;\n\t\t}\n\t}\n}\n\n/**\n * Cascade blur for RGBA bitmaps - uses gaussianBlur which handles multi-channel\n * For RGBA, we fall back to the standard gaussian blur since cascade is optimized\n * for single-channel grayscale bitmaps.\n */\nfunction cascadeBlurRGBA(\n\tbitmap: Bitmap,\n\tradiusX: number,\n\tradiusY: number,\n): Bitmap {\n\t// For RGBA, use the standard gaussianBlur which handles multi-channel correctly\n\t// Use average of radiusX and radiusY since gaussianBlur only supports single radius\n\tconst avgRadius = (radiusX + radiusY) / 2;\n\treturn gaussianBlur(bitmap, avgRadius);\n}\n\n/**\n * Cascade Gaussian blur with asymmetric X/Y radii\n * High-performance blur using pyramid scaling for large radii\n * @param bitmap Input bitmap to blur\n * @param radiusX Blur radius along X axis in pixels\n * @param radiusY Blur radius along Y axis in pixels (defaults to radiusX)\n * @returns New bitmap with blur applied (dimensions may change)\n */\nexport function cascadeBlur(\n\tbitmap: Bitmap,\n\tradiusX: number,\n\tradiusY: number = radiusX,\n): Bitmap {\n\tif (radiusX <= 0 && radiusY <= 0) {\n\t\treturn bitmap;\n\t}\n\n\t// Handle RGBA bitmaps - fall back to gaussianBlur which handles multi-channel\n\tif (bitmap.pixelMode === PixelMode.RGBA) {\n\t\treturn cascadeBlurRGBA(bitmap, radiusX, radiusY);\n\t}\n\n\t// Grayscale cascade blur implementation\n\tconst r2x = radiusX * radiusX;\n\tconst r2y = radiusY * radiusY;\n\n\tconst blurX = findBestMethod(r2x);\n\tconst blurY = findBestMethod(r2y);\n\n\tlet w = bitmap.width;\n\tlet h = bitmap.rows;\n\n\t// Calculate output dimensions\n\tconst offsetX = ((2 * blurX.radius + 9) << blurX.level) - 5;\n\tconst offsetY = ((2 * blurY.radius + 9) << blurY.level) - 5;\n\tconst endW = ((w + offsetX) & ~((1 << blurX.level) - 1)) - 4;\n\tconst endH = ((h + offsetY) & ~((1 << blurY.level) - 1)) - 4;\n\n\t// Allocate working buffers (use Float32 for precision during cascade)\n\tconst maxSize = Math.max(w * h, endW * endH) * 2;\n\tconst buf0 = new Float32Array(maxSize);\n\tconst buf1 = new Float32Array(maxSize);\n\n\t// Unpack bitmap to float buffer\n\tfor (let y = 0; y < h; y++) {\n\t\tfor (let x = 0; x < w; x++) {\n\t\t\tbuf0[y * w + x] = bitmap.buffer[y * bitmap.pitch + x] ?? 0;\n\t\t}\n\t}\n\n\tlet src = buf0;\n\tlet dst = buf1;\n\tlet stride = w;\n\n\t// Cascade down: shrink vertically\n\tfor (let i = 0; i < blurY.level; i++) {\n\t\tconst newH = Math.floor((h + 5) / 2);\n\t\tshrinkVert(dst, src, w, h, stride, w);\n\t\th = newH;\n\t\t[src, dst] = [dst, src];\n\t}\n\n\t// Cascade down: shrink horizontally\n\tfor (let i = 0; i < blurX.level; i++) {\n\t\tconst newW = Math.floor((w + 5) / 2);\n\t\tshrinkHorz(dst, src, w, h, stride, newW);\n\t\tw = newW;\n\t\tstride = newW;\n\t\t[src, dst] = [dst, src];\n\t}\n\n\t// Apply horizontal blur\n\tconst blurredW = w + 2 * blurX.radius;\n\tblurHorz(dst, src, w, h, stride, blurredW, blurX.radius, blurX.coeff);\n\tw = blurredW;\n\tstride = blurredW;\n\t[src, dst] = [dst, src];\n\n\t// Apply vertical blur\n\tconst blurredH = h + 2 * blurY.radius;\n\tblurVert(dst, src, w, h, stride, stride, blurY.radius, blurY.coeff);\n\th = blurredH;\n\t[src, dst] = [dst, src];\n\n\t// Cascade up: expand horizontally\n\tfor (let i = 0; i < blurX.level; i++) {\n\t\tconst newW = w * 2 + 4;\n\t\texpandHorz(dst, src, w, h, stride, newW);\n\t\tw = newW;\n\t\tstride = newW;\n\t\t[src, dst] = [dst, src];\n\t}\n\n\t// Cascade up: expand vertically\n\tfor (let i = 0; i < blurY.level; i++) {\n\t\tconst newH = h * 2 + 4;\n\t\texpandVert(dst, src, w, h, stride, stride);\n\t\th = newH;\n\t\t[src, dst] = [dst, src];\n\t}\n\n\t// Create output bitmap\n\tconst outWidth = Math.min(w, endW);\n\tconst outHeight = Math.min(h, endH);\n\tconst outBuffer = new Uint8Array(outWidth * outHeight);\n\n\t// Pack float buffer back to uint8\n\tfor (let y = 0; y < outHeight; y++) {\n\t\tfor (let x = 0; x < outWidth; x++) {\n\t\t\tconst val = src[y * stride + x] ?? 0;\n\t\t\toutBuffer[y * outWidth + x] = Math.max(0, Math.min(255, Math.round(val)));\n\t\t}\n\t}\n\n\treturn {\n\t\tbuffer: outBuffer,\n\t\twidth: outWidth,\n\t\trows: outHeight,\n\t\tpitch: outWidth,\n\t\tpixelMode: PixelMode.Gray,\n\t\tnumGrays: 256,\n\t};\n}\n\n/**\n * Fast Gaussian blur using cascade algorithm\n * This is the recommended blur function for large radii (> 3 pixels)\n * @param bitmap Input bitmap to blur\n * @param radius Blur radius in pixels\n * @returns New bitmap with blur applied (dimensions may change)\n */\nexport function fastGaussianBlur(bitmap: Bitmap, radius: number): Bitmap {\n\treturn cascadeBlur(bitmap, radius, radius);\n}\n\n/**\n * Adaptive blur that chooses the best algorithm based on radius\n * For small radii ( 3): uses simple separable Gaussian (more precise)\n * For large radii (> 3): uses cascade algorithm (faster)\n * @param bitmap Input bitmap to blur\n * @param radiusX Horizontal blur radius in pixels\n * @param radiusY Vertical blur radius in pixels (defaults to radiusX)\n * @returns Blurred bitmap using the optimal algorithm\n */\nexport function adaptiveBlur(\n\tbitmap: Bitmap,\n\tradiusX: number,\n\tradiusY?: number,\n): Bitmap {\n\tconst ry = radiusY ?? radiusX;\n\tconst maxRadius = Math.max(radiusX, ry);\n\n\tif (maxRadius <= 3) {\n\t\t// For small radii, use simple Gaussian (more precise for small kernels)\n\t\t// gaussianBlur only supports single radius, use average\n\t\treturn gaussianBlur(bitmap, (radiusX + ry) / 2);\n\t}\n\treturn cascadeBlur(bitmap, radiusX, ry);\n}\n",
    "/**\n * BitmapBuilder: Fluent builder for raster bitmap operations\n *\n * All operations are eager (applied immediately) and return new builder instances\n */\n\nimport {\n\taddBitmaps,\n\tblendBitmap,\n\tcompositeBitmaps,\n\tconvertBitmap,\n\tcopyBitmap,\n\temboldenBitmap,\n\temboldenBitmapWithBearing,\n\texpandRasterMetrics,\n\tmaxBitmaps,\n\tmeasureRasterGlyph,\n\tmulBitmaps,\n\tpadBitmap,\n\tresizeBitmap,\n\tresizeBitmapBilinear,\n\tshearBitmapX,\n\tshearBitmapY,\n\tshiftBitmap,\n\tsubBitmaps,\n\ttransformBitmap2D,\n\ttransformBitmap3D,\n} from \"../raster/bitmap-utils.ts\";\nimport { boxBlur, gaussianBlur } from \"../raster/blur.ts\";\nimport {\n\tadaptiveBlur,\n\tcascadeBlur,\n\tfastGaussianBlur,\n} from \"../raster/cascade-blur.ts\";\nimport { createGradientBitmap, type Gradient } from \"../raster/gradient.ts\";\nimport { bitmapToGray, bitmapToRGBA } from \"../raster/rasterize.ts\";\nimport {\n\ttype Bitmap,\n\tcreateBitmap,\n\tPixelMode,\n\ttype RasterizedGlyph,\n} from \"../raster/types.ts\";\nimport type { Matrix2D, Matrix3x3 } from \"../render/outline-transform.ts\";\n\n/**\n * BitmapBuilder provides a fluent interface for bitmap manipulations\n */\nexport class BitmapBuilder {\n\tprivate constructor(\n\t\tprivate readonly _bitmap: Bitmap,\n\t\tprivate readonly _bearingX: number = 0,\n\t\tprivate readonly _bearingY: number = 0,\n\t) {}\n\n\t// === Static Factory Methods ===\n\n\t/**\n\t * Create from existing bitmap\n\t */\n\tstatic fromBitmap(bitmap: Bitmap): BitmapBuilder {\n\t\treturn new BitmapBuilder(copyBitmap(bitmap));\n\t}\n\n\t/**\n\t * Create from existing bitmap with bearing info\n\t */\n\tstatic fromBitmapWithBearing(\n\t\tbitmap: Bitmap,\n\t\tbearingX: number,\n\t\tbearingY: number,\n\t): BitmapBuilder {\n\t\treturn new BitmapBuilder(copyBitmap(bitmap), bearingX, bearingY);\n\t}\n\n\t/**\n\t * Create from rasterized glyph result\n\t */\n\tstatic fromRasterizedGlyph(glyph: RasterizedGlyph): BitmapBuilder {\n\t\treturn new BitmapBuilder(\n\t\t\tcopyBitmap(glyph.bitmap),\n\t\t\tglyph.bearingX,\n\t\t\tglyph.bearingY,\n\t\t);\n\t}\n\n\t/**\n\t * Create empty bitmap\n\t */\n\tstatic create(\n\t\twidth: number,\n\t\theight: number,\n\t\tpixelMode: PixelMode = PixelMode.Gray,\n\t): BitmapBuilder {\n\t\treturn new BitmapBuilder(createBitmap(width, height, pixelMode));\n\t}\n\n\t/**\n\t * Create gradient bitmap\n\t */\n\tstatic fromGradient(\n\t\twidth: number,\n\t\theight: number,\n\t\tgradient: Gradient,\n\t): BitmapBuilder {\n\t\treturn new BitmapBuilder(createGradientBitmap(width, height, gradient));\n\t}\n\n\t// === Blur Effects ===\n\n\t/**\n\t * Gaussian blur\n\t */\n\tblur(radius: number): BitmapBuilder {\n\t\tconst blurred = gaussianBlur(copyBitmap(this._bitmap), radius);\n\t\treturn new BitmapBuilder(blurred, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Box blur (faster, less smooth)\n\t */\n\tboxBlur(radius: number): BitmapBuilder {\n\t\tconst blurred = boxBlur(copyBitmap(this._bitmap), radius);\n\t\treturn new BitmapBuilder(blurred, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Cascade blur (fast for large radii, O(1) per pixel)\n\t */\n\tcascadeBlur(radiusX: number, radiusY?: number): BitmapBuilder {\n\t\tconst blurred = cascadeBlur(\n\t\t\tcopyBitmap(this._bitmap),\n\t\t\tradiusX,\n\t\t\tradiusY ?? radiusX,\n\t\t);\n\t\treturn new BitmapBuilder(blurred, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Adaptive blur (auto-selects best algorithm based on radius)\n\t */\n\tadaptiveBlur(radiusX: number, radiusY?: number): BitmapBuilder {\n\t\tconst blurred = adaptiveBlur(\n\t\t\tcopyBitmap(this._bitmap),\n\t\t\tradiusX,\n\t\t\tradiusY ?? radiusX,\n\t\t);\n\t\treturn new BitmapBuilder(blurred, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Fast Gaussian blur using cascade algorithm\n\t * Recommended for large radii (> 3 pixels)\n\t */\n\tfastBlur(radius: number): BitmapBuilder {\n\t\tconst blurred = fastGaussianBlur(copyBitmap(this._bitmap), radius);\n\t\treturn new BitmapBuilder(blurred, this._bearingX, this._bearingY);\n\t}\n\n\t// === Transform Effects ===\n\n\t/**\n\t * Embolden (dilate) bitmap\n\t */\n\tembolden(xStrength: number, yStrength?: number): BitmapBuilder {\n\t\tconst emboldened = emboldenBitmap(\n\t\t\tthis._bitmap,\n\t\t\txStrength,\n\t\t\tyStrength ?? xStrength,\n\t\t);\n\t\treturn new BitmapBuilder(emboldened, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Embolden bitmap and update bearing to avoid clipping\n\t */\n\temboldenWithBearing(\n\t\txStrength: number,\n\t\tyStrength?: number,\n\t): BitmapBuilder {\n\t\tconst result = emboldenBitmapWithBearing(\n\t\t\tthis._bitmap,\n\t\t\tthis._bearingX,\n\t\t\tthis._bearingY,\n\t\t\txStrength,\n\t\t\tyStrength ?? xStrength,\n\t\t);\n\t\treturn new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);\n\t}\n\n\t/**\n\t * Apply 2D affine transform to bitmap (bearing-aware)\n\t */\n\ttransform2D(\n\t\tmatrix: Matrix2D,\n\t\toptions?: { offsetX26?: number; offsetY26?: number },\n\t): BitmapBuilder {\n\t\tconst result = transformBitmap2D(this._bitmap, matrix, {\n\t\t\tbearingX: this._bearingX,\n\t\t\tbearingY: this._bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n\t\treturn new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);\n\t}\n\n\t/**\n\t * Apply 3D perspective transform to bitmap (bearing-aware)\n\t */\n\ttransform3D(\n\t\tmatrix: Matrix3x3,\n\t\toptions?: { offsetX26?: number; offsetY26?: number },\n\t): BitmapBuilder {\n\t\tconst result = transformBitmap3D(this._bitmap, matrix, {\n\t\t\tbearingX: this._bearingX,\n\t\t\tbearingY: this._bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n\t\treturn new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);\n\t}\n\n\t/**\n\t * Shear bitmap horizontally (synthetic italic)\n\t */\n\tshearX(\n\t\tamount: number,\n\t\toptions?: { offsetX26?: number; offsetY26?: number },\n\t): BitmapBuilder {\n\t\tconst result = shearBitmapX(this._bitmap, amount, {\n\t\t\tbearingX: this._bearingX,\n\t\t\tbearingY: this._bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n\t\treturn new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);\n\t}\n\n\t/**\n\t * Shear bitmap vertically\n\t */\n\tshearY(\n\t\tamount: number,\n\t\toptions?: { offsetX26?: number; offsetY26?: number },\n\t): BitmapBuilder {\n\t\tconst result = shearBitmapY(this._bitmap, amount, {\n\t\t\tbearingX: this._bearingX,\n\t\t\tbearingY: this._bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n\t\treturn new BitmapBuilder(result.bitmap, result.bearingX, result.bearingY);\n\t}\n\n\t/**\n\t * Shift bitmap position\n\t */\n\tshift(dx: number, dy: number): BitmapBuilder {\n\t\tconst shifted = shiftBitmap(this._bitmap, dx, dy);\n\t\treturn new BitmapBuilder(shifted, this._bearingX + dx, this._bearingY - dy);\n\t}\n\n\t/**\n\t * Resize with nearest-neighbor interpolation\n\t */\n\tresize(width: number, height: number): BitmapBuilder {\n\t\tconst resized = resizeBitmap(this._bitmap, width, height);\n\t\treturn new BitmapBuilder(resized, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Resize with bilinear interpolation (smoother, better for downsampling)\n\t */\n\tresizeBilinear(width: number, height: number): BitmapBuilder {\n\t\tconst resized = resizeBitmapBilinear(this._bitmap, width, height);\n\t\treturn new BitmapBuilder(resized, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Pad bitmap with empty space\n\t */\n\tpad(left: number, top: number, right: number, bottom: number): BitmapBuilder;\n\tpad(all: number): BitmapBuilder;\n\tpad(\n\t\tleftOrAll: number,\n\t\ttop?: number,\n\t\tright?: number,\n\t\tbottom?: number,\n\t): BitmapBuilder {\n\t\tconst l = leftOrAll;\n\t\tconst t = top ?? leftOrAll;\n\t\tconst r = right ?? leftOrAll;\n\t\tconst b = bottom ?? leftOrAll;\n\t\tconst padded = padBitmap(this._bitmap, l, t, r, b);\n\t\treturn new BitmapBuilder(padded, this._bearingX - l, this._bearingY + t);\n\t}\n\n\t// === Metrics ===\n\n\t/**\n\t * Measure ascent/descent from bitmap coverage\n\t */\n\tmeasure(): { ascent: number; descent: number } {\n\t\treturn measureRasterGlyph(this._bitmap, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Get raster metrics for this bitmap (includes ascent/descent)\n\t */\n\tmetrics(): {\n\t\twidth: number;\n\t\theight: number;\n\t\tbearingX: number;\n\t\tbearingY: number;\n\t\tascent: number;\n\t\tdescent: number;\n\t} {\n\t\tconst { ascent, descent } = this.measure();\n\t\treturn {\n\t\t\twidth: this._bitmap.width,\n\t\t\theight: this._bitmap.rows,\n\t\t\tbearingX: this._bearingX,\n\t\t\tbearingY: this._bearingY,\n\t\t\tascent,\n\t\t\tdescent,\n\t\t};\n\t}\n\n\t/**\n\t * Expand raster metrics for blur/border/shadow padding\n\t */\n\texpandMetrics(options: {\n\t\tblur?: number;\n\t\tbe?: number;\n\t\tborder?: number;\n\t\tshadowX?: number;\n\t\tshadowY?: number;\n\t}): {\n\t\twidth: number;\n\t\theight: number;\n\t\tbearingX: number;\n\t\tbearingY: number;\n\t\tascent: number;\n\t\tdescent: number;\n\t\tpadLeft: number;\n\t\tpadRight: number;\n\t\tpadTop: number;\n\t\tpadBottom: number;\n\t} {\n\t\treturn expandRasterMetrics(this.metrics(), options);\n\t}\n\n\t// === Compositing ===\n\n\t/**\n\t * Alpha blend another bitmap onto this one at position\n\t */\n\tblend(\n\t\tother: BitmapBuilder | Bitmap,\n\t\tx: number,\n\t\ty: number,\n\t\topacity: number = 1,\n\t): BitmapBuilder {\n\t\tconst src = other instanceof BitmapBuilder ? other._bitmap : other;\n\t\tconst dst = copyBitmap(this._bitmap);\n\t\tblendBitmap(dst, src, x, y, opacity);\n\t\treturn new BitmapBuilder(dst, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Composite another bitmap using Porter-Duff \"over\" operation\n\t */\n\tcomposite(\n\t\tother: BitmapBuilder | Bitmap,\n\t\tx: number = 0,\n\t\ty: number = 0,\n\t): BitmapBuilder {\n\t\tconst src = other instanceof BitmapBuilder ? other._bitmap : other;\n\t\tconst dst = copyBitmap(this._bitmap);\n\t\tcompositeBitmaps(dst, src, x, y);\n\t\treturn new BitmapBuilder(dst, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Additive blend: result = clamp(this + other, 0, 255)\n\t */\n\tadd(\n\t\tother: BitmapBuilder | Bitmap,\n\t\tx: number = 0,\n\t\ty: number = 0,\n\t): BitmapBuilder {\n\t\tconst src = other instanceof BitmapBuilder ? other._bitmap : other;\n\t\tconst dst = copyBitmap(this._bitmap);\n\t\taddBitmaps(dst, src, x, y);\n\t\treturn new BitmapBuilder(dst, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Subtractive blend: result = clamp(this - other, 0, 255)\n\t */\n\tsubtract(\n\t\tother: BitmapBuilder | Bitmap,\n\t\tx: number = 0,\n\t\ty: number = 0,\n\t): BitmapBuilder {\n\t\tconst src = other instanceof BitmapBuilder ? other._bitmap : other;\n\t\tconst dst = copyBitmap(this._bitmap);\n\t\tsubBitmaps(dst, src, x, y);\n\t\treturn new BitmapBuilder(dst, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Multiplicative blend: result = (this * other) / 255\n\t */\n\tmultiply(\n\t\tother: BitmapBuilder | Bitmap,\n\t\tx: number = 0,\n\t\ty: number = 0,\n\t): BitmapBuilder {\n\t\tconst src = other instanceof BitmapBuilder ? other._bitmap : other;\n\t\tconst dst = copyBitmap(this._bitmap);\n\t\tmulBitmaps(dst, src, x, y);\n\t\treturn new BitmapBuilder(dst, this._bearingX, this._bearingY);\n\t}\n\n\t/**\n\t * Maximum blend: result = max(this, other)\n\t */\n\tmax(\n\t\tother: BitmapBuilder | Bitmap,\n\t\tx: number = 0,\n\t\ty: number = 0,\n\t): BitmapBuilder {\n\t\tconst src = other instanceof BitmapBuilder ? other._bitmap : other;\n\t\tconst dst = copyBitmap(this._bitmap);\n\t\tmaxBitmaps(dst, src, x, y);\n\t\treturn new BitmapBuilder(dst, this._bearingX, this._bearingY);\n\t}\n\n\t// === Conversion ===\n\n\t/**\n\t * Convert to different pixel mode\n\t */\n\tconvert(targetMode: PixelMode): BitmapBuilder {\n\t\tconst converted = convertBitmap(this._bitmap, targetMode);\n\t\treturn new BitmapBuilder(converted, this._bearingX, this._bearingY);\n\t}\n\n\t// === Output ===\n\n\t/**\n\t * Get RGBA pixel array (for canvas ImageData, WebGL textures)\n\t */\n\ttoRGBA(): Uint8Array {\n\t\treturn bitmapToRGBA(this._bitmap);\n\t}\n\n\t/**\n\t * Get grayscale array\n\t */\n\ttoGray(): Uint8Array {\n\t\treturn bitmapToGray(this._bitmap);\n\t}\n\n\t/**\n\t * Get raw bitmap (cloned)\n\t */\n\ttoBitmap(): Bitmap {\n\t\treturn copyBitmap(this._bitmap);\n\t}\n\n\t/**\n\t * Get bitmap with bearing info\n\t */\n\ttoRasterizedGlyph(): RasterizedGlyph {\n\t\treturn {\n\t\t\tbitmap: copyBitmap(this._bitmap),\n\t\t\tbearingX: this._bearingX,\n\t\t\tbearingY: this._bearingY,\n\t\t};\n\t}\n\n\t/**\n\t * Clone this builder\n\t */\n\tclone(): BitmapBuilder {\n\t\treturn new BitmapBuilder(\n\t\t\tcopyBitmap(this._bitmap),\n\t\t\tthis._bearingX,\n\t\t\tthis._bearingY,\n\t\t);\n\t}\n\n\t// === Accessors ===\n\n\t/**\n\t * Get bitmap width\n\t */\n\tget width(): number {\n\t\treturn this._bitmap.width;\n\t}\n\n\t/**\n\t * Get bitmap height (rows)\n\t */\n\tget height(): number {\n\t\treturn this._bitmap.rows;\n\t}\n\n\t/**\n\t * Get pixel mode\n\t */\n\tget pixelMode(): PixelMode {\n\t\treturn this._bitmap.pixelMode;\n\t}\n\n\t/**\n\t * Get horizontal bearing\n\t */\n\tget bearingX(): number {\n\t\treturn this._bearingX;\n\t}\n\n\t/**\n\t * Get vertical bearing\n\t */\n\tget bearingY(): number {\n\t\treturn this._bearingY;\n\t}\n}\n",
    "/**\n * PathBuilder: Fluent builder for vector path operations\n *\n * Transforms are lazy by default - accumulated as matrix until rasterization or .apply()\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport {\n\ttype AsymmetricStrokeOptions,\n\tstrokeAsymmetric,\n\tstrokeAsymmetricCombined,\n} from \"../raster/asymmetric-stroke.ts\";\nimport type { Gradient } from \"../raster/gradient.ts\";\nimport { type MsdfOptions, renderMsdf } from \"../raster/msdf.ts\";\nimport { getPathBounds } from \"../raster/outline-decompose.ts\";\nimport {\n\trasterizePath,\n\trasterizePathWithGradient,\n} from \"../raster/rasterize.ts\";\nimport { renderSdf, type SdfOptions } from \"../raster/sdf.ts\";\nimport {\n\ttype LineCap,\n\ttype LineJoin,\n\ttype StrokerOptions,\n\tstrokePath,\n} from \"../raster/stroker.ts\";\nimport { condensePath, emboldenPath, obliquePath } from \"../raster/synth.ts\";\nimport { FillRule, PixelMode } from \"../raster/types.ts\";\nimport {\n\tclonePath,\n\tcombinePaths,\n\tcomputeControlBox,\n\tcomputeTightBounds,\n\tidentity2D,\n\tidentity3x3,\n\ttype Matrix2D,\n\ttype Matrix3x3,\n\tmultiply2D,\n\tmultiply3x3,\n\tperspectiveMatrix,\n\trotate2D,\n\tscale2D,\n\tshear2D,\n\ttransformOutline2D,\n\ttransformOutline3D,\n\ttranslate2D,\n} from \"../render/outline-transform.ts\";\nimport {\n\tcreatePath2D,\n\ttype GlyphPath,\n\tgetGlyphPath,\n\tgetGlyphPathWithVariation,\n\tpathToCanvas,\n\tpathToCanvasWithMatrix,\n\tpathToCanvasWithMatrix3D,\n\tpathToSVG,\n} from \"../render/path.ts\";\nimport type { GlyphId } from \"../types.ts\";\nimport { BitmapBuilder } from \"./bitmap-builder.ts\";\nimport type {\n\tAutoRasterOptions,\n\tCanvasOptions,\n\tRasterOptions,\n\tSVGElementOptions,\n\tSVGOptions,\n\tTransformState,\n} from \"./types.ts\";\n\n/**\n * PathBuilder provides a fluent interface for path transformations and rendering\n */\nexport class PathBuilder {\n\tprivate constructor(\n\t\tprivate readonly _path: GlyphPath,\n\t\tprivate readonly _transform: TransformState,\n\t\tprivate readonly _font: Font | null,\n\t) {}\n\n\t// === Static Factory Methods ===\n\n\t/**\n\t * Create PathBuilder from a font glyph\n\t */\n\tstatic fromGlyph(font: Font, glyphId: GlyphId): PathBuilder | null {\n\t\tconst path = getGlyphPath(font, glyphId);\n\t\tif (!path) return null;\n\t\treturn new PathBuilder(\n\t\t\tpath,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tfont,\n\t\t);\n\t}\n\n\t/**\n\t * Create PathBuilder from a font glyph with variable font coordinates\n\t */\n\tstatic fromGlyphWithVariation(\n\t\tfont: Font,\n\t\tglyphId: GlyphId,\n\t\taxisCoords: number[],\n\t): PathBuilder | null {\n\t\tconst path = getGlyphPathWithVariation(font, glyphId, axisCoords);\n\t\tif (!path) return null;\n\t\treturn new PathBuilder(\n\t\t\tpath,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tfont,\n\t\t);\n\t}\n\n\t/**\n\t * Create PathBuilder from an existing GlyphPath\n\t */\n\tstatic fromPath(path: GlyphPath): PathBuilder {\n\t\treturn new PathBuilder(\n\t\t\tclonePath(path),\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tnull,\n\t\t);\n\t}\n\n\t/**\n\t * Combine multiple PathBuilders into one\n\t */\n\tstatic combine(...builders: PathBuilder[]): PathBuilder {\n\t\tconst paths = builders.map((b) => b.toPath());\n\t\tconst combined = combinePaths(paths);\n\t\treturn new PathBuilder(\n\t\t\tcombined,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tnull,\n\t\t);\n\t}\n\n\t// === 2D Affine Transforms (Lazy - accumulates matrix) ===\n\n\t/**\n\t * Scale uniformly or non-uniformly\n\t */\n\tscale(sx: number, sy: number = sx): PathBuilder {\n\t\tconst newMatrix = multiply2D(this._transform.matrix2D, scale2D(sx, sy));\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ ...this._transform, matrix2D: newMatrix },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Translate by offset\n\t */\n\ttranslate(dx: number, dy: number): PathBuilder {\n\t\tconst newMatrix = multiply2D(this._transform.matrix2D, translate2D(dx, dy));\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ ...this._transform, matrix2D: newMatrix },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Rotate by angle in radians around origin\n\t */\n\trotate(angle: number): PathBuilder {\n\t\tconst newMatrix = multiply2D(this._transform.matrix2D, rotate2D(angle));\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ ...this._transform, matrix2D: newMatrix },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Rotate by angle in degrees around origin\n\t */\n\trotateDeg(angleDeg: number): PathBuilder {\n\t\treturn this.rotate((angleDeg * Math.PI) / 180);\n\t}\n\n\t/**\n\t * Shear/skew transformation\n\t */\n\tshear(shearX: number, shearY: number): PathBuilder {\n\t\tconst newMatrix = multiply2D(\n\t\t\tthis._transform.matrix2D,\n\t\t\tshear2D(shearX, shearY),\n\t\t);\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ ...this._transform, matrix2D: newMatrix },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Apply italic slant (angle in degrees, typically 12-15 for italic)\n\t */\n\titalic(angleDeg: number): PathBuilder {\n\t\tconst shearX = Math.tan((angleDeg * Math.PI) / 180);\n\t\treturn this.shear(shearX, 0);\n\t}\n\n\t/**\n\t * Apply custom 2D affine matrix\n\t */\n\tmatrix(m: Matrix2D): PathBuilder {\n\t\tconst newMatrix = multiply2D(this._transform.matrix2D, m);\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ ...this._transform, matrix2D: newMatrix },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Reset transform to identity\n\t */\n\tresetTransform(): PathBuilder {\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t// === 3D Perspective Transforms (Lazy) ===\n\n\t/**\n\t * Apply 3x3 perspective matrix\n\t */\n\tperspective(m: Matrix3x3): PathBuilder {\n\t\tconst newMatrix3D = this._transform.matrix3D\n\t\t\t? multiply3x3(this._transform.matrix3D, m)\n\t\t\t: m;\n\t\treturn new PathBuilder(\n\t\t\tthis._path,\n\t\t\t{ ...this._transform, matrix3D: newMatrix3D },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Create perspective with vanishing point\n\t */\n\tperspectiveVanish(\n\t\tvanishingPointX: number,\n\t\tvanishingPointY: number,\n\t\tstrength: number,\n\t): PathBuilder {\n\t\tconst m = perspectiveMatrix(vanishingPointX, vanishingPointY, strength);\n\t\treturn this.perspective(m);\n\t}\n\n\t// === Path Effects (Eager - applies transform first, modifies path) ===\n\n\t/**\n\t * Force application of pending transforms\n\t * Returns new PathBuilder with transforms applied and reset\n\t */\n\tapply(): PathBuilder {\n\t\tconst transformed = this.applyTransformToPath();\n\t\treturn new PathBuilder(\n\t\t\ttransformed,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Synthetic bold/embolden\n\t */\n\tembolden(strength: number): PathBuilder {\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst emboldened = emboldenPath(transformed, strength);\n\t\treturn new PathBuilder(\n\t\t\temboldened,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Horizontal condensing (factor < 1) or expansion (factor > 1)\n\t */\n\tcondense(factor: number): PathBuilder {\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst condensed = condensePath(transformed, factor);\n\t\treturn new PathBuilder(\n\t\t\tcondensed,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Oblique/slant transformation\n\t */\n\toblique(slant: number): PathBuilder {\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst obliqued = obliquePath(transformed, slant);\n\t\treturn new PathBuilder(\n\t\t\tobliqued,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Convert to stroked outline\n\t */\n\tstroke(options: StrokerOptions): PathBuilder;\n\tstroke(width: number, cap?: LineCap, join?: LineJoin): PathBuilder;\n\tstroke(\n\t\toptionsOrWidth: StrokerOptions | number,\n\t\tcap?: LineCap,\n\t\tjoin?: LineJoin,\n\t): PathBuilder {\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst opts: StrokerOptions =\n\t\t\ttypeof optionsOrWidth === \"number\"\n\t\t\t\t? { width: optionsOrWidth, lineCap: cap, lineJoin: join }\n\t\t\t\t: optionsOrWidth;\n\t\tconst stroked = strokePath(transformed, opts);\n\t\treturn new PathBuilder(\n\t\t\tstroked,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t/**\n\t * Asymmetric stroke with independent X/Y border widths\n\t * Returns outer and inner paths\n\t */\n\tstrokeAsymmetric(options: AsymmetricStrokeOptions): {\n\t\touter: PathBuilder;\n\t\tinner: PathBuilder;\n\t} {\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst { outer, inner } = strokeAsymmetric(transformed, options);\n\t\treturn {\n\t\t\touter: new PathBuilder(\n\t\t\t\touter,\n\t\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\t\tthis._font,\n\t\t\t),\n\t\t\tinner: new PathBuilder(\n\t\t\t\tinner,\n\t\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\t\tthis._font,\n\t\t\t),\n\t\t};\n\t}\n\n\t/**\n\t * Asymmetric stroke combined (both inner and outer as single fillable path)\n\t */\n\tstrokeAsymmetricCombined(options: AsymmetricStrokeOptions): PathBuilder {\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst combined = strokeAsymmetricCombined(transformed, options);\n\t\treturn new PathBuilder(\n\t\t\tcombined,\n\t\t\t{ matrix2D: identity2D(), matrix3D: null },\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t// === Bounds & Metrics ===\n\n\t/**\n\t * Get control box (bounding box of control points)\n\t * Note: Returns bounds AFTER applying transforms\n\t */\n\tcontrolBox(): { xMin: number; yMin: number; xMax: number; yMax: number } {\n\t\tconst transformed = this.applyTransformToPath();\n\t\treturn computeControlBox(transformed);\n\t}\n\n\t/**\n\t * Get tight bounds (exact bounds considering curve extrema)\n\t * Note: Returns bounds AFTER applying transforms\n\t */\n\ttightBounds(): { xMin: number; yMin: number; xMax: number; yMax: number } {\n\t\tconst transformed = this.applyTransformToPath();\n\t\treturn computeTightBounds(transformed);\n\t}\n\n\t/**\n\t * Get the accumulated 2D transform matrix\n\t */\n\tgetTransformMatrix(): Matrix2D {\n\t\treturn [...this._transform.matrix2D] as Matrix2D;\n\t}\n\n\t/**\n\t * Get the accumulated 3D transform matrix (if any)\n\t */\n\tgetTransformMatrix3D(): Matrix3x3 | null {\n\t\tif (!this._transform.matrix3D) return null;\n\t\treturn this._transform.matrix3D.map((row) => [...row]) as Matrix3x3;\n\t}\n\n\t// === Rasterization (Transition to BitmapBuilder) ===\n\n\t/**\n\t * Rasterize to bitmap with explicit size\n\t */\n\trasterize(options: RasterOptions): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst {\n\t\t\twidth = 100,\n\t\t\theight = 100,\n\t\t\tscale = 1,\n\t\t\toffsetX = 0,\n\t\t\toffsetY = 0,\n\t\t\tpixelMode = PixelMode.Gray,\n\t\t\tfillRule = FillRule.NonZero,\n\t\t\tflipY = true,\n\t\t} = options;\n\n\t\tconst bitmap = rasterizePath(transformedPath, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tpixelMode,\n\t\t\tfillRule,\n\t\t\tflipY,\n\t\t});\n\n\t\treturn BitmapBuilder.fromBitmap(bitmap);\n\t}\n\n\t/**\n\t * Rasterize with auto-computed size from bounds\n\t */\n\trasterizeAuto(options?: AutoRasterOptions): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst {\n\t\t\tpadding = 1,\n\t\t\tscale = 1,\n\t\t\tpixelMode = PixelMode.Gray,\n\t\t\tfillRule = FillRule.NonZero,\n\t\t\tflipY = true,\n\t\t} = options ?? {};\n\n\t\tconst bounds = getPathBounds(transformedPath, scale, flipY);\n\t\tif (!bounds) {\n\t\t\t// Empty path - return 1x1 empty bitmap\n\t\t\tconst { createBitmap } = require(\"../raster/types.ts\");\n\t\t\treturn BitmapBuilder.fromBitmap(createBitmap(1, 1, pixelMode));\n\t\t}\n\n\t\tconst width = bounds.maxX - bounds.minX + padding * 2;\n\t\tconst height = bounds.maxY - bounds.minY + padding * 2;\n\t\tconst offsetX = -bounds.minX + padding;\n\t\tconst offsetY = -bounds.minY + padding;\n\n\t\tconst bitmap = rasterizePath(transformedPath, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tpixelMode,\n\t\t\tfillRule,\n\t\t\tflipY,\n\t\t});\n\n\t\treturn BitmapBuilder.fromBitmapWithBearing(\n\t\t\tbitmap,\n\t\t\tbounds.minX - padding,\n\t\t\t-(bounds.minY - padding),\n\t\t);\n\t}\n\n\t/**\n\t * Rasterize with gradient fill\n\t */\n\trasterizeWithGradient(\n\t\tgradient: Gradient,\n\t\toptions: RasterOptions,\n\t): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst {\n\t\t\twidth = 100,\n\t\t\theight = 100,\n\t\t\tscale = 1,\n\t\t\toffsetX = 0,\n\t\t\toffsetY = 0,\n\t\t\tpixelMode = PixelMode.Gray,\n\t\t\tfillRule = FillRule.NonZero,\n\t\t\tflipY = true,\n\t\t} = options;\n\n\t\tconst bitmap = rasterizePathWithGradient(transformedPath, gradient, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tpixelMode,\n\t\t\tfillRule,\n\t\t\tflipY,\n\t\t});\n\n\t\treturn BitmapBuilder.fromBitmap(bitmap);\n\t}\n\n\t/**\n\t * Render as Signed Distance Field (SDF)\n\t * Useful for GPU text rendering at any scale\n\t */\n\ttoSdf(options: SdfOptions): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst bitmap = renderSdf(transformedPath, options);\n\t\treturn BitmapBuilder.fromBitmap(bitmap);\n\t}\n\n\t/**\n\t * Render as SDF with auto-computed size from bounds\n\t */\n\ttoSdfAuto(options?: {\n\t\tpadding?: number;\n\t\tscale?: number;\n\t\tspread?: number;\n\t\tflipY?: boolean;\n\t}): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst { padding = 1, scale = 1, spread = 8, flipY = true } = options ?? {};\n\n\t\tconst bounds = getPathBounds(transformedPath, scale, flipY);\n\t\tif (!bounds) {\n\t\t\tconst { createBitmap } = require(\"../raster/types.ts\");\n\t\t\treturn BitmapBuilder.fromBitmap(createBitmap(1, 1, PixelMode.Gray));\n\t\t}\n\n\t\tconst width = bounds.maxX - bounds.minX + padding * 2 + spread * 2;\n\t\tconst height = bounds.maxY - bounds.minY + padding * 2 + spread * 2;\n\t\tconst offsetX = -bounds.minX + padding + spread;\n\t\tconst offsetY = flipY\n\t\t\t? bounds.maxY + padding + spread\n\t\t\t: -bounds.minY + padding + spread;\n\n\t\tconst bitmap = renderSdf(transformedPath, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tflipY,\n\t\t\tspread,\n\t\t});\n\n\t\treturn BitmapBuilder.fromBitmapWithBearing(\n\t\t\tbitmap,\n\t\t\tbounds.minX - padding - spread,\n\t\t\t-(bounds.minY - padding - spread),\n\t\t);\n\t}\n\n\t/**\n\t * Render as Multi-channel Signed Distance Field (MSDF)\n\t * Better quality than SDF for sharp corners\n\t */\n\ttoMsdf(options: MsdfOptions): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst bitmap = renderMsdf(transformedPath, options);\n\t\treturn BitmapBuilder.fromBitmap(bitmap);\n\t}\n\n\t/**\n\t * Render as MSDF with auto-computed size from bounds\n\t */\n\ttoMsdfAuto(options?: {\n\t\tpadding?: number;\n\t\tscale?: number;\n\t\tspread?: number;\n\t\tflipY?: boolean;\n\t}): BitmapBuilder {\n\t\tconst transformedPath = this.applyTransformToPath();\n\t\tconst { padding = 1, scale = 1, spread = 8, flipY = true } = options ?? {};\n\n\t\tconst bounds = getPathBounds(transformedPath, scale, flipY);\n\t\tif (!bounds) {\n\t\t\tconst { createBitmap } = require(\"../raster/types.ts\");\n\t\t\treturn BitmapBuilder.fromBitmap(createBitmap(1, 1, PixelMode.LCD));\n\t\t}\n\n\t\tconst width = bounds.maxX - bounds.minX + padding * 2 + spread * 2;\n\t\tconst height = bounds.maxY - bounds.minY + padding * 2 + spread * 2;\n\t\tconst offsetX = -bounds.minX + padding + spread;\n\t\tconst offsetY = flipY\n\t\t\t? bounds.maxY + padding + spread\n\t\t\t: -bounds.minY + padding + spread;\n\n\t\tconst bitmap = renderMsdf(transformedPath, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tflipY,\n\t\t\tspread,\n\t\t});\n\n\t\treturn BitmapBuilder.fromBitmapWithBearing(\n\t\t\tbitmap,\n\t\t\tbounds.minX - padding - spread,\n\t\t\t-(bounds.minY - padding - spread),\n\t\t);\n\t}\n\n\t// === Direct Output (applies transforms) ===\n\n\t/**\n\t * Convert to SVG path data string\n\t */\n\ttoSVG(options?: SVGOptions): string {\n\t\tconst { flipY = true, scale = 1 } = options ?? {};\n\n\t\tif (this.hasTransform()) {\n\t\t\t// Apply transform to path coordinates\n\t\t\tconst transformed = this.applyTransformToPath();\n\t\t\treturn pathToSVG(transformed, { flipY, scale });\n\t\t}\n\n\t\treturn pathToSVG(this._path, { flipY, scale });\n\t}\n\n\t/**\n\t * Convert to full SVG element string\n\t */\n\ttoSVGElement(options?: SVGElementOptions): string {\n\t\tconst {\n\t\t\tfontSize = 100,\n\t\t\tfill = \"currentColor\",\n\t\t\tstroke,\n\t\t\tstrokeWidth = 1,\n\t\t} = options ?? {};\n\n\t\tconst transformed = this.applyTransformToPath();\n\t\tconst bounds = computeTightBounds(transformed);\n\n\t\tconst scale = this._font ? fontSize / this._font.unitsPerEm : 1;\n\t\tconst scaledPath =\n\t\t\tscale !== 1\n\t\t\t\t? transformOutline2D(transformed, scale2D(scale, scale))\n\t\t\t\t: transformed;\n\t\tconst scaledBounds =\n\t\t\tscale !== 1\n\t\t\t\t? {\n\t\t\t\t\t\txMin: bounds.xMin * scale,\n\t\t\t\t\t\tyMin: bounds.yMin * scale,\n\t\t\t\t\t\txMax: bounds.xMax * scale,\n\t\t\t\t\t\tyMax: bounds.yMax * scale,\n\t\t\t\t\t}\n\t\t\t\t: bounds;\n\n\t\tconst strokePadding = stroke ? strokeWidth / 2 : 0;\n\t\tconst width = Math.ceil(\n\t\t\tscaledBounds.xMax - scaledBounds.xMin + strokePadding * 2,\n\t\t);\n\t\tconst height = Math.ceil(\n\t\t\tscaledBounds.yMax - scaledBounds.yMin + strokePadding * 2,\n\t\t);\n\t\tconst viewBox = `${scaledBounds.xMin - strokePadding} ${-scaledBounds.yMax - strokePadding} ${scaledBounds.xMax - scaledBounds.xMin + strokePadding * 2} ${scaledBounds.yMax - scaledBounds.yMin + strokePadding * 2}`;\n\n\t\tconst pathData = pathToSVG(scaledPath, { flipY: true, scale: 1 });\n\t\tconst strokeAttr = stroke\n\t\t\t? ` stroke=\"${stroke}\" stroke-width=\"${strokeWidth}\"`\n\t\t\t: \"\";\n\n\t\treturn `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\" viewBox=\"${viewBox}\">\n  <path d=\"${pathData}\" fill=\"${fill}\"${strokeAttr}/>\n</svg>`;\n\t}\n\n\t/**\n\t * Render to canvas context\n\t */\n\ttoCanvas(ctx: CanvasRenderingContext2D, options?: CanvasOptions): void {\n\t\tconst {\n\t\t\tflipY = true,\n\t\t\tscale = 1,\n\t\t\toffsetX = 0,\n\t\t\toffsetY = 0,\n\t\t\tfill = \"black\",\n\t\t\tstroke,\n\t\t\tstrokeWidth = 1,\n\t\t} = options ?? {};\n\n\t\tctx.beginPath();\n\n\t\tif (this._transform.matrix3D) {\n\t\t\t// Use 3D matrix rendering\n\t\t\tconst combined = this.combinedMatrix3D(scale, offsetX, offsetY);\n\t\t\tpathToCanvasWithMatrix3D(ctx, this._path, combined, { flipY });\n\t\t} else if (this.hasTransform2D()) {\n\t\t\t// Use 2D matrix rendering\n\t\t\tconst combined = this.combinedMatrix2D(scale, offsetX, offsetY);\n\t\t\tpathToCanvasWithMatrix(ctx, this._path, combined, { flipY });\n\t\t} else {\n\t\t\t// No transform - use simple rendering\n\t\t\tpathToCanvas(ctx, this._path, { flipY, scale, offsetX, offsetY });\n\t\t}\n\n\t\tif (fill !== \"none\") {\n\t\t\tctx.fillStyle = fill;\n\t\t\tctx.fill();\n\t\t}\n\t\tif (stroke) {\n\t\t\tctx.strokeStyle = stroke;\n\t\t\tctx.lineWidth = strokeWidth;\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\t/**\n\t * Get Path2D object for canvas\n\t */\n\ttoPath2D(options?: { flipY?: boolean; scale?: number }): Path2D {\n\t\tconst transformed = this.applyTransformToPath();\n\t\treturn createPath2D(transformed, options);\n\t}\n\n\t/**\n\t * Extract the raw GlyphPath (with transforms applied)\n\t */\n\ttoPath(): GlyphPath {\n\t\treturn this.applyTransformToPath();\n\t}\n\n\t/**\n\t * Clone this builder\n\t */\n\tclone(): PathBuilder {\n\t\treturn new PathBuilder(\n\t\t\tclonePath(this._path),\n\t\t\t{\n\t\t\t\tmatrix2D: [...this._transform.matrix2D] as Matrix2D,\n\t\t\t\tmatrix3D: this._transform.matrix3D\n\t\t\t\t\t? (this._transform.matrix3D.map((row) => [...row]) as Matrix3x3)\n\t\t\t\t\t: null,\n\t\t\t},\n\t\t\tthis._font,\n\t\t);\n\t}\n\n\t// === Private Helpers ===\n\n\t/**\n\t * Apply accumulated transforms to path\n\t */\n\tprivate applyTransformToPath(): GlyphPath {\n\t\tif (this._transform.matrix3D) {\n\t\t\t// Convert 2D matrix to 3x3 and combine with perspective\n\t\t\tconst m2d = this._transform.matrix2D;\n\t\t\tconst affine3x3: Matrix3x3 = [\n\t\t\t\t[m2d[0], m2d[2], m2d[4]],\n\t\t\t\t[m2d[1], m2d[3], m2d[5]],\n\t\t\t\t[0, 0, 1],\n\t\t\t];\n\t\t\tconst combined = multiply3x3(this._transform.matrix3D, affine3x3);\n\t\t\treturn transformOutline3D(this._path, combined);\n\t\t}\n\t\treturn transformOutline2D(this._path, this._transform.matrix2D);\n\t}\n\n\t/**\n\t * Check if there's any non-identity transform\n\t */\n\tprivate hasTransform(): boolean {\n\t\treturn this.hasTransform2D() || this._transform.matrix3D !== null;\n\t}\n\n\t/**\n\t * Check if 2D matrix is non-identity\n\t */\n\tprivate hasTransform2D(): boolean {\n\t\tconst m = this._transform.matrix2D;\n\t\treturn (\n\t\t\tm[0] !== 1 ||\n\t\t\tm[1] !== 0 ||\n\t\t\tm[2] !== 0 ||\n\t\t\tm[3] !== 1 ||\n\t\t\tm[4] !== 0 ||\n\t\t\tm[5] !== 0\n\t\t);\n\t}\n\n\t/**\n\t * Combine accumulated 2D transform with render options\n\t */\n\tprivate combinedMatrix2D(\n\t\tscale: number,\n\t\toffsetX: number,\n\t\toffsetY: number,\n\t): Matrix2D {\n\t\tconst m = this._transform.matrix2D;\n\t\treturn [\n\t\t\tm[0] * scale,\n\t\t\tm[1] * scale,\n\t\t\tm[2] * scale,\n\t\t\tm[3] * scale,\n\t\t\tm[0] * offsetX + m[2] * offsetY + m[4] * scale,\n\t\t\tm[1] * offsetX + m[3] * offsetY + m[5] * scale,\n\t\t];\n\t}\n\n\t/**\n\t * Combine accumulated transforms into 3x3 matrix with render options\n\t */\n\tprivate combinedMatrix3D(\n\t\tscale: number,\n\t\toffsetX: number,\n\t\toffsetY: number,\n\t): Matrix3x3 {\n\t\tconst m2d = this._transform.matrix2D;\n\t\tconst m3d = this._transform.matrix3D ?? identity3x3();\n\n\t\t// Combine: scale -> 2D transform -> 3D perspective -> offset\n\t\tconst affine3x3: Matrix3x3 = [\n\t\t\t[m2d[0] * scale, m2d[2] * scale, m2d[4] * scale + offsetX],\n\t\t\t[m2d[1] * scale, m2d[3] * scale, m2d[5] * scale + offsetY],\n\t\t\t[0, 0, 1],\n\t\t];\n\n\t\treturn multiply3x3(m3d, affine3x3);\n\t}\n}\n",
    "/**\n * Pipe-style functional utilities for composing transforms and rendering\n *\n * Provides an alternative to the builder pattern for users who prefer\n * functional composition.\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport {\n\ttype AsymmetricStrokeOptions,\n\tstrokeAsymmetricCombined as strokeAsymmetricCombinedFn,\n\tstrokeAsymmetric as strokeAsymmetricFn,\n} from \"../raster/asymmetric-stroke.ts\";\nimport {\n\tconvertBitmap,\n\tcopyBitmap,\n\temboldenBitmap as emboldenBitmapFn,\n\temboldenBitmapWithBearing,\n\tpadBitmap,\n\tresizeBitmapBilinear as resizeBitmapBilinearFn,\n\tresizeBitmap as resizeBitmapFn,\n\tshearBitmapX as shearBitmapXFn,\n\tshearBitmapY as shearBitmapYFn,\n\tshiftBitmap,\n\ttransformBitmap2D as transformBitmap2DFn,\n\ttransformBitmap3D as transformBitmap3DFn,\n} from \"../raster/bitmap-utils.ts\";\nimport { boxBlur as boxBlurFn, gaussianBlur } from \"../raster/blur.ts\";\nimport {\n\tadaptiveBlur as adaptiveBlurFn,\n\tcascadeBlur as cascadeBlurFn,\n\tfastGaussianBlur as fastGaussianBlurFn,\n} from \"../raster/cascade-blur.ts\";\nimport type { Gradient } from \"../raster/gradient.ts\";\nimport {\n\ttype MsdfOptions,\n\trenderMsdf as renderMsdfFn,\n} from \"../raster/msdf.ts\";\nimport { getPathBounds } from \"../raster/outline-decompose.ts\";\nimport {\n\tbitmapToGray as bitmapToGrayFn,\n\tbitmapToRGBA as bitmapToRGBAFn,\n\trasterizePath as rasterizePathFn,\n\trasterizePathWithGradient,\n} from \"../raster/rasterize.ts\";\nimport { renderSdf as renderSdfFn, type SdfOptions } from \"../raster/sdf.ts\";\nimport type { LineCap, LineJoin, StrokerOptions } from \"../raster/stroker.ts\";\nimport { strokePath as strokePathFn } from \"../raster/stroker.ts\";\nimport {\n\tcondensePath as condensePathFn,\n\temboldenPath as emboldenPathFn,\n\tobliquePath as obliquePathFn,\n} from \"../raster/synth.ts\";\nimport type {\n\tBitmap,\n\tPixelMode,\n\tRasterizeOptions,\n\tRasterizedGlyph,\n} from \"../raster/types.ts\";\nimport { FillRule, PixelMode as PM } from \"../raster/types.ts\";\nimport type { Matrix2D, Matrix3x3 } from \"../render/outline-transform.ts\";\nimport {\n\tclonePath,\n\tcombinePaths as combinePathsFn,\n\trotate2D,\n\tscale2D,\n\tshear2D,\n\ttransformOutline2D,\n\ttransformOutline3D,\n\ttranslate2D,\n} from \"../render/outline-transform.ts\";\nimport type { GlyphPath } from \"../render/path.ts\";\nimport { getGlyphPath, pathToSVG as pathToSVGFn } from \"../render/path.ts\";\nimport type { GlyphId } from \"../types.ts\";\n\n// === Pipe Function ===\n\n/**\n * Compose functions left-to-right\n *\n * @example\n * ```typescript\n * const result = pipe(\n *   getGlyphPath(font, glyphId),\n *   scale(2, 2),\n *   rotate(Math.PI / 4),\n *   rasterize({ width: 100, height: 100 }),\n *   blur(5),\n *   toRGBA\n * );\n * ```\n */\nexport function pipe<A>(a: A): A;\nexport function pipe<A, B>(a: A, ab: (a: A) => B): B;\nexport function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C;\nexport function pipe<A, B, C, D>(\n\ta: A,\n\tab: (a: A) => B,\n\tbc: (b: B) => C,\n\tcd: (c: C) => D,\n): D;\nexport function pipe<A, B, C, D, E>(\n\ta: A,\n\tab: (a: A) => B,\n\tbc: (b: B) => C,\n\tcd: (c: C) => D,\n\tde: (d: D) => E,\n): E;\nexport function pipe<A, B, C, D, E, F>(\n\ta: A,\n\tab: (a: A) => B,\n\tbc: (b: B) => C,\n\tcd: (c: C) => D,\n\tde: (d: D) => E,\n\tef: (e: E) => F,\n): F;\nexport function pipe<A, B, C, D, E, F, G>(\n\ta: A,\n\tab: (a: A) => B,\n\tbc: (b: B) => C,\n\tcd: (c: C) => D,\n\tde: (d: D) => E,\n\tef: (e: E) => F,\n\tfg: (f: F) => G,\n): G;\nexport function pipe<A, B, C, D, E, F, G, H>(\n\ta: A,\n\tab: (a: A) => B,\n\tbc: (b: B) => C,\n\tcd: (c: C) => D,\n\tde: (d: D) => E,\n\tef: (e: E) => F,\n\tfg: (f: F) => G,\n\tgh: (g: G) => H,\n): H;\nexport function pipe(\n\tinitial: unknown,\n\t...fns: Array<(x: unknown) => unknown>\n): unknown {\n\treturn fns.reduce((acc, fn) => fn(acc), initial);\n}\n\n// === Path Source ===\n\n/**\n * Get glyph path from font (for use with pipe)\n */\nexport function fromGlyph(font: Font, glyphId: GlyphId): GlyphPath | null {\n\treturn getGlyphPath(font, glyphId);\n}\n\n// === Path Transform Operators ===\n\n/**\n * Scale path uniformly or non-uniformly\n */\nexport function scale(sx: number, sy?: number): (path: GlyphPath) => GlyphPath {\n\treturn (path) => transformOutline2D(path, scale2D(sx, sy ?? sx));\n}\n\n/**\n * Translate path by offset\n */\nexport function translate(\n\tdx: number,\n\tdy: number,\n): (path: GlyphPath) => GlyphPath {\n\treturn (path) => transformOutline2D(path, translate2D(dx, dy));\n}\n\n/**\n * Rotate path by angle in radians\n */\nexport function rotate(angle: number): (path: GlyphPath) => GlyphPath {\n\treturn (path) => transformOutline2D(path, rotate2D(angle));\n}\n\n/**\n * Rotate path by angle in degrees\n */\nexport function rotateDeg(angleDeg: number): (path: GlyphPath) => GlyphPath {\n\treturn (path) =>\n\t\ttransformOutline2D(path, rotate2D((angleDeg * Math.PI) / 180));\n}\n\n/**\n * Shear/skew path\n */\nexport function shear(\n\tshearX: number,\n\tshearY: number,\n): (path: GlyphPath) => GlyphPath {\n\treturn (path) => transformOutline2D(path, shear2D(shearX, shearY));\n}\n\n/**\n * Apply italic slant (angle in degrees)\n */\nexport function italic(angleDeg: number): (path: GlyphPath) => GlyphPath {\n\tconst shearX = Math.tan((angleDeg * Math.PI) / 180);\n\treturn (path) => transformOutline2D(path, shear2D(shearX, 0));\n}\n\n/**\n * Apply custom 2D affine matrix\n */\nexport function matrix(m: Matrix2D): (path: GlyphPath) => GlyphPath {\n\treturn (path) => transformOutline2D(path, m);\n}\n\n/**\n * Apply 3D perspective matrix\n */\nexport function perspective(m: Matrix3x3): (path: GlyphPath) => GlyphPath {\n\treturn (path) => transformOutline3D(path, m);\n}\n\n// === Path Effects ===\n\n/**\n * Embolden path\n */\nexport function emboldenPath(strength: number): (path: GlyphPath) => GlyphPath {\n\treturn (path) => emboldenPathFn(path, strength);\n}\n\n/**\n * Condense/expand path horizontally\n */\nexport function condensePath(factor: number): (path: GlyphPath) => GlyphPath {\n\treturn (path) => condensePathFn(path, factor);\n}\n\n/**\n * Apply oblique/slant to path\n */\nexport function obliquePath(slant: number): (path: GlyphPath) => GlyphPath {\n\treturn (path) => obliquePathFn(path, slant);\n}\n\n/**\n * Stroke path to create outline\n */\nexport function strokePath(\n\toptions: StrokerOptions,\n): (path: GlyphPath) => GlyphPath;\nexport function strokePath(\n\twidth: number,\n\tcap?: LineCap,\n\tjoin?: LineJoin,\n): (path: GlyphPath) => GlyphPath;\nexport function strokePath(\n\toptionsOrWidth: StrokerOptions | number,\n\tcap?: LineCap,\n\tjoin?: LineJoin,\n): (path: GlyphPath) => GlyphPath {\n\tconst opts: StrokerOptions =\n\t\ttypeof optionsOrWidth === \"number\"\n\t\t\t? { width: optionsOrWidth, lineCap: cap, lineJoin: join }\n\t\t\t: optionsOrWidth;\n\treturn (path) => strokePathFn(path, opts);\n}\n\n/**\n * Clone path\n */\nexport function clone(): (path: GlyphPath) => GlyphPath {\n\treturn (path) => clonePath(path);\n}\n\n/**\n * Combine multiple paths\n */\nexport function combinePaths(paths: GlyphPath[]): GlyphPath {\n\treturn combinePathsFn(paths);\n}\n\n/**\n * Asymmetric stroke with independent X/Y border widths\n */\nexport function strokeAsymmetric(\n\toptions: AsymmetricStrokeOptions,\n): (path: GlyphPath) => { outer: GlyphPath; inner: GlyphPath } {\n\treturn (path) => strokeAsymmetricFn(path, options);\n}\n\n/**\n * Asymmetric stroke combined (both inner and outer as single fillable path)\n */\nexport function strokeAsymmetricCombined(\n\toptions: AsymmetricStrokeOptions,\n): (path: GlyphPath) => GlyphPath {\n\treturn (path) => strokeAsymmetricCombinedFn(path, options);\n}\n\n// === Rasterization (Path -> Bitmap) ===\n\n/**\n * Rasterize path to bitmap\n */\nexport function rasterize(\n\toptions: RasterizeOptions,\n): (path: GlyphPath) => Bitmap {\n\treturn (path) =>\n\t\trasterizePathFn(path, {\n\t\t\twidth: options.width ?? 100,\n\t\t\theight: options.height ?? 100,\n\t\t\tscale: options.scale ?? 1,\n\t\t\toffsetX: options.offsetX ?? 0,\n\t\t\toffsetY: options.offsetY ?? 0,\n\t\t\tpixelMode: options.pixelMode ?? PM.Gray,\n\t\t\tfillRule: options.fillRule ?? FillRule.NonZero,\n\t\t\tflipY: options.flipY ?? true,\n\t\t});\n}\n\n/**\n * Rasterize with auto-computed size from bounds\n */\nexport function rasterizeAuto(options?: {\n\tpadding?: number;\n\tscale?: number;\n\tpixelMode?: PixelMode;\n}): (path: GlyphPath) => Bitmap {\n\tconst { padding = 1, scale: s = 1, pixelMode = PM.Gray } = options ?? {};\n\treturn (path) => {\n\t\tconst bounds = getPathBounds(path, s, true);\n\t\tif (!bounds) {\n\t\t\tconst { createBitmap } = require(\"../raster/types.ts\");\n\t\t\treturn createBitmap(1, 1, pixelMode);\n\t\t}\n\n\t\tconst width = bounds.maxX - bounds.minX + padding * 2;\n\t\tconst height = bounds.maxY - bounds.minY + padding * 2;\n\t\tconst offsetX = -bounds.minX + padding;\n\t\tconst offsetY = -bounds.minY + padding;\n\n\t\treturn rasterizePathFn(path, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale: s,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tpixelMode,\n\t\t\tfillRule: FillRule.NonZero,\n\t\t\tflipY: true,\n\t\t});\n\t};\n}\n\n/**\n * Rasterize with gradient fill\n */\nexport function rasterizeWithGradient(\n\tgradient: Gradient,\n\toptions: RasterizeOptions,\n): (path: GlyphPath) => Bitmap {\n\treturn (path) =>\n\t\trasterizePathWithGradient(path, gradient, {\n\t\t\twidth: options.width ?? 100,\n\t\t\theight: options.height ?? 100,\n\t\t\tscale: options.scale ?? 1,\n\t\t\toffsetX: options.offsetX ?? 0,\n\t\t\toffsetY: options.offsetY ?? 0,\n\t\t\tpixelMode: options.pixelMode ?? PM.Gray,\n\t\t\tfillRule: options.fillRule ?? FillRule.NonZero,\n\t\t\tflipY: options.flipY ?? true,\n\t\t});\n}\n\n/**\n * Render path as Signed Distance Field\n */\nexport function renderSdf(options: SdfOptions): (path: GlyphPath) => Bitmap {\n\treturn (path) => renderSdfFn(path, options);\n}\n\n/**\n * Render path as Multi-channel Signed Distance Field\n */\nexport function renderMsdf(options: MsdfOptions): (path: GlyphPath) => Bitmap {\n\treturn (path) => renderMsdfFn(path, options);\n}\n\n// === Bitmap Operators ===\n\n/**\n * Gaussian blur bitmap\n */\nexport function blur(radius: number): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => gaussianBlur(copyBitmap(bitmap), radius);\n}\n\n/**\n * Box blur bitmap\n */\nexport function boxBlur(radius: number): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => boxBlurFn(copyBitmap(bitmap), radius);\n}\n\n/**\n * Cascade blur (fast for large radii)\n */\nexport function cascadeBlur(\n\tradiusX: number,\n\tradiusY?: number,\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\tcascadeBlurFn(copyBitmap(bitmap), radiusX, radiusY ?? radiusX);\n}\n\n/**\n * Adaptive blur (auto-selects best algorithm)\n */\nexport function adaptiveBlur(\n\tradiusX: number,\n\tradiusY?: number,\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\tadaptiveBlurFn(copyBitmap(bitmap), radiusX, radiusY ?? radiusX);\n}\n\n/**\n * Fast Gaussian blur using cascade algorithm\n * Recommended for large radii (> 3 pixels)\n */\nexport function fastBlur(radius: number): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => fastGaussianBlurFn(copyBitmap(bitmap), radius);\n}\n\n/**\n * Embolden bitmap operator\n */\nexport function embolden(\n\txStrength: number,\n\tyStrength?: number,\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\temboldenBitmapFn(bitmap, xStrength, yStrength ?? xStrength);\n}\n\n/**\n * Embolden bitmap and expand bearings (for rasterized glyphs)\n */\nexport function emboldenGlyph(\n\txStrength: number,\n\tyStrength?: number,\n): (glyph: RasterizedGlyph) => RasterizedGlyph {\n\treturn (glyph) =>\n\t\temboldenBitmapWithBearing(\n\t\t\tglyph.bitmap,\n\t\t\tglyph.bearingX,\n\t\t\tglyph.bearingY,\n\t\t\txStrength,\n\t\t\tyStrength ?? xStrength,\n\t\t);\n}\n\n/**\n * Transform bitmap with 2D matrix (origin at top-left)\n */\nexport function transformBitmap2D(\n\tmatrix: Matrix2D,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\ttransformBitmap2DFn(bitmap, matrix, {\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t}).bitmap;\n}\n\n/**\n * Transform bitmap with 3D matrix (origin at top-left)\n */\nexport function transformBitmap3D(\n\tmatrix: Matrix3x3,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\ttransformBitmap3DFn(bitmap, matrix, {\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t}).bitmap;\n}\n\n/**\n * Transform rasterized glyph with 2D matrix (bearing-aware)\n */\nexport function transformGlyph2D(\n\tmatrix: Matrix2D,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (glyph: RasterizedGlyph) => RasterizedGlyph {\n\treturn (glyph) =>\n\t\ttransformBitmap2DFn(glyph.bitmap, matrix, {\n\t\t\tbearingX: glyph.bearingX,\n\t\t\tbearingY: glyph.bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n}\n\n/**\n * Transform rasterized glyph with 3D matrix (bearing-aware)\n */\nexport function transformGlyph3D(\n\tmatrix: Matrix3x3,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (glyph: RasterizedGlyph) => RasterizedGlyph {\n\treturn (glyph) =>\n\t\ttransformBitmap3DFn(glyph.bitmap, matrix, {\n\t\t\tbearingX: glyph.bearingX,\n\t\t\tbearingY: glyph.bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n}\n\n/**\n * Shear bitmap horizontally (origin at top-left)\n */\nexport function shearBitmapX(\n\tamount: number,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\tshearBitmapXFn(bitmap, amount, {\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t}).bitmap;\n}\n\n/**\n * Shear bitmap vertically (origin at top-left)\n */\nexport function shearBitmapY(\n\tamount: number,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) =>\n\t\tshearBitmapYFn(bitmap, amount, {\n\t\t\tbearingX: 0,\n\t\t\tbearingY: 0,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t}).bitmap;\n}\n\n/**\n * Shear rasterized glyph horizontally (bearing-aware)\n */\nexport function shearGlyphX(\n\tamount: number,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (glyph: RasterizedGlyph) => RasterizedGlyph {\n\treturn (glyph) =>\n\t\tshearBitmapXFn(glyph.bitmap, amount, {\n\t\t\tbearingX: glyph.bearingX,\n\t\t\tbearingY: glyph.bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n}\n\n/**\n * Shear rasterized glyph vertically (bearing-aware)\n */\nexport function shearGlyphY(\n\tamount: number,\n\toptions?: { offsetX26?: number; offsetY26?: number },\n): (glyph: RasterizedGlyph) => RasterizedGlyph {\n\treturn (glyph) =>\n\t\tshearBitmapYFn(glyph.bitmap, amount, {\n\t\t\tbearingX: glyph.bearingX,\n\t\t\tbearingY: glyph.bearingY,\n\t\t\toffsetX26: options?.offsetX26,\n\t\t\toffsetY26: options?.offsetY26,\n\t\t});\n}\n\n/**\n * Shift bitmap position\n */\nexport function shift(dx: number, dy: number): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => shiftBitmap(bitmap, dx, dy);\n}\n\n/**\n * Resize bitmap with nearest-neighbor\n */\nexport function resize(\n\twidth: number,\n\theight: number,\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => resizeBitmapFn(bitmap, width, height);\n}\n\n/**\n * Resize bitmap with bilinear interpolation\n */\nexport function resizeBilinear(\n\twidth: number,\n\theight: number,\n): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => resizeBitmapBilinearFn(bitmap, width, height);\n}\n\n/**\n * Pad bitmap\n */\nexport function pad(\n\tleft: number,\n\ttop: number,\n\tright: number,\n\tbottom: number,\n): (bitmap: Bitmap) => Bitmap;\nexport function pad(all: number): (bitmap: Bitmap) => Bitmap;\nexport function pad(\n\tleftOrAll: number,\n\ttop?: number,\n\tright?: number,\n\tbottom?: number,\n): (bitmap: Bitmap) => Bitmap {\n\tconst l = leftOrAll;\n\tconst t = top ?? leftOrAll;\n\tconst r = right ?? leftOrAll;\n\tconst b = bottom ?? leftOrAll;\n\treturn (bitmap) => padBitmap(bitmap, l, t, r, b);\n}\n\n/**\n * Convert bitmap to different pixel mode\n */\nexport function convert(targetMode: PixelMode): (bitmap: Bitmap) => Bitmap {\n\treturn (bitmap) => convertBitmap(bitmap, targetMode);\n}\n\n// === Output Operators ===\n\n/**\n * Convert bitmap to RGBA array\n */\nexport function toRGBA(bitmap: Bitmap): Uint8Array {\n\treturn bitmapToRGBAFn(bitmap);\n}\n\n/**\n * Convert bitmap to grayscale array\n */\nexport function toGray(bitmap: Bitmap): Uint8Array {\n\treturn bitmapToGrayFn(bitmap);\n}\n\n/**\n * Convert path to SVG string\n */\nexport function toSVG(options?: {\n\tflipY?: boolean;\n\tscale?: number;\n}): (path: GlyphPath) => string {\n\treturn (path) => pathToSVGFn(path, options);\n}\n\n/**\n * Copy bitmap\n */\nexport function copy(bitmap: Bitmap): Bitmap {\n\treturn copyBitmap(bitmap);\n}\n",
    "/**\n * Fluent API for transform and rendering operations\n *\n * Provides two styles of composition:\n * 1. Builder pattern: glyph(font, id).scale(2).blur(5).toRGBA()\n * 2. Pipe pattern: pipe(path, scale(2), rasterize(...), blur(5), toRGBA)\n */\n\nimport type { Font } from \"../font/font.ts\";\nimport {\n\tatlasToAlpha,\n\tatlasToRGBA,\n\tbuildAsciiAtlas,\n\tbuildAtlas,\n\tbuildStringAtlas,\n\tgetGlyphUV,\n} from \"../raster/atlas.ts\";\nimport {\n\tbuildMsdfAsciiAtlas,\n\tbuildMsdfAtlas,\n\tbuildMsdfStringAtlas,\n\tmsdfAtlasToRGB,\n\tmsdfAtlasToRGBA,\n} from \"../raster/msdf.ts\";\nimport {\n\trasterizeGlyph,\n\trasterizeGlyphWithTransform,\n\trasterizeText,\n} from \"../raster/rasterize.ts\";\nimport type {\n\tAtlasOptions,\n\tBitmap,\n\tGlyphAtlas,\n\tMsdfAtlasOptions,\n} from \"../raster/types.ts\";\nimport type { GlyphPath } from \"../render/path.ts\";\nimport {\n\trenderShapedText,\n\trenderShapedTextWithVariation,\n\tshapedTextToSVG,\n\tshapedTextToSVGWithVariation,\n} from \"../render/path.ts\";\nimport type { GlyphId } from \"../types.ts\";\nimport { BitmapBuilder } from \"./bitmap-builder.ts\";\nimport { PathBuilder } from \"./path-builder.ts\";\n\n// === Builder Classes ===\n\nexport { BitmapBuilder } from \"./bitmap-builder.ts\";\nexport { PathBuilder } from \"./path-builder.ts\";\n\n// === Types ===\n\nexport type {\n\tAutoRasterOptions,\n\tCanvasOptions,\n\tRasterOptions,\n\tSVGElementOptions,\n\tSVGOptions,\n\tTransformState,\n} from \"./types.ts\";\n\n// === Entry Points ===\n\n/**\n * Create PathBuilder from a font glyph\n *\n * @example\n * ```typescript\n * const rgba = glyph(font, glyphId)\n *   ?.scale(2)\n *   .rotateDeg(15)\n *   .rasterizeAuto({ padding: 2 })\n *   .blur(5)\n *   .toRGBA();\n * ```\n */\nexport function glyph(font: Font, glyphId: GlyphId): PathBuilder | null {\n\treturn PathBuilder.fromGlyph(font, glyphId);\n}\n\n/**\n * Create PathBuilder from a character in a font\n *\n * @example\n * ```typescript\n * const rgba = char(font, \"A\")\n *   ?.scale(2)\n *   .rasterizeAuto()\n *   .toRGBA();\n * ```\n */\nexport function char(font: Font, character: string): PathBuilder | null {\n\tconst codepoint = character.codePointAt(0);\n\tif (codepoint === undefined) return null;\n\tconst glyphId = font.glyphId(codepoint);\n\tif (glyphId === undefined) return null;\n\treturn PathBuilder.fromGlyph(font, glyphId);\n}\n\n/**\n * Create PathBuilder from a font glyph with variable font coordinates\n *\n * @example\n * ```typescript\n * const rgba = glyphVar(font, glyphId, [400, 100])  // weight=400, width=100\n *   ?.scale(2)\n *   .rasterizeAuto()\n *   .toRGBA();\n * ```\n */\nexport function glyphVar(\n\tfont: Font,\n\tglyphId: GlyphId,\n\taxisCoords: number[],\n): PathBuilder | null {\n\treturn PathBuilder.fromGlyphWithVariation(font, glyphId, axisCoords);\n}\n\n/**\n * Wrap an existing GlyphPath in a PathBuilder\n *\n * @example\n * ```typescript\n * const existingPath = getGlyphPath(font, glyphId);\n * const rgba = path(existingPath)\n *   .scale(2)\n *   .rasterizeAuto()\n *   .toRGBA();\n * ```\n */\nexport function path(p: GlyphPath): PathBuilder {\n\treturn PathBuilder.fromPath(p);\n}\n\n/**\n * Wrap an existing Bitmap in a BitmapBuilder\n *\n * @example\n * ```typescript\n * const existingBitmap = rasterizePath(path, options);\n * const rgba = bitmap(existingBitmap)\n *   .blur(5)\n *   .toRGBA();\n * ```\n */\nexport function bitmap(b: Bitmap): BitmapBuilder {\n\treturn BitmapBuilder.fromBitmap(b);\n}\n\n/**\n * Combine multiple PathBuilders into one\n *\n * @example\n * ```typescript\n * const h = glyph(font, hGlyphId)?.translate(0, 0);\n * const i = glyph(font, iGlyphId)?.translate(100, 0);\n * if (h && i) {\n *   const combined = combine(h, i).scale(2).rasterizeAuto().toRGBA();\n * }\n * ```\n */\nexport function combine(...paths: PathBuilder[]): PathBuilder {\n\treturn PathBuilder.combine(...paths);\n}\n\n// === Pipe Function and Operators ===\n\nexport {\n\tadaptiveBlur,\n\t// Bitmap operators\n\tblur,\n\tboxBlur,\n\tcascadeBlur,\n\tclone,\n\tcombinePaths,\n\tcondensePath,\n\tconvert,\n\tcopy,\n\tembolden,\n\temboldenGlyph,\n\t// Path effects\n\temboldenPath,\n\t// Fast blur\n\tfastBlur,\n\t// Path source\n\tfromGlyph,\n\titalic,\n\tmatrix,\n\tobliquePath,\n\tpad,\n\tperspective,\n\t// Core pipe function\n\tpipe,\n\t// Rasterization (path -> bitmap)\n\trasterize,\n\trasterizeAuto,\n\trasterizeWithGradient,\n\trenderMsdf,\n\t// SDF/MSDF rendering\n\trenderSdf,\n\tresize,\n\tresizeBilinear,\n\trotate,\n\trotateDeg,\n\t// Path transform operators\n\tscale,\n\tshear,\n\tshearBitmapX,\n\tshearBitmapY,\n\tshearGlyphX,\n\tshearGlyphY,\n\tshift,\n\tstrokeAsymmetric,\n\tstrokeAsymmetricCombined,\n\t// Stroke operators\n\tstrokePath,\n\ttoGray,\n\t// Output operators\n\ttoRGBA,\n\ttoSVG,\n\ttransformBitmap2D,\n\ttransformBitmap3D,\n\ttransformGlyph2D,\n\ttransformGlyph3D,\n\ttranslate,\n} from \"./pipe.ts\";\n\n// === Atlas Building ===\n\nexport {\n\tbuildAtlas,\n\tbuildAsciiAtlas,\n\tbuildStringAtlas,\n\tatlasToRGBA,\n\tatlasToAlpha,\n\tgetGlyphUV,\n};\n\n// === MSDF Atlas Building ===\n\nexport {\n\tbuildMsdfAtlas,\n\tbuildMsdfAsciiAtlas,\n\tbuildMsdfStringAtlas,\n\tmsdfAtlasToRGB,\n\tmsdfAtlasToRGBA,\n};\n\n// === Direct Glyph Rasterization ===\n\nexport { rasterizeGlyph, rasterizeGlyphWithTransform, rasterizeText };\n\n// === Shaped Text Rendering ===\n\nexport {\n\trenderShapedText,\n\tshapedTextToSVG,\n\trenderShapedTextWithVariation,\n\tshapedTextToSVGWithVariation,\n};\n\n// === Re-export Types ===\n\nexport type { AtlasOptions, GlyphAtlas, MsdfAtlasOptions };\n",
    "import type {\n\tF2Dot14,\n\tFixed,\n\tint16,\n\tint32,\n\tOffset16,\n\tOffset32,\n\tTag,\n\tuint8,\n\tuint16,\n\tuint32,\n} from \"../../types.ts\";\n\n/**\n * Zero-copy binary reader for OpenType font data.\n * All multi-byte values are big-endian per OpenType spec.\n */\nexport class Reader {\n\tprivate readonly data: DataView;\n\tprivate readonly start: number;\n\tprivate readonly end: number;\n\tprivate pos: number;\n\n\tconstructor(buffer: ArrayBuffer | DataView, offset = 0, length?: number) {\n\t\tif (buffer instanceof ArrayBuffer) {\n\t\t\tthis.data = new DataView(buffer);\n\t\t\tthis.start = offset;\n\t\t\tthis.end = length !== undefined ? offset + length : buffer.byteLength;\n\t\t} else {\n\t\t\tthis.data = buffer;\n\t\t\tthis.start = buffer.byteOffset + offset;\n\t\t\tthis.end =\n\t\t\t\tlength !== undefined\n\t\t\t\t\t? this.start + length\n\t\t\t\t\t: buffer.byteOffset + buffer.byteLength;\n\t\t}\n\t\tthis.pos = this.start;\n\t}\n\n\t/** Current read position relative to start */\n\tget offset(): number {\n\t\treturn this.pos - this.start;\n\t}\n\n\t/** Bytes remaining to read */\n\tget remaining(): number {\n\t\treturn this.end - this.pos;\n\t}\n\n\t/** Total length of this reader's view */\n\tget length(): number {\n\t\treturn this.end - this.start;\n\t}\n\n\t/** Seek to absolute offset (relative to this reader's start) */\n\tseek(offset: number): void {\n\t\tthis.pos = this.start + offset;\n\t}\n\n\t/** Skip bytes */\n\tskip(bytes: number): void {\n\t\tthis.pos += bytes;\n\t}\n\n\t/** Create a sub-reader (zero-copy slice) */\n\tslice(offset: number, length: number): Reader {\n\t\treturn new Reader(this.data, this.start + offset, length);\n\t}\n\n\t/** Create a sub-reader from current position */\n\tsliceFrom(offset: number): Reader {\n\t\treturn new Reader(\n\t\t\tthis.data,\n\t\t\tthis.start + offset,\n\t\t\tthis.end - this.start - offset,\n\t\t);\n\t}\n\n\t/** Peek at a value without advancing position */\n\tpeek<T>(fn: () => T): T {\n\t\tconst savedPos = this.pos;\n\t\tconst result = fn();\n\t\tthis.pos = savedPos;\n\t\treturn result;\n\t}\n\n\t// Primitive readers (big-endian)\n\n\tuint8(): uint8 {\n\t\tconst value = this.data.getUint8(this.pos);\n\t\tthis.pos += 1;\n\t\treturn value;\n\t}\n\n\tint8(): number {\n\t\tconst value = this.data.getInt8(this.pos);\n\t\tthis.pos += 1;\n\t\treturn value;\n\t}\n\n\tuint16(): uint16 {\n\t\tconst value = this.data.getUint16(this.pos, false);\n\t\tthis.pos += 2;\n\t\treturn value;\n\t}\n\n\tint16(): int16 {\n\t\tconst value = this.data.getInt16(this.pos, false);\n\t\tthis.pos += 2;\n\t\treturn value;\n\t}\n\n\tuint32(): uint32 {\n\t\tconst value = this.data.getUint32(this.pos, false);\n\t\tthis.pos += 4;\n\t\treturn value;\n\t}\n\n\tint32(): int32 {\n\t\tconst value = this.data.getInt32(this.pos, false);\n\t\tthis.pos += 4;\n\t\treturn value;\n\t}\n\n\t// OpenType-specific types\n\n\t/** 16.16 fixed-point number */\n\tfixed(): Fixed {\n\t\treturn this.int32() / 65536;\n\t}\n\n\t/** 2.14 fixed-point number */\n\tf2dot14(): F2Dot14 {\n\t\treturn this.int16() / 16384;\n\t}\n\n\t/** Signed 16-bit integer in font design units */\n\tfword(): int16 {\n\t\treturn this.int16();\n\t}\n\n\t/** Unsigned 16-bit integer in font design units */\n\tufword(): uint16 {\n\t\treturn this.uint16();\n\t}\n\n\t/** 64-bit signed integer (seconds since 1904-01-01) */\n\tlongDateTime(): bigint {\n\t\tconst high = this.uint32();\n\t\tconst low = this.uint32();\n\t\treturn (BigInt(high) << 32n) | BigInt(low);\n\t}\n\n\t/** 4-byte ASCII tag as packed uint32 */\n\ttag(): Tag {\n\t\treturn this.uint32();\n\t}\n\n\t/** 4-byte ASCII tag as string */\n\ttagString(): string {\n\t\tconst t = this.uint32();\n\t\treturn String.fromCharCode(\n\t\t\t(t >> 24) & 0xff,\n\t\t\t(t >> 16) & 0xff,\n\t\t\t(t >> 8) & 0xff,\n\t\t\tt & 0xff,\n\t\t);\n\t}\n\n\t/** 16-bit offset */\n\toffset16(): Offset16 {\n\t\treturn this.uint16();\n\t}\n\n\t/** 32-bit offset */\n\toffset32(): Offset32 {\n\t\treturn this.uint32();\n\t}\n\n\t/** 24-bit unsigned integer */\n\tuint24(): number {\n\t\tconst b0 = this.data.getUint8(this.pos);\n\t\tconst b1 = this.data.getUint8(this.pos + 1);\n\t\tconst b2 = this.data.getUint8(this.pos + 2);\n\t\tthis.pos += 3;\n\t\treturn (b0 << 16) | (b1 << 8) | b2;\n\t}\n\n\t// Array readers\n\n\tuint8Array(count: number): Uint8Array {\n\t\tconst result = new Uint8Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.uint8();\n\t\t}\n\t\treturn result;\n\t}\n\n\tuint16Array(count: number): Uint16Array {\n\t\tconst result = new Uint16Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.uint16();\n\t\t}\n\t\treturn result;\n\t}\n\n\tint16Array(count: number): Int16Array {\n\t\tconst result = new Int16Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.int16();\n\t\t}\n\t\treturn result;\n\t}\n\n\tuint32Array(count: number): Uint32Array {\n\t\tconst result = new Uint32Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = this.uint32();\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Read array using custom reader function */\n\tarray<T>(count: number, readFn: (reader: Reader) => T): T[] {\n\t\tconst result: T[] = new Array(count);\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tresult[i] = readFn(this);\n\t\t}\n\t\treturn result;\n\t}\n\n\t// String readers\n\n\t/** Read ASCII string of given length */\n\tascii(length: number): string {\n\t\tlet result = \"\";\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult += String.fromCharCode(this.uint8());\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Read UTF-16BE string (used in 'name' table) */\n\tutf16be(length: number): string {\n\t\tconst chars: number[] = [];\n\t\tconst charCount = length / 2;\n\t\tfor (let i = 0; i < charCount; i++) {\n\t\t\tchars.push(this.uint16());\n\t\t}\n\t\treturn String.fromCharCode(...chars);\n\t}\n\n\t// Utility methods\n\n\t/** Check if there are enough bytes remaining */\n\thasRemaining(bytes: number): boolean {\n\t\treturn this.remaining >= bytes;\n\t}\n\n\t/** Throw if not enough bytes remaining */\n\tensureRemaining(bytes: number): void {\n\t\tif (this.remaining < bytes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unexpected end of data: need ${bytes} bytes, have ${this.remaining}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/** Get raw bytes as Uint8Array (zero-copy view) */\n\tbytes(length: number): Uint8Array {\n\t\tconst result = new Uint8Array(\n\t\t\tthis.data.buffer,\n\t\t\tthis.data.byteOffset + this.pos,\n\t\t\tlength,\n\t\t);\n\t\tthis.pos += length;\n\t\treturn result;\n\t}\n\n\t/** Read value at specific offset without moving position */\n\treadAt<T>(offset: number, fn: (reader: Reader) => T): T {\n\t\tconst savedPos = this.pos;\n\t\tthis.pos = this.start + offset;\n\t\tconst result = fn(this);\n\t\tthis.pos = savedPos;\n\t\treturn result;\n\t}\n}\n",
    "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Axis Variations table (avar)\n * Maps user-facing axis values to normalized coordinates\n */\nexport interface AvarTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\taxisSegmentMaps: AxisSegmentMap[];\n}\n\n/**\n * Segment map for an axis\n */\nexport interface AxisSegmentMap {\n\taxisValueMaps: AxisValueMap[];\n}\n\n/**\n * Single value mapping\n */\nexport interface AxisValueMap {\n\tfromCoordinate: number; // F2DOT14\n\ttoCoordinate: number; // F2DOT14\n}\n\n/**\n * Parse avar table\n */\nexport function parseAvar(reader: Reader, axisCount: number): AvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\treader.skip(2); // reserved\n\n\tconst axisSegmentMaps: AxisSegmentMap[] = [];\n\n\tfor (let i = 0; i < axisCount; i++) {\n\t\tconst positionMapCount = reader.uint16();\n\t\tconst axisValueMaps: AxisValueMap[] = [];\n\n\t\tfor (let j = 0; j < positionMapCount; j++) {\n\t\t\taxisValueMaps.push({\n\t\t\t\tfromCoordinate: reader.f2dot14(),\n\t\t\t\ttoCoordinate: reader.f2dot14(),\n\t\t\t});\n\t\t}\n\n\t\taxisSegmentMaps.push({ axisValueMaps });\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\taxisSegmentMaps,\n\t};\n}\n\n/**\n * Apply avar mapping to a normalized coordinate\n */\nexport function applyAvarMapping(\n\tsegmentMap: AxisSegmentMap,\n\tcoord: number,\n): number {\n\tconst maps = segmentMap.axisValueMaps;\n\n\tif (maps.length === 0) return coord;\n\n\t// Find the segment containing coord\n\tfor (let i = 0; i < maps.length - 1; i++) {\n\t\tconst map1 = maps[i];\n\t\tconst map2 = maps[i + 1];\n\t\tif (!map1 || !map2) continue;\n\n\t\tif (coord >= map1.fromCoordinate && coord <= map2.fromCoordinate) {\n\t\t\t// Linear interpolation\n\t\t\tconst t =\n\t\t\t\t(coord - map1.fromCoordinate) /\n\t\t\t\t(map2.fromCoordinate - map1.fromCoordinate);\n\t\t\treturn map1.toCoordinate + t * (map2.toCoordinate - map1.toCoordinate);\n\t\t}\n\t}\n\n\t// Clamp to range\n\tconst firstMap = maps[0];\n\tconst lastMap = maps[maps.length - 1];\n\tif (firstMap && coord <= firstMap.fromCoordinate) {\n\t\treturn firstMap.toCoordinate;\n\t}\n\treturn lastMap?.toCoordinate ?? coord;\n}\n\n/**\n * Apply avar mappings to all axis coordinates\n */\nexport function applyAvar(avar: AvarTable, coords: number[]): number[] {\n\tconst result: number[] = [];\n\n\tfor (let i = 0; i < coords.length; i++) {\n\t\tconst coord = coords[i]!;\n\t\tconst segmentMap = avar.axisSegmentMaps[i];\n\t\tif (segmentMap) {\n\t\t\tresult.push(applyAvarMapping(segmentMap, coord));\n\t\t} else {\n\t\t\tresult.push(coord);\n\t\t}\n\t}\n\n\treturn result;\n}\n",
    "import type { Fixed, Tag } from \"../../types.ts\";\nimport { tagToString } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Font Variations table (fvar)\n * Defines axes of variation in a variable font\n */\nexport interface FvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\taxes: VariationAxis[];\n\tinstances: NamedInstance[];\n}\n\n/**\n * Variation axis definition\n */\nexport interface VariationAxis {\n\t/** 4-byte axis tag (e.g., 'wght', 'wdth', 'ital') */\n\ttag: Tag;\n\t/** Minimum coordinate value */\n\tminValue: Fixed;\n\t/** Default coordinate value */\n\tdefaultValue: Fixed;\n\t/** Maximum coordinate value */\n\tmaxValue: Fixed;\n\t/** Axis qualifiers (flags) */\n\tflags: number;\n\t/** Name ID for this axis */\n\taxisNameId: number;\n}\n\n/**\n * Named instance (predefined variation)\n */\nexport interface NamedInstance {\n\t/** Name ID for this instance */\n\tsubfamilyNameId: number;\n\t/** Flags */\n\tflags: number;\n\t/** Coordinate values for each axis */\n\tcoordinates: Fixed[];\n\t/** PostScript name ID (optional) */\n\tpostScriptNameId?: number;\n}\n\n/**\n * Common axis tags\n */\nexport const AxisTags = {\n\t/** Weight (100-900, default 400) */\n\twght: 0x77676874,\n\t/** Width (50-200%, default 100) */\n\twdth: 0x77647468,\n\t/** Italic (0-1) */\n\tital: 0x6974616c,\n\t/** Slant (-90 to 90 degrees) */\n\tslnt: 0x736c6e74,\n\t/** Optical size (in points) */\n\topsz: 0x6f70737a,\n} as const;\n\n/**\n * Parse fvar table - font variations defining axes and named instances\n * @param reader - Reader positioned at start of fvar table\n * @returns Parsed fvar table with variation axes and instances\n */\nexport function parseFvar(reader: Reader): FvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst axesArrayOffset = reader.offset16();\n\treader.skip(2); // reserved\n\tconst axisCount = reader.uint16();\n\tconst axisSize = reader.uint16();\n\tconst instanceCount = reader.uint16();\n\tconst instanceSize = reader.uint16();\n\n\t// Parse axes\n\tconst axes: VariationAxis[] = [];\n\treader.seek(axesArrayOffset);\n\n\tfor (let i = 0; i < axisCount; i++) {\n\t\tconst axisStart = reader.offset;\n\t\tconst tag = reader.uint32();\n\t\tconst minValue = reader.fixed();\n\t\tconst defaultValue = reader.fixed();\n\t\tconst maxValue = reader.fixed();\n\t\tconst flags = reader.uint16();\n\t\tconst axisNameId = reader.uint16();\n\n\t\taxes.push({\n\t\t\ttag,\n\t\t\tminValue,\n\t\t\tdefaultValue,\n\t\t\tmaxValue,\n\t\t\tflags,\n\t\t\taxisNameId,\n\t\t});\n\n\t\t// Move to next axis (in case axisSize is larger than expected)\n\t\treader.seek(axisStart + axisSize);\n\t}\n\n\t// Parse instances\n\tconst instances: NamedInstance[] = [];\n\tconst hasPostScriptNameId = instanceSize >= 4 + axisCount * 4 + 2;\n\n\tfor (let i = 0; i < instanceCount; i++) {\n\t\tconst instanceStart = reader.offset;\n\t\tconst subfamilyNameId = reader.uint16();\n\t\tconst flags = reader.uint16();\n\n\t\tconst coordinates: Fixed[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tcoordinates.push(reader.fixed());\n\t\t}\n\n\t\tconst instance: NamedInstance = {\n\t\t\tsubfamilyNameId,\n\t\t\tflags,\n\t\t\tcoordinates,\n\t\t};\n\n\t\tif (hasPostScriptNameId) {\n\t\t\tinstance.postScriptNameId = reader.uint16();\n\t\t}\n\n\t\tinstances.push(instance);\n\n\t\t// Move to next instance\n\t\treader.seek(instanceStart + instanceSize);\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\taxes,\n\t\tinstances,\n\t};\n}\n\n/**\n * Normalize axis value to range [-1, 1]\n */\nexport function normalizeAxisValue(axis: VariationAxis, value: number): number {\n\tif (value < axis.defaultValue) {\n\t\tif (value < axis.minValue) value = axis.minValue;\n\t\tif (axis.defaultValue === axis.minValue) return 0;\n\t\treturn (value - axis.defaultValue) / (axis.defaultValue - axis.minValue);\n\t} else if (value > axis.defaultValue) {\n\t\tif (value > axis.maxValue) value = axis.maxValue;\n\t\tif (axis.defaultValue === axis.maxValue) return 0;\n\t\treturn (value - axis.defaultValue) / (axis.maxValue - axis.defaultValue);\n\t}\n\treturn 0;\n}\n\n/**\n * Get axis by tag\n */\nexport function getAxis(fvar: FvarTable, axisTag: Tag): VariationAxis | null {\n\treturn fvar.axes.find((a) => a.tag === axisTag) ?? null;\n}\n\n/**\n * Get axis index by tag\n */\nexport function getAxisIndex(fvar: FvarTable, axisTag: Tag): number {\n\treturn fvar.axes.findIndex((a) => a.tag === axisTag);\n}\n\n/**\n * Debug: Print axis info\n */\nexport function formatAxis(axis: VariationAxis): string {\n\treturn `${tagToString(axis.tag)}: ${axis.minValue.toFixed(1)}..${axis.defaultValue.toFixed(1)}..${axis.maxValue.toFixed(1)}`;\n}\n",
    "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Horizontal Metrics Variations table (HVAR)\n * Provides variations for horizontal advance widths and LSB\n */\nexport interface HvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\titemVariationStore: ItemVariationStore;\n\tadvanceWidthMapping: DeltaSetIndexMap | null;\n\tlsbMapping: DeltaSetIndexMap | null;\n\trsbMapping: DeltaSetIndexMap | null;\n}\n\n/**\n * Item Variation Store - stores delta values for variations\n */\nexport interface ItemVariationStore {\n\tformat: number;\n\tvariationRegions: VariationRegion[];\n\titemVariationData: ItemVariationData[];\n}\n\n/**\n * Variation region defines the space where deltas apply\n */\nexport interface VariationRegion {\n\tregionAxes: RegionAxisCoordinates[];\n}\n\n/**\n * Axis coordinates for a region\n */\nexport interface RegionAxisCoordinates {\n\tstartCoord: number; // F2DOT14\n\tpeakCoord: number;\n\tendCoord: number;\n}\n\n/**\n * Item variation data subtable\n */\nexport interface ItemVariationData {\n\titemCount: uint16;\n\tregionIndexes: uint16[];\n\tdeltaSets: number[][];\n}\n\n/**\n * Delta set index map for mapping glyphs to variation data\n */\nexport interface DeltaSetIndexMap {\n\tformat: number;\n\tmapCount: uint32;\n\tentryFormat: number;\n\tinnerIndexBitCount: number;\n\tmapData: { outer: number; inner: number }[];\n}\n\n/**\n * Parse HVAR table\n */\nexport function parseHvar(reader: Reader): HvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst itemVariationStoreOffset = reader.offset32();\n\tconst advanceWidthMappingOffset = reader.offset32();\n\tconst lsbMappingOffset = reader.offset32();\n\tconst rsbMappingOffset = reader.offset32();\n\n\t// Parse item variation store\n\tconst itemVariationStore = parseItemVariationStore(\n\t\treader.sliceFrom(itemVariationStoreOffset),\n\t);\n\n\t// Parse mappings\n\tconst advanceWidthMapping =\n\t\tadvanceWidthMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(advanceWidthMappingOffset))\n\t\t\t: null;\n\n\tconst lsbMapping =\n\t\tlsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(lsbMappingOffset))\n\t\t\t: null;\n\n\tconst rsbMapping =\n\t\trsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(rsbMappingOffset))\n\t\t\t: null;\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\titemVariationStore,\n\t\tadvanceWidthMapping,\n\t\tlsbMapping,\n\t\trsbMapping,\n\t};\n}\n\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.offset32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: uint32[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.offset32());\n\t}\n\n\t// Parse variation regions\n\tconst regionReader = reader.sliceFrom(variationRegionListOffset);\n\tconst axisCount = regionReader.uint16();\n\tconst regionCount = regionReader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: RegionAxisCoordinates[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: regionReader.f2dot14(),\n\t\t\t\tpeakCoord: regionReader.f2dot14(),\n\t\t\t\tendCoord: regionReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data\n\tconst itemVariationData: ItemVariationData[] = [];\n\tfor (let i = 0; i < itemVariationDataOffsets.length; i++) {\n\t\tconst offset = itemVariationDataOffsets[i]!;\n\t\tconst dataReader = reader.sliceFrom(offset);\n\t\tconst itemCount = dataReader.uint16();\n\t\tconst wordDeltaCount = dataReader.uint16();\n\t\tconst regionIndexCount = dataReader.uint16();\n\n\t\tconst regionIndexes: uint16[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(dataReader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\t\tconst shortCount = regionIndexCount - wordCount;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\t// Read word-sized deltas\n\t\t\tfor (let j = 0; j < wordCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int32());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read short-sized deltas\n\t\t\tfor (let j = 0; j < shortCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({ itemCount, regionIndexes, deltaSets });\n\t}\n\n\treturn { format, variationRegions, itemVariationData };\n}\n\nfunction parseDeltaSetIndexMap(reader: Reader): DeltaSetIndexMap {\n\tconst format = reader.uint8();\n\tconst entryFormat = reader.uint8();\n\tconst mapCount = format === 0 ? reader.uint16() : reader.uint32();\n\n\tconst innerIndexBitCount = (entryFormat & 0x0f) + 1;\n\tconst mapEntrySize = ((entryFormat >> 4) & 0x03) + 1;\n\n\tconst mapData: { outer: number; inner: number }[] = [];\n\tfor (let i = 0; i < mapCount; i++) {\n\t\tlet entry = 0;\n\t\tfor (let j = 0; j < mapEntrySize; j++) {\n\t\t\tentry = (entry << 8) | reader.uint8();\n\t\t}\n\n\t\tconst inner = entry & ((1 << innerIndexBitCount) - 1);\n\t\tconst outer = entry >> innerIndexBitCount;\n\t\tmapData.push({ outer, inner });\n\t}\n\n\treturn { format, mapCount, entryFormat, innerIndexBitCount, mapData };\n}\n\n/**\n * Calculate scalar for a variation region given axis coordinates\n */\nexport function calculateRegionScalar(\n\tregion: VariationRegion,\n\tcoords: number[], // Normalized axis coordinates [-1, 1]\n): number {\n\tlet scalar = 1.0;\n\n\tfor (let i = 0; i < region.regionAxes.length && i < coords.length; i++) {\n\t\tconst axis = region.regionAxes[i];\n\t\tconst coord = coords[i];\n\t\tif (axis === undefined || coord === undefined) continue;\n\n\t\t// Outside the region\n\t\tif (coord < axis.startCoord || coord > axis.endCoord) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// At peak\n\t\tif (coord === axis.peakCoord) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Interpolate\n\t\tif (coord < axis.peakCoord) {\n\t\t\tif (axis.peakCoord === axis.startCoord) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscalar *= (coord - axis.startCoord) / (axis.peakCoord - axis.startCoord);\n\t\t} else {\n\t\t\tif (axis.peakCoord === axis.endCoord) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscalar *= (axis.endCoord - coord) / (axis.endCoord - axis.peakCoord);\n\t\t}\n\t}\n\n\treturn scalar;\n}\n\n/**\n * Get delta for a glyph from HVAR using a specific mapping\n */\nfunction getDeltaFromMapping(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n\tmapping: DeltaSetIndexMap | null,\n): number {\n\t// Get outer/inner index\n\tlet outer: number;\n\tlet inner: number;\n\n\tif (mapping && glyphId < mapping.mapData.length) {\n\t\tconst entry = mapping.mapData[glyphId];\n\t\tif (!entry) {\n\t\t\touter = 0;\n\t\t\tinner = glyphId;\n\t\t} else {\n\t\t\touter = entry.outer;\n\t\t\tinner = entry.inner;\n\t\t}\n\t} else {\n\t\t// Direct mapping: outer = 0, inner = glyphId\n\t\touter = 0;\n\t\tinner = glyphId;\n\t}\n\n\t// Get variation data\n\tconst varData = hvar.itemVariationStore.itemVariationData[outer];\n\tif (!varData || inner >= varData.itemCount) {\n\t\treturn 0;\n\t}\n\n\tconst deltaSet = varData.deltaSets[inner];\n\tif (!deltaSet) {\n\t\treturn 0;\n\t}\n\n\t// Calculate total delta\n\tlet delta = 0;\n\tfor (let i = 0; i < varData.regionIndexes.length; i++) {\n\t\tconst regionIndex = varData.regionIndexes[i]!;\n\t\tconst region = hvar.itemVariationStore.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\tconst scalar = calculateRegionScalar(region, coords);\n\t\tconst regionDelta = deltaSet[i] ?? 0;\n\t\tdelta += scalar * regionDelta;\n\t}\n\n\treturn Math.round(delta);\n}\n\n/**\n * Get advance width delta for a glyph at given variation coordinates\n */\nexport function getAdvanceWidthDelta(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\treturn getDeltaFromMapping(hvar, glyphId, coords, hvar.advanceWidthMapping);\n}\n\n/**\n * Get left side bearing delta for a glyph at given variation coordinates\n */\nexport function getLsbDelta(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tif (!hvar.lsbMapping) {\n\t\treturn 0; // No LSB variations in this font\n\t}\n\treturn getDeltaFromMapping(hvar, glyphId, coords, hvar.lsbMapping);\n}\n\n/**\n * Get right side bearing delta for a glyph at given variation coordinates\n */\nexport function getRsbDelta(\n\thvar: HvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tif (!hvar.rsbMapping) {\n\t\treturn 0; // No RSB variations in this font\n\t}\n\treturn getDeltaFromMapping(hvar, glyphId, coords, hvar.rsbMapping);\n}\n",
    "import type { GlyphId, Tag, Variation } from \"../types.ts\";\nimport { tag } from \"../types.ts\";\nimport type { Font } from \"./font.ts\";\nimport { applyAvar } from \"./tables/avar.ts\";\nimport { normalizeAxisValue, type VariationAxis } from \"./tables/fvar.ts\";\nimport { getAdvanceWidthDelta, getLsbDelta } from \"./tables/hvar.ts\";\n\n/**\n * A Face represents a specific instance of a variable font.\n * For non-variable fonts, it simply wraps the Font.\n */\nexport class Face {\n\treadonly font: Font;\n\n\t/** Normalized axis coordinates [-1, 1] */\n\tprivate _coords: number[];\n\n\t/** User-space axis values */\n\tprivate _variations: Map<Tag, number>;\n\n\t/** Cached advance width deltas for variable fonts (glyphId -> delta) */\n\tprivate _advanceDeltas: Map<GlyphId, number> | null = null;\n\n\tconstructor(font: Font, variations?: Record<string, number> | Variation[]) {\n\t\tthis.font = font;\n\t\tthis._coords = [];\n\t\tthis._variations = new Map();\n\n\t\t// Initialize to default axis values\n\t\tconst fvar = font.fvar;\n\t\tif (fvar) {\n\t\t\tthis._coords = new Array(fvar.axes.length).fill(0);\n\n\t\t\t// Apply user variations\n\t\t\tif (variations) {\n\t\t\t\tthis.setVariations(variations);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set variation axis values\n\t * @param variations Object with axis tags as keys (e.g., { wght: 700, wdth: 100 })\n\t *                   or array of Variation objects\n\t */\n\tsetVariations(variations: Record<string, number> | Variation[]): void {\n\t\tconst fvar = this.font.fvar;\n\t\tif (!fvar) return;\n\n\t\t// Clear delta cache when variations change\n\t\tthis._advanceDeltas = null;\n\n\t\t// Convert to map\n\t\tif (Array.isArray(variations)) {\n\t\t\tfor (let i = 0; i < variations.length; i++) {\n\t\t\t\tconst v = variations[i]!;\n\t\t\t\tthis._variations.set(v.tag, v.value);\n\t\t\t}\n\t\t} else {\n\t\t\tconst entries = Object.entries(variations);\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\tconst [tagStr, value] = entries[i]!;\n\t\t\t\tconst t = tag(tagStr.padEnd(4, \" \"));\n\t\t\t\tthis._variations.set(t, value);\n\t\t\t}\n\t\t}\n\n\t\t// Normalize coordinates\n\t\tfor (let i = 0; i < fvar.axes.length; i++) {\n\t\t\tconst axis = fvar.axes[i]!;\n\t\t\tconst userValue = this._variations.get(axis.tag) ?? axis.defaultValue;\n\t\t\tthis._coords[i] = normalizeAxisValue(axis, userValue);\n\t\t}\n\n\t\t// Apply avar mapping if present\n\t\tconst avar = this.font.avar;\n\t\tif (avar) {\n\t\t\tthis._coords = applyAvar(avar, this._coords);\n\t\t}\n\t}\n\n\t/**\n\t * Get normalized coordinates for variation processing\n\t */\n\tget normalizedCoords(): number[] {\n\t\treturn this._coords;\n\t}\n\n\t/**\n\t * Check if this is a variable font instance\n\t */\n\tget isVariable(): boolean {\n\t\treturn this.font.isVariable;\n\t}\n\n\t/**\n\t * Get variation axes\n\t */\n\tget axes(): VariationAxis[] {\n\t\treturn this.font.fvar?.axes ?? [];\n\t}\n\n\t/**\n\t * Get current value for an axis\n\t */\n\tgetAxisValue(axisTag: Tag | string): number | null {\n\t\tconst t =\n\t\t\ttypeof axisTag === \"string\" ? tag(axisTag.padEnd(4, \" \")) : axisTag;\n\t\tconst fvar = this.font.fvar;\n\t\tif (!fvar) return null;\n\n\t\tconst value = this._variations.get(t);\n\t\tif (value !== undefined) return value;\n\n\t\tconst axis = fvar.axes.find((a) => a.tag === t);\n\t\treturn axis?.defaultValue ?? null;\n\t}\n\n\t/**\n\t * Get advance width for a glyph, including variation deltas\n\t */\n\tadvanceWidth(glyphId: GlyphId): number {\n\t\tconst advance = this.font.advanceWidth(glyphId);\n\n\t\t// Apply HVAR delta if variable\n\t\tif (this._coords.length > 0 && this.font.hvar) {\n\t\t\t// Check cache first\n\t\t\tif (this._advanceDeltas) {\n\t\t\t\tconst cached = this._advanceDeltas.get(glyphId);\n\t\t\t\tif (cached !== undefined) {\n\t\t\t\t\treturn advance + cached;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._advanceDeltas = new Map();\n\t\t\t}\n\n\t\t\t// Calculate and cache delta\n\t\t\tconst delta = getAdvanceWidthDelta(this.font.hvar, glyphId, this._coords);\n\t\t\tthis._advanceDeltas.set(glyphId, delta);\n\t\t\treturn advance + delta;\n\t\t}\n\n\t\treturn advance;\n\t}\n\n\t/**\n\t * Get left side bearing for a glyph, including variation deltas\n\t */\n\tleftSideBearing(glyphId: GlyphId): number {\n\t\tlet lsb = this.font.leftSideBearing(glyphId);\n\n\t\t// Apply HVAR LSB delta if variable\n\t\tif (this._coords.length > 0 && this.font.hvar) {\n\t\t\tconst delta = getLsbDelta(this.font.hvar, glyphId, this._coords);\n\t\t\tlsb += delta;\n\t\t}\n\n\t\treturn lsb;\n\t}\n\n\t// Delegate common properties to font\n\n\tget numGlyphs(): number {\n\t\treturn this.font.numGlyphs;\n\t}\n\n\tget unitsPerEm(): number {\n\t\treturn this.font.unitsPerEm;\n\t}\n\n\tget ascender(): number {\n\t\treturn this.font.ascender;\n\t}\n\n\tget descender(): number {\n\t\treturn this.font.descender;\n\t}\n\n\tget lineGap(): number {\n\t\treturn this.font.lineGap;\n\t}\n\n\tglyphId(codepoint: number): GlyphId {\n\t\treturn this.font.glyphId(codepoint);\n\t}\n\n\tglyphIdForChar(char: string): GlyphId {\n\t\treturn this.font.glyphIdForChar(char);\n\t}\n\n\thasTable(t: Tag): boolean {\n\t\treturn this.font.hasTable(t);\n\t}\n\n\t// Expose tables\n\tget gdef() {\n\t\treturn this.font.gdef;\n\t}\n\tget gsub() {\n\t\treturn this.font.gsub;\n\t}\n\tget gpos() {\n\t\treturn this.font.gpos;\n\t}\n\tget kern() {\n\t\treturn this.font.kern;\n\t}\n\tget morx() {\n\t\treturn this.font.morx;\n\t}\n\tget cmap() {\n\t\treturn this.font.cmap;\n\t}\n\tget hmtx() {\n\t\treturn this.font.hmtx;\n\t}\n\tget hhea() {\n\t\treturn this.font.hhea;\n\t}\n}\n\n/**\n * Create a face from a font with optional variations\n */\nexport function createFace(\n\tfont: Font,\n\tvariations?: Record<string, number> | Variation[],\n): Face {\n\treturn new Face(font, variations);\n}\n",
    "import { Reader } from \"./binary/reader.ts\";\n\nconst TTCF_MAGIC = 0x74746366; // \"ttcf\"\n\nexport interface TtcHeader {\n\tversion: number;\n\tnumFonts: number;\n\toffsets: number[];\n\tdsigTag?: number;\n\tdsigOffset?: number;\n\tdsigLength?: number;\n}\n\nexport function isTtc(buffer: ArrayBuffer): boolean {\n\tconst view = new DataView(buffer);\n\treturn view.getUint32(0, false) === TTCF_MAGIC;\n}\n\nexport function parseTtcHeader(buffer: ArrayBuffer): TtcHeader {\n\tconst reader = new Reader(buffer);\n\tconst tag = reader.uint32();\n\tif (tag !== TTCF_MAGIC) {\n\t\tthrow new Error(\"Invalid TTC header\");\n\t}\n\n\tconst version = reader.uint32();\n\tconst numFonts = reader.uint32();\n\tif (numFonts <= 0) {\n\t\tthrow new Error(\"Invalid TTC font count\");\n\t}\n\n\tconst maxFonts = Math.floor((buffer.byteLength - 12) / 4);\n\tif (numFonts > maxFonts) {\n\t\tthrow new Error(\"Invalid TTC font count\");\n\t}\n\n\tconst offsets: number[] = new Array(numFonts);\n\tfor (let i = 0; i < numFonts; i++) {\n\t\toffsets[i] = reader.uint32();\n\t}\n\n\tif (version === 0x00020000 && reader.remaining >= 12) {\n\t\tconst dsigTag = reader.uint32();\n\t\tconst dsigOffset = reader.uint32();\n\t\tconst dsigLength = reader.uint32();\n\t\treturn { version, numFonts, offsets, dsigTag, dsigOffset, dsigLength };\n\t}\n\n\treturn { version, numFonts, offsets };\n}\n",
    "/**\n * WOFF2 to SFNT Converter\n *\n * Converts WOFF2 compressed fonts back to raw TTF/OTF format.\n * Reference: https://www.w3.org/TR/WOFF2/\n */\n\n// Known table tags indexed by flag value 0-62\nconst KNOWN_TAGS = [\n\t\"cmap\",\n\t\"head\",\n\t\"hhea\",\n\t\"hmtx\",\n\t\"maxp\",\n\t\"name\",\n\t\"OS/2\",\n\t\"post\",\n\t\"cvt \",\n\t\"fpgm\",\n\t\"glyf\",\n\t\"loca\",\n\t\"prep\",\n\t\"CFF \",\n\t\"VORG\",\n\t\"EBDT\",\n\t\"EBLC\",\n\t\"gasp\",\n\t\"hdmx\",\n\t\"kern\",\n\t\"LTSH\",\n\t\"PCLT\",\n\t\"VDMX\",\n\t\"vhea\",\n\t\"vmtx\",\n\t\"BASE\",\n\t\"GDEF\",\n\t\"GPOS\",\n\t\"GSUB\",\n\t\"EBSC\",\n\t\"JSTF\",\n\t\"MATH\",\n\t\"CBDT\",\n\t\"CBLC\",\n\t\"COLR\",\n\t\"CPAL\",\n\t\"SVG \",\n\t\"sbix\",\n\t\"acnt\",\n\t\"avar\",\n\t\"bdat\",\n\t\"bloc\",\n\t\"bsln\",\n\t\"cvar\",\n\t\"fdsc\",\n\t\"feat\",\n\t\"fmtx\",\n\t\"fvar\",\n\t\"gvar\",\n\t\"hsty\",\n\t\"just\",\n\t\"lcar\",\n\t\"mort\",\n\t\"morx\",\n\t\"opbd\",\n\t\"prop\",\n\t\"trak\",\n\t\"Zapf\",\n\t\"Silf\",\n\t\"Glat\",\n\t\"Gloc\",\n\t\"Feat\",\n\t\"Sill\",\n];\n\ninterface Woff2TableEntry {\n\ttag: string;\n\torigLength: number;\n\ttransformLength: number;\n\ttransformVersion: number;\n}\n\n/** Read UIntBase128 variable-length integer */\nfunction readUIntBase128(data: Uint8Array, offset: { value: number }): number {\n\tlet result = 0;\n\tfor (let i = 0; i < 5; i++) {\n\t\tconst byte = data[offset.value++];\n\t\tif (i === 0 && byte === 0x80) {\n\t\t\tthrow new Error(\"Invalid UIntBase128: leading zeros\");\n\t\t}\n\t\tif (result > 0x1fffff) {\n\t\t\tthrow new Error(\"UIntBase128 overflow\");\n\t\t}\n\t\tresult = (result << 7) | (byte & 0x7f);\n\t\tif ((byte & 0x80) === 0) {\n\t\t\treturn result;\n\t\t}\n\t}\n\tthrow new Error(\"UIntBase128 too long\");\n}\n\n/** Read 255UInt16 */\nfunction read255UInt16(data: Uint8Array, offset: { value: number }): number {\n\tconst code = data[offset.value++];\n\tif (code === 253) {\n\t\tconst hi = data[offset.value++];\n\t\tconst lo = data[offset.value++];\n\t\treturn (hi << 8) | lo;\n\t} else if (code === 255) {\n\t\treturn data[offset.value++] + 253 * 2;\n\t} else if (code === 254) {\n\t\treturn data[offset.value++] + 253;\n\t}\n\treturn code;\n}\n\n/** Parse WOFF2 table directory entries */\nfunction parseTableDirectory(\n\tdata: Uint8Array,\n\toffset: { value: number },\n\tnumTables: number,\n): Woff2TableEntry[] {\n\tconst tables: Woff2TableEntry[] = [];\n\n\tfor (let i = 0; i < numTables; i++) {\n\t\tconst flags = data[offset.value++];\n\t\tconst tagIndex = flags & 0x3f;\n\t\tconst transformVersion = (flags >> 6) & 0x03;\n\n\t\tlet tag: string;\n\t\tif (tagIndex === 63) {\n\t\t\ttag = String.fromCharCode(\n\t\t\t\tdata[offset.value++],\n\t\t\t\tdata[offset.value++],\n\t\t\t\tdata[offset.value++],\n\t\t\t\tdata[offset.value++],\n\t\t\t);\n\t\t} else {\n\t\t\ttag = KNOWN_TAGS[tagIndex];\n\t\t}\n\n\t\tconst origLength = readUIntBase128(data, offset);\n\n\t\tlet transformLength = origLength;\n\t\t// glyf/loca: transform version 0 = transformed, 3 = null transform\n\t\t// others: transform version 0 = null transform\n\t\tconst hasTransform =\n\t\t\ttag === \"glyf\" || tag === \"loca\"\n\t\t\t\t? transformVersion === 0\n\t\t\t\t: transformVersion !== 0;\n\n\t\tif (hasTransform) {\n\t\t\ttransformLength = readUIntBase128(data, offset);\n\t\t}\n\n\t\ttables.push({ tag, origLength, transformLength, transformVersion });\n\t}\n\n\treturn tables;\n}\n\n/** Decompress Brotli data */\nasync function decompressBrotli(data: Uint8Array): Promise<Uint8Array> {\n\t// Try native DecompressionStream with \"brotli\" (Safari 18.4+, Deno)\n\tif (typeof DecompressionStream !== \"undefined\") {\n\t\ttry {\n\t\t\tconst ds = new DecompressionStream(\"brotli\" as CompressionFormat);\n\t\t\tconst blob = new Blob([data.buffer as ArrayBuffer]);\n\t\t\tconst decompressedStream = blob.stream().pipeThrough(ds);\n\t\t\tconst result = await new Response(decompressedStream).arrayBuffer();\n\t\t\treturn new Uint8Array(result);\n\t\t} catch {\n\t\t\t// \"brotli\" not supported in this browser\n\t\t}\n\t}\n\n\t// Pure TypeScript brotli decoder\n\tconst { decompress } = await import(\"./brotli/decode.ts\");\n\treturn decompress(data);\n}\n\n/** Write uint16 big-endian */\nfunction writeUint16BE(arr: Uint8Array, offset: number, value: number): void {\n\tarr[offset] = (value >> 8) & 0xff;\n\tarr[offset + 1] = value & 0xff;\n}\n\n/** Write uint32 big-endian */\nfunction writeUint32BE(arr: Uint8Array, offset: number, value: number): void {\n\tarr[offset] = (value >> 24) & 0xff;\n\tarr[offset + 1] = (value >> 16) & 0xff;\n\tarr[offset + 2] = (value >> 8) & 0xff;\n\tarr[offset + 3] = value & 0xff;\n}\n\n/** Read uint16 big-endian */\nfunction readUint16BE(arr: Uint8Array, offset: number): number {\n\treturn (arr[offset] << 8) | arr[offset + 1];\n}\n\n/** Read int16 big-endian */\nfunction readInt16BE(arr: Uint8Array, offset: number): number {\n\tconst val = readUint16BE(arr, offset);\n\treturn val >= 0x8000 ? val - 0x10000 : val;\n}\n\n/** Read uint32 big-endian */\nfunction readUint32BE(arr: Uint8Array, offset: number): number {\n\treturn (\n\t\t((arr[offset] << 24) |\n\t\t\t(arr[offset + 1] << 16) |\n\t\t\t(arr[offset + 2] << 8) |\n\t\t\tarr[offset + 3]) >>>\n\t\t0\n\t);\n}\n\n/** Calculate OpenType checksum */\nfunction calcChecksum(\n\tdata: Uint8Array,\n\toffset: number,\n\tlength: number,\n): number {\n\tlet sum = 0;\n\tconst nLongs = Math.ceil(length / 4);\n\tfor (let i = 0; i < nLongs; i++) {\n\t\tconst idx = offset + i * 4;\n\t\tsum =\n\t\t\t(sum +\n\t\t\t\t(((data[idx] || 0) << 24) |\n\t\t\t\t\t((data[idx + 1] || 0) << 16) |\n\t\t\t\t\t((data[idx + 2] || 0) << 8) |\n\t\t\t\t\t(data[idx + 3] || 0))) >>>\n\t\t\t0;\n\t}\n\treturn sum;\n}\n\n/** Round up to 4-byte boundary */\nfunction pad4(n: number): number {\n\treturn (n + 3) & ~3;\n}\n\n/**\n * Decode triplet-encoded coordinates from WOFF2 glyph stream.\n * Based on fonttools implementation.\n *\n * Flag byte structure:\n *   bit 7: on-curve (0) or off-curve (1) - NOTE: inverted from TrueType!\n *   bits 0-6: encoding index (0-127)\n *\n * Encoding index determines:\n *   0-9: dy only (1 byte)\n *   10-19: dx only (1 byte)\n *   20-83: dx and dy (1 byte total)\n *   84-119: dx and dy (2 bytes total)\n *   120-123: dx and dy (3 bytes total)\n *   124-127: dx and dy (4 bytes total)\n */\nfunction decodeTriplets(\n\tflagStream: Uint8Array,\n\tglyphStream: Uint8Array,\n\tnPoints: number,\n\tflagIdx: { value: number },\n\tglyphIdx: { value: number },\n): { x: number; y: number; onCurve: boolean }[] {\n\tconst points: { x: number; y: number; onCurve: boolean }[] = [];\n\tlet x = 0,\n\t\ty = 0;\n\n\tfunction withSign(flag: number, baseval: number): number {\n\t\treturn flag & 1 ? baseval : -baseval;\n\t}\n\n\tfor (let i = 0; i < nPoints; i++) {\n\t\tconst flag = flagStream[flagIdx.value++];\n\t\tconst onCurve = flag >> 7 === 0; // bit 7 clear = on curve\n\t\tconst flagValue = flag & 0x7f;\n\n\t\tlet dx = 0,\n\t\t\tdy = 0;\n\n\t\tif (flagValue < 10) {\n\t\t\t// dy only, 1 byte\n\t\t\tdx = 0;\n\t\t\tdy = withSign(\n\t\t\t\tflag,\n\t\t\t\t((flagValue & 14) << 7) + glyphStream[glyphIdx.value++],\n\t\t\t);\n\t\t} else if (flagValue < 20) {\n\t\t\t// dx only, 1 byte\n\t\t\tdx = withSign(\n\t\t\t\tflag,\n\t\t\t\t(((flagValue - 10) & 14) << 7) + glyphStream[glyphIdx.value++],\n\t\t\t);\n\t\t\tdy = 0;\n\t\t} else if (flagValue < 84) {\n\t\t\t// Both in 1 byte\n\t\t\tconst b0 = flagValue - 20;\n\t\t\tconst b1 = glyphStream[glyphIdx.value++];\n\t\t\tdx = withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\n\t\t\tdy = withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\n\t\t} else if (flagValue < 120) {\n\t\t\t// Both in 2 bytes\n\t\t\tconst b0 = flagValue - 84;\n\t\t\tdx = withSign(\n\t\t\t\tflag,\n\t\t\t\t1 + (Math.floor(b0 / 12) << 8) + glyphStream[glyphIdx.value++],\n\t\t\t);\n\t\t\tdy = withSign(\n\t\t\t\tflag >> 1,\n\t\t\t\t1 + (((b0 % 12) >> 2) << 8) + glyphStream[glyphIdx.value++],\n\t\t\t);\n\t\t} else if (flagValue < 124) {\n\t\t\t// Both in 3 bytes\n\t\t\tconst b1 = glyphStream[glyphIdx.value++];\n\t\t\tconst b2 = glyphStream[glyphIdx.value++];\n\t\t\tconst b3 = glyphStream[glyphIdx.value++];\n\t\t\tdx = withSign(flag, (b1 << 4) + (b2 >> 4));\n\t\t\tdy = withSign(flag >> 1, ((b2 & 0x0f) << 8) + b3);\n\t\t} else {\n\t\t\t// Both in 4 bytes\n\t\t\tdx = withSign(\n\t\t\t\tflag,\n\t\t\t\t(glyphStream[glyphIdx.value++] << 8) + glyphStream[glyphIdx.value++],\n\t\t\t);\n\t\t\tdy = withSign(\n\t\t\t\tflag >> 1,\n\t\t\t\t(glyphStream[glyphIdx.value++] << 8) + glyphStream[glyphIdx.value++],\n\t\t\t);\n\t\t}\n\n\t\tx += dx;\n\t\ty += dy;\n\t\tpoints.push({ x, y, onCurve });\n\t}\n\n\treturn points;\n}\n\n/** Reconstruct glyf and loca tables from WOFF2 transformed format */\nfunction reconstructGlyfLoca(\n\tglyfTransform: Uint8Array,\n\tnumGlyphs: number,\n\tindexFormat: number,\n): { glyf: Uint8Array; loca: Uint8Array } {\n\tlet offset = 0;\n\n\t// Read transformed glyf header (per WOFF2 spec Table 1)\n\tconst version = readUint16BE(glyfTransform, offset);\n\toffset += 2;\n\tif (version !== 0) {\n\t\tthrow new Error(`Unsupported glyf transform version: ${version}`);\n\t}\n\tconst optionFlags = readUint16BE(glyfTransform, offset);\n\toffset += 2;\n\tconst _numGlyphsHeader = readUint16BE(glyfTransform, offset);\n\toffset += 2;\n\tconst _indexFormatHeader = readUint16BE(glyfTransform, offset);\n\toffset += 2;\n\n\tconst nContourStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\tconst nPointsStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\tconst flagStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\tconst glyphStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\tconst compositeStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\tconst bboxStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\tconst instructionStreamSize = readUint32BE(glyfTransform, offset);\n\toffset += 4;\n\n\t// Extract streams\n\tconst nContourStream = glyfTransform.slice(\n\t\toffset,\n\t\toffset + nContourStreamSize,\n\t);\n\toffset += nContourStreamSize;\n\tconst nPointsStream = glyfTransform.slice(offset, offset + nPointsStreamSize);\n\toffset += nPointsStreamSize;\n\tconst flagStream = glyfTransform.slice(offset, offset + flagStreamSize);\n\toffset += flagStreamSize;\n\tconst glyphStream = glyfTransform.slice(offset, offset + glyphStreamSize);\n\toffset += glyphStreamSize;\n\tconst compositeStream = glyfTransform.slice(\n\t\toffset,\n\t\toffset + compositeStreamSize,\n\t);\n\toffset += compositeStreamSize;\n\tconst bboxStream = glyfTransform.slice(offset, offset + bboxStreamSize);\n\toffset += bboxStreamSize;\n\tconst instructionStream = glyfTransform.slice(\n\t\toffset,\n\t\toffset + instructionStreamSize,\n\t);\n\n\t// Stream indices\n\tconst nContourIdx = { value: 0 };\n\tconst nPointsIdx = { value: 0 };\n\tconst flagIdx = { value: 0 };\n\tconst glyphIdx = { value: 0 };\n\tconst compositeIdx = { value: 0 };\n\tconst bboxIdx = { value: 0 };\n\tconst instructionIdx = { value: 0 };\n\n\t// First pass: calculate glyf size\n\tconst glyphOffsets: number[] = [0];\n\tconst glyphParts: Uint8Array[] = [];\n\tlet totalGlyfSize = 0;\n\n\tfor (let g = 0; g < numGlyphs; g++) {\n\t\tconst nContours = readInt16BE(nContourStream, nContourIdx.value);\n\t\tnContourIdx.value += 2;\n\n\t\tif (nContours === 0) {\n\t\t\t// Empty glyph\n\t\t\tglyphParts.push(new Uint8Array(0));\n\t\t\tglyphOffsets.push(totalGlyfSize);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nContours > 0) {\n\t\t\t// Simple glyph\n\t\t\tconst glyphData = reconstructSimpleGlyph(\n\t\t\t\tnContours,\n\t\t\t\tnPointsStream,\n\t\t\t\tnPointsIdx,\n\t\t\t\tflagStream,\n\t\t\t\tflagIdx,\n\t\t\t\tglyphStream,\n\t\t\t\tglyphIdx,\n\t\t\t\tbboxStream,\n\t\t\t\tbboxIdx,\n\t\t\t\tinstructionStream,\n\t\t\t\tinstructionIdx,\n\t\t\t\toptionFlags,\n\t\t\t);\n\t\t\tglyphParts.push(glyphData);\n\t\t\ttotalGlyfSize += pad4(glyphData.length);\n\t\t\tglyphOffsets.push(totalGlyfSize);\n\t\t} else {\n\t\t\t// Composite glyph (nContours === -1)\n\t\t\tconst glyphData = reconstructCompositeGlyph(\n\t\t\t\tcompositeStream,\n\t\t\t\tcompositeIdx,\n\t\t\t\tbboxStream,\n\t\t\t\tbboxIdx,\n\t\t\t\tinstructionStream,\n\t\t\t\tinstructionIdx,\n\t\t\t\toptionFlags,\n\t\t\t);\n\t\t\tglyphParts.push(glyphData);\n\t\t\ttotalGlyfSize += pad4(glyphData.length);\n\t\t\tglyphOffsets.push(totalGlyfSize);\n\t\t}\n\t}\n\n\t// Build glyf table\n\tconst glyf = new Uint8Array(totalGlyfSize);\n\tlet glyfOffset = 0;\n\tfor (let i = 0; i < glyphParts.length; i++) {\n\t\tconst part = glyphParts[i]!;\n\t\tglyf.set(part, glyfOffset);\n\t\tglyfOffset += pad4(part.length);\n\t}\n\n\t// Build loca table\n\tconst locaSize =\n\t\tindexFormat === 0 ? (numGlyphs + 1) * 2 : (numGlyphs + 1) * 4;\n\tconst loca = new Uint8Array(locaSize);\n\n\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\tif (indexFormat === 0) {\n\t\t\twriteUint16BE(loca, i * 2, glyphOffsets[i] / 2);\n\t\t} else {\n\t\t\twriteUint32BE(loca, i * 4, glyphOffsets[i]);\n\t\t}\n\t}\n\n\treturn { glyf, loca };\n}\n\nfunction reconstructSimpleGlyph(\n\tnContours: number,\n\tnPointsStream: Uint8Array,\n\tnPointsIdx: { value: number },\n\tflagStream: Uint8Array,\n\tflagIdx: { value: number },\n\tglyphStream: Uint8Array,\n\tglyphIdx: { value: number },\n\tbboxStream: Uint8Array,\n\tbboxIdx: { value: number },\n\tinstructionStream: Uint8Array,\n\tinstructionIdx: { value: number },\n\toptionFlags: number,\n): Uint8Array {\n\t// Read endpoints\n\tconst endPtsOfContours: number[] = [];\n\tlet totalPoints = 0;\n\tfor (let c = 0; c < nContours; c++) {\n\t\tconst nPoints = read255UInt16(nPointsStream, nPointsIdx);\n\t\ttotalPoints += nPoints;\n\t\tendPtsOfContours.push(totalPoints - 1);\n\t}\n\n\t// Read point data using triplet encoding\n\tconst points = decodeTriplets(\n\t\tflagStream,\n\t\tglyphStream,\n\t\ttotalPoints,\n\t\tflagIdx,\n\t\tglyphIdx,\n\t);\n\n\t// Read/compute bbox\n\tlet xMin: number, yMin: number, xMax: number, yMax: number;\n\tconst bboxBitmap = (optionFlags & 1) === 0; // bit 0 clear = explicit bboxes stored\n\n\tif (bboxBitmap && bboxIdx.value + 8 <= bboxStream.length) {\n\t\txMin = readInt16BE(bboxStream, bboxIdx.value);\n\t\tbboxIdx.value += 2;\n\t\tyMin = readInt16BE(bboxStream, bboxIdx.value);\n\t\tbboxIdx.value += 2;\n\t\txMax = readInt16BE(bboxStream, bboxIdx.value);\n\t\tbboxIdx.value += 2;\n\t\tyMax = readInt16BE(bboxStream, bboxIdx.value);\n\t\tbboxIdx.value += 2;\n\t} else {\n\t\t// Compute bbox\n\t\txMin = yMin = 0x7fff;\n\t\txMax = yMax = -0x8000;\n\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\tconst pt = points[i]!;\n\t\t\txMin = Math.min(xMin, pt.x);\n\t\t\tyMin = Math.min(yMin, pt.y);\n\t\t\txMax = Math.max(xMax, pt.x);\n\t\t\tyMax = Math.max(yMax, pt.y);\n\t\t}\n\t}\n\n\t// Read instructions - length is read from glyphStream using 255UInt16 encoding\n\tconst instructionLength = read255UInt16(glyphStream, glyphIdx);\n\tconst instructions = instructionStream.slice(\n\t\tinstructionIdx.value,\n\t\tinstructionIdx.value + instructionLength,\n\t);\n\tinstructionIdx.value += instructionLength;\n\n\t// Encode glyph in TrueType format\n\t// Convert absolute coords to deltas and encode\n\tconst xDeltas: number[] = [];\n\tconst yDeltas: number[] = [];\n\tlet prevX = 0,\n\t\tprevY = 0;\n\tfor (let i = 0; i < points.length; i++) {\n\t\tconst pt = points[i]!;\n\t\txDeltas.push(pt.x - prevX);\n\t\tyDeltas.push(pt.y - prevY);\n\t\tprevX = pt.x;\n\t\tprevY = pt.y;\n\t}\n\n\t// Encode flags and coordinates\n\tconst encodedFlags: number[] = [];\n\tconst encodedX: number[] = [];\n\tconst encodedY: number[] = [];\n\n\tfor (let i = 0; i < totalPoints; i++) {\n\t\tlet flag = points[i].onCurve ? 1 : 0;\n\t\tconst dx = xDeltas[i];\n\t\tconst dy = yDeltas[i];\n\n\t\t// X encoding\n\t\tif (dx === 0) {\n\t\t\tflag |= 0x10; // x-same\n\t\t} else if (dx >= -255 && dx <= 255) {\n\t\t\tflag |= 0x02; // x-short\n\t\t\tif (dx > 0) flag |= 0x10; // positive\n\t\t\tencodedX.push(Math.abs(dx));\n\t\t} else {\n\t\t\tencodedX.push((dx >> 8) & 0xff, dx & 0xff);\n\t\t}\n\n\t\t// Y encoding\n\t\tif (dy === 0) {\n\t\t\tflag |= 0x20; // y-same\n\t\t} else if (dy >= -255 && dy <= 255) {\n\t\t\tflag |= 0x04; // y-short\n\t\t\tif (dy > 0) flag |= 0x20; // positive\n\t\t\tencodedY.push(Math.abs(dy));\n\t\t} else {\n\t\t\tencodedY.push((dy >> 8) & 0xff, dy & 0xff);\n\t\t}\n\n\t\tencodedFlags.push(flag);\n\t}\n\n\t// Build glyph buffer\n\tconst headerSize = 10 + nContours * 2 + 2 + instructionLength;\n\tconst totalSize =\n\t\theaderSize + encodedFlags.length + encodedX.length + encodedY.length;\n\tconst data = new Uint8Array(totalSize);\n\tlet off = 0;\n\n\t// Header\n\twriteUint16BE(data, off, nContours);\n\toff += 2;\n\twriteUint16BE(data, off, xMin & 0xffff);\n\toff += 2;\n\twriteUint16BE(data, off, yMin & 0xffff);\n\toff += 2;\n\twriteUint16BE(data, off, xMax & 0xffff);\n\toff += 2;\n\twriteUint16BE(data, off, yMax & 0xffff);\n\toff += 2;\n\n\t// End points\n\tfor (let i = 0; i < endPtsOfContours.length; i++) {\n\t\tconst endPt = endPtsOfContours[i]!;\n\t\twriteUint16BE(data, off, endPt);\n\t\toff += 2;\n\t}\n\n\t// Instructions\n\twriteUint16BE(data, off, instructionLength);\n\toff += 2;\n\tdata.set(instructions, off);\n\toff += instructionLength;\n\n\t// Flags\n\tfor (let i = 0; i < encodedFlags.length; i++) {\n\t\tconst f = encodedFlags[i]!;\n\t\tdata[off++] = f;\n\t}\n\n\t// X coordinates\n\tfor (let i = 0; i < encodedX.length; i++) {\n\t\tconst x = encodedX[i]!;\n\t\tdata[off++] = x;\n\t}\n\n\t// Y coordinates\n\tfor (let i = 0; i < encodedY.length; i++) {\n\t\tconst y = encodedY[i]!;\n\t\tdata[off++] = y;\n\t}\n\n\treturn data.slice(0, off);\n}\n\nfunction reconstructCompositeGlyph(\n\tcompositeStream: Uint8Array,\n\tcompositeIdx: { value: number },\n\tbboxStream: Uint8Array,\n\tbboxIdx: { value: number },\n\tinstructionStream: Uint8Array,\n\tinstructionIdx: { value: number },\n\t_optionFlags: number,\n): Uint8Array {\n\tconst parts: number[] = [];\n\n\t// Read bbox\n\tconst xMin = readInt16BE(bboxStream, bboxIdx.value);\n\tbboxIdx.value += 2;\n\tconst yMin = readInt16BE(bboxStream, bboxIdx.value);\n\tbboxIdx.value += 2;\n\tconst xMax = readInt16BE(bboxStream, bboxIdx.value);\n\tbboxIdx.value += 2;\n\tconst yMax = readInt16BE(bboxStream, bboxIdx.value);\n\tbboxIdx.value += 2;\n\n\t// Header\n\tparts.push(0xff, 0xff); // nContours = -1\n\tparts.push((xMin >> 8) & 0xff, xMin & 0xff);\n\tparts.push((yMin >> 8) & 0xff, yMin & 0xff);\n\tparts.push((xMax >> 8) & 0xff, xMax & 0xff);\n\tparts.push((yMax >> 8) & 0xff, yMax & 0xff);\n\n\t// Read components\n\tlet hasMoreComponents = true;\n\tlet hasInstructions = false;\n\n\twhile (hasMoreComponents) {\n\t\tconst flags = readUint16BE(compositeStream, compositeIdx.value);\n\t\tcompositeIdx.value += 2;\n\t\tconst glyphIndex = readUint16BE(compositeStream, compositeIdx.value);\n\t\tcompositeIdx.value += 2;\n\n\t\tparts.push((flags >> 8) & 0xff, flags & 0xff);\n\t\tparts.push((glyphIndex >> 8) & 0xff, glyphIndex & 0xff);\n\n\t\t// Arguments\n\t\tif (flags & 0x0001) {\n\t\t\t// ARG_1_AND_2_ARE_WORDS\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t} else {\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t}\n\n\t\t// Transform\n\t\tif (flags & 0x0008) {\n\t\t\t// WE_HAVE_A_SCALE\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t} else if (flags & 0x0040) {\n\t\t\t// WE_HAVE_AN_X_AND_Y_SCALE\n\t\t\tfor (let i = 0; i < 4; i++)\n\t\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t} else if (flags & 0x0080) {\n\t\t\t// WE_HAVE_A_TWO_BY_TWO\n\t\t\tfor (let i = 0; i < 8; i++)\n\t\t\t\tparts.push(compositeStream[compositeIdx.value++]);\n\t\t}\n\n\t\thasMoreComponents = (flags & 0x0020) !== 0;\n\t\tif (flags & 0x0100) hasInstructions = true;\n\t}\n\n\t// Instructions\n\tif (hasInstructions) {\n\t\tconst instrLen = read255UInt16(instructionStream, instructionIdx);\n\t\tparts.push((instrLen >> 8) & 0xff, instrLen & 0xff);\n\t\tfor (let i = 0; i < instrLen; i++) {\n\t\t\tparts.push(instructionStream[instructionIdx.value++]);\n\t\t}\n\t}\n\n\treturn new Uint8Array(parts);\n}\n\n/** Convert WOFF2 to SFNT */\nexport async function woff2ToSfnt(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n\tconst data = new Uint8Array(buffer);\n\tconst view = new DataView(buffer);\n\n\t// Read header\n\tconst signature = view.getUint32(0, false);\n\tif (signature !== 0x774f4632) {\n\t\tthrow new Error(\"Not a valid WOFF2 file\");\n\t}\n\n\tconst flavor = view.getUint32(4, false);\n\tconst numTables = view.getUint16(12, false);\n\tconst totalCompressedSize = view.getUint32(20, false);\n\n\t// Parse table directory\n\tconst offset = { value: 48 };\n\tconst tables = parseTableDirectory(data, offset, numTables);\n\n\t// Decompress all table data\n\tconst compressedData = data.slice(\n\t\toffset.value,\n\t\toffset.value + totalCompressedSize,\n\t);\n\tconst decompressedData = await decompressBrotli(compressedData);\n\n\t// Extract individual table data\n\tconst tableData: Map<string, Uint8Array> = new Map();\n\tlet decompOffset = 0;\n\n\tfor (let i = 0; i < tables.length; i++) {\n\t\tconst table = tables[i]!;\n\t\tconst tdata = decompressedData.slice(\n\t\t\tdecompOffset,\n\t\t\tdecompOffset + table.transformLength,\n\t\t);\n\t\ttableData.set(table.tag, tdata);\n\t\tdecompOffset += table.transformLength;\n\t}\n\n\t// Get metadata from maxp and head\n\tconst maxpData = tableData.get(\"maxp\");\n\tconst headData = tableData.get(\"head\");\n\tif (!maxpData || !headData) {\n\t\tthrow new Error(\"Missing required tables\");\n\t}\n\n\tconst numGlyphs = readUint16BE(maxpData, 4);\n\tconst indexToLocFormat = readInt16BE(headData, 50);\n\n\t// Handle glyf/loca transform\n\tconst glyfEntry = tables.find((t) => t.tag === \"glyf\");\n\tconst locaEntry = tables.find((t) => t.tag === \"loca\");\n\n\tif (glyfEntry && glyfEntry.transformVersion === 0) {\n\t\tconst glyfTransformed = tableData.get(\"glyf\");\n\t\tif (!glyfTransformed) {\n\t\t\tthrow new Error(\"Missing glyf table data for transform\");\n\t\t}\n\t\tconst { glyf, loca } = reconstructGlyfLoca(\n\t\t\tglyfTransformed,\n\t\t\tnumGlyphs,\n\t\t\tindexToLocFormat,\n\t\t);\n\t\ttableData.set(\"glyf\", glyf);\n\t\ttableData.set(\"loca\", loca);\n\n\t\t// Update lengths\n\t\tglyfEntry.origLength = glyf.length;\n\t\tif (locaEntry) {\n\t\t\tlocaEntry.origLength = loca.length;\n\t\t}\n\t}\n\n\t// Calculate SFNT size\n\tconst headerSize = 12;\n\tconst directorySize = numTables * 16;\n\tlet tableOffset = headerSize + directorySize;\n\n\tconst tableOffsets: number[] = [];\n\tfor (let i = 0; i < tables.length; i++) {\n\t\tconst table = tables[i]!;\n\t\ttableOffsets.push(tableOffset);\n\t\ttableOffset += pad4(table.origLength);\n\t}\n\n\t// Build output\n\tconst output = new Uint8Array(tableOffset);\n\n\t// SFNT header\n\tconst searchRange = 2 ** Math.floor(Math.log2(numTables)) * 16;\n\tconst entrySelector = Math.floor(Math.log2(numTables));\n\tconst rangeShift = numTables * 16 - searchRange;\n\n\twriteUint32BE(output, 0, flavor);\n\twriteUint16BE(output, 4, numTables);\n\twriteUint16BE(output, 6, searchRange);\n\twriteUint16BE(output, 8, entrySelector);\n\twriteUint16BE(output, 10, rangeShift);\n\n\t// Table directory and data\n\tlet headOffset = -1;\n\tfor (let i = 0; i < tables.length; i++) {\n\t\tconst table = tables[i];\n\t\tconst tdata = tableData.get(table.tag);\n\t\tif (!tdata) {\n\t\t\tthrow new Error(`Missing table data for ${table.tag}`);\n\t\t}\n\t\tconst dirOffset = headerSize + i * 16;\n\n\t\tconst tableOff = tableOffsets[i];\n\t\tif (table.tag === \"head\" && tableOff !== undefined) {\n\t\t\theadOffset = tableOff;\n\t\t}\n\n\t\t// Tag\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\toutput[dirOffset + j] = table.tag.charCodeAt(j);\n\t\t}\n\n\t\t// Checksum\n\t\tconst checksum = calcChecksum(tdata, 0, tdata.length);\n\t\twriteUint32BE(output, dirOffset + 4, checksum);\n\n\t\t// Offset\n\t\twriteUint32BE(output, dirOffset + 8, tableOffsets[i]);\n\n\t\t// Length\n\t\twriteUint32BE(output, dirOffset + 12, table.origLength);\n\n\t\t// Copy table data\n\t\toutput.set(tdata.slice(0, table.origLength), tableOffsets[i]);\n\t}\n\n\t// Fix head checksum adjustment\n\tif (headOffset >= 0) {\n\t\tconst totalChecksum = calcChecksum(output, 0, output.length);\n\t\tconst checksumAdjustment = (0xb1b0afba - totalChecksum) >>> 0;\n\t\twriteUint32BE(output, headOffset + 8, checksumAdjustment);\n\t}\n\n\treturn output.buffer;\n}\n",
    "import type { int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * BASE table - Baseline alignment data\n * Provides baseline offsets for scripts to align mixed-script text\n */\n\n/** Baseline tags */\nexport const BaselineTag = {\n\t/** Hanging baseline (Devanagari, Tibetan) */\n\thang: 0x68616e67,\n\t/** Ideographic character face bottom edge (CJK) */\n\ticfb: 0x69636662,\n\t/** Ideographic character face top edge (CJK) */\n\ticft: 0x69636674,\n\t/** Ideographic em-box bottom edge (CJK) */\n\tideo: 0x6964656f,\n\t/** Ideographic em-box top edge */\n\tidtp: 0x69647470,\n\t/** Mathematical baseline (math layout) */\n\tmath: 0x6d617468,\n\t/** Roman baseline (Latin, Greek, Cyrillic) */\n\tromn: 0x726f6d6e,\n} as const;\n\n/** A single baseline value */\nexport interface BaselineValue {\n\tbaselineTag: number;\n\tcoordinate: int16;\n}\n\n/** Min/max extent values */\nexport interface MinMaxRecord {\n\tminCoord: int16 | null;\n\tmaxCoord: int16 | null;\n}\n\n/** Feature-specific min/max values */\nexport interface FeatMinMaxRecord {\n\tfeatureTag: number;\n\tminCoord: int16 | null;\n\tmaxCoord: int16 | null;\n}\n\n/** Base values for a script */\nexport interface BaseValues {\n\tdefaultBaselineIndex: uint16;\n\tbaseCoords: int16[];\n}\n\n/** MinMax values for a language system */\nexport interface MinMax {\n\tminCoord: int16 | null;\n\tmaxCoord: int16 | null;\n\tfeatMinMaxRecords: FeatMinMaxRecord[];\n}\n\n/** Base script record */\nexport interface BaseScriptRecord {\n\tscriptTag: number;\n\tbaseValues: BaseValues | null;\n\tdefaultMinMax: MinMax | null;\n\tbaseLangSysRecords: Map<number, MinMax>;\n}\n\n/** Axis table (horizontal or vertical) */\nexport interface AxisTable {\n\tbaseTagList: number[];\n\tbaseScriptList: BaseScriptRecord[];\n}\n\n/** BASE table */\nexport interface BaseTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\thorizAxis: AxisTable | null;\n\tvertAxis: AxisTable | null;\n}\n\n/** Coordinate format */\ninterface BaseCoord {\n\tformat: uint16;\n\tcoordinate: int16;\n\treferenceGlyph?: uint16;\n\tbaseCoordPoint?: uint16;\n\tdeviceOffset?: uint16;\n}\n\nfunction parseBaseCoord(reader: Reader): BaseCoord {\n\tconst format = reader.uint16();\n\tconst coordinate = reader.int16();\n\n\tconst result: BaseCoord = { format, coordinate };\n\n\tif (format === 2) {\n\t\tresult.referenceGlyph = reader.uint16();\n\t\tresult.baseCoordPoint = reader.uint16();\n\t} else if (format === 3) {\n\t\tresult.deviceOffset = reader.uint16();\n\t}\n\n\treturn result;\n}\n\nfunction parseMinMax(reader: Reader, minMaxOffset: number): MinMax | null {\n\tif (minMaxOffset === 0) return null;\n\n\tconst minMaxReader = reader.sliceFrom(minMaxOffset);\n\tconst minCoordOffset = minMaxReader.uint16();\n\tconst maxCoordOffset = minMaxReader.uint16();\n\tconst featMinMaxCount = minMaxReader.uint16();\n\n\tlet minCoord: int16 | null = null;\n\tlet maxCoord: int16 | null = null;\n\n\tif (minCoordOffset !== 0) {\n\t\tconst coordReader = reader.sliceFrom(minMaxOffset + minCoordOffset);\n\t\tminCoord = parseBaseCoord(coordReader).coordinate;\n\t}\n\n\tif (maxCoordOffset !== 0) {\n\t\tconst coordReader = reader.sliceFrom(minMaxOffset + maxCoordOffset);\n\t\tmaxCoord = parseBaseCoord(coordReader).coordinate;\n\t}\n\n\tconst featMinMaxRecords: FeatMinMaxRecord[] = [];\n\tfor (let i = 0; i < featMinMaxCount; i++) {\n\t\tconst featureTag = minMaxReader.uint32();\n\t\tconst minOffset = minMaxReader.uint16();\n\t\tconst maxOffset = minMaxReader.uint16();\n\n\t\tlet featMin: int16 | null = null;\n\t\tlet featMax: int16 | null = null;\n\n\t\tif (minOffset !== 0) {\n\t\t\tconst coordReader = reader.sliceFrom(minMaxOffset + minOffset);\n\t\t\tfeatMin = parseBaseCoord(coordReader).coordinate;\n\t\t}\n\n\t\tif (maxOffset !== 0) {\n\t\t\tconst coordReader = reader.sliceFrom(minMaxOffset + maxOffset);\n\t\t\tfeatMax = parseBaseCoord(coordReader).coordinate;\n\t\t}\n\n\t\tfeatMinMaxRecords.push({\n\t\t\tfeatureTag,\n\t\t\tminCoord: featMin,\n\t\t\tmaxCoord: featMax,\n\t\t});\n\t}\n\n\treturn { minCoord, maxCoord, featMinMaxRecords };\n}\n\nfunction parseBaseValues(\n\treader: Reader,\n\tbaseValuesOffset: number,\n\t_baseTagList: number[],\n): BaseValues | null {\n\tif (baseValuesOffset === 0) return null;\n\n\tconst bvReader = reader.sliceFrom(baseValuesOffset);\n\tconst defaultBaselineIndex = bvReader.uint16();\n\tconst baseCoordCount = bvReader.uint16();\n\n\tconst coordOffsets: uint16[] = [];\n\tfor (let i = 0; i < baseCoordCount; i++) {\n\t\tcoordOffsets.push(bvReader.uint16());\n\t}\n\n\tconst baseCoords: int16[] = [];\n\tfor (let i = 0; i < coordOffsets.length; i++) {\n\t\tconst offset = coordOffsets[i]!;\n\t\tif (offset !== 0) {\n\t\t\tconst coordReader = reader.sliceFrom(baseValuesOffset + offset);\n\t\t\tbaseCoords.push(parseBaseCoord(coordReader).coordinate);\n\t\t} else {\n\t\t\tbaseCoords.push(0);\n\t\t}\n\t}\n\n\treturn { defaultBaselineIndex, baseCoords };\n}\n\nfunction parseBaseScriptRecord(\n\treader: Reader,\n\tscriptOffset: number,\n\tbaseTagList: number[],\n): Omit<BaseScriptRecord, \"scriptTag\"> {\n\tconst scriptReader = reader.sliceFrom(scriptOffset);\n\tconst baseValuesOffset = scriptReader.uint16();\n\tconst defaultMinMaxOffset = scriptReader.uint16();\n\tconst baseLangSysCount = scriptReader.uint16();\n\n\tconst baseLangSysRecords = new Map<number, MinMax>();\n\tconst langSysData: Array<{ tag: number; offset: number }> = [];\n\n\tfor (let i = 0; i < baseLangSysCount; i++) {\n\t\tconst tag = scriptReader.uint32();\n\t\tconst offset = scriptReader.uint16();\n\t\tlangSysData.push({ tag, offset });\n\t}\n\n\tconst baseValues = parseBaseValues(\n\t\treader,\n\t\tscriptOffset + baseValuesOffset,\n\t\tbaseTagList,\n\t);\n\tconst defaultMinMax = parseMinMax(reader, scriptOffset + defaultMinMaxOffset);\n\n\tfor (let i = 0; i < langSysData.length; i++) {\n\t\tconst item = langSysData[i]!;\n\t\tconst minMax = parseMinMax(reader, scriptOffset + item.offset);\n\t\tif (minMax) {\n\t\t\tbaseLangSysRecords.set(item.tag, minMax);\n\t\t}\n\t}\n\n\treturn { baseValues, defaultMinMax, baseLangSysRecords };\n}\n\nfunction parseAxisTable(reader: Reader, axisOffset: number): AxisTable | null {\n\tif (axisOffset === 0) return null;\n\n\tconst axisReader = reader.sliceFrom(axisOffset);\n\tconst baseTagListOffset = axisReader.uint16();\n\tconst baseScriptListOffset = axisReader.uint16();\n\n\t// Parse base tag list\n\tconst baseTagList: number[] = [];\n\tif (baseTagListOffset !== 0) {\n\t\tconst tagReader = reader.sliceFrom(axisOffset + baseTagListOffset);\n\t\tconst baseTagCount = tagReader.uint16();\n\t\tfor (let i = 0; i < baseTagCount; i++) {\n\t\t\tbaseTagList.push(tagReader.uint32());\n\t\t}\n\t}\n\n\t// Parse base script list\n\tconst baseScriptList: BaseScriptRecord[] = [];\n\tif (baseScriptListOffset !== 0) {\n\t\tconst scriptListReader = reader.sliceFrom(\n\t\t\taxisOffset + baseScriptListOffset,\n\t\t);\n\t\tconst baseScriptCount = scriptListReader.uint16();\n\n\t\tconst scriptData: Array<{ tag: number; offset: number }> = [];\n\t\tfor (let i = 0; i < baseScriptCount; i++) {\n\t\t\tconst tag = scriptListReader.uint32();\n\t\t\tconst offset = scriptListReader.uint16();\n\t\t\tscriptData.push({ tag, offset });\n\t\t}\n\n\t\tfor (let i = 0; i < scriptData.length; i++) {\n\t\t\tconst item = scriptData[i]!;\n\t\t\tconst record = parseBaseScriptRecord(\n\t\t\t\treader,\n\t\t\t\taxisOffset + baseScriptListOffset + item.offset,\n\t\t\t\tbaseTagList,\n\t\t\t);\n\t\t\tbaseScriptList.push({ scriptTag: item.tag, ...record });\n\t\t}\n\t}\n\n\treturn { baseTagList, baseScriptList };\n}\n\nexport function parseBase(reader: Reader): BaseTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst horizAxisOffset = reader.uint16();\n\tconst vertAxisOffset = reader.uint16();\n\n\tconst horizAxis = parseAxisTable(reader, horizAxisOffset);\n\tconst vertAxis = parseAxisTable(reader, vertAxisOffset);\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\thorizAxis,\n\t\tvertAxis,\n\t};\n}\n\n/** Get baseline value for a script */\nexport function getBaselineForScript(\n\tbase: BaseTable,\n\tscriptTag: number,\n\tbaselineTag: number,\n\thorizontal: boolean = true,\n): int16 | null {\n\tconst axis = horizontal ? base.horizAxis : base.vertAxis;\n\tif (!axis) return null;\n\n\t// Find script record\n\tconst scriptRecord = axis.baseScriptList.find(\n\t\t(r) => r.scriptTag === scriptTag,\n\t);\n\tif (!scriptRecord?.baseValues) return null;\n\n\t// Find baseline tag index\n\tconst tagIndex = axis.baseTagList.indexOf(baselineTag);\n\tif (tagIndex === -1) return null;\n\n\treturn scriptRecord.baseValues.baseCoords[tagIndex] ?? null;\n}\n\n/** Get default baseline for a script */\nexport function getDefaultBaseline(\n\tbase: BaseTable,\n\tscriptTag: number,\n\thorizontal: boolean = true,\n): { tag: number; coordinate: int16 } | null {\n\tconst axis = horizontal ? base.horizAxis : base.vertAxis;\n\tif (!axis) return null;\n\n\tconst scriptRecord = axis.baseScriptList.find(\n\t\t(r) => r.scriptTag === scriptTag,\n\t);\n\tif (!scriptRecord?.baseValues) return null;\n\n\tconst index = scriptRecord.baseValues.defaultBaselineIndex;\n\tconst tag = axis.baseTagList[index];\n\tconst coordinate = scriptRecord.baseValues.baseCoords[index];\n\n\tif (tag === undefined || coordinate === undefined) return null;\n\n\treturn { tag, coordinate };\n}\n\n/** Get min/max extent for a script/language */\nexport function getMinMaxExtent(\n\tbase: BaseTable,\n\tscriptTag: number,\n\tlanguageTag?: number,\n\thorizontal: boolean = true,\n): MinMaxRecord | null {\n\tconst axis = horizontal ? base.horizAxis : base.vertAxis;\n\tif (!axis) return null;\n\n\tconst scriptRecord = axis.baseScriptList.find(\n\t\t(r) => r.scriptTag === scriptTag,\n\t);\n\tif (!scriptRecord) return null;\n\n\t// Try language-specific first\n\tif (languageTag !== undefined) {\n\t\tconst langMinMax = scriptRecord.baseLangSysRecords.get(languageTag);\n\t\tif (langMinMax) {\n\t\t\treturn { minCoord: langMinMax.minCoord, maxCoord: langMinMax.maxCoord };\n\t\t}\n\t}\n\n\t// Fall back to default\n\tif (scriptRecord.defaultMinMax) {\n\t\treturn {\n\t\t\tminCoord: scriptRecord.defaultMinMax.minCoord,\n\t\t\tmaxCoord: scriptRecord.defaultMinMax.maxCoord,\n\t\t};\n\t}\n\n\treturn null;\n}\n",
    "import type { GlyphId, int8, uint8, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Color Bitmap Data Table (CBDT)\n * Google's color bitmap table for emoji fonts\n * Used together with CBLC (Color Bitmap Location Table)\n */\nexport interface CbdtTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\t/** Raw data for bitmap lookup */\n\tdata: Uint8Array;\n}\n\n/**\n * Color Bitmap Location Table (CBLC)\n * Index for looking up bitmaps in CBDT\n */\nexport interface CblcTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tbitmapSizes: BitmapSize[];\n}\n\n/**\n * Bitmap size record\n */\nexport interface BitmapSize {\n\tindexSubTableArrayOffset: uint32;\n\tindexTablesSize: uint32;\n\tnumberOfIndexSubTables: uint32;\n\tcolorRef: uint32;\n\thori: SbitLineMetrics;\n\tvert: SbitLineMetrics;\n\tstartGlyphIndex: GlyphId;\n\tendGlyphIndex: GlyphId;\n\tppemX: uint8;\n\tppemY: uint8;\n\tbitDepth: uint8;\n\tflags: int8;\n\tindexSubTables: IndexSubTable[];\n}\n\n/**\n * Line metrics for bitmap glyphs\n */\nexport interface SbitLineMetrics {\n\tascender: int8;\n\tdescender: int8;\n\twidthMax: uint8;\n\tcaretSlopeNumerator: int8;\n\tcaretSlopeDenominator: int8;\n\tcaretOffset: int8;\n\tminOriginSB: int8;\n\tminAdvanceSB: int8;\n\tmaxBeforeBL: int8;\n\tminAfterBL: int8;\n\tpad1: int8;\n\tpad2: int8;\n}\n\n/**\n * Index sub-table for glyph lookup\n */\nexport interface IndexSubTable {\n\tfirstGlyphIndex: GlyphId;\n\tlastGlyphIndex: GlyphId;\n\tindexFormat: uint16;\n\timageFormat: uint16;\n\timageDataOffset: uint32;\n\t/** Glyph offsets (format-dependent) */\n\tglyphOffsets: Map<GlyphId, { offset: uint32; length: uint32 }>;\n}\n\n/**\n * Bitmap glyph metrics\n */\nexport interface GlyphBitmapMetrics {\n\theight: uint8;\n\twidth: uint8;\n\tbearingX: int8;\n\tbearingY: int8;\n\tadvance: uint8;\n}\n\n/**\n * Bitmap glyph data\n */\nexport interface BitmapGlyph {\n\tmetrics: GlyphBitmapMetrics;\n\timageFormat: uint16;\n\tdata: Uint8Array;\n}\n\n/**\n * Image formats in CBDT\n */\nexport const CbdtImageFormat = {\n\tSmallMetrics: 1, // Small metrics, byte-aligned\n\tSmallMetricsPng: 17, // Small metrics + PNG\n\tBigMetrics: 2, // Big metrics, byte-aligned\n\tBigMetricsPng: 18, // Big metrics + PNG\n\tCompressedPng: 19, // Metrics in CBLC + PNG\n} as const;\n\n/**\n * Parse CBLC table\n */\nexport function parseCblc(reader: Reader): CblcTable {\n\tconst tableStart = reader.offset;\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst numSizes = reader.uint32();\n\n\tconst bitmapSizes: BitmapSize[] = [];\n\n\t// Read BitmapSize records\n\tfor (let i = 0; i < numSizes; i++) {\n\t\tconst indexSubTableArrayOffset = reader.uint32();\n\t\tconst indexTablesSize = reader.uint32();\n\t\tconst numberOfIndexSubTables = reader.uint32();\n\t\tconst colorRef = reader.uint32();\n\n\t\tconst hori = parseSbitLineMetrics(reader);\n\t\tconst vert = parseSbitLineMetrics(reader);\n\n\t\tconst startGlyphIndex = reader.uint16();\n\t\tconst endGlyphIndex = reader.uint16();\n\t\tconst ppemX = reader.uint8();\n\t\tconst ppemY = reader.uint8();\n\t\tconst bitDepth = reader.uint8();\n\t\tconst flags = reader.int8();\n\n\t\tbitmapSizes.push({\n\t\t\tindexSubTableArrayOffset,\n\t\t\tindexTablesSize,\n\t\t\tnumberOfIndexSubTables,\n\t\t\tcolorRef,\n\t\t\thori,\n\t\t\tvert,\n\t\t\tstartGlyphIndex,\n\t\t\tendGlyphIndex,\n\t\t\tppemX,\n\t\t\tppemY,\n\t\t\tbitDepth,\n\t\t\tflags,\n\t\t\tindexSubTables: [],\n\t\t});\n\t}\n\n\t// Parse index sub-tables for each bitmap size\n\tfor (let i = 0; i < bitmapSizes.length; i++) {\n\t\tconst size = bitmapSizes[i]!;\n\t\tconst subTableReader = reader.sliceFrom(\n\t\t\ttableStart + size.indexSubTableArrayOffset,\n\t\t);\n\n\t\t// Read IndexSubTableArray\n\t\tconst subTableHeaders: {\n\t\t\tfirstGlyphIndex: uint16;\n\t\t\tlastGlyphIndex: uint16;\n\t\t\tadditionalOffsetToIndexSubtable: uint32;\n\t\t}[] = [];\n\n\t\tfor (let j = 0; j < size.numberOfIndexSubTables; j++) {\n\t\t\tsubTableHeaders.push({\n\t\t\t\tfirstGlyphIndex: subTableReader.uint16(),\n\t\t\t\tlastGlyphIndex: subTableReader.uint16(),\n\t\t\t\tadditionalOffsetToIndexSubtable: subTableReader.uint32(),\n\t\t\t});\n\t\t}\n\n\t\t// Parse each index sub-table\n\t\tfor (let j = 0; j < subTableHeaders.length; j++) {\n\t\t\tconst header = subTableHeaders[j]!;\n\t\t\tconst indexSubTable = parseIndexSubTable(\n\t\t\t\treader,\n\t\t\t\ttableStart +\n\t\t\t\t\tsize.indexSubTableArrayOffset +\n\t\t\t\t\theader.additionalOffsetToIndexSubtable,\n\t\t\t\theader.firstGlyphIndex,\n\t\t\t\theader.lastGlyphIndex,\n\t\t\t);\n\t\t\tsize.indexSubTables.push(indexSubTable);\n\t\t}\n\t}\n\n\treturn { majorVersion, minorVersion, bitmapSizes };\n}\n\nfunction parseSbitLineMetrics(reader: Reader): SbitLineMetrics {\n\treturn {\n\t\tascender: reader.int8(),\n\t\tdescender: reader.int8(),\n\t\twidthMax: reader.uint8(),\n\t\tcaretSlopeNumerator: reader.int8(),\n\t\tcaretSlopeDenominator: reader.int8(),\n\t\tcaretOffset: reader.int8(),\n\t\tminOriginSB: reader.int8(),\n\t\tminAdvanceSB: reader.int8(),\n\t\tmaxBeforeBL: reader.int8(),\n\t\tminAfterBL: reader.int8(),\n\t\tpad1: reader.int8(),\n\t\tpad2: reader.int8(),\n\t};\n}\n\nfunction parseIndexSubTable(\n\treader: Reader,\n\toffset: number,\n\tfirstGlyph: GlyphId,\n\tlastGlyph: GlyphId,\n): IndexSubTable {\n\tconst subReader = reader.sliceFrom(offset);\n\tconst indexFormat = subReader.uint16();\n\tconst imageFormat = subReader.uint16();\n\tconst imageDataOffset = subReader.uint32();\n\n\tconst glyphOffsets = new Map<GlyphId, { offset: uint32; length: uint32 }>();\n\tconst numGlyphs = lastGlyph - firstGlyph + 1;\n\n\tswitch (indexFormat) {\n\t\tcase 1: {\n\t\t\t// Variable metrics, 4-byte offsets\n\t\t\tconst offsets: uint32[] = [];\n\t\t\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\t\t\toffsets.push(subReader.uint32());\n\t\t\t}\n\t\t\tfor (let i = 0; i < numGlyphs; i++) {\n\t\t\t\tconst glyphOffset = offsets[i];\n\t\t\t\tconst nextOffset = offsets[i + 1];\n\t\t\t\tif (glyphOffset === undefined || nextOffset === undefined) continue;\n\t\t\t\tif (nextOffset > glyphOffset) {\n\t\t\t\t\tglyphOffsets.set(firstGlyph + i, {\n\t\t\t\t\t\toffset: imageDataOffset + glyphOffset,\n\t\t\t\t\t\tlength: nextOffset - glyphOffset,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\t// Constant image size\n\t\t\tconst imageSize = subReader.uint32();\n\t\t\t// Big metrics follow\n\t\t\tconst _bigMetrics = {\n\t\t\t\theight: subReader.uint8(),\n\t\t\t\twidth: subReader.uint8(),\n\t\t\t\thoriBearingX: subReader.int8(),\n\t\t\t\thoriBearingY: subReader.int8(),\n\t\t\t\thoriAdvance: subReader.uint8(),\n\t\t\t\tvertBearingX: subReader.int8(),\n\t\t\t\tvertBearingY: subReader.int8(),\n\t\t\t\tvertAdvance: subReader.uint8(),\n\t\t\t};\n\t\t\tfor (let i = 0; i < numGlyphs; i++) {\n\t\t\t\tglyphOffsets.set(firstGlyph + i, {\n\t\t\t\t\toffset: imageDataOffset + i * imageSize,\n\t\t\t\t\tlength: imageSize,\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\t// Variable metrics, 2-byte offsets\n\t\t\tconst offsets: uint16[] = [];\n\t\t\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\t\t\toffsets.push(subReader.uint16());\n\t\t\t}\n\t\t\tfor (let i = 0; i < numGlyphs; i++) {\n\t\t\t\tconst glyphOffset = offsets[i];\n\t\t\t\tconst nextOffset = offsets[i + 1];\n\t\t\t\tif (glyphOffset === undefined || nextOffset === undefined) continue;\n\t\t\t\tif (nextOffset > glyphOffset) {\n\t\t\t\t\tglyphOffsets.set(firstGlyph + i, {\n\t\t\t\t\t\toffset: imageDataOffset + glyphOffset,\n\t\t\t\t\t\tlength: nextOffset - glyphOffset,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 4: {\n\t\t\t// Sparse glyph array\n\t\t\tconst numGlyphsActual = subReader.uint32();\n\t\t\tconst glyphArray: { glyphId: uint16; offset: uint16 }[] = [];\n\t\t\tfor (let i = 0; i <= numGlyphsActual; i++) {\n\t\t\t\tglyphArray.push({\n\t\t\t\t\tglyphId: subReader.uint16(),\n\t\t\t\t\toffset: subReader.uint16(),\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (let i = 0; i < numGlyphsActual; i++) {\n\t\t\t\tconst entry = glyphArray[i];\n\t\t\t\tconst nextEntry = glyphArray[i + 1];\n\t\t\t\tif (entry === undefined || nextEntry === undefined) continue;\n\t\t\t\tglyphOffsets.set(entry.glyphId, {\n\t\t\t\t\toffset: imageDataOffset + entry.offset,\n\t\t\t\t\tlength: nextEntry.offset - entry.offset,\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 5: {\n\t\t\t// Constant metrics, sparse glyph array\n\t\t\tconst imageSize = subReader.uint32();\n\t\t\t// Big metrics\n\t\t\tsubReader.skip(8);\n\t\t\tconst numGlyphsActual = subReader.uint32();\n\t\t\tfor (let i = 0; i < numGlyphsActual; i++) {\n\t\t\t\tconst glyphId = subReader.uint16();\n\t\t\t\tglyphOffsets.set(glyphId, {\n\t\t\t\t\toffset: imageDataOffset + i * imageSize,\n\t\t\t\t\tlength: imageSize,\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tfirstGlyphIndex: firstGlyph,\n\t\tlastGlyphIndex: lastGlyph,\n\t\tindexFormat,\n\t\timageFormat,\n\t\timageDataOffset,\n\t\tglyphOffsets,\n\t};\n}\n\n/**\n * Parse CBDT table\n */\nexport function parseCbdt(reader: Reader): CbdtTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\t// Store raw data for later lookup\n\tconst data = reader.bytes(reader.remaining);\n\n\treturn { majorVersion, minorVersion, data };\n}\n\n/**\n * Get bitmap glyph from CBDT using CBLC index\n */\nexport function getBitmapGlyph(\n\tcblc: CblcTable,\n\tcbdt: CbdtTable,\n\tglyphId: GlyphId,\n\tppem: number,\n): BitmapGlyph | null {\n\t// Find matching bitmap size\n\tlet bestSize: BitmapSize | null = null;\n\tlet bestDiff = Infinity;\n\n\tfor (let i = 0; i < cblc.bitmapSizes.length; i++) {\n\t\tconst size = cblc.bitmapSizes[i]!;\n\t\tif (glyphId < size.startGlyphIndex || glyphId > size.endGlyphIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst diff = Math.abs(size.ppemX - ppem);\n\t\tif (diff < bestDiff) {\n\t\t\tbestDiff = diff;\n\t\t\tbestSize = size;\n\t\t}\n\t}\n\n\tif (!bestSize) return null;\n\n\t// Find glyph in index sub-tables\n\tfor (let i = 0; i < bestSize.indexSubTables.length; i++) {\n\t\tconst subTable = bestSize.indexSubTables[i]!;\n\t\tconst glyphInfo = subTable.glyphOffsets.get(glyphId);\n\t\tif (!glyphInfo) continue;\n\n\t\t// Read glyph data from CBDT\n\t\tconst glyphData = cbdt.data.slice(\n\t\t\tglyphInfo.offset - 4, // Adjust for CBDT header\n\t\t\tglyphInfo.offset - 4 + glyphInfo.length,\n\t\t);\n\n\t\treturn parseGlyphData(glyphData, subTable.imageFormat);\n\t}\n\n\treturn null;\n}\n\nfunction parseGlyphData(\n\tdata: Uint8Array,\n\timageFormat: uint16,\n): BitmapGlyph | null {\n\tif (data.length === 0) return null;\n\n\tlet offset = 0;\n\tlet metrics: GlyphBitmapMetrics;\n\n\tswitch (imageFormat) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 17:\n\t\tcase 18: {\n\t\t\t// Small or big metrics embedded\n\t\t\tif (imageFormat === 1 || imageFormat === 17) {\n\t\t\t\t// Small metrics (5 bytes)\n\t\t\t\tif (offset + 5 > data.length) return null;\n\t\t\t\tmetrics = {\n\t\t\t\t\theight: data[offset++] ?? 0,\n\t\t\t\t\twidth: data[offset++] ?? 0,\n\t\t\t\t\tbearingX: ((data[offset++] ?? 0) << 24) >> 24, // Sign extend\n\t\t\t\t\tbearingY: ((data[offset++] ?? 0) << 24) >> 24,\n\t\t\t\t\tadvance: data[offset++] ?? 0,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Big metrics (8 bytes)\n\t\t\t\tif (offset + 8 > data.length) return null;\n\t\t\t\tmetrics = {\n\t\t\t\t\theight: data[offset++] ?? 0,\n\t\t\t\t\twidth: data[offset++] ?? 0,\n\t\t\t\t\tbearingX: ((data[offset++] ?? 0) << 24) >> 24,\n\t\t\t\t\tbearingY: ((data[offset++] ?? 0) << 24) >> 24,\n\t\t\t\t\tadvance: data[offset++] ?? 0,\n\t\t\t\t};\n\t\t\t\toffset += 3; // Skip vertical metrics\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 19: {\n\t\t\t// Metrics in CBLC, just PNG data\n\t\t\tmetrics = { height: 0, width: 0, bearingX: 0, bearingY: 0, advance: 0 };\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n\n\treturn {\n\t\tmetrics,\n\t\timageFormat,\n\t\tdata: data.slice(offset),\n\t};\n}\n\n/**\n * Check if glyph has color bitmap\n */\nexport function hasColorBitmap(\n\tcblc: CblcTable,\n\tglyphId: GlyphId,\n\tppem?: number,\n): boolean {\n\tfor (let i = 0; i < cblc.bitmapSizes.length; i++) {\n\t\tconst size = cblc.bitmapSizes[i]!;\n\t\tif (ppem !== undefined && size.ppemX !== ppem) continue;\n\t\tif (glyphId < size.startGlyphIndex || glyphId > size.endGlyphIndex) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let j = 0; j < size.indexSubTables.length; j++) {\n\t\t\tconst subTable = size.indexSubTables[j]!;\n\t\t\tif (subTable.glyphOffsets.has(glyphId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Get available ppem sizes for color bitmaps\n */\nexport function getColorBitmapSizes(cblc: CblcTable): number[] {\n\tconst sizes = new Set<number>();\n\tfor (let i = 0; i < cblc.bitmapSizes.length; i++) {\n\t\tconst size = cblc.bitmapSizes[i]!;\n\t\tsizes.add(size.ppemX);\n\t}\n\treturn [...sizes].sort((a, b) => a - b);\n}\n",
    "import { Reader } from \"../binary/reader.ts\";\n\n/**\n * CFF (Compact Font Format) table parser\n * Used by OpenType fonts with PostScript outlines\n */\n\nexport interface CffTable {\n\tversion: { major: number; minor: number };\n\tnames: string[];\n\ttopDicts: TopDict[];\n\tstrings: string[];\n\tglobalSubrs: Uint8Array[];\n\tcharStrings: Uint8Array[][];\n\tlocalSubrs: Uint8Array[][];\n\tfdArrays: FDDict[][];\n\tfdSelects: FDSelect[];\n}\n\nexport interface TopDict {\n\tversion?: string;\n\tnotice?: string;\n\tcopyright?: string;\n\tfullName?: string;\n\tfamilyName?: string;\n\tweight?: string;\n\tisFixedPitch?: boolean;\n\titalicAngle?: number;\n\tunderlinePosition?: number;\n\tunderlineThickness?: number;\n\tpaintType?: number;\n\tcharstringType?: number;\n\tfontMatrix?: number[];\n\tuniqueID?: number;\n\tfontBBox?: number[];\n\tstrokeWidth?: number;\n\tcharset?: number;\n\tencoding?: number;\n\tcharStrings?: number;\n\tprivate?: [number, number]; // [size, offset]\n\tsyntheticBase?: number;\n\tpostScript?: string;\n\tbaseFontName?: string;\n\tbaseFontBlend?: number[];\n\t// CIDFont-specific\n\tros?: { registry: string; ordering: string; supplement: number };\n\tcidFontVersion?: number;\n\tcidFontRevision?: number;\n\tcidFontType?: number;\n\tcidCount?: number;\n\tuidBase?: number;\n\tfdArray?: number;\n\tfdSelect?: number;\n\tfontName?: string;\n}\n\nexport interface PrivateDict {\n\tblueValues?: number[];\n\totherBlues?: number[];\n\tfamilyBlues?: number[];\n\tfamilyOtherBlues?: number[];\n\tblueScale?: number;\n\tblueShift?: number;\n\tblueFuzz?: number;\n\tstdHW?: number;\n\tstdVW?: number;\n\tstemSnapH?: number[];\n\tstemSnapV?: number[];\n\tforceBold?: boolean;\n\tlanguageGroup?: number;\n\texpansionFactor?: number;\n\tinitialRandomSeed?: number;\n\tsubrs?: number;\n\tdefaultWidthX?: number;\n\tnominalWidthX?: number;\n}\n\nexport interface FDDict extends PrivateDict {\n\tfontName?: string;\n\t/** Private dict offset and size [size, offset] */\n\tprivate?: [number, number];\n\t/** Local subroutines for this FD (parsed from private dict subrs offset) */\n\tlocalSubrs?: Uint8Array[];\n}\n\nexport interface FDSelect {\n\tformat: number;\n\tselect: (glyphId: number) => number;\n}\n\n// Standard strings defined in CFF spec\nconst STANDARD_STRINGS = [\n\t\".notdef\",\n\t\"space\",\n\t\"exclam\",\n\t\"quotedbl\",\n\t\"numbersign\",\n\t\"dollar\",\n\t\"percent\",\n\t\"ampersand\",\n\t\"quoteright\",\n\t\"parenleft\",\n\t\"parenright\",\n\t\"asterisk\",\n\t\"plus\",\n\t\"comma\",\n\t\"hyphen\",\n\t\"period\",\n\t\"slash\",\n\t\"zero\",\n\t\"one\",\n\t\"two\",\n\t\"three\",\n\t\"four\",\n\t\"five\",\n\t\"six\",\n\t\"seven\",\n\t\"eight\",\n\t\"nine\",\n\t\"colon\",\n\t\"semicolon\",\n\t\"less\",\n\t\"equal\",\n\t\"greater\",\n\t\"question\",\n\t\"at\",\n\t\"A\",\n\t\"B\",\n\t\"C\",\n\t\"D\",\n\t\"E\",\n\t\"F\",\n\t\"G\",\n\t\"H\",\n\t\"I\",\n\t\"J\",\n\t\"K\",\n\t\"L\",\n\t\"M\",\n\t\"N\",\n\t\"O\",\n\t\"P\",\n\t\"Q\",\n\t\"R\",\n\t\"S\",\n\t\"T\",\n\t\"U\",\n\t\"V\",\n\t\"W\",\n\t\"X\",\n\t\"Y\",\n\t\"Z\",\n\t\"bracketleft\",\n\t\"backslash\",\n\t\"bracketright\",\n\t\"asciicircum\",\n\t\"underscore\",\n\t\"quoteleft\",\n\t\"a\",\n\t\"b\",\n\t\"c\",\n\t\"d\",\n\t\"e\",\n\t\"f\",\n\t\"g\",\n\t\"h\",\n\t\"i\",\n\t\"j\",\n\t\"k\",\n\t\"l\",\n\t\"m\",\n\t\"n\",\n\t\"o\",\n\t\"p\",\n\t\"q\",\n\t\"r\",\n\t\"s\",\n\t\"t\",\n\t\"u\",\n\t\"v\",\n\t\"w\",\n\t\"x\",\n\t\"y\",\n\t\"z\",\n\t\"braceleft\",\n\t\"bar\",\n\t\"braceright\",\n\t\"asciitilde\",\n\t\"exclamdown\",\n\t\"cent\",\n\t\"sterling\",\n\t\"fraction\",\n\t\"yen\",\n\t\"florin\",\n\t\"section\",\n\t\"currency\",\n\t\"quotesingle\",\n\t\"quotedblleft\",\n\t\"guillemotleft\",\n\t\"guilsinglleft\",\n\t\"guilsinglright\",\n\t\"fi\",\n\t\"fl\",\n\t\"endash\",\n\t\"dagger\",\n\t\"daggerdbl\",\n\t\"periodcentered\",\n\t\"paragraph\",\n\t\"bullet\",\n\t\"quotesinglbase\",\n\t\"quotedblbase\",\n\t\"quotedblright\",\n\t\"guillemotright\",\n\t\"ellipsis\",\n\t\"perthousand\",\n\t\"questiondown\",\n\t\"grave\",\n\t\"acute\",\n\t\"circumflex\",\n\t\"tilde\",\n\t\"macron\",\n\t\"breve\",\n\t\"dotaccent\",\n\t\"dieresis\",\n\t\"ring\",\n\t\"cedilla\",\n\t\"hungarumlaut\",\n\t\"ogonek\",\n\t\"caron\",\n\t\"emdash\",\n\t\"AE\",\n\t\"ordfeminine\",\n\t\"Lslash\",\n\t\"Oslash\",\n\t\"OE\",\n\t\"ordmasculine\",\n\t\"ae\",\n\t\"dotlessi\",\n\t\"lslash\",\n\t\"oslash\",\n\t\"oe\",\n\t\"germandbls\",\n\t\"onesuperior\",\n\t\"logicalnot\",\n\t\"mu\",\n\t\"trademark\",\n\t\"Eth\",\n\t\"onehalf\",\n\t\"plusminus\",\n\t\"Thorn\",\n\t\"onequarter\",\n\t\"divide\",\n\t\"brokenbar\",\n\t\"degree\",\n\t\"thorn\",\n\t\"threequarters\",\n\t\"twosuperior\",\n\t\"registered\",\n\t\"minus\",\n\t\"eth\",\n\t\"multiply\",\n\t\"threesuperior\",\n\t\"copyright\",\n\t\"Aacute\",\n\t\"Acircumflex\",\n\t\"Adieresis\",\n\t\"Agrave\",\n\t\"Aring\",\n\t\"Atilde\",\n\t\"Ccedilla\",\n\t\"Eacute\",\n\t\"Ecircumflex\",\n\t\"Edieresis\",\n\t\"Egrave\",\n\t\"Iacute\",\n\t\"Icircumflex\",\n\t\"Idieresis\",\n\t\"Igrave\",\n\t\"Ntilde\",\n\t\"Oacute\",\n\t\"Ocircumflex\",\n\t\"Odieresis\",\n\t\"Ograve\",\n\t\"Otilde\",\n\t\"Scaron\",\n\t\"Uacute\",\n\t\"Ucircumflex\",\n\t\"Udieresis\",\n\t\"Ugrave\",\n\t\"Yacute\",\n\t\"Ydieresis\",\n\t\"Zcaron\",\n\t\"aacute\",\n\t\"acircumflex\",\n\t\"adieresis\",\n\t\"agrave\",\n\t\"aring\",\n\t\"atilde\",\n\t\"ccedilla\",\n\t\"eacute\",\n\t\"ecircumflex\",\n\t\"edieresis\",\n\t\"egrave\",\n\t\"iacute\",\n\t\"icircumflex\",\n\t\"idieresis\",\n\t\"igrave\",\n\t\"ntilde\",\n\t\"oacute\",\n\t\"ocircumflex\",\n\t\"odieresis\",\n\t\"ograve\",\n\t\"otilde\",\n\t\"scaron\",\n\t\"uacute\",\n\t\"ucircumflex\",\n\t\"udieresis\",\n\t\"ugrave\",\n\t\"yacute\",\n\t\"ydieresis\",\n\t\"zcaron\",\n\t\"exclamsmall\",\n\t\"Hungarumlautsmall\",\n\t\"dollaroldstyle\",\n\t\"dollarsuperior\",\n\t\"ampersandsmall\",\n\t\"Acutesmall\",\n\t\"parenleftsuperior\",\n\t\"parenrightsuperior\",\n\t\"twodotenleader\",\n\t\"onedotenleader\",\n\t\"zerooldstyle\",\n\t\"oneoldstyle\",\n\t\"twooldstyle\",\n\t\"threeoldstyle\",\n\t\"fouroldstyle\",\n\t\"fiveoldstyle\",\n\t\"sixoldstyle\",\n\t\"sevenoldstyle\",\n\t\"eightoldstyle\",\n\t\"nineoldstyle\",\n\t\"commasuperior\",\n\t\"threequartersemdash\",\n\t\"periodsuperior\",\n\t\"questionsmall\",\n\t\"asuperior\",\n\t\"bsuperior\",\n\t\"centsuperior\",\n\t\"dsuperior\",\n\t\"esuperior\",\n\t\"isuperior\",\n\t\"lsuperior\",\n\t\"msuperior\",\n\t\"nsuperior\",\n\t\"osuperior\",\n\t\"rsuperior\",\n\t\"ssuperior\",\n\t\"tsuperior\",\n\t\"ff\",\n\t\"ffi\",\n\t\"ffl\",\n\t\"parenleftinferior\",\n\t\"parenrightinferior\",\n\t\"Circumflexsmall\",\n\t\"hyphensuperior\",\n\t\"Gravesmall\",\n\t\"Asmall\",\n\t\"Bsmall\",\n\t\"Csmall\",\n\t\"Dsmall\",\n\t\"Esmall\",\n\t\"Fsmall\",\n\t\"Gsmall\",\n\t\"Hsmall\",\n\t\"Ismall\",\n\t\"Jsmall\",\n\t\"Ksmall\",\n\t\"Lsmall\",\n\t\"Msmall\",\n\t\"Nsmall\",\n\t\"Osmall\",\n\t\"Psmall\",\n\t\"Qsmall\",\n\t\"Rsmall\",\n\t\"Ssmall\",\n\t\"Tsmall\",\n\t\"Usmall\",\n\t\"Vsmall\",\n\t\"Wsmall\",\n\t\"Xsmall\",\n\t\"Ysmall\",\n\t\"Zsmall\",\n\t\"colonmonetary\",\n\t\"onefitted\",\n\t\"rupiah\",\n\t\"Tildesmall\",\n\t\"exclamdownsmall\",\n\t\"centoldstyle\",\n\t\"Lslashsmall\",\n\t\"Scaronsmall\",\n\t\"Zcaronsmall\",\n\t\"Dieresissmall\",\n\t\"Brevesmall\",\n\t\"Caronsmall\",\n\t\"Dotaccentsmall\",\n\t\"Macronsmall\",\n\t\"figuredash\",\n\t\"hypheninferior\",\n\t\"Ogoneksmall\",\n\t\"Ringsmall\",\n\t\"Cedillasmall\",\n\t\"questiondownsmall\",\n\t\"oneeighth\",\n\t\"threeeighths\",\n\t\"fiveeighths\",\n\t\"seveneighths\",\n\t\"onethird\",\n\t\"twothirds\",\n\t\"zerosuperior\",\n\t\"foursuperior\",\n\t\"fivesuperior\",\n\t\"sixsuperior\",\n\t\"sevensuperior\",\n\t\"eightsuperior\",\n\t\"ninesuperior\",\n\t\"zeroinferior\",\n\t\"oneinferior\",\n\t\"twoinferior\",\n\t\"threeinferior\",\n\t\"fourinferior\",\n\t\"fiveinferior\",\n\t\"sixinferior\",\n\t\"seveninferior\",\n\t\"eightinferior\",\n\t\"nineinferior\",\n\t\"centinferior\",\n\t\"dollarinferior\",\n\t\"periodinferior\",\n\t\"commainferior\",\n\t\"Agravesmall\",\n\t\"Aacutesmall\",\n\t\"Acircumflexsmall\",\n\t\"Atildesmall\",\n\t\"Adieresissmall\",\n\t\"Aringsmall\",\n\t\"AEsmall\",\n\t\"Ccedillasmall\",\n\t\"Egravesmall\",\n\t\"Eacutesmall\",\n\t\"Ecircumflexsmall\",\n\t\"Edieresissmall\",\n\t\"Igravesmall\",\n\t\"Iacutesmall\",\n\t\"Icircumflexsmall\",\n\t\"Idieresissmall\",\n\t\"Ethsmall\",\n\t\"Ntildesmall\",\n\t\"Ogravesmall\",\n\t\"Oacutesmall\",\n\t\"Ocircumflexsmall\",\n\t\"Otildesmall\",\n\t\"Odieresissmall\",\n\t\"OEsmall\",\n\t\"Oslashsmall\",\n\t\"Ugravesmall\",\n\t\"Uacutesmall\",\n\t\"Ucircumflexsmall\",\n\t\"Udieresissmall\",\n\t\"Yacutesmall\",\n\t\"Thornsmall\",\n\t\"Ydieresissmall\",\n\t\"001.000\",\n\t\"001.001\",\n\t\"001.002\",\n\t\"001.003\",\n\t\"Black\",\n\t\"Bold\",\n\t\"Book\",\n\t\"Light\",\n\t\"Medium\",\n\t\"Regular\",\n\t\"Roman\",\n\t\"Semibold\",\n];\n\n// Top DICT operators\nenum TopDictOp {\n\tversion = 0,\n\tNotice = 1,\n\tFullName = 2,\n\tFamilyName = 3,\n\tWeight = 4,\n\tFontBBox = 5,\n\tUniqueID = 13,\n\tXUID = 14,\n\tcharset = 15,\n\tEncoding = 16,\n\tCharStrings = 17,\n\tPrivate = 18,\n\tCopyright = 0x0c00,\n\tisFixedPitch = 0x0c01,\n\tItalicAngle = 0x0c02,\n\tUnderlinePosition = 0x0c03,\n\tUnderlineThickness = 0x0c04,\n\tPaintType = 0x0c05,\n\tCharstringType = 0x0c06,\n\tFontMatrix = 0x0c07,\n\tStrokeWidth = 0x0c08,\n\tSyntheticBase = 0x0c14,\n\tPostScript = 0x0c15,\n\tBaseFontName = 0x0c16,\n\tBaseFontBlend = 0x0c17,\n\t// CID-specific\n\tROS = 0x0c1e,\n\tCIDFontVersion = 0x0c1f,\n\tCIDFontRevision = 0x0c20,\n\tCIDFontType = 0x0c21,\n\tCIDCount = 0x0c22,\n\tUIDBase = 0x0c23,\n\tFDArray = 0x0c24,\n\tFDSelect = 0x0c25,\n\tFontName = 0x0c26,\n}\n\n// Private DICT operators\nenum PrivateDictOp {\n\tBlueValues = 6,\n\tOtherBlues = 7,\n\tFamilyBlues = 8,\n\tFamilyOtherBlues = 9,\n\tStdHW = 10,\n\tStdVW = 11,\n\tSubrs = 19,\n\tdefaultWidthX = 20,\n\tnominalWidthX = 21,\n\tBlueScale = 0x0c09,\n\tBlueShift = 0x0c0a,\n\tBlueFuzz = 0x0c0b,\n\tStemSnapH = 0x0c0c,\n\tStemSnapV = 0x0c0d,\n\tForceBold = 0x0c0e,\n\tLanguageGroup = 0x0c11,\n\tExpansionFactor = 0x0c12,\n\tinitialRandomSeed = 0x0c13,\n}\n\n/**\n * Parse CFF table - Compact Font Format for PostScript outlines\n * @param reader - Reader positioned at start of CFF table\n * @returns Parsed CFF table with CharStrings, DICTs, and subroutines\n */\nexport function parseCff(reader: Reader): CffTable {\n\tconst startOffset = reader.offset;\n\n\t// Header\n\tconst major = reader.uint8();\n\tconst minor = reader.uint8();\n\tconst hdrSize = reader.uint8();\n\tconst _offSize = reader.uint8();\n\n\treader.seek(startOffset + hdrSize);\n\n\t// Name INDEX\n\tconst names = parseIndex(reader).map((data) =>\n\t\tnew TextDecoder().decode(data),\n\t);\n\n\t// Top DICT INDEX\n\tconst topDictData = parseIndex(reader);\n\tconst topDicts: TopDict[] = [];\n\n\t// String INDEX\n\tconst stringData = parseIndex(reader);\n\tconst strings = stringData.map((data) => new TextDecoder().decode(data));\n\n\t// Global Subr INDEX\n\tconst globalSubrs = parseIndex(reader);\n\n\t// Parse Top DICTs\n\tfor (let i = 0; i < topDictData.length; i++) {\n\t\tconst data = topDictData[i]!;\n\t\ttopDicts.push(\n\t\t\tparseTopDict(\n\t\t\t\tnew Reader(\n\t\t\t\t\tdata.buffer as ArrayBuffer,\n\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\tdata.byteLength,\n\t\t\t\t),\n\t\t\t\tstrings,\n\t\t\t),\n\t\t);\n\t}\n\n\t// Parse CharStrings and local subrs for each font\n\tconst charStrings: Uint8Array[][] = [];\n\tconst localSubrs: Uint8Array[][] = [];\n\tconst fdArrays: FDDict[][] = [];\n\tconst fdSelects: FDSelect[] = [];\n\n\tfor (let i = 0; i < topDicts.length; i++) {\n\t\tconst topDict = topDicts[i]!;\n\t\t// CharStrings\n\t\tif (topDict.charStrings !== undefined) {\n\t\t\treader.seek(startOffset + topDict.charStrings);\n\t\t\tcharStrings.push(parseIndex(reader));\n\t\t} else {\n\t\t\tcharStrings.push([]);\n\t\t}\n\n\t\t// Private DICT and local subrs\n\t\tif (topDict.private) {\n\t\t\tconst [privateSize, privateOffset] = topDict.private;\n\t\t\tconst privateDict = parsePrivateDict(\n\t\t\t\treader.slice(privateOffset, privateSize),\n\t\t\t\tstrings,\n\t\t\t);\n\n\t\t\tif (privateDict.subrs !== undefined) {\n\t\t\t\treader.seek(startOffset + privateOffset + privateDict.subrs);\n\t\t\t\tlocalSubrs.push(parseIndex(reader));\n\t\t\t} else {\n\t\t\t\tlocalSubrs.push([]);\n\t\t\t}\n\t\t} else {\n\t\t\tlocalSubrs.push([]);\n\t\t}\n\n\t\t// FDArray (for CID fonts)\n\t\tif (topDict.fdArray !== undefined) {\n\t\t\treader.seek(startOffset + topDict.fdArray);\n\t\t\tconst fdData = parseIndex(reader);\n\t\t\tconst fds: FDDict[] = [];\n\t\t\tfor (let j = 0; j < fdData.length; j++) {\n\t\t\t\tconst data = fdData[j]!;\n\t\t\t\tconst fdDict = parseTopDict(\n\t\t\t\t\tnew Reader(\n\t\t\t\t\t\tdata.buffer as ArrayBuffer,\n\t\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\t\tdata.byteLength,\n\t\t\t\t\t),\n\t\t\t\t\tstrings,\n\t\t\t\t) as FDDict;\n\n\t\t\t\t// Parse FD-specific private dict and local subrs\n\t\t\t\tif (fdDict.private) {\n\t\t\t\t\tconst [fdPrivateSize, fdPrivateOffset] = fdDict.private;\n\t\t\t\t\tconst fdPrivateDict = parsePrivateDict(\n\t\t\t\t\t\treader.slice(startOffset + fdPrivateOffset, fdPrivateSize),\n\t\t\t\t\t\tstrings,\n\t\t\t\t\t);\n\t\t\t\t\t// Copy private dict properties to fdDict\n\t\t\t\t\tObject.assign(fdDict, fdPrivateDict);\n\n\t\t\t\t\t// Parse FD-specific local subrs\n\t\t\t\t\tif (fdPrivateDict.subrs !== undefined) {\n\t\t\t\t\t\treader.seek(startOffset + fdPrivateOffset + fdPrivateDict.subrs);\n\t\t\t\t\t\tfdDict.localSubrs = parseIndex(reader);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfds.push(fdDict);\n\t\t\t}\n\t\t\tfdArrays.push(fds);\n\t\t} else {\n\t\t\tfdArrays.push([]);\n\t\t}\n\n\t\t// FDSelect (for CID fonts)\n\t\tif (topDict.fdSelect !== undefined) {\n\t\t\treader.seek(startOffset + topDict.fdSelect);\n\t\t\tconst lastCharStrings = charStrings[charStrings.length - 1];\n\t\t\tfdSelects.push(parseFDSelect(reader, lastCharStrings?.length ?? 0));\n\t\t} else {\n\t\t\tfdSelects.push({ format: 0, select: () => 0 });\n\t\t}\n\t}\n\n\treturn {\n\t\tversion: { major, minor },\n\t\tnames,\n\t\ttopDicts,\n\t\tstrings,\n\t\tglobalSubrs,\n\t\tcharStrings,\n\t\tlocalSubrs,\n\t\tfdArrays,\n\t\tfdSelects,\n\t};\n}\n\n/**\n * Parse an INDEX structure\n */\nfunction parseIndex(reader: Reader): Uint8Array[] {\n\tconst count = reader.uint16();\n\tif (count === 0) return [];\n\n\tconst offSize = reader.uint8();\n\tconst offsets: number[] = [];\n\n\tfor (let i = 0; i <= count; i++) {\n\t\toffsets.push(readOffset(reader, offSize));\n\t}\n\n\tconst result: Uint8Array[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tconst start = offsets[i];\n\t\tconst end = offsets[i + 1];\n\t\tif (start === undefined || end === undefined) continue;\n\t\tconst length = end - start;\n\t\tresult.push(reader.bytes(length));\n\t}\n\n\treturn result;\n}\n\n/**\n * Read offset of given size\n */\nfunction readOffset(reader: Reader, offSize: number): number {\n\tswitch (offSize) {\n\t\tcase 1:\n\t\t\treturn reader.uint8();\n\t\tcase 2:\n\t\t\treturn reader.uint16();\n\t\tcase 3:\n\t\t\treturn reader.uint24();\n\t\tcase 4:\n\t\t\treturn reader.uint32();\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid offset size: ${offSize}`);\n\t}\n}\n\n/**\n * Parse a DICT structure\n */\nfunction parseDict(reader: Reader): Map<number, number[]> {\n\tconst result = new Map<number, number[]>();\n\tconst operands: number[] = [];\n\n\twhile (reader.remaining > 0) {\n\t\tconst b0 = reader.uint8();\n\n\t\tif (b0 <= 21) {\n\t\t\t// Operator\n\t\t\tlet op = b0;\n\t\t\tif (b0 === 12) {\n\t\t\t\top = 0x0c00 | reader.uint8();\n\t\t\t}\n\t\t\tresult.set(op, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 28) {\n\t\t\t// 16-bit signed integer\n\t\t\toperands.push(reader.int16());\n\t\t} else if (b0 === 29) {\n\t\t\t// 32-bit signed integer\n\t\t\toperands.push(reader.int32());\n\t\t} else if (b0 === 30) {\n\t\t\t// Real number\n\t\t\toperands.push(parseReal(reader));\n\t\t} else if (b0 >= 32 && b0 <= 246) {\n\t\t\toperands.push(b0 - 139);\n\t\t} else if (b0 >= 247 && b0 <= 250) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push((b0 - 247) * 256 + b1 + 108);\n\t\t} else if (b0 >= 251 && b0 <= 254) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push(-(b0 - 251) * 256 - b1 - 108);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse real number from DICT\n */\nfunction parseReal(reader: Reader): number {\n\tlet str = \"\";\n\tconst nibbleChars = \"0123456789.EE -\";\n\tlet done = false;\n\n\twhile (!done) {\n\t\tconst byte = reader.uint8();\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tconst nibble = i === 0 ? byte >> 4 : byte & 0x0f;\n\t\t\tif (nibble === 0x0f) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nibble === 0x0c) {\n\t\t\t\tstr += \"E-\";\n\t\t\t} else {\n\t\t\t\tstr += nibbleChars[nibble];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parseFloat(str);\n}\n\n/**\n * Parse Top DICT\n */\nfunction parseTopDict(reader: Reader, strings: string[]): TopDict {\n\tconst dict = parseDict(reader);\n\tconst result: TopDict = {};\n\n\tconst getString = (sid: number): string => {\n\t\tif (sid < STANDARD_STRINGS.length) {\n\t\t\tconst str = STANDARD_STRINGS[sid];\n\t\t\treturn str ?? \"\";\n\t\t}\n\t\treturn strings[sid - STANDARD_STRINGS.length] ?? \"\";\n\t};\n\n\tconst dictEntries = [...dict];\n\tfor (let i = 0; i < dictEntries.length; i++) {\n\t\tconst [op, operands] = dictEntries[i]!;\n\t\tconst op0 = operands[0];\n\t\tconst op1 = operands[1];\n\t\tconst op2 = operands[2];\n\n\t\tswitch (op) {\n\t\t\tcase TopDictOp.version:\n\t\t\t\tif (op0 !== undefined) result.version = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Notice:\n\t\t\t\tif (op0 !== undefined) result.notice = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Copyright:\n\t\t\t\tif (op0 !== undefined) result.copyright = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FullName:\n\t\t\t\tif (op0 !== undefined) result.fullName = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FamilyName:\n\t\t\t\tif (op0 !== undefined) result.familyName = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Weight:\n\t\t\t\tif (op0 !== undefined) result.weight = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.isFixedPitch:\n\t\t\t\tresult.isFixedPitch = op0 !== 0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.ItalicAngle:\n\t\t\t\tresult.italicAngle = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UnderlinePosition:\n\t\t\t\tresult.underlinePosition = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UnderlineThickness:\n\t\t\t\tresult.underlineThickness = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.PaintType:\n\t\t\t\tresult.paintType = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CharstringType:\n\t\t\t\tresult.charstringType = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FontMatrix:\n\t\t\t\tresult.fontMatrix = operands;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UniqueID:\n\t\t\t\tresult.uniqueID = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FontBBox:\n\t\t\t\tresult.fontBBox = operands;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.StrokeWidth:\n\t\t\t\tresult.strokeWidth = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.charset:\n\t\t\t\tresult.charset = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Encoding:\n\t\t\t\tresult.encoding = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CharStrings:\n\t\t\t\tresult.charStrings = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.Private:\n\t\t\t\tif (op0 !== undefined && op1 !== undefined) {\n\t\t\t\t\tresult.private = [op0, op1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.SyntheticBase:\n\t\t\t\tresult.syntheticBase = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.PostScript:\n\t\t\t\tif (op0 !== undefined) result.postScript = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.BaseFontName:\n\t\t\t\tif (op0 !== undefined) result.baseFontName = getString(op0);\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.BaseFontBlend:\n\t\t\t\tresult.baseFontBlend = operands;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.ROS:\n\t\t\t\tif (op0 !== undefined && op1 !== undefined && op2 !== undefined) {\n\t\t\t\t\tresult.ros = {\n\t\t\t\t\t\tregistry: getString(op0),\n\t\t\t\t\t\tordering: getString(op1),\n\t\t\t\t\t\tsupplement: op2,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDFontVersion:\n\t\t\t\tresult.cidFontVersion = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDFontRevision:\n\t\t\t\tresult.cidFontRevision = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDFontType:\n\t\t\t\tresult.cidFontType = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.CIDCount:\n\t\t\t\tresult.cidCount = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.UIDBase:\n\t\t\t\tresult.uidBase = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FDArray:\n\t\t\t\tresult.fdArray = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FDSelect:\n\t\t\t\tresult.fdSelect = op0;\n\t\t\t\tbreak;\n\t\t\tcase TopDictOp.FontName:\n\t\t\t\tif (op0 !== undefined) result.fontName = getString(op0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse Private DICT\n */\nfunction parsePrivateDict(reader: Reader, _strings: string[]): PrivateDict {\n\tconst dict = parseDict(reader);\n\tconst result: PrivateDict = {};\n\n\tconst dictEntries = [...dict];\n\tfor (let i = 0; i < dictEntries.length; i++) {\n\t\tconst [op, operands] = dictEntries[i]!;\n\t\tconst op0 = operands[0];\n\n\t\tswitch (op) {\n\t\t\tcase PrivateDictOp.BlueValues:\n\t\t\t\tresult.blueValues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.OtherBlues:\n\t\t\t\tresult.otherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.FamilyBlues:\n\t\t\t\tresult.familyBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.FamilyOtherBlues:\n\t\t\t\tresult.familyOtherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.BlueScale:\n\t\t\t\tresult.blueScale = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.BlueShift:\n\t\t\t\tresult.blueShift = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.BlueFuzz:\n\t\t\t\tresult.blueFuzz = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StdHW:\n\t\t\t\tresult.stdHW = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StdVW:\n\t\t\t\tresult.stdVW = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StemSnapH:\n\t\t\t\tresult.stemSnapH = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.StemSnapV:\n\t\t\t\tresult.stemSnapV = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.ForceBold:\n\t\t\t\tresult.forceBold = op0 !== 0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.LanguageGroup:\n\t\t\t\tresult.languageGroup = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.ExpansionFactor:\n\t\t\t\tresult.expansionFactor = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.initialRandomSeed:\n\t\t\t\tresult.initialRandomSeed = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.Subrs:\n\t\t\t\tresult.subrs = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.defaultWidthX:\n\t\t\t\tresult.defaultWidthX = op0;\n\t\t\t\tbreak;\n\t\t\tcase PrivateDictOp.nominalWidthX:\n\t\t\t\tresult.nominalWidthX = op0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert delta-encoded values to absolute\n */\nfunction deltaToAbsolute(deltas: number[]): number[] {\n\tconst result: number[] = [];\n\tlet value = 0;\n\tfor (let i = 0; i < deltas.length; i++) {\n\t\tconst delta = deltas[i]!;\n\t\tvalue += delta;\n\t\tresult.push(value);\n\t}\n\treturn result;\n}\n\n/**\n * Parse FDSelect structure\n */\nfunction parseFDSelect(reader: Reader, numGlyphs: number): FDSelect {\n\tconst format = reader.uint8();\n\n\tif (format === 0) {\n\t\tconst fds = reader.uint8Array(numGlyphs);\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => fds[glyphId] ?? 0,\n\t\t};\n\t} else if (format === 3) {\n\t\tconst nRanges = reader.uint16();\n\t\tconst ranges: Array<{ first: number; fd: number }> = [];\n\n\t\tfor (let i = 0; i < nRanges; i++) {\n\t\t\tranges.push({\n\t\t\t\tfirst: reader.uint16(),\n\t\t\t\tfd: reader.uint8(),\n\t\t\t});\n\t\t}\n\t\tconst _sentinel = reader.uint16();\n\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => {\n\t\t\t\t// Binary search through ranges\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = ranges.length - 1;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tconst mid = Math.ceil((lo + hi) / 2);\n\t\t\t\t\tconst range = ranges[mid];\n\t\t\t\t\tif (range && range.first <= glyphId) {\n\t\t\t\t\t\tlo = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst foundRange = ranges[lo];\n\t\t\t\treturn foundRange?.fd ?? 0;\n\t\t\t},\n\t\t};\n\t}\n\n\treturn { format, select: () => 0 };\n}\n\n/**\n * Get string by SID\n */\nexport function getCffString(cff: CffTable, sid: number): string {\n\tif (sid < STANDARD_STRINGS.length) {\n\t\tconst str = STANDARD_STRINGS[sid];\n\t\treturn str ?? \"\";\n\t}\n\treturn cff.strings[sid - STANDARD_STRINGS.length] ?? \"\";\n}\n",
    "import type { GlyphId } from \"../../types.ts\";\nimport type { CffTable } from \"./cff.ts\";\nimport type { Cff2Table, ItemVariationStore } from \"./cff2.ts\";\nimport type { Contour, GlyphPoint } from \"./glyf.ts\";\n\n/**\n * CFF CharString interpreter\n * Executes Type 2 CharString programs to produce glyph outlines\n */\n\n// CharString operators\nenum Op {\n\t// Path construction\n\thstem = 1,\n\tvstem = 3,\n\tvmoveto = 4,\n\trlineto = 5,\n\thlineto = 6,\n\tvlineto = 7,\n\trrcurveto = 8,\n\tcallsubr = 10,\n\treturn_ = 11,\n\tendchar = 14,\n\thstemhm = 18,\n\thintmask = 19,\n\tcntrmask = 20,\n\trmoveto = 21,\n\thmoveto = 22,\n\tvstemhm = 23,\n\trcurveline = 24,\n\trlinecurve = 25,\n\tvvcurveto = 26,\n\thhcurveto = 27,\n\tcallgsubr = 29,\n\tvhcurveto = 30,\n\thvcurveto = 31,\n\n\t// Two-byte operators (12 xx)\n\tdotsection = 0x0c00,\n\tand_ = 0x0c03,\n\tor_ = 0x0c04,\n\tnot_ = 0x0c05,\n\tabs_ = 0x0c09,\n\tadd_ = 0x0c0a,\n\tsub_ = 0x0c0b,\n\tdiv_ = 0x0c0c,\n\tneg_ = 0x0c0e,\n\teq_ = 0x0c0f,\n\tdrop_ = 0x0c12,\n\tput_ = 0x0c14,\n\tget_ = 0x0c15,\n\tifelse_ = 0x0c16,\n\trandom_ = 0x0c17,\n\tmul_ = 0x0c18,\n\tsqrt_ = 0x0c1a,\n\tdup_ = 0x0c1b,\n\texch_ = 0x0c1c,\n\tindex_ = 0x0c1d,\n\troll_ = 0x0c1e,\n\thflex = 0x0c22,\n\tflex = 0x0c23,\n\thflex1 = 0x0c24,\n\tflex1 = 0x0c25,\n\n\t// CFF2 operators\n\tvsindex = 15,\n\tblend = 16,\n}\n\ninterface CharStringState {\n\tx: number;\n\ty: number;\n\tstack: number[];\n\t/** Current read position for shift-like operations (O(1) instead of O(n) shift) */\n\tstackPos: number;\n\tnStems: number;\n\thaveWidth: boolean;\n\twidth: number;\n\tcontours: Contour[];\n\tcurrentContour: GlyphPoint[];\n\ttransientArray: number[];\n\t// For subroutine calls\n\tcallStack: { data: Uint8Array; pos: number }[];\n\t// For CFF2 blending\n\tvsindex: number;\n\taxisCoords: number[] | null;\n\tvstore: ItemVariationStore | null;\n}\n\n/** Get number of available stack values (from stackPos to end) */\nfunction stackLen(state: CharStringState): number {\n\treturn state.stack.length - state.stackPos;\n}\n\n/** Read next value from stack (replaces shift - O(1)) */\nfunction stackShift(state: CharStringState): number | undefined {\n\tif (state.stackPos >= state.stack.length) return undefined;\n\treturn state.stack[state.stackPos++];\n}\n\n/** Clear the stack (reset both pointer and length) */\nfunction stackClear(state: CharStringState): void {\n\tstate.stack.length = 0;\n\tstate.stackPos = 0;\n}\n\n/**\n * Execute a CFF charstring and return contours\n */\nexport function executeCffCharString(\n\tcff: CffTable,\n\tglyphId: GlyphId,\n\tfontIndex: number = 0,\n): Contour[] | null {\n\tconst charStrings = cff.charStrings[fontIndex];\n\tif (!charStrings || glyphId >= charStrings.length) return null;\n\n\tconst charString = charStrings[glyphId];\n\tif (!charString) return null;\n\n\tconst globalSubrs = cff.globalSubrs;\n\n\t// For CID fonts, use fdSelect to get the right FD and its local subrs\n\tconst topDict = cff.topDicts[fontIndex];\n\tconst isCID = topDict?.ros !== undefined;\n\tlet localSubrs: Uint8Array[] = [];\n\n\tif (isCID && cff.fdSelects[fontIndex] && cff.fdArrays[fontIndex]) {\n\t\tconst fdIndex = cff.fdSelects[fontIndex]?.select(glyphId) ?? 0;\n\t\tconst fdArray = cff.fdArrays[fontIndex];\n\t\tconst fd = fdArray?.[fdIndex];\n\t\t// Use FD-specific local subrs if available\n\t\tlocalSubrs = fd?.localSubrs || cff.localSubrs[fontIndex] || [];\n\t} else {\n\t\tlocalSubrs = cff.localSubrs[fontIndex] || [];\n\t}\n\n\tconst state: CharStringState = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tstack: [],\n\t\tstackPos: 0,\n\t\tnStems: 0,\n\t\thaveWidth: false,\n\t\twidth: 0,\n\t\tcontours: [],\n\t\tcurrentContour: [],\n\t\ttransientArray: new Array(32).fill(0),\n\t\tcallStack: [],\n\t\tvsindex: 0,\n\t\taxisCoords: null,\n\t\tvstore: null,\n\t};\n\n\texecuteCharString(state, charString, globalSubrs, localSubrs);\n\n\t// Close any open contour\n\tif (state.currentContour.length > 0) {\n\t\tstate.contours.push(state.currentContour);\n\t}\n\n\treturn state.contours;\n}\n\n/**\n * Execute a CFF2 charstring with variation support\n */\nexport function executeCff2CharString(\n\tcff2: Cff2Table,\n\tglyphId: GlyphId,\n\taxisCoords: number[] | null = null,\n): Contour[] | null {\n\tif (glyphId >= cff2.charStrings.length) return null;\n\n\tconst charString = cff2.charStrings[glyphId];\n\tif (!charString) return null;\n\n\tconst globalSubrs = cff2.globalSubrs;\n\n\t// Get FD index and local subrs\n\tconst fdIndex = cff2.fdSelect?.select(glyphId) ?? 0;\n\tconst fd = cff2.fdArray[fdIndex];\n\tconst localSubrs = fd?.localSubrs || [];\n\n\tconst state: CharStringState = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tstack: [],\n\t\tstackPos: 0,\n\t\tnStems: 0,\n\t\thaveWidth: true, // CFF2 doesn't have width in charstring\n\t\twidth: 0,\n\t\tcontours: [],\n\t\tcurrentContour: [],\n\t\ttransientArray: new Array(32).fill(0),\n\t\tcallStack: [],\n\t\tvsindex: fd?.private?.vsindex ?? 0,\n\t\taxisCoords,\n\t\tvstore: cff2.vstore,\n\t};\n\n\texecuteCharString(state, charString, globalSubrs, localSubrs);\n\n\t// Close any open contour\n\tif (state.currentContour.length > 0) {\n\t\tstate.contours.push(state.currentContour);\n\t}\n\n\treturn state.contours;\n}\n\nfunction executeCharString(\n\tstate: CharStringState,\n\tdata: Uint8Array,\n\tglobalSubrs: Uint8Array[],\n\tlocalSubrs: Uint8Array[],\n): void {\n\tlet pos = 0;\n\n\twhile (pos < data.length) {\n\t\tconst b0 = data[pos++];\n\t\tif (b0 === undefined) return;\n\n\t\tif (b0 === 28) {\n\t\t\t// 16-bit signed integer\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tconst b2 = data[pos++];\n\t\t\tif (b2 === undefined) return;\n\t\t\tstate.stack.push((((b1 << 8) | b2) << 16) >> 16);\n\t\t} else if (b0 === 255) {\n\t\t\t// 32-bit fixed point (16.16)\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tconst b2 = data[pos++];\n\t\t\tif (b2 === undefined) return;\n\t\t\tconst b3 = data[pos++];\n\t\t\tif (b3 === undefined) return;\n\t\t\tconst b4 = data[pos++];\n\t\t\tif (b4 === undefined) return;\n\t\t\tconst val = ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) >> 0;\n\t\t\tstate.stack.push(val / 65536);\n\t\t} else if (b0 >= 32 && b0 <= 246) {\n\t\t\tstate.stack.push(b0 - 139);\n\t\t} else if (b0 >= 247 && b0 <= 250) {\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tstate.stack.push((b0 - 247) * 256 + b1 + 108);\n\t\t} else if (b0 >= 251 && b0 <= 254) {\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tstate.stack.push(-(b0 - 251) * 256 - b1 - 108);\n\t\t} else if (b0 === 12) {\n\t\t\t// Two-byte operator\n\t\t\tconst b1 = data[pos++];\n\t\t\tif (b1 === undefined) return;\n\t\t\tconst op = 0x0c00 | b1;\n\t\t\texecuteOperator(state, op, globalSubrs, localSubrs);\n\t\t} else if (b0 === Op.hintmask || b0 === Op.cntrmask) {\n\t\t\t// hintmask/cntrmask: process stems from stack, then skip mask bytes\n\t\t\tconst len = stackLen(state);\n\t\t\tconst hasWidth = len % 2 !== 0;\n\t\t\tif (hasWidth && !state.haveWidth) {\n\t\t\t\tconst width = stackShift(state);\n\t\t\t\tif (width !== undefined) {\n\t\t\t\t\tstate.width = width;\n\t\t\t\t\tstate.haveWidth = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.nStems += stackLen(state) / 2;\n\t\t\tstackClear(state);\n\t\t\t// Skip mask bytes (ceil(nStems / 8) bytes)\n\t\t\tconst maskBytes = Math.ceil(state.nStems / 8);\n\t\t\tpos += maskBytes;\n\t\t} else {\n\t\t\t// Single-byte operator\n\t\t\texecuteOperator(state, b0, globalSubrs, localSubrs);\n\t\t}\n\n\t\t// Handle return from subroutine\n\t\tif (state.callStack.length > 0) {\n\t\t\tconst frame = state.callStack[state.callStack.length - 1];\n\t\t\tif (frame && frame.pos >= frame.data.length) {\n\t\t\t\tstate.callStack.pop();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction executeOperator(\n\tstate: CharStringState,\n\top: number,\n\tglobalSubrs: Uint8Array[],\n\tlocalSubrs: Uint8Array[],\n): void {\n\tconst stack = state.stack;\n\n\tswitch (op) {\n\t\tcase Op.hstem:\n\t\tcase Op.vstem:\n\t\tcase Op.hstemhm:\n\t\tcase Op.vstemhm: {\n\t\t\t// Stem hints\n\t\t\tconst len = stackLen(state);\n\t\t\tconst hasWidth = len % 2 !== 0;\n\t\t\tif (hasWidth && !state.haveWidth) {\n\t\t\t\tconst width = stackShift(state);\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\tstate.nStems += stackLen(state) / 2;\n\t\t\tstackClear(state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hintmask:\n\t\tcase Op.cntrmask:\n\t\t\t// Handled inline in executeCharString to skip mask bytes\n\t\t\tbreak;\n\n\t\tcase Op.rmoveto: {\n\t\t\tif (stackLen(state) > 2 && !state.haveWidth) {\n\t\t\t\tconst width = stackShift(state);\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\t// Close current contour if any\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\t// rmoveto uses shift order: dx dy\n\t\t\tconst dx = stackShift(state);\n\t\t\tif (dx === undefined) break;\n\t\t\tconst dy = stackShift(state);\n\t\t\tif (dy === undefined) break;\n\t\t\tstate.x += dx;\n\t\t\tstate.y += dy;\n\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\tstackClear(state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hmoveto: {\n\t\t\tif (stackLen(state) > 1 && !state.haveWidth) {\n\t\t\t\tconst width = stackShift(state);\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tconst dx = stackShift(state);\n\t\t\tif (dx === undefined) break;\n\t\t\tstate.x += dx;\n\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\tstackClear(state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vmoveto: {\n\t\t\tif (stackLen(state) > 1 && !state.haveWidth) {\n\t\t\t\tconst width = stackShift(state);\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tconst dy = stackShift(state);\n\t\t\tif (dy === undefined) break;\n\t\t\tstate.y += dy;\n\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\tstackClear(state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rlineto: {\n\t\t\twhile (stackLen(state) >= 2) {\n\t\t\t\tconst dx = stackShift(state);\n\t\t\t\tif (dx === undefined) break;\n\t\t\t\tconst dy = stackShift(state);\n\t\t\t\tif (dy === undefined) break;\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hlineto: {\n\t\t\tlet isHorizontal = true;\n\t\t\twhile (stackLen(state) >= 1) {\n\t\t\t\tconst val = stackShift(state);\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tstate.x += val;\n\t\t\t\t} else {\n\t\t\t\t\tstate.y += val;\n\t\t\t\t}\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t\tisHorizontal = !isHorizontal;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vlineto: {\n\t\t\tlet isVertical = true;\n\t\t\twhile (stackLen(state) >= 1) {\n\t\t\t\tconst val = stackShift(state);\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tif (isVertical) {\n\t\t\t\t\tstate.y += val;\n\t\t\t\t} else {\n\t\t\t\t\tstate.x += val;\n\t\t\t\t}\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t\tisVertical = !isVertical;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rrcurveto: {\n\t\t\twhile (stackLen(state) >= 6) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hhcurveto: {\n\t\t\tlet dy1 = 0;\n\t\t\tif (stackLen(state) % 4 === 1) {\n\t\t\t\tconst val = stackShift(state);\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tdy1 = val;\n\t\t\t}\n\t\t\twhile (stackLen(state) >= 4) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, 0);\n\t\t\t\tdy1 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vvcurveto: {\n\t\t\tlet dx1 = 0;\n\t\t\tif (stackLen(state) % 4 === 1) {\n\t\t\t\tconst val = stackShift(state);\n\t\t\t\tif (val === undefined) break;\n\t\t\t\tdx1 = val;\n\t\t\t}\n\t\t\twhile (stackLen(state) >= 4) {\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, 0, dy3);\n\t\t\t\tdx1 = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hvcurveto: {\n\t\t\t// Alternates horizontal/vertical starting tangent\n\t\t\tlet isHorizontal = true;\n\t\t\twhile (stackLen(state) >= 4) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\t\tconst dx3 = stackLen(state) === 1 ? (stackShift(state) ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, dx1, 0, dx2, dy2, dx3, dy3);\n\t\t\t\t} else {\n\t\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\t\tconst dy3 = stackLen(state) === 1 ? (stackShift(state) ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, 0, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\t}\n\t\t\t\tisHorizontal = !isHorizontal;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vhcurveto: {\n\t\t\t// Alternates vertical/horizontal starting tangent\n\t\t\tlet isVertical = true;\n\t\t\twhile (stackLen(state) >= 4) {\n\t\t\t\tif (isVertical) {\n\t\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\t\tconst dy3 = stackLen(state) === 1 ? (stackShift(state) ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, 0, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\t} else {\n\t\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\t\tconst dx3 = stackLen(state) === 1 ? (stackShift(state) ?? 0) : 0;\n\t\t\t\t\taddCubicBezier(state, dx1, 0, dx2, dy2, dx3, dy3);\n\t\t\t\t}\n\t\t\t\tisVertical = !isVertical;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rcurveline: {\n\t\t\twhile (stackLen(state) >= 8) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t}\n\t\t\t// Final line\n\t\t\tif (stackLen(state) >= 2) {\n\t\t\t\tconst dx = stackShift(state);\n\t\t\t\tif (dx === undefined) break;\n\t\t\t\tconst dy = stackShift(state);\n\t\t\t\tif (dy === undefined) break;\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.rlinecurve: {\n\t\t\twhile (stackLen(state) >= 8) {\n\t\t\t\tconst dx = stackShift(state);\n\t\t\t\tif (dx === undefined) break;\n\t\t\t\tconst dy = stackShift(state);\n\t\t\t\tif (dy === undefined) break;\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t\tstate.currentContour.push({ x: state.x, y: state.y, onCurve: true });\n\t\t\t}\n\t\t\t// Final curve\n\t\t\tif (stackLen(state) >= 6) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.callsubr: {\n\t\t\tconst index = stack.pop();\n\t\t\tif (index === undefined) break;\n\t\t\tconst biasedIndex = index + getSubrBias(localSubrs.length);\n\t\t\tconst subr = localSubrs[biasedIndex];\n\t\t\tif (subr) {\n\t\t\t\texecuteCharString(state, subr, globalSubrs, localSubrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.callgsubr: {\n\t\t\tconst index = stack.pop();\n\t\t\tif (index === undefined) break;\n\t\t\tconst biasedIndex = index + getSubrBias(globalSubrs.length);\n\t\t\tconst subr = globalSubrs[biasedIndex];\n\t\t\tif (subr) {\n\t\t\t\texecuteCharString(state, subr, globalSubrs, localSubrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.return_:\n\t\t\t// Return from subroutine - handled by caller\n\t\t\tbreak;\n\n\t\tcase Op.endchar: {\n\t\t\tif (stackLen(state) > 0 && !state.haveWidth) {\n\t\t\t\tconst width = stackShift(state);\n\t\t\t\tif (width === undefined) break;\n\t\t\t\tstate.width = width;\n\t\t\t\tstate.haveWidth = true;\n\t\t\t}\n\t\t\t// Close current contour\n\t\t\tif (state.currentContour.length > 0) {\n\t\t\t\tstate.contours.push(state.currentContour);\n\t\t\t\tstate.currentContour = [];\n\t\t\t}\n\t\t\tstackClear(state);\n\t\t\tbreak;\n\t\t}\n\n\t\t// Flex operators\n\t\tcase Op.flex: {\n\t\t\t// 12 arguments: dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd\n\t\t\tif (stackLen(state) >= 13) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\tconst dx4 = stackShift(state);\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dy4 = stackShift(state);\n\t\t\t\tif (dy4 === undefined) break;\n\t\t\t\tconst dx5 = stackShift(state);\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dy5 = stackShift(state);\n\t\t\t\tif (dy5 === undefined) break;\n\t\t\t\tconst dx6 = stackShift(state);\n\t\t\t\tif (dx6 === undefined) break;\n\t\t\t\tconst dy6 = stackShift(state);\n\t\t\t\tif (dy6 === undefined) break;\n\t\t\t\tstackShift(state); // fd (flex depth) - not used for rendering\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\taddCubicBezier(state, dx4, dy4, dx5, dy5, dx6, dy6);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hflex: {\n\t\t\t// dx1 dx2 dy2 dx3 dx4 dx5 dx6\n\t\t\tif (stackLen(state) >= 7) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dx4 = stackShift(state);\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dx5 = stackShift(state);\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dx6 = stackShift(state);\n\t\t\t\tif (dx6 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, 0, dx2, dy2, dx3, 0);\n\t\t\t\taddCubicBezier(state, dx4, 0, dx5, -dy2, dx6, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.hflex1: {\n\t\t\t// dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6\n\t\t\tif (stackLen(state) >= 9) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dx4 = stackShift(state);\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dx5 = stackShift(state);\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dy5 = stackShift(state);\n\t\t\t\tif (dy5 === undefined) break;\n\t\t\t\tconst dx6 = stackShift(state);\n\t\t\t\tif (dx6 === undefined) break;\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, 0);\n\t\t\t\taddCubicBezier(state, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.flex1: {\n\t\t\t// dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6\n\t\t\tif (stackLen(state) >= 11) {\n\t\t\t\tconst dx1 = stackShift(state);\n\t\t\t\tif (dx1 === undefined) break;\n\t\t\t\tconst dy1 = stackShift(state);\n\t\t\t\tif (dy1 === undefined) break;\n\t\t\t\tconst dx2 = stackShift(state);\n\t\t\t\tif (dx2 === undefined) break;\n\t\t\t\tconst dy2 = stackShift(state);\n\t\t\t\tif (dy2 === undefined) break;\n\t\t\t\tconst dx3 = stackShift(state);\n\t\t\t\tif (dx3 === undefined) break;\n\t\t\t\tconst dy3 = stackShift(state);\n\t\t\t\tif (dy3 === undefined) break;\n\t\t\t\tconst dx4 = stackShift(state);\n\t\t\t\tif (dx4 === undefined) break;\n\t\t\t\tconst dy4 = stackShift(state);\n\t\t\t\tif (dy4 === undefined) break;\n\t\t\t\tconst dx5 = stackShift(state);\n\t\t\t\tif (dx5 === undefined) break;\n\t\t\t\tconst dy5 = stackShift(state);\n\t\t\t\tif (dy5 === undefined) break;\n\t\t\t\tconst d6 = stackShift(state);\n\t\t\t\tif (d6 === undefined) break;\n\n\t\t\t\tconst dx = dx1 + dx2 + dx3 + dx4 + dx5;\n\t\t\t\tconst dy = dy1 + dy2 + dy3 + dy4 + dy5;\n\n\t\t\t\tlet dx6: number, dy6: number;\n\t\t\t\tif (Math.abs(dx) > Math.abs(dy)) {\n\t\t\t\t\tdx6 = d6;\n\t\t\t\t\tdy6 = -dy;\n\t\t\t\t} else {\n\t\t\t\t\tdx6 = -dx;\n\t\t\t\t\tdy6 = d6;\n\t\t\t\t}\n\n\t\t\t\taddCubicBezier(state, dx1, dy1, dx2, dy2, dx3, dy3);\n\t\t\t\taddCubicBezier(state, dx4, dy4, dx5, dy5, dx6, dy6);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// Arithmetic operators\n\t\tcase Op.and_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a && b ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.or_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a || b ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.not_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a ? 0 : 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.abs_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(Math.abs(a));\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.add_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a + b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.sub_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a - b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.div_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a / b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.neg_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(-a);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.eq_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a === b ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.drop_: {\n\t\t\tstack.pop();\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.put_: {\n\t\t\tconst i = stack.pop();\n\t\t\tif (i === undefined) break;\n\t\t\tconst val = stack.pop();\n\t\t\tif (val === undefined) break;\n\t\t\tstate.transientArray[i] = val;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.get_: {\n\t\t\tconst i = stack.pop();\n\t\t\tif (i === undefined) break;\n\t\t\tstack.push(state.transientArray[i] ?? 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.ifelse_: {\n\t\t\tconst v2 = stack.pop();\n\t\t\tif (v2 === undefined) break;\n\t\t\tconst v1 = stack.pop();\n\t\t\tif (v1 === undefined) break;\n\t\t\tconst s2 = stack.pop();\n\t\t\tif (s2 === undefined) break;\n\t\t\tconst s1 = stack.pop();\n\t\t\tif (s1 === undefined) break;\n\t\t\tstack.push(v1 <= v2 ? s1 : s2);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.random_: {\n\t\t\tstack.push(Math.random());\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.mul_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a * b);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.sqrt_: {\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(Math.sqrt(a));\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.dup_: {\n\t\t\tconst a = stack[stack.length - 1];\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(a);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.exch_: {\n\t\t\tconst b = stack.pop();\n\t\t\tif (b === undefined) break;\n\t\t\tconst a = stack.pop();\n\t\t\tif (a === undefined) break;\n\t\t\tstack.push(b, a);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.index_: {\n\t\t\tconst i = stack.pop();\n\t\t\tif (i === undefined) break;\n\t\t\tconst idx = stack.length - 1 - i;\n\t\t\tstack.push(stack[idx] ?? 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.roll_: {\n\t\t\tconst j = stack.pop();\n\t\t\tif (j === undefined) break;\n\t\t\tconst n = stack.pop();\n\t\t\tif (n === undefined) break;\n\t\t\tif (n > 0) {\n\t\t\t\tconst items = stack.splice(-n);\n\t\t\t\tconst shift = ((j % n) + n) % n;\n\t\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\t\tconst item = items[(i + shift) % n];\n\t\t\t\t\tif (item !== undefined) {\n\t\t\t\t\t\tstack.push(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// CFF2 blend operator\n\t\tcase Op.blend: {\n\t\t\tif (!state.axisCoords || !state.vstore) break;\n\n\t\t\tconst n = stack.pop();\n\t\t\tif (n === undefined) break;\n\t\t\tconst regionCount =\n\t\t\t\tstate.vstore.itemVariationData[state.vsindex]?.regionIndexCount ?? 0;\n\n\t\t\t// For each of n values, there are regionCount deltas\n\t\t\tconst totalDeltaCount = n * regionCount;\n\t\t\tconst deltas = stack.splice(-totalDeltaCount);\n\t\t\tconst defaults = stack.splice(-n);\n\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tconst defaultVal = defaults[i];\n\t\t\t\tif (defaultVal === undefined) continue;\n\t\t\t\tlet value = defaultVal;\n\t\t\t\tfor (let r = 0; r < regionCount; r++) {\n\t\t\t\t\tconst delta = deltas[i * regionCount + r];\n\t\t\t\t\tif (delta === undefined) continue;\n\t\t\t\t\tconst scalar = computeRegionScalar(\n\t\t\t\t\t\tstate.vstore,\n\t\t\t\t\t\tstate.vsindex,\n\t\t\t\t\t\tr,\n\t\t\t\t\t\tstate.axisCoords,\n\t\t\t\t\t);\n\t\t\t\t\tvalue += delta * scalar;\n\t\t\t\t}\n\t\t\t\tstack.push(value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.vsindex: {\n\t\t\tconst vsindex = stack.pop();\n\t\t\tif (vsindex === undefined) break;\n\t\t\tstate.vsindex = vsindex;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase Op.dotsection:\n\t\t\t// Deprecated, ignore\n\t\t\tbreak;\n\t}\n}\n\nfunction addCubicBezier(\n\tstate: CharStringState,\n\tdx1: number,\n\tdy1: number,\n\tdx2: number,\n\tdy2: number,\n\tdx3: number,\n\tdy3: number,\n): void {\n\t// CFF uses cubic Beziers\n\t// Store control points with onCurve: false and special marker for cubic\n\t// We use a convention: cubic control points are stored as pairs with a special flag\n\n\tconst x0 = state.x;\n\tconst y0 = state.y;\n\tconst x1 = x0 + dx1;\n\tconst y1 = y0 + dy1;\n\tconst x2 = x1 + dx2;\n\tconst y2 = y1 + dy2;\n\tconst x3 = x2 + dx3;\n\tconst y3 = y2 + dy3;\n\n\t// Store as: cp1 (cubic=true), cp2 (cubic=true), endpoint (onCurve=true)\n\t// The 'cubic' property distinguishes this from TrueType quadratic off-curve points\n\tstate.currentContour.push({\n\t\tx: x1,\n\t\ty: y1,\n\t\tonCurve: false,\n\t\tcubic: true,\n\t} as GlyphPoint);\n\tstate.currentContour.push({\n\t\tx: x2,\n\t\ty: y2,\n\t\tonCurve: false,\n\t\tcubic: true,\n\t} as GlyphPoint);\n\tstate.currentContour.push({ x: x3, y: y3, onCurve: true });\n\n\tstate.x = x3;\n\tstate.y = y3;\n}\n\nfunction getSubrBias(count: number): number {\n\tif (count < 1240) return 107;\n\tif (count < 33900) return 1131;\n\treturn 32768;\n}\n\nfunction computeRegionScalar(\n\tvstore: ItemVariationStore,\n\tvsindex: number,\n\tregionIndex: number,\n\taxisCoords: number[],\n): number {\n\tconst data = vstore.itemVariationData[vsindex];\n\tif (!data) return 0;\n\n\tconst actualRegionIndex = data.regionIndexes[regionIndex];\n\tif (actualRegionIndex === undefined) return 0;\n\n\tconst region = vstore.variationRegionList.regions[actualRegionIndex];\n\tif (!region) return 0;\n\n\tlet scalar = 1;\n\tfor (let i = 0; i < region.axes.length && i < axisCoords.length; i++) {\n\t\tconst coords = region.axes[i];\n\t\tif (!coords) continue;\n\t\tconst coord = axisCoords[i];\n\t\tif (coord === undefined) continue;\n\n\t\tif (coord < coords.startCoord || coord > coords.endCoord) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (coord === coords.peakCoord) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (coord < coords.peakCoord) {\n\t\t\tscalar *=\n\t\t\t\t(coord - coords.startCoord) / (coords.peakCoord - coords.startCoord);\n\t\t} else {\n\t\t\tscalar *=\n\t\t\t\t(coords.endCoord - coord) / (coords.endCoord - coords.peakCoord);\n\t\t}\n\t}\n\n\treturn scalar;\n}\n\n/**\n * Get glyph width from CFF charstring\n */\nexport function getCffGlyphWidth(\n\tcff: CffTable,\n\t_glyphId: GlyphId,\n\tfontIndex: number = 0,\n): number {\n\t// Would need to parse charstring just enough to get width\n\t// For now, return nominalWidthX as default\n\tconst _topDict = cff.topDicts[fontIndex];\n\treturn 0; // Proper implementation would parse the charstring\n}\n",
    "import { Reader } from \"../binary/reader.ts\";\n\n/**\n * CFF2 (Compact Font Format 2) table parser\n * Used by variable fonts with PostScript outlines\n */\n\nexport interface Cff2Table {\n\tversion: { major: number; minor: number };\n\ttopDict: Cff2TopDict;\n\tglobalSubrs: Uint8Array[];\n\tcharStrings: Uint8Array[];\n\tfdArray: Cff2FDDict[];\n\tfdSelect: Cff2FDSelect | null;\n\tvstore: ItemVariationStore | null;\n}\n\nexport interface Cff2TopDict {\n\tcharStrings?: number;\n\tfdArray?: number;\n\tfdSelect?: number;\n\tvstore?: number;\n\tfontMatrix?: number[];\n}\n\nexport interface Cff2PrivateDict {\n\tblueValues?: number[];\n\totherBlues?: number[];\n\tfamilyBlues?: number[];\n\tfamilyOtherBlues?: number[];\n\tblueScale?: number;\n\tblueShift?: number;\n\tblueFuzz?: number;\n\tstdHW?: number;\n\tstdVW?: number;\n\tstemSnapH?: number[];\n\tstemSnapV?: number[];\n\tlanguageGroup?: number;\n\texpansionFactor?: number;\n\tsubrs?: number;\n\tvsindex?: number;\n\tblend?: number[];\n}\n\nexport interface Cff2FDDict {\n\tfontName?: string;\n\tprivate?: Cff2PrivateDict;\n\tprivateOffset?: number;\n\tprivateSize?: number;\n\tlocalSubrs?: Uint8Array[];\n}\n\nexport interface Cff2FDSelect {\n\tformat: number;\n\tselect: (glyphId: number) => number;\n}\n\nexport interface ItemVariationStore {\n\tformat: number;\n\tvariationRegionList: VariationRegionList;\n\titemVariationData: ItemVariationData[];\n}\n\nexport interface VariationRegionList {\n\taxisCount: number;\n\tregionCount: number;\n\tregions: VariationRegion[];\n}\n\nexport interface VariationRegion {\n\taxes: RegionAxisCoordinates[];\n}\n\nexport interface RegionAxisCoordinates {\n\tstartCoord: number;\n\tpeakCoord: number;\n\tendCoord: number;\n}\n\nexport interface ItemVariationData {\n\titemCount: number;\n\tregionIndexCount: number;\n\tregionIndexes: number[];\n\tdeltaSets: number[][];\n}\n\n// CFF2 Top DICT operators\nenum Cff2TopDictOp {\n\tFontMatrix = 0x0c07,\n\tCharStrings = 17,\n\tFDArray = 0x0c24,\n\tFDSelect = 0x0c25,\n\tvstore = 24,\n}\n\n// CFF2 Private DICT operators\nenum Cff2PrivateDictOp {\n\tBlueValues = 6,\n\tOtherBlues = 7,\n\tFamilyBlues = 8,\n\tFamilyOtherBlues = 9,\n\tStdHW = 10,\n\tStdVW = 11,\n\tSubrs = 19,\n\tvsindex = 22,\n\tblend = 23,\n\tBlueScale = 0x0c09,\n\tBlueShift = 0x0c0a,\n\tBlueFuzz = 0x0c0b,\n\tStemSnapH = 0x0c0c,\n\tStemSnapV = 0x0c0d,\n\tLanguageGroup = 0x0c11,\n\tExpansionFactor = 0x0c12,\n}\n\n/**\n * Parse CFF2 table\n */\nexport function parseCff2(reader: Reader): Cff2Table {\n\tconst startOffset = reader.offset;\n\n\t// Header\n\tconst major = reader.uint8();\n\tconst minor = reader.uint8();\n\tconst headerSize = reader.uint8();\n\tconst topDictLength = reader.uint16();\n\n\t// Skip to after header\n\treader.seek(startOffset + headerSize);\n\n\t// Top DICT (not an INDEX in CFF2, just raw data)\n\tconst topDictReader = reader.slice(\n\t\treader.offset - startOffset,\n\t\ttopDictLength,\n\t);\n\treader.skip(topDictLength);\n\tconst topDict = parseCff2TopDict(topDictReader);\n\n\t// Global Subr INDEX\n\tconst globalSubrs = parseIndex(reader);\n\n\t// CharStrings INDEX\n\tlet charStrings: Uint8Array[] = [];\n\tif (topDict.charStrings !== undefined) {\n\t\treader.seek(startOffset + topDict.charStrings);\n\t\tcharStrings = parseIndex(reader);\n\t}\n\n\t// FDArray INDEX\n\tconst fdArray: Cff2FDDict[] = [];\n\tif (topDict.fdArray !== undefined) {\n\t\treader.seek(startOffset + topDict.fdArray);\n\t\tconst fdDictData = parseIndex(reader);\n\n\t\tfor (let i = 0; i < fdDictData.length; i++) {\n\t\t\tconst data = fdDictData[i]!;\n\t\t\tconst fd = parseCff2FDDict(\n\t\t\t\tnew Reader(\n\t\t\t\t\tdata.buffer as ArrayBuffer,\n\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\tdata.byteLength,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Parse local subrs if Private DICT has them\n\t\t\tif (fd.privateOffset !== undefined && fd.privateSize !== undefined) {\n\t\t\t\treader.seek(startOffset + fd.privateOffset);\n\t\t\t\tconst privateReader = reader.slice(0, fd.privateSize);\n\t\t\t\tfd.private = parseCff2PrivateDict(privateReader);\n\n\t\t\t\tif (fd.private.subrs !== undefined) {\n\t\t\t\t\treader.seek(startOffset + fd.privateOffset + fd.private.subrs);\n\t\t\t\t\tfd.localSubrs = parseIndex(reader);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfdArray.push(fd);\n\t\t}\n\t}\n\n\t// FDSelect\n\tlet fdSelect: Cff2FDSelect | null = null;\n\tif (topDict.fdSelect !== undefined) {\n\t\treader.seek(startOffset + topDict.fdSelect);\n\t\tfdSelect = parseFDSelect(reader, charStrings.length);\n\t}\n\n\t// Variation Store\n\tlet vstore: ItemVariationStore | null = null;\n\tif (topDict.vstore !== undefined) {\n\t\treader.seek(startOffset + topDict.vstore);\n\t\tvstore = parseItemVariationStore(reader);\n\t}\n\n\treturn {\n\t\tversion: { major, minor },\n\t\ttopDict,\n\t\tglobalSubrs,\n\t\tcharStrings,\n\t\tfdArray,\n\t\tfdSelect,\n\t\tvstore,\n\t};\n}\n\n/**\n * Parse CFF2 INDEX structure (uses 32-bit count)\n */\nfunction parseIndex(reader: Reader): Uint8Array[] {\n\tconst count = reader.uint32();\n\tif (count === 0) return [];\n\n\tconst offSize = reader.uint8();\n\tconst offsets: number[] = [];\n\n\tfor (let i = 0; i <= count; i++) {\n\t\toffsets.push(readOffset(reader, offSize));\n\t}\n\n\tconst result: Uint8Array[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tconst start = offsets[i];\n\t\tconst end = offsets[i + 1];\n\t\tif (start === undefined || end === undefined) continue;\n\t\tconst length = end - start;\n\t\tresult.push(reader.bytes(length));\n\t}\n\n\treturn result;\n}\n\n/**\n * Read offset of given size\n */\nfunction readOffset(reader: Reader, offSize: number): number {\n\tswitch (offSize) {\n\t\tcase 1:\n\t\t\treturn reader.uint8();\n\t\tcase 2:\n\t\t\treturn reader.uint16();\n\t\tcase 3:\n\t\t\treturn reader.uint24();\n\t\tcase 4:\n\t\t\treturn reader.uint32();\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid offset size: ${offSize}`);\n\t}\n}\n\n/**\n * Parse a CFF2 DICT structure\n */\nfunction parseDict(reader: Reader): Map<number, number[]> {\n\tconst result = new Map<number, number[]>();\n\tconst operands: number[] = [];\n\n\twhile (reader.remaining > 0) {\n\t\tconst b0 = reader.uint8();\n\n\t\tif (b0 <= 21) {\n\t\t\t// Operator\n\t\t\tlet op = b0;\n\t\t\tif (b0 === 12) {\n\t\t\t\top = 0x0c00 | reader.uint8();\n\t\t\t}\n\t\t\tresult.set(op, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 22) {\n\t\t\t// vsindex operator\n\t\t\tresult.set(22, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 23) {\n\t\t\t// blend operator\n\t\t\tresult.set(23, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 24) {\n\t\t\t// vstore operator\n\t\t\tresult.set(24, [...operands]);\n\t\t\toperands.length = 0;\n\t\t} else if (b0 === 28) {\n\t\t\t// 16-bit signed integer\n\t\t\toperands.push(reader.int16());\n\t\t} else if (b0 === 29) {\n\t\t\t// 32-bit signed integer\n\t\t\toperands.push(reader.int32());\n\t\t} else if (b0 === 30) {\n\t\t\t// Real number\n\t\t\toperands.push(parseReal(reader));\n\t\t} else if (b0 >= 32 && b0 <= 246) {\n\t\t\toperands.push(b0 - 139);\n\t\t} else if (b0 >= 247 && b0 <= 250) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push((b0 - 247) * 256 + b1 + 108);\n\t\t} else if (b0 >= 251 && b0 <= 254) {\n\t\t\tconst b1 = reader.uint8();\n\t\t\toperands.push(-(b0 - 251) * 256 - b1 - 108);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse real number\n */\nfunction parseReal(reader: Reader): number {\n\tlet str = \"\";\n\tconst nibbleChars = \"0123456789.EE -\";\n\tlet done = false;\n\n\twhile (!done) {\n\t\tconst byte = reader.uint8();\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tconst nibble = i === 0 ? byte >> 4 : byte & 0x0f;\n\t\t\tif (nibble === 0x0f) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nibble === 0x0c) {\n\t\t\t\tstr += \"E-\";\n\t\t\t} else {\n\t\t\t\tconst char = nibbleChars[nibble];\n\t\t\t\tif (char !== undefined) str += char;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parseFloat(str);\n}\n\n/**\n * Parse CFF2 Top DICT\n */\nfunction parseCff2TopDict(reader: Reader): Cff2TopDict {\n\tconst dict = parseDict(reader);\n\tconst result: Cff2TopDict = {};\n\n\tconst dictEntries = [...dict];\n\tfor (let i = 0; i < dictEntries.length; i++) {\n\t\tconst [op, operands] = dictEntries[i]!;\n\t\tswitch (op) {\n\t\t\tcase Cff2TopDictOp.FontMatrix:\n\t\t\t\tresult.fontMatrix = operands;\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.CharStrings:\n\t\t\t\tresult.charStrings = operands[0];\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.FDArray:\n\t\t\t\tresult.fdArray = operands[0];\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.FDSelect:\n\t\t\t\tresult.fdSelect = operands[0];\n\t\t\t\tbreak;\n\t\t\tcase Cff2TopDictOp.vstore:\n\t\t\t\tresult.vstore = operands[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse CFF2 FD DICT\n */\nfunction parseCff2FDDict(reader: Reader): Cff2FDDict {\n\tconst dict = parseDict(reader);\n\tconst result: Cff2FDDict = {};\n\n\t// Private DICT pointer (operator 18)\n\tconst privateOp = dict.get(18);\n\tif (privateOp && privateOp.length >= 2) {\n\t\tresult.privateSize = privateOp[0];\n\t\tresult.privateOffset = privateOp[1];\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse CFF2 Private DICT\n */\nfunction parseCff2PrivateDict(reader: Reader): Cff2PrivateDict {\n\tconst dict = parseDict(reader);\n\tconst result: Cff2PrivateDict = {};\n\n\tconst dictEntries = [...dict];\n\tfor (let i = 0; i < dictEntries.length; i++) {\n\t\tconst [op, operands] = dictEntries[i]!;\n\t\tconst op0 = operands[0];\n\n\t\tswitch (op) {\n\t\t\tcase Cff2PrivateDictOp.BlueValues:\n\t\t\t\tresult.blueValues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.OtherBlues:\n\t\t\t\tresult.otherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.FamilyBlues:\n\t\t\t\tresult.familyBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.FamilyOtherBlues:\n\t\t\t\tresult.familyOtherBlues = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.BlueScale:\n\t\t\t\tresult.blueScale = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.BlueShift:\n\t\t\t\tresult.blueShift = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.BlueFuzz:\n\t\t\t\tresult.blueFuzz = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StdHW:\n\t\t\t\tresult.stdHW = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StdVW:\n\t\t\t\tresult.stdVW = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StemSnapH:\n\t\t\t\tresult.stemSnapH = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.StemSnapV:\n\t\t\t\tresult.stemSnapV = deltaToAbsolute(operands);\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.LanguageGroup:\n\t\t\t\tresult.languageGroup = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.ExpansionFactor:\n\t\t\t\tresult.expansionFactor = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.Subrs:\n\t\t\t\tresult.subrs = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.vsindex:\n\t\t\t\tresult.vsindex = op0;\n\t\t\t\tbreak;\n\t\t\tcase Cff2PrivateDictOp.blend:\n\t\t\t\tresult.blend = operands;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Convert delta-encoded values to absolute\n */\nfunction deltaToAbsolute(deltas: number[]): number[] {\n\tconst result: number[] = [];\n\tlet value = 0;\n\tfor (let i = 0; i < deltas.length; i++) {\n\t\tconst delta = deltas[i]!;\n\t\tvalue += delta;\n\t\tresult.push(value);\n\t}\n\treturn result;\n}\n\n/**\n * Parse FDSelect structure\n */\nfunction parseFDSelect(reader: Reader, numGlyphs: number): Cff2FDSelect {\n\tconst format = reader.uint8();\n\n\tif (format === 0) {\n\t\tconst fds = reader.uint8Array(numGlyphs);\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => fds[glyphId] ?? 0,\n\t\t};\n\t} else if (format === 3) {\n\t\tconst nRanges = reader.uint16();\n\t\tconst ranges: Array<{ first: number; fd: number }> = [];\n\n\t\tfor (let i = 0; i < nRanges; i++) {\n\t\t\tranges.push({\n\t\t\t\tfirst: reader.uint16(),\n\t\t\t\tfd: reader.uint8(),\n\t\t\t});\n\t\t}\n\t\treader.uint16(); // sentinel\n\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => {\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = ranges.length - 1;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tconst mid = Math.ceil((lo + hi) / 2);\n\t\t\t\t\tconst range = ranges[mid];\n\t\t\t\t\tif (range && range.first <= glyphId) {\n\t\t\t\t\t\tlo = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst foundRange = ranges[lo];\n\t\t\t\treturn foundRange?.fd ?? 0;\n\t\t\t},\n\t\t};\n\t} else if (format === 4) {\n\t\t// CFF2 format 4: 32-bit range records\n\t\tconst nRanges = reader.uint32();\n\t\tconst ranges: Array<{ first: number; fd: number }> = [];\n\n\t\tfor (let i = 0; i < nRanges; i++) {\n\t\t\tranges.push({\n\t\t\t\tfirst: reader.uint32(),\n\t\t\t\tfd: reader.uint16(),\n\t\t\t});\n\t\t}\n\t\treader.uint32(); // sentinel\n\n\t\treturn {\n\t\t\tformat,\n\t\t\tselect: (glyphId: number) => {\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = ranges.length - 1;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tconst mid = Math.ceil((lo + hi) / 2);\n\t\t\t\t\tconst range = ranges[mid];\n\t\t\t\t\tif (range && range.first <= glyphId) {\n\t\t\t\t\t\tlo = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst foundRange = ranges[lo];\n\t\t\t\treturn foundRange?.fd ?? 0;\n\t\t\t},\n\t\t};\n\t}\n\n\treturn { format, select: () => 0 };\n}\n\n/**\n * Parse ItemVariationStore\n */\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst startOffset = reader.offset;\n\n\tconst _length = reader.uint16();\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.uint32();\n\tconst itemVariationDataCount = reader.uint16();\n\tconst itemVariationDataOffsets: number[] = [];\n\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.uint32());\n\t}\n\n\t// Parse VariationRegionList\n\treader.seek(startOffset + variationRegionListOffset);\n\tconst variationRegionList = parseVariationRegionList(reader);\n\n\t// Parse ItemVariationData\n\tconst itemVariationData: ItemVariationData[] = [];\n\tfor (let i = 0; i < itemVariationDataOffsets.length; i++) {\n\t\tconst offset = itemVariationDataOffsets[i]!;\n\t\treader.seek(startOffset + offset);\n\t\titemVariationData.push(parseItemVariationData(reader));\n\t}\n\n\treturn {\n\t\tformat,\n\t\tvariationRegionList,\n\t\titemVariationData,\n\t};\n}\n\n/**\n * Parse VariationRegionList\n */\nfunction parseVariationRegionList(reader: Reader): VariationRegionList {\n\tconst axisCount = reader.uint16();\n\tconst regionCount = reader.uint16();\n\tconst regions: VariationRegion[] = [];\n\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst axes: RegionAxisCoordinates[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\taxes.push({\n\t\t\t\tstartCoord: reader.f2dot14(),\n\t\t\t\tpeakCoord: reader.f2dot14(),\n\t\t\t\tendCoord: reader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tregions.push({ axes });\n\t}\n\n\treturn { axisCount, regionCount, regions };\n}\n\n/**\n * Parse ItemVariationData\n */\nfunction parseItemVariationData(reader: Reader): ItemVariationData {\n\tconst itemCount = reader.uint16();\n\tconst wordDeltaCount = reader.uint16();\n\tconst regionIndexCount = wordDeltaCount & 0x7fff;\n\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\n\tconst regionIndexes: number[] = [];\n\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\tregionIndexes.push(reader.uint16());\n\t}\n\n\tconst deltaSets: number[][] = [];\n\tfor (let i = 0; i < itemCount; i++) {\n\t\tconst deltas: number[] = [];\n\t\tfor (let j = 0; j < regionIndexCount; j++) {\n\t\t\tif (longWords) {\n\t\t\t\tdeltas.push(reader.int32());\n\t\t\t} else {\n\t\t\t\tdeltas.push(reader.int16());\n\t\t\t}\n\t\t}\n\t\tdeltaSets.push(deltas);\n\t}\n\n\treturn {\n\t\titemCount,\n\t\tregionIndexCount,\n\t\tregionIndexes,\n\t\tdeltaSets,\n\t};\n}\n\n/**\n * Calculate variation delta for given coordinates\n */\nexport function calculateVariationDelta(\n\tvstore: ItemVariationStore,\n\touterIndex: number,\n\tinnerIndex: number,\n\tnormalizedCoords: number[],\n): number {\n\tconst itemData = vstore.itemVariationData[outerIndex];\n\tif (!itemData) return 0;\n\n\tconst deltaSet = itemData.deltaSets[innerIndex];\n\tif (!deltaSet) return 0;\n\n\tlet delta = 0;\n\tfor (let i = 0; i < itemData.regionIndexCount; i++) {\n\t\tconst regionIndex = itemData.regionIndexes[i];\n\t\tif (regionIndex === undefined) continue;\n\t\tconst region = vstore.variationRegionList.regions[regionIndex];\n\t\tif (!region) continue;\n\n\t\t// Calculate scalar for this region\n\t\tlet scalar = 1.0;\n\t\tfor (let axis = 0; axis < region.axes.length; axis++) {\n\t\t\tconst coords = region.axes[axis]!;\n\t\t\tconst coord = normalizedCoords[axis] ?? 0;\n\n\t\t\tif (coords.peakCoord === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (coord < coords.startCoord || coord > coords.endCoord) {\n\t\t\t\tscalar = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (coord === coords.peakCoord) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (coord < coords.peakCoord) {\n\t\t\t\tscalar *=\n\t\t\t\t\t(coord - coords.startCoord) / (coords.peakCoord - coords.startCoord);\n\t\t\t} else {\n\t\t\t\tscalar *=\n\t\t\t\t\t(coords.endCoord - coord) / (coords.endCoord - coords.peakCoord);\n\t\t\t}\n\t\t}\n\n\t\tdelta += scalar * (deltaSet[i] ?? 0);\n\t}\n\n\treturn Math.round(delta);\n}\n\n// Export internal functions for testing\nexport const __testing = {\n\tparseIndex,\n\treadOffset,\n\tparseDict,\n\tparseReal,\n\tparseCff2TopDict,\n\tparseCff2FDDict,\n\tparseCff2PrivateDict,\n\tdeltaToAbsolute,\n\tparseFDSelect,\n\tparseItemVariationStore,\n\tparseVariationRegionList,\n\tparseItemVariationData,\n};\n",
    "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Platform IDs */\nexport enum PlatformId {\n\tUnicode = 0,\n\tMacintosh = 1,\n\tISO = 2, // deprecated\n\tWindows = 3,\n\tCustom = 4,\n}\n\n/** Encoding record in cmap header */\nexport interface EncodingRecord {\n\tplatformId: uint16;\n\tencodingId: uint16;\n\toffset: uint32;\n}\n\n/** Base interface for cmap subtables */\ninterface CmapSubtableBase {\n\tformat: number;\n\tlookup(codepoint: number): GlyphId | undefined;\n}\n\n/** Format 0: Byte encoding table (legacy, 256 entries) */\ninterface CmapFormat0 extends CmapSubtableBase {\n\tformat: 0;\n\tglyphIdArray: Uint8Array;\n}\n\n/** Format 4: Segment mapping to delta values (BMP characters) */\ninterface CmapFormat4 extends CmapSubtableBase {\n\tformat: 4;\n\tsegCount: number;\n\tendCodes: Uint16Array;\n\tstartCodes: Uint16Array;\n\tidDeltas: Int16Array;\n\tidRangeOffsets: Uint16Array;\n\tglyphIdArray: Uint16Array;\n}\n\n/** Format 12: Segmented coverage (full Unicode) */\ninterface CmapFormat12 extends CmapSubtableBase {\n\tformat: 12;\n\tgroups: Array<{\n\t\tstartCharCode: uint32;\n\t\tendCharCode: uint32;\n\t\tstartGlyphId: uint32;\n\t}>;\n}\n\n/** Variation selector record */\ninterface VariationSelectorRecord {\n\tvarSelector: number;\n\tdefaultUVS: Array<{\n\t\tstartUnicodeValue: number;\n\t\tadditionalCount: number;\n\t}> | null;\n\tnonDefaultUVS: Array<{ unicodeValue: number; glyphId: GlyphId }> | null;\n}\n\n/** Format 14: Unicode Variation Sequences */\ninterface CmapFormat14 extends CmapSubtableBase {\n\tformat: 14;\n\tvarSelectorRecords: VariationSelectorRecord[];\n\tlookupVariation(\n\t\tcodepoint: number,\n\t\tvariationSelector: number,\n\t): GlyphId | undefined | \"default\";\n}\n\nexport type CmapSubtable =\n\t| CmapFormat0\n\t| CmapFormat4\n\t| CmapFormat12\n\t| CmapFormat14;\n\n/** Character to glyph index mapping table */\nexport interface CmapTable {\n\tversion: uint16;\n\tnumTables: uint16;\n\tencodingRecords: EncodingRecord[];\n\tsubtables: Map<string, CmapSubtable>;\n\t/** Best subtable for Unicode lookup */\n\tbestSubtable: CmapSubtable | null;\n}\n\nexport function parseCmap(reader: Reader, tableLength: number): CmapTable {\n\tconst _tableStart = reader.offset;\n\tconst version = reader.uint16();\n\tconst numTables = reader.uint16();\n\n\tconst encodingRecords: EncodingRecord[] = [];\n\tfor (let i = 0; i < numTables; i++) {\n\t\tencodingRecords.push({\n\t\t\tplatformId: reader.uint16(),\n\t\t\tencodingId: reader.uint16(),\n\t\t\toffset: reader.uint32(),\n\t\t});\n\t}\n\n\t// Parse subtables\n\tconst subtables = new Map<string, CmapSubtable>();\n\tconst parsedOffsets = new Set<number>();\n\n\tfor (let i = 0; i < encodingRecords.length; i++) {\n\t\tconst record = encodingRecords[i]!;\n\t\t// Skip duplicates (multiple records can point to same subtable)\n\t\tif (parsedOffsets.has(record.offset)) {\n\t\t\tconst key = `${record.platformId}-${record.encodingId}`;\n\t\t\t// Find existing subtable\n\t\t\tconst subtablesEntries = [...subtables.entries()];\n\t\t\tfor (let j = 0; j < subtablesEntries.length; j++) {\n\t\t\t\tconst [existingKey, subtable] = subtablesEntries[j]!;\n\t\t\t\tconst parts = existingKey.split(\"@\");\n\t\t\t\tconst existingOffset = parts[0];\n\t\t\t\tif (\n\t\t\t\t\texistingOffset &&\n\t\t\t\t\tNumber.parseInt(existingOffset, 10) === record.offset\n\t\t\t\t) {\n\t\t\t\t\tsubtables.set(key, subtable);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tparsedOffsets.add(record.offset);\n\n\t\tconst subtableReader = reader.slice(\n\t\t\trecord.offset,\n\t\t\ttableLength - record.offset,\n\t\t);\n\t\tconst subtable = parseCmapSubtable(subtableReader);\n\n\t\tif (subtable) {\n\t\t\tconst key = `${record.platformId}-${record.encodingId}`;\n\t\t\tsubtables.set(key, subtable);\n\t\t}\n\t}\n\n\t// Find best subtable for Unicode lookup\n\t// Prefer: Windows Unicode full (3-10), Unicode full (0-4), Windows BMP (3-1), Unicode BMP (0-3)\n\tconst preferredKeys = [\"3-10\", \"0-4\", \"3-1\", \"0-3\", \"0-6\", \"1-0\"];\n\tlet bestSubtable: CmapSubtable | null = null;\n\n\tfor (let i = 0; i < preferredKeys.length; i++) {\n\t\tconst key = preferredKeys[i]!;\n\t\tconst subtable = subtables.get(key);\n\t\tif (subtable && subtable.format !== 14) {\n\t\t\tbestSubtable = subtable;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Fallback to first non-format-14 subtable\n\tif (!bestSubtable) {\n\t\tconst subtablesValues = [...subtables.values()];\n\t\tfor (let i = 0; i < subtablesValues.length; i++) {\n\t\t\tconst subtable = subtablesValues[i]!;\n\t\t\tif (subtable.format !== 14) {\n\t\t\t\tbestSubtable = subtable;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tversion,\n\t\tnumTables,\n\t\tencodingRecords,\n\t\tsubtables,\n\t\tbestSubtable,\n\t};\n}\n\nfunction parseCmapSubtable(reader: Reader): CmapSubtable | null {\n\tconst format = reader.uint16();\n\n\tswitch (format) {\n\t\tcase 0:\n\t\t\treturn parseCmapFormat0(reader);\n\t\tcase 4:\n\t\t\treturn parseCmapFormat4(reader);\n\t\tcase 12:\n\t\t\treturn parseCmapFormat12(reader);\n\t\tcase 14:\n\t\t\treturn parseCmapFormat14(reader);\n\t\tdefault:\n\t\t\t// Unsupported format - skip\n\t\t\treturn null;\n\t}\n}\n\nfunction parseCmapFormat0(reader: Reader): CmapFormat0 {\n\tconst _length = reader.uint16();\n\tconst _language = reader.uint16();\n\tconst glyphIdArray = reader.uint8Array(256);\n\n\treturn {\n\t\tformat: 0,\n\t\tglyphIdArray,\n\t\tlookup(codepoint: number): GlyphId | undefined {\n\t\t\tif (codepoint >= 0 && codepoint < 256) {\n\t\t\t\treturn glyphIdArray[codepoint];\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t};\n}\n\nfunction parseCmapFormat4(reader: Reader): CmapFormat4 {\n\tconst _length = reader.uint16();\n\tconst _language = reader.uint16();\n\tconst segCountX2 = reader.uint16();\n\tconst segCount = segCountX2 / 2;\n\n\treader.skip(6); // searchRange, entrySelector, rangeShift\n\n\tconst endCodes = reader.uint16Array(segCount);\n\treader.skip(2); // reservedPad\n\tconst startCodes = reader.uint16Array(segCount);\n\tconst idDeltas = reader.int16Array(segCount);\n\n\t// Save position before idRangeOffsets for glyph ID calculation\n\tconst _idRangeOffsetPos = reader.offset;\n\tconst idRangeOffsets = reader.uint16Array(segCount);\n\n\t// Read remaining glyph IDs\n\tconst remainingBytes = reader.remaining;\n\tconst glyphIdCount = remainingBytes / 2;\n\tconst glyphIdArray = reader.uint16Array(glyphIdCount);\n\n\t// Helper function for binary search lookup (used for cache building and fallback)\n\tconst binarySearchLookup = (codepoint: number): GlyphId | undefined => {\n\t\tlet low = 0;\n\t\tlet high = segCount - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst endCode = endCodes[mid]!;\n\n\t\t\tif (codepoint > endCode) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tconst startCode = startCodes[mid]!;\n\t\t\t\tif (codepoint < startCode) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst idRangeOffset = idRangeOffsets[mid]!;\n\t\t\t\t\tconst idDelta = idDeltas[mid]!;\n\n\t\t\t\t\tif (idRangeOffset === 0) {\n\t\t\t\t\t\treturn (codepoint + idDelta) & 0xffff;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst glyphIdIndex =\n\t\t\t\t\t\tidRangeOffset / 2 - (segCount - mid) + (codepoint - startCode);\n\n\t\t\t\t\tconst glyphId = glyphIdArray[glyphIdIndex];\n\t\t\t\t\tif (glyphId === undefined || glyphId === 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn (glyphId + idDelta) & 0xffff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t};\n\n\t// Build ASCII cache for O(1) lookups of common characters (0-255)\n\t// Uses 512 bytes but eliminates binary search for 95%+ of Latin text\n\tconst asciiCache = new Uint16Array(256);\n\tfor (let cp = 0; cp < 256; cp++) {\n\t\tconst gid = binarySearchLookup(cp);\n\t\t// Store glyph ID + 1 so we can distinguish \"not found\" (0) from glyph 0\n\t\tasciiCache[cp] = gid !== undefined ? gid + 1 : 0;\n\t}\n\n\treturn {\n\t\tformat: 4,\n\t\tsegCount,\n\t\tendCodes,\n\t\tstartCodes,\n\t\tidDeltas,\n\t\tidRangeOffsets,\n\t\tglyphIdArray,\n\t\tlookup(codepoint: number): GlyphId | undefined {\n\t\t\t// FAST PATH: O(1) direct lookup for ASCII/Latin-1 (0-255)\n\t\t\tif (codepoint < 256) {\n\t\t\t\tconst cached = asciiCache[codepoint]!;\n\t\t\t\treturn cached === 0 ? undefined : cached - 1;\n\t\t\t}\n\n\t\t\tif (codepoint > 0xffff) return undefined;\n\n\t\t\t// SLOW PATH: Binary search for higher codepoints\n\t\t\treturn binarySearchLookup(codepoint);\n\t\t},\n\t};\n}\n\nfunction parseCmapFormat12(reader: Reader): CmapFormat12 {\n\treader.skip(2); // reserved\n\tconst _length = reader.uint32();\n\tconst _language = reader.uint32();\n\tconst numGroups = reader.uint32();\n\n\tconst groups: CmapFormat12[\"groups\"] = new Array(numGroups);\n\tfor (let i = 0; i < numGroups; i++) {\n\t\tgroups[i] = {\n\t\t\tstartCharCode: reader.uint32(),\n\t\t\tendCharCode: reader.uint32(),\n\t\t\tstartGlyphId: reader.uint32(),\n\t\t};\n\t}\n\n\t// Helper for binary search lookup\n\tconst binarySearchLookup = (codepoint: number): GlyphId | undefined => {\n\t\tlet low = 0;\n\t\tlet high = groups.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst group = groups[mid];\n\t\t\tif (!group) break;\n\n\t\t\tif (codepoint > group.endCharCode) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (codepoint < group.startCharCode) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn group.startGlyphId + (codepoint - group.startCharCode);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t};\n\n\t// Build ASCII cache for O(1) lookups of common characters (0-127)\n\t// Uses 256 bytes but eliminates binary search for ASCII text\n\tconst asciiCache = new Uint16Array(128);\n\tfor (let cp = 0; cp < 128; cp++) {\n\t\tconst gid = binarySearchLookup(cp);\n\t\t// Store glyph ID + 1 so we can distinguish \"not found\" (0) from glyph 0\n\t\tasciiCache[cp] = gid !== undefined ? gid + 1 : 0;\n\t}\n\n\treturn {\n\t\tformat: 12,\n\t\tgroups,\n\t\tlookup(codepoint: number): GlyphId | undefined {\n\t\t\t// FAST PATH: O(1) direct lookup for ASCII (0-127)\n\t\t\tif (codepoint < 128) {\n\t\t\t\tconst cached = asciiCache[codepoint]!;\n\t\t\t\treturn cached === 0 ? undefined : cached - 1;\n\t\t\t}\n\n\t\t\t// SLOW PATH: Binary search for higher codepoints\n\t\t\treturn binarySearchLookup(codepoint);\n\t\t},\n\t};\n}\n\nfunction parseCmapFormat14(reader: Reader): CmapFormat14 {\n\tconst subtableStart = reader.offset - 2; // Account for format already read\n\tconst _length = reader.uint32();\n\tconst numVarSelectorRecords = reader.uint32();\n\n\t// First pass: read all variation selector records\n\tconst rawRecords: Array<{\n\t\tvarSelector: number;\n\t\tdefaultUVSOffset: number;\n\t\tnonDefaultUVSOffset: number;\n\t}> = [];\n\n\tfor (let i = 0; i < numVarSelectorRecords; i++) {\n\t\trawRecords.push({\n\t\t\tvarSelector: reader.uint24(),\n\t\t\tdefaultUVSOffset: reader.uint32(),\n\t\t\tnonDefaultUVSOffset: reader.uint32(),\n\t\t});\n\t}\n\n\t// Second pass: parse the UVS tables\n\tconst varSelectorRecords: VariationSelectorRecord[] = [];\n\n\tfor (let i = 0; i < rawRecords.length; i++) {\n\t\tconst raw = rawRecords[i]!;\n\t\tlet defaultUVS: VariationSelectorRecord[\"defaultUVS\"] = null;\n\t\tlet nonDefaultUVS: VariationSelectorRecord[\"nonDefaultUVS\"] = null;\n\n\t\t// Parse default UVS table (ranges where default glyph is used)\n\t\tif (raw.defaultUVSOffset !== 0) {\n\t\t\tconst uvsReader = reader.sliceFrom(subtableStart + raw.defaultUVSOffset);\n\t\t\tconst numUnicodeValueRanges = uvsReader.uint32();\n\t\t\tdefaultUVS = [];\n\n\t\t\tfor (let j = 0; j < numUnicodeValueRanges; j++) {\n\t\t\t\tdefaultUVS.push({\n\t\t\t\t\tstartUnicodeValue: uvsReader.uint24(),\n\t\t\t\t\tadditionalCount: uvsReader.uint8(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Parse non-default UVS table (specific glyph mappings)\n\t\tif (raw.nonDefaultUVSOffset !== 0) {\n\t\t\tconst uvsReader = reader.sliceFrom(\n\t\t\t\tsubtableStart + raw.nonDefaultUVSOffset,\n\t\t\t);\n\t\t\tconst numUVSMappings = uvsReader.uint32();\n\t\t\tnonDefaultUVS = [];\n\n\t\t\tfor (let j = 0; j < numUVSMappings; j++) {\n\t\t\t\tnonDefaultUVS.push({\n\t\t\t\t\tunicodeValue: uvsReader.uint24(),\n\t\t\t\t\tglyphId: uvsReader.uint16(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvarSelectorRecords.push({\n\t\t\tvarSelector: raw.varSelector,\n\t\t\tdefaultUVS,\n\t\t\tnonDefaultUVS,\n\t\t});\n\t}\n\n\treturn {\n\t\tformat: 14,\n\t\tvarSelectorRecords,\n\t\tlookup(_codepoint: number): GlyphId | undefined {\n\t\t\t// Format 14 is only for variation selectors\n\t\t\treturn undefined;\n\t\t},\n\t\tlookupVariation(\n\t\t\tcodepoint: number,\n\t\t\tvariationSelector: number,\n\t\t): GlyphId | undefined | \"default\" {\n\t\t\t// Binary search for the variation selector\n\t\t\tlet low = 0;\n\t\t\tlet high = varSelectorRecords.length - 1;\n\t\t\tlet record: VariationSelectorRecord | null = null;\n\n\t\t\twhile (low <= high) {\n\t\t\t\tconst mid = (low + high) >>> 1;\n\t\t\t\tconst rec = varSelectorRecords[mid];\n\t\t\t\tif (!rec) break;\n\n\t\t\t\tif (variationSelector > rec.varSelector) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t} else if (variationSelector < rec.varSelector) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\trecord = rec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!record) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Check non-default UVS first (specific glyph mappings)\n\t\t\tif (record.nonDefaultUVS) {\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = record.nonDefaultUVS.length - 1;\n\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tconst mid = (lo + hi) >>> 1;\n\t\t\t\t\tconst mapping = record.nonDefaultUVS[mid];\n\t\t\t\t\tif (!mapping) break;\n\n\t\t\t\t\tif (codepoint > mapping.unicodeValue) {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t} else if (codepoint < mapping.unicodeValue) {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn mapping.glyphId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check default UVS (use default glyph for base codepoint)\n\t\t\tif (record.defaultUVS) {\n\t\t\t\tfor (let i = 0; i < record.defaultUVS.length; i++) {\n\t\t\t\t\tconst range = record.defaultUVS[i]!;\n\t\t\t\t\tconst end = range.startUnicodeValue + range.additionalCount;\n\t\t\t\t\tif (codepoint >= range.startUnicodeValue && codepoint <= end) {\n\t\t\t\t\t\treturn \"default\"; // Signal to use the default glyph\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t},\n\t};\n}\n\n/** Get glyph ID for a codepoint using the best subtable */\nexport function getGlyphId(cmap: CmapTable, codepoint: number): GlyphId {\n\treturn cmap.bestSubtable?.lookup(codepoint) ?? 0;\n}\n\n/** Get glyph ID for a variation sequence (base + variation selector) */\nexport function getVariationGlyphId(\n\tcmap: CmapTable,\n\tcodepoint: number,\n\tvariationSelector: number,\n): GlyphId | undefined {\n\t// Find Format 14 subtable\n\tconst format14 = [...cmap.subtables.values()].find(\n\t\t(s): s is CmapFormat14 => s.format === 14,\n\t);\n\n\tif (!format14) {\n\t\treturn undefined;\n\t}\n\n\tconst result = format14.lookupVariation(codepoint, variationSelector);\n\n\tif (result === \"default\") {\n\t\t// Use the default glyph for this codepoint\n\t\treturn getGlyphId(cmap, codepoint);\n\t}\n\n\treturn result;\n}\n\n/** Check if a codepoint is a variation selector */\nexport function isVariationSelector(codepoint: number): boolean {\n\t// Variation Selectors block (VS1-VS16)\n\tif (codepoint >= 0xfe00 && codepoint <= 0xfe0f) {\n\t\treturn true;\n\t}\n\t// Variation Selectors Supplement (VS17-VS256)\n\tif (codepoint >= 0xe0100 && codepoint <= 0xe01ef) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
    "import type { GlyphId } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * COLR (Color) table parser\n * Defines color glyph layers\n */\n\nexport interface ColrTable {\n\tversion: number;\n\t// v0 data\n\tbaseGlyphRecords: BaseGlyphRecord[];\n\tlayerRecords: LayerRecord[];\n\t// v1 data\n\tbaseGlyphPaintRecords?: BaseGlyphPaintRecord[];\n\tlayerList?: Paint[];\n\tclipList?: ClipRecord[];\n\tvarIdxMap?: number[];\n\titemVariationStore?: ItemVariationStore;\n}\n\n// v0 structures\nexport interface BaseGlyphRecord {\n\tglyphId: GlyphId;\n\tfirstLayerIndex: number;\n\tnumLayers: number;\n}\n\nexport interface LayerRecord {\n\tglyphId: GlyphId;\n\tpaletteIndex: number;\n}\n\n// v1 structures\nexport interface BaseGlyphPaintRecord {\n\tglyphId: GlyphId;\n\tpaint: Paint;\n}\n\n// Paint types for COLR v1\nexport enum PaintFormat {\n\tColrLayers = 1,\n\tSolid = 2,\n\tVarSolid = 3,\n\tLinearGradient = 4,\n\tVarLinearGradient = 5,\n\tRadialGradient = 6,\n\tVarRadialGradient = 7,\n\tSweepGradient = 8,\n\tVarSweepGradient = 9,\n\tGlyph = 10,\n\tColrGlyph = 11,\n\tTransform = 12,\n\tVarTransform = 13,\n\tTranslate = 14,\n\tVarTranslate = 15,\n\tScale = 16,\n\tVarScale = 17,\n\tScaleAroundCenter = 18,\n\tVarScaleAroundCenter = 19,\n\tScaleUniform = 20,\n\tVarScaleUniform = 21,\n\tScaleUniformAroundCenter = 22,\n\tVarScaleUniformAroundCenter = 23,\n\tRotate = 24,\n\tVarRotate = 25,\n\tRotateAroundCenter = 26,\n\tVarRotateAroundCenter = 27,\n\tSkew = 28,\n\tVarSkew = 29,\n\tSkewAroundCenter = 30,\n\tVarSkewAroundCenter = 31,\n\tComposite = 32,\n}\n\nexport type Paint =\n\t| PaintColrLayers\n\t| PaintSolid\n\t| PaintLinearGradient\n\t| PaintRadialGradient\n\t| PaintSweepGradient\n\t| PaintGlyph\n\t| PaintColrGlyph\n\t| PaintTransform\n\t| PaintTranslate\n\t| PaintScale\n\t| PaintRotate\n\t| PaintSkew\n\t| PaintComposite;\n\nexport interface PaintColrLayers {\n\tformat: PaintFormat.ColrLayers;\n\tnumLayers: number;\n\tfirstLayerIndex: number;\n}\n\nexport interface PaintSolid {\n\tformat: PaintFormat.Solid | PaintFormat.VarSolid;\n\tpaletteIndex: number;\n\talpha: number;\n\tvarIndexBase?: number;\n}\n\nexport interface PaintLinearGradient {\n\tformat: PaintFormat.LinearGradient | PaintFormat.VarLinearGradient;\n\tcolorLine: ColorLine;\n\tx0: number;\n\ty0: number;\n\tx1: number;\n\ty1: number;\n\tx2: number;\n\ty2: number;\n}\n\nexport interface PaintRadialGradient {\n\tformat: PaintFormat.RadialGradient | PaintFormat.VarRadialGradient;\n\tcolorLine: ColorLine;\n\tx0: number;\n\ty0: number;\n\tradius0: number;\n\tx1: number;\n\ty1: number;\n\tradius1: number;\n}\n\nexport interface PaintSweepGradient {\n\tformat: PaintFormat.SweepGradient | PaintFormat.VarSweepGradient;\n\tcolorLine: ColorLine;\n\tcenterX: number;\n\tcenterY: number;\n\tstartAngle: number;\n\tendAngle: number;\n}\n\nexport interface PaintGlyph {\n\tformat: PaintFormat.Glyph;\n\tpaint: Paint;\n\tglyphId: GlyphId;\n}\n\nexport interface PaintColrGlyph {\n\tformat: PaintFormat.ColrGlyph;\n\tglyphId: GlyphId;\n}\n\nexport interface PaintTransform {\n\tformat: PaintFormat.Transform | PaintFormat.VarTransform;\n\tpaint: Paint;\n\ttransform: Affine2x3;\n}\n\nexport interface PaintTranslate {\n\tformat: PaintFormat.Translate | PaintFormat.VarTranslate;\n\tpaint: Paint;\n\tdx: number;\n\tdy: number;\n}\n\nexport interface PaintScale {\n\tformat:\n\t\t| PaintFormat.Scale\n\t\t| PaintFormat.VarScale\n\t\t| PaintFormat.ScaleAroundCenter\n\t\t| PaintFormat.VarScaleAroundCenter\n\t\t| PaintFormat.ScaleUniform\n\t\t| PaintFormat.VarScaleUniform\n\t\t| PaintFormat.ScaleUniformAroundCenter\n\t\t| PaintFormat.VarScaleUniformAroundCenter;\n\tpaint: Paint;\n\tscaleX: number;\n\tscaleY: number;\n\tcenterX?: number;\n\tcenterY?: number;\n}\n\nexport interface PaintRotate {\n\tformat:\n\t\t| PaintFormat.Rotate\n\t\t| PaintFormat.VarRotate\n\t\t| PaintFormat.RotateAroundCenter\n\t\t| PaintFormat.VarRotateAroundCenter;\n\tpaint: Paint;\n\tangle: number;\n\tcenterX?: number;\n\tcenterY?: number;\n}\n\nexport interface PaintSkew {\n\tformat:\n\t\t| PaintFormat.Skew\n\t\t| PaintFormat.VarSkew\n\t\t| PaintFormat.SkewAroundCenter\n\t\t| PaintFormat.VarSkewAroundCenter;\n\tpaint: Paint;\n\txSkewAngle: number;\n\tySkewAngle: number;\n\tcenterX?: number;\n\tcenterY?: number;\n}\n\nexport interface PaintComposite {\n\tformat: PaintFormat.Composite;\n\tsourcePaint: Paint;\n\tcompositeMode: CompositeMode;\n\tbackdropPaint: Paint;\n}\n\nexport interface ColorLine {\n\textend: Extend;\n\tcolorStops: ColorStop[];\n}\n\nexport interface ColorStop {\n\tstopOffset: number;\n\tpaletteIndex: number;\n\talpha: number;\n}\n\nexport enum Extend {\n\tPad = 0,\n\tRepeat = 1,\n\tReflect = 2,\n}\n\nexport enum CompositeMode {\n\tClear = 0,\n\tSrc = 1,\n\tDest = 2,\n\tSrcOver = 3,\n\tDestOver = 4,\n\tSrcIn = 5,\n\tDestIn = 6,\n\tSrcOut = 7,\n\tDestOut = 8,\n\tSrcAtop = 9,\n\tDestAtop = 10,\n\tXor = 11,\n\tPlus = 12,\n\tScreen = 13,\n\tOverlay = 14,\n\tDarken = 15,\n\tLighten = 16,\n\tColorDodge = 17,\n\tColorBurn = 18,\n\tHardLight = 19,\n\tSoftLight = 20,\n\tDifference = 21,\n\tExclusion = 22,\n\tMultiply = 23,\n\tHue = 24,\n\tSaturation = 25,\n\tColor = 26,\n\tLuminosity = 27,\n}\n\nexport interface Affine2x3 {\n\txx: number;\n\tyx: number;\n\txy: number;\n\tyy: number;\n\tdx: number;\n\tdy: number;\n}\n\nexport interface ClipRecord {\n\tstartGlyphId: GlyphId;\n\tendGlyphId: GlyphId;\n\tclipBox: ClipBox;\n}\n\nexport interface ClipBox {\n\tformat: number;\n\txMin: number;\n\tyMin: number;\n\txMax: number;\n\tyMax: number;\n\tvarIndexBase?: number;\n}\n\nexport interface ItemVariationStore {\n\tformat: number;\n\tvariationRegionListOffset: number;\n\titemVariationDataCount: number;\n\titemVariationDataOffsets: number[];\n\tvariationRegions: VariationRegion[];\n\titemVariationData: ItemVariationData[];\n}\n\nexport interface VariationRegion {\n\tregionAxes: RegionAxisCoordinates[];\n}\n\nexport interface RegionAxisCoordinates {\n\tstartCoord: number;\n\tpeakCoord: number;\n\tendCoord: number;\n}\n\nexport interface ItemVariationData {\n\titemCount: number;\n\twordDeltaCount: number;\n\tregionIndexCount: number;\n\tregionIndexes: number[];\n\tdeltaSets: number[][];\n}\n\nexport interface VarColorLine extends ColorLine {\n\tvarIndexBase?: number;\n}\n\nexport interface VarColorStop extends ColorStop {\n\tvarIndexBase?: number;\n}\n\n/**\n * Parse COLR table - color glyph definitions with layered or gradient fills\n * Supports both v0 (simple layers) and v1 (advanced paint operations)\n * @param reader - Reader positioned at start of COLR table\n * @returns Parsed COLR table with color layer and paint definitions\n */\nexport function parseColr(reader: Reader): ColrTable {\n\tconst startOffset = reader.offset;\n\n\tconst version = reader.uint16();\n\tconst numBaseGlyphRecords = reader.uint16();\n\tconst baseGlyphRecordsOffset = reader.uint32();\n\tconst layerRecordsOffset = reader.uint32();\n\tconst numLayerRecords = reader.uint16();\n\n\t// Parse v0 base glyph records\n\tconst baseGlyphRecords: BaseGlyphRecord[] = [];\n\tif (baseGlyphRecordsOffset !== 0 && numBaseGlyphRecords > 0) {\n\t\treader.seek(startOffset + baseGlyphRecordsOffset);\n\t\tfor (let i = 0; i < numBaseGlyphRecords; i++) {\n\t\t\tbaseGlyphRecords.push({\n\t\t\t\tglyphId: reader.uint16(),\n\t\t\t\tfirstLayerIndex: reader.uint16(),\n\t\t\t\tnumLayers: reader.uint16(),\n\t\t\t});\n\t\t}\n\t}\n\n\t// Parse v0 layer records\n\tconst layerRecords: LayerRecord[] = [];\n\tif (layerRecordsOffset !== 0 && numLayerRecords > 0) {\n\t\treader.seek(startOffset + layerRecordsOffset);\n\t\tfor (let i = 0; i < numLayerRecords; i++) {\n\t\t\tlayerRecords.push({\n\t\t\t\tglyphId: reader.uint16(),\n\t\t\t\tpaletteIndex: reader.uint16(),\n\t\t\t});\n\t\t}\n\t}\n\n\tconst result: ColrTable = {\n\t\tversion,\n\t\tbaseGlyphRecords,\n\t\tlayerRecords,\n\t};\n\n\t// Parse v1 extensions\n\tif (version >= 1) {\n\t\treader.seek(startOffset + 14); // After v0 header\n\n\t\tconst baseGlyphListOffset = reader.uint32();\n\t\tconst layerListOffset = reader.uint32();\n\t\tconst clipListOffset = reader.uint32();\n\t\tconst varIdxMapOffset = reader.uint32();\n\t\tconst itemVariationStoreOffset = reader.uint32();\n\n\t\t// Parse base glyph paint records\n\t\tif (baseGlyphListOffset !== 0) {\n\t\t\tconst baseGlyphListStart = startOffset + baseGlyphListOffset;\n\t\t\treader.seek(baseGlyphListStart);\n\t\t\tconst numRecords = reader.uint32();\n\t\t\tresult.baseGlyphPaintRecords = [];\n\n\t\t\tfor (let i = 0; i < numRecords; i++) {\n\t\t\t\tconst glyphId = reader.uint16();\n\t\t\t\tconst paintOffset = reader.uint32();\n\n\t\t\t\t// Parse paint at offset (paintOffset is relative to start of BaseGlyphList)\n\t\t\t\tconst savedPos = reader.offset;\n\t\t\t\treader.seek(baseGlyphListStart + paintOffset);\n\t\t\t\tconst paint = parsePaint(reader, startOffset);\n\t\t\t\treader.seek(savedPos);\n\n\t\t\t\tresult.baseGlyphPaintRecords.push({ glyphId, paint });\n\t\t\t}\n\t\t}\n\n\t\t// Parse layer list\n\t\tif (layerListOffset !== 0) {\n\t\t\treader.seek(startOffset + layerListOffset);\n\t\t\tconst numLayers = reader.uint32();\n\t\t\tconst paintOffsets: number[] = [];\n\n\t\t\tfor (let i = 0; i < numLayers; i++) {\n\t\t\t\tpaintOffsets.push(reader.uint32());\n\t\t\t}\n\n\t\t\tresult.layerList = [];\n\t\t\tfor (let i = 0; i < paintOffsets.length; i++) {\n\t\t\t\tconst offset = paintOffsets[i]!;\n\t\t\t\treader.seek(startOffset + layerListOffset + offset);\n\t\t\t\tresult.layerList.push(parsePaint(reader, startOffset));\n\t\t\t}\n\t\t}\n\n\t\t// Parse clip list\n\t\tif (clipListOffset !== 0) {\n\t\t\treader.seek(startOffset + clipListOffset);\n\t\t\tresult.clipList = parseClipList(reader, startOffset);\n\t\t}\n\n\t\t// Parse DeltaSetIndexMap (for variable fonts)\n\t\tif (varIdxMapOffset !== 0) {\n\t\t\treader.seek(startOffset + varIdxMapOffset);\n\t\t\tresult.varIdxMap = parseDeltaSetIndexMap(reader);\n\t\t}\n\n\t\t// Parse ItemVariationStore (for variable fonts)\n\t\tif (itemVariationStoreOffset !== 0) {\n\t\t\treader.seek(startOffset + itemVariationStoreOffset);\n\t\t\tresult.itemVariationStore = parseItemVariationStore(reader);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse a Paint structure\n * All Offset24 values are relative to the start of the paint record (format byte)\n */\nfunction parsePaint(reader: Reader, tableOffset: number): Paint {\n\tconst paintStart = reader.offset; // Position of format byte\n\tconst format = reader.uint8();\n\n\tswitch (format) {\n\t\tcase PaintFormat.ColrLayers:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tnumLayers: reader.uint8(),\n\t\t\t\tfirstLayerIndex: reader.uint32(),\n\t\t\t};\n\n\t\tcase PaintFormat.Solid:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tpaletteIndex: reader.uint16(),\n\t\t\t\talpha: reader.f2dot14(),\n\t\t\t};\n\n\t\tcase PaintFormat.VarSolid:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tpaletteIndex: reader.uint16(),\n\t\t\t\talpha: reader.f2dot14(),\n\t\t\t\tvarIndexBase: reader.uint32(),\n\t\t\t};\n\n\t\tcase PaintFormat.LinearGradient:\n\t\tcase PaintFormat.VarLinearGradient: {\n\t\t\tconst colorLineOffset = reader.uint24();\n\t\t\tconst x0 = reader.fword();\n\t\t\tconst y0 = reader.fword();\n\t\t\tconst x1 = reader.fword();\n\t\t\tconst y1 = reader.fword();\n\t\t\tconst x2 = reader.fword();\n\t\t\tconst y2 = reader.fword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(paintStart + colorLineOffset);\n\t\t\tconst colorLine = parseColorLine(reader);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, colorLine, x0, y0, x1, y1, x2, y2 };\n\t\t}\n\n\t\tcase PaintFormat.RadialGradient:\n\t\tcase PaintFormat.VarRadialGradient: {\n\t\t\tconst colorLineOffset = reader.uint24();\n\t\t\tconst x0 = reader.fword();\n\t\t\tconst y0 = reader.fword();\n\t\t\tconst radius0 = reader.ufword();\n\t\t\tconst x1 = reader.fword();\n\t\t\tconst y1 = reader.fword();\n\t\t\tconst radius1 = reader.ufword();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(paintStart + colorLineOffset);\n\t\t\tconst colorLine = parseColorLine(reader);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, colorLine, x0, y0, radius0, x1, y1, radius1 };\n\t\t}\n\n\t\tcase PaintFormat.SweepGradient:\n\t\tcase PaintFormat.VarSweepGradient: {\n\t\t\tconst colorLineOffset = reader.uint24();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\t\t\tconst startAngle = reader.f2dot14();\n\t\t\tconst endAngle = reader.f2dot14();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(paintStart + colorLineOffset);\n\t\t\tconst colorLine = parseColorLine(reader);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, colorLine, centerX, centerY, startAngle, endAngle };\n\t\t}\n\n\t\tcase PaintFormat.Glyph: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst glyphId = reader.uint16();\n\n\t\t\tconst savedPos = reader.offset;\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\t\t\treader.seek(savedPos);\n\n\t\t\treturn { format, paint, glyphId };\n\t\t}\n\n\t\tcase PaintFormat.ColrGlyph:\n\t\t\treturn {\n\t\t\t\tformat,\n\t\t\t\tglyphId: reader.uint16(),\n\t\t\t};\n\n\t\tcase PaintFormat.Transform:\n\t\tcase PaintFormat.VarTransform: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst transformOffset = reader.uint24();\n\n\t\t\treader.seek(paintStart + transformOffset);\n\t\t\tconst transform: Affine2x3 = {\n\t\t\t\txx: reader.fixed(),\n\t\t\t\tyx: reader.fixed(),\n\t\t\t\txy: reader.fixed(),\n\t\t\t\tyy: reader.fixed(),\n\t\t\t\tdx: reader.fixed(),\n\t\t\t\tdy: reader.fixed(),\n\t\t\t};\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, transform };\n\t\t}\n\n\t\tcase PaintFormat.Translate:\n\t\tcase PaintFormat.VarTranslate: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst dx = reader.fword();\n\t\t\tconst dy = reader.fword();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, dx, dy };\n\t\t}\n\n\t\tcase PaintFormat.Scale:\n\t\tcase PaintFormat.VarScale: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scaleX = reader.f2dot14();\n\t\t\tconst scaleY = reader.f2dot14();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, scaleX, scaleY };\n\t\t}\n\n\t\tcase PaintFormat.ScaleAroundCenter:\n\t\tcase PaintFormat.VarScaleAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scaleX = reader.f2dot14();\n\t\t\tconst scaleY = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, scaleX, scaleY, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.ScaleUniform:\n\t\tcase PaintFormat.VarScaleUniform: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scale = reader.f2dot14();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, scaleX: scale, scaleY: scale };\n\t\t}\n\n\t\tcase PaintFormat.ScaleUniformAroundCenter:\n\t\tcase PaintFormat.VarScaleUniformAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst scale = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, scaleX: scale, scaleY: scale, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.Rotate:\n\t\tcase PaintFormat.VarRotate: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst angle = reader.f2dot14();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, angle };\n\t\t}\n\n\t\tcase PaintFormat.RotateAroundCenter:\n\t\tcase PaintFormat.VarRotateAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst angle = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, angle, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.Skew:\n\t\tcase PaintFormat.VarSkew: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst xSkewAngle = reader.f2dot14();\n\t\t\tconst ySkewAngle = reader.f2dot14();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, xSkewAngle, ySkewAngle };\n\t\t}\n\n\t\tcase PaintFormat.SkewAroundCenter:\n\t\tcase PaintFormat.VarSkewAroundCenter: {\n\t\t\tconst paintOffset = reader.uint24();\n\t\t\tconst xSkewAngle = reader.f2dot14();\n\t\t\tconst ySkewAngle = reader.f2dot14();\n\t\t\tconst centerX = reader.fword();\n\t\t\tconst centerY = reader.fword();\n\n\t\t\treader.seek(paintStart + paintOffset);\n\t\t\tconst paint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, paint, xSkewAngle, ySkewAngle, centerX, centerY };\n\t\t}\n\n\t\tcase PaintFormat.Composite: {\n\t\t\tconst sourcePaintOffset = reader.uint24();\n\t\t\tconst compositeMode = reader.uint8() as CompositeMode;\n\t\t\tconst backdropPaintOffset = reader.uint24();\n\n\t\t\treader.seek(paintStart + sourcePaintOffset);\n\t\t\tconst sourcePaint = parsePaint(reader, tableOffset);\n\n\t\t\treader.seek(paintStart + backdropPaintOffset);\n\t\t\tconst backdropPaint = parsePaint(reader, tableOffset);\n\n\t\t\treturn { format, sourcePaint, compositeMode, backdropPaint };\n\t\t}\n\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown paint format: ${format}`);\n\t}\n}\n\n/**\n * Parse ColorLine structure\n */\nfunction parseColorLine(reader: Reader): ColorLine {\n\tconst extend = reader.uint8() as Extend;\n\tconst numStops = reader.uint16();\n\tconst colorStops: ColorStop[] = [];\n\n\tfor (let i = 0; i < numStops; i++) {\n\t\tcolorStops.push({\n\t\t\tstopOffset: reader.f2dot14(),\n\t\t\tpaletteIndex: reader.uint16(),\n\t\t\talpha: reader.f2dot14(),\n\t\t});\n\t}\n\n\treturn { extend, colorStops };\n}\n\n/**\n * Parse ClipList structure\n * Offset to ClipBox is relative to start of ClipRecord (startGlyphId field)\n */\nfunction parseClipList(reader: Reader, _tableOffset: number): ClipRecord[] {\n\tconst clipListStart = reader.offset;\n\tconst _format = reader.uint8();\n\tconst numClips = reader.uint32();\n\tconst records: ClipRecord[] = [];\n\n\tfor (let i = 0; i < numClips; i++) {\n\t\tconst startGlyphId = reader.uint16();\n\t\tconst endGlyphId = reader.uint16();\n\t\tconst clipBoxOffset = reader.uint24();\n\n\t\tconst savedPos = reader.offset;\n\t\t// clipBoxOffset is relative to the start of ClipList, not the record\n\t\treader.seek(clipListStart + clipBoxOffset);\n\n\t\tconst boxFormat = reader.uint8();\n\t\tconst clipBox: ClipBox = {\n\t\t\tformat: boxFormat,\n\t\t\txMin: reader.fword(),\n\t\t\tyMin: reader.fword(),\n\t\t\txMax: reader.fword(),\n\t\t\tyMax: reader.fword(),\n\t\t};\n\n\t\tif (boxFormat === 2) {\n\t\t\tclipBox.varIndexBase = reader.uint32();\n\t\t}\n\n\t\treader.seek(savedPos);\n\n\t\trecords.push({ startGlyphId, endGlyphId, clipBox });\n\t}\n\n\treturn records;\n}\n\n/**\n * Get color layers for a glyph (v0)\n */\nexport function getColorLayers(\n\tcolr: ColrTable,\n\tglyphId: GlyphId,\n): LayerRecord[] | null {\n\t// Binary search for base glyph record\n\tconst records = colr.baseGlyphRecords;\n\tlet lo = 0;\n\tlet hi = records.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst record = records[mid];\n\t\tif (!record) break;\n\n\t\tif (record.glyphId === glyphId) {\n\t\t\tconst layers: LayerRecord[] = [];\n\t\t\tfor (let i = 0; i < record.numLayers; i++) {\n\t\t\t\tconst layer = colr.layerRecords[record.firstLayerIndex + i];\n\t\t\t\tif (layer) layers.push(layer);\n\t\t\t}\n\t\t\treturn layers;\n\t\t} else if (record.glyphId < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Get paint for a glyph (v1)\n */\nexport function getColorPaint(colr: ColrTable, glyphId: GlyphId): Paint | null {\n\tif (!colr.baseGlyphPaintRecords) return null;\n\n\t// Binary search\n\tconst records = colr.baseGlyphPaintRecords;\n\tlet lo = 0;\n\tlet hi = records.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst record = records[mid];\n\t\tif (!record) break;\n\n\t\tif (record.glyphId === glyphId) {\n\t\t\treturn record.paint;\n\t\t} else if (record.glyphId < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Check if glyph has color data\n */\nexport function hasColorGlyph(colr: ColrTable, glyphId: GlyphId): boolean {\n\treturn (\n\t\tgetColorLayers(colr, glyphId) !== null ||\n\t\tgetColorPaint(colr, glyphId) !== null\n\t);\n}\n\n/**\n * Parse DeltaSetIndexMap (used by variable fonts)\n */\nfunction parseDeltaSetIndexMap(reader: Reader): number[] {\n\tconst format = reader.uint8();\n\tconst entryFormat = reader.uint8();\n\tconst mapCount = format === 0 ? reader.uint16() : reader.uint32();\n\n\tconst innerBits = (entryFormat & 0x0f) + 1;\n\tconst outerBits = ((entryFormat >> 4) & 0x0f) + 1;\n\tconst entrySize = Math.ceil((innerBits + outerBits) / 8);\n\n\tconst result: number[] = [];\n\tfor (let i = 0; i < mapCount; i++) {\n\t\tlet entry = 0;\n\t\tfor (let b = 0; b < entrySize; b++) {\n\t\t\tentry = (entry << 8) | reader.uint8();\n\t\t}\n\t\t// Pack outer and inner indices into a single number\n\t\t// Format: (outer << 16) | inner\n\t\tconst innerMask = (1 << innerBits) - 1;\n\t\tconst inner = entry & innerMask;\n\t\tconst outer = entry >> innerBits;\n\t\tresult.push((outer << 16) | inner);\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse ItemVariationStore (used by variable fonts)\n */\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst storeOffset = reader.offset;\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.uint32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: number[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.uint32());\n\t}\n\n\t// Parse variation region list\n\treader.seek(storeOffset + variationRegionListOffset);\n\tconst axisCount = reader.uint16();\n\tconst regionCount = reader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: RegionAxisCoordinates[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: reader.f2dot14(),\n\t\t\t\tpeakCoord: reader.f2dot14(),\n\t\t\t\tendCoord: reader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data subtables\n\tconst itemVariationData: ItemVariationData[] = [];\n\tfor (let i = 0; i < itemVariationDataOffsets.length; i++) {\n\t\tconst offset = itemVariationDataOffsets[i]!;\n\t\treader.seek(storeOffset + offset);\n\t\tconst itemCount = reader.uint16();\n\t\tconst wordDeltaCount = reader.uint16();\n\t\tconst regionIndexCount = reader.uint16();\n\n\t\tconst regionIndexes: number[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(reader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\tfor (let j = 0; j < regionIndexCount; j++) {\n\t\t\t\tif (j < wordCount) {\n\t\t\t\t\tdeltas.push(longWords ? reader.int32() : reader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(longWords ? reader.int16() : reader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({\n\t\t\titemCount,\n\t\t\twordDeltaCount,\n\t\t\tregionIndexCount,\n\t\t\tregionIndexes,\n\t\t\tdeltaSets,\n\t\t});\n\t}\n\n\treturn {\n\t\tformat,\n\t\tvariationRegionListOffset,\n\t\titemVariationDataCount,\n\t\titemVariationDataOffsets,\n\t\tvariationRegions,\n\t\titemVariationData,\n\t};\n}\n\n/**\n * Get clip box for a glyph\n */\nexport function getClipBox(colr: ColrTable, glyphId: GlyphId): ClipBox | null {\n\tif (!colr.clipList) return null;\n\n\tfor (let i = 0; i < colr.clipList.length; i++) {\n\t\tconst record = colr.clipList[i]!;\n\t\tif (glyphId >= record.startGlyphId && glyphId <= record.endGlyphId) {\n\t\t\treturn record.clipBox;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Calculate variation delta for a paint value\n */\nexport function getColorVariationDelta(\n\tcolr: ColrTable,\n\tvarIndex: number,\n\tcoords: number[],\n): number {\n\tif (!colr.itemVariationStore || !colr.varIdxMap) return 0;\n\n\t// Get outer/inner indices from varIdxMap\n\tconst mappedIndex = colr.varIdxMap[varIndex];\n\tif (mappedIndex === undefined) return 0;\n\n\tconst outer = mappedIndex >> 16;\n\tconst inner = mappedIndex & 0xffff;\n\n\tconst store = colr.itemVariationStore;\n\tconst data = store.itemVariationData[outer];\n\tif (!data) return 0;\n\n\tconst deltas = data.deltaSets[inner];\n\tif (!deltas) return 0;\n\n\t// Calculate scalar for each region and sum deltas\n\tlet result = 0;\n\tfor (let i = 0; i < data.regionIndexCount; i++) {\n\t\tconst regionIndex = data.regionIndexes[i];\n\t\tif (regionIndex === undefined) continue;\n\t\tconst region = store.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\t// Calculate scalar for this region\n\t\tlet scalar = 1.0;\n\t\tfor (let j = 0; j < region.regionAxes.length && j < coords.length; j++) {\n\t\t\tconst axis = region.regionAxes[j];\n\t\t\tconst coord = coords[j];\n\t\t\tif (axis === undefined || coord === undefined) continue;\n\t\t\tscalar *= calculateAxisScalar(\n\t\t\t\tcoord,\n\t\t\t\taxis.startCoord,\n\t\t\t\taxis.peakCoord,\n\t\t\t\taxis.endCoord,\n\t\t\t);\n\t\t\tif (scalar === 0) break;\n\t\t}\n\n\t\tconst delta = deltas[i];\n\t\tif (delta !== undefined) {\n\t\t\tresult += delta * scalar;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Calculate scalar contribution for a single axis\n */\nfunction calculateAxisScalar(\n\tcoord: number,\n\tstart: number,\n\tpeak: number,\n\tend: number,\n): number {\n\t// If region is degenerate (all zeros), no variation - return neutral\n\tif (start === 0 && peak === 0 && end === 0) return 1.0;\n\n\t// If coord exactly at peak, full contribution\n\tif (coord === peak) return 1.0;\n\n\t// If coord outside range, no contribution\n\tif (coord < start || coord > end) return 0.0;\n\n\t// Interpolate\n\tif (coord < peak) {\n\t\tif (start === peak) return 1.0;\n\t\treturn (coord - start) / (peak - start);\n\t} else {\n\t\tif (peak === end) return 1.0;\n\t\treturn (end - coord) / (end - peak);\n\t}\n}\n\n/**\n * Check if COLR table is version 1\n */\nexport function isColrV1(colr: ColrTable): boolean {\n\treturn colr.version >= 1 && colr.baseGlyphPaintRecords !== undefined;\n}\n\n/**\n * Get the paint layer at a specific index from the layer list\n */\nexport function getLayerPaint(colr: ColrTable, index: number): Paint | null {\n\treturn colr.layerList?.[index] ?? null;\n}\n",
    "import type { Reader } from \"../binary/reader.ts\";\n\n/**\n * CPAL (Color Palette) table parser\n * Provides color palettes for color fonts\n */\n\nexport interface CpalTable {\n\tversion: number;\n\tnumPalettes: number;\n\tnumPaletteEntries: number;\n\tpalettes: ColorPalette[];\n\tpaletteTypes?: number[];\n\tpaletteLabels?: number[];\n\tpaletteEntryLabels?: number[];\n}\n\nexport interface ColorPalette {\n\tcolors: Color[];\n}\n\nexport interface Color {\n\tblue: number; // 0-255\n\tgreen: number; // 0-255\n\tred: number; // 0-255\n\talpha: number; // 0-255\n}\n\n/**\n * Palette type flags\n */\nexport enum PaletteType {\n\tUsableWithLightBackground = 0x0001,\n\tUsableWithDarkBackground = 0x0002,\n}\n\n/**\n * Parse CPAL table\n */\nexport function parseCpal(reader: Reader): CpalTable {\n\tconst startOffset = reader.offset;\n\n\tconst version = reader.uint16();\n\tconst numPaletteEntries = reader.uint16();\n\tconst numPalettes = reader.uint16();\n\tconst numColorRecords = reader.uint16();\n\tconst colorRecordsArrayOffset = reader.uint32();\n\n\t// Read color record indices for each palette\n\tconst colorRecordIndices: number[] = [];\n\tfor (let i = 0; i < numPalettes; i++) {\n\t\tcolorRecordIndices.push(reader.uint16());\n\t}\n\n\t// Read all color records\n\treader.seek(startOffset + colorRecordsArrayOffset);\n\tconst colorRecords: Color[] = [];\n\tfor (let i = 0; i < numColorRecords; i++) {\n\t\tcolorRecords.push({\n\t\t\tblue: reader.uint8(),\n\t\t\tgreen: reader.uint8(),\n\t\t\tred: reader.uint8(),\n\t\t\talpha: reader.uint8(),\n\t\t});\n\t}\n\n\t// Build palettes\n\tconst palettes: ColorPalette[] = [];\n\tfor (let i = 0; i < numPalettes; i++) {\n\t\tconst startIndex = colorRecordIndices[i];\n\t\tif (startIndex === undefined) continue;\n\t\tconst colors: Color[] = [];\n\t\tfor (let j = 0; j < numPaletteEntries; j++) {\n\t\t\tconst color = colorRecords[startIndex + j];\n\t\t\tif (color) colors.push(color);\n\t\t}\n\t\tpalettes.push({ colors });\n\t}\n\n\t// Version 1 extensions\n\tlet paletteTypes: number[] | undefined;\n\tlet paletteLabels: number[] | undefined;\n\tlet paletteEntryLabels: number[] | undefined;\n\n\tif (version >= 1) {\n\t\t// After color record indices\n\t\treader.seek(startOffset + 12 + numPalettes * 2);\n\n\t\tconst paletteTypesArrayOffset = reader.uint32();\n\t\tconst paletteLabelsArrayOffset = reader.uint32();\n\t\tconst paletteEntryLabelsArrayOffset = reader.uint32();\n\n\t\tif (paletteTypesArrayOffset !== 0) {\n\t\t\treader.seek(startOffset + paletteTypesArrayOffset);\n\t\t\tpaletteTypes = [];\n\t\t\tfor (let i = 0; i < numPalettes; i++) {\n\t\t\t\tpaletteTypes.push(reader.uint32());\n\t\t\t}\n\t\t}\n\n\t\tif (paletteLabelsArrayOffset !== 0) {\n\t\t\treader.seek(startOffset + paletteLabelsArrayOffset);\n\t\t\tpaletteLabels = [];\n\t\t\tfor (let i = 0; i < numPalettes; i++) {\n\t\t\t\tpaletteLabels.push(reader.uint16());\n\t\t\t}\n\t\t}\n\n\t\tif (paletteEntryLabelsArrayOffset !== 0) {\n\t\t\treader.seek(startOffset + paletteEntryLabelsArrayOffset);\n\t\t\tpaletteEntryLabels = [];\n\t\t\tfor (let i = 0; i < numPaletteEntries; i++) {\n\t\t\t\tpaletteEntryLabels.push(reader.uint16());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tversion,\n\t\tnumPalettes,\n\t\tnumPaletteEntries,\n\t\tpalettes,\n\t\tpaletteTypes,\n\t\tpaletteLabels,\n\t\tpaletteEntryLabels,\n\t};\n}\n\n/**\n * Get color from palette\n */\nexport function getColor(\n\tcpal: CpalTable,\n\tpaletteIndex: number,\n\tcolorIndex: number,\n): Color | null {\n\tconst palette = cpal.palettes[paletteIndex];\n\tif (!palette) return null;\n\treturn palette.colors[colorIndex] ?? null;\n}\n\n/**\n * Convert color to CSS rgba string\n */\nexport function colorToRgba(color: Color): string {\n\treturn `rgba(${color.red}, ${color.green}, ${color.blue}, ${(color.alpha / 255).toFixed(3)})`;\n}\n\n/**\n * Convert color to CSS hex string\n */\nexport function colorToHex(color: Color): string {\n\tconst r = color.red.toString(16).padStart(2, \"0\");\n\tconst g = color.green.toString(16).padStart(2, \"0\");\n\tconst b = color.blue.toString(16).padStart(2, \"0\");\n\tif (color.alpha === 255) {\n\t\treturn `#${r}${g}${b}`;\n\t}\n\tconst a = color.alpha.toString(16).padStart(2, \"0\");\n\treturn `#${r}${g}${b}${a}`;\n}\n",
    "import type { uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * AAT Feature Name table (feat)\n * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6feat.html\n *\n * Defines the font's typographic features that can be controlled by the user.\n * Each feature has a type and settings with human-readable names.\n */\nexport interface FeatTable {\n\tversion: number;\n\tfeatures: FeatureRecord[];\n}\n\n/**\n * A single feature record\n */\nexport interface FeatureRecord {\n\t/** Feature type (e.g., 1 = ligatures, 2 = cursive connection) */\n\tfeatureType: uint16;\n\t/** Number of settings for this feature */\n\tnSettings: uint16;\n\t/** Offset to setting name array */\n\tsettingTableOffset: uint32;\n\t/** Feature flags */\n\tfeatureFlags: uint16;\n\t/** Default setting index */\n\tdefaultSettingIndex: uint16;\n\t/** Name table ID for feature name */\n\tnameId: uint16;\n\t/** Parsed settings */\n\tsettings: FeatureSetting[];\n}\n\n/**\n * A single feature setting\n */\nexport interface FeatureSetting {\n\t/** Setting value to use in morx feature table */\n\tsettingValue: uint16;\n\t/** Name table ID for setting name */\n\tnameId: uint16;\n}\n\n/**\n * Feature type constants (Apple-defined)\n */\nexport enum FeatureType {\n\t/** All typographic features */\n\tAllTypographicFeatures = 0,\n\t/** Ligatures */\n\tLigatures = 1,\n\t/** Cursive connection */\n\tCursiveConnection = 2,\n\t/** Letter case */\n\tLetterCase = 3,\n\t/** Vertical substitution */\n\tVerticalSubstitution = 4,\n\t/** Linguistic rearrangement */\n\tLinguisticRearrangement = 5,\n\t/** Number spacing */\n\tNumberSpacing = 6,\n\t/** Smart swashes */\n\tSmartSwashes = 8,\n\t/** Diacritics */\n\tDiacritics = 9,\n\t/** Vertical position */\n\tVerticalPosition = 10,\n\t/** Fractions */\n\tFractions = 11,\n\t/** Overlapping characters */\n\tOverlappingCharacters = 13,\n\t/** Typographic extras */\n\tTypographicExtras = 14,\n\t/** Mathematical extras */\n\tMathematicalExtras = 15,\n\t/** Ornament sets */\n\tOrnamentSets = 16,\n\t/** Character alternatives */\n\tCharacterAlternatives = 17,\n\t/** Design complexity */\n\tDesignComplexity = 18,\n\t/** Style options */\n\tStyleOptions = 19,\n\t/** Character shape */\n\tCharacterShape = 20,\n\t/** Number case */\n\tNumberCase = 21,\n\t/** Text spacing */\n\tTextSpacing = 22,\n\t/** Transliteration */\n\tTransliteration = 23,\n\t/** Annotation */\n\tAnnotation = 24,\n\t/** Kana spacing */\n\tKanaSpacing = 25,\n\t/** Ideographic spacing */\n\tIdeographicSpacing = 26,\n\t/** Unicode decomposition */\n\tUnicodeDecomposition = 27,\n\t/** Ruby kana */\n\tRubyKana = 28,\n\t/** CJK symbol alternatives */\n\tCJKSymbolAlternatives = 29,\n\t/** Ideographic alternatives */\n\tIdeographicAlternatives = 30,\n\t/** CJK vertical roman placement */\n\tCJKVerticalRomanPlacement = 31,\n\t/** Italic CJK roman */\n\tItalicCJKRoman = 32,\n\t/** Case-sensitive layout */\n\tCaseSensitiveLayout = 33,\n\t/** Alternate kana */\n\tAlternateKana = 34,\n\t/** Stylistic alternatives */\n\tStylisticAlternatives = 35,\n\t/** Contextual alternatives */\n\tContextualAlternatives = 36,\n\t/** Lower case */\n\tLowerCase = 37,\n\t/** Upper case */\n\tUpperCase = 38,\n\t/** Language tag */\n\tLanguageTag = 39,\n\t/** CJK roman spacing */\n\tCJKRomanSpacing = 103,\n}\n\n/**\n * Common ligature settings\n */\nexport enum LigatureSetting {\n\tRequiredLigaturesOn = 0,\n\tRequiredLigaturesOff = 1,\n\tCommonLigaturesOn = 2,\n\tCommonLigaturesOff = 3,\n\tRareLigaturesOn = 4,\n\tRareLigaturesOff = 5,\n\tLogosOn = 6,\n\tLogosOff = 7,\n\tRebusPicturesOn = 8,\n\tRebusPicturesOff = 9,\n\tDiphthongLigaturesOn = 10,\n\tDiphthongLigaturesOff = 11,\n\tSquaredLigaturesOn = 12,\n\tSquaredLigaturesOff = 13,\n\tAbbrevSquaredLigaturesOn = 14,\n\tAbbrevSquaredLigaturesOff = 15,\n\tSymbolLigaturesOn = 16,\n\tSymbolLigaturesOff = 17,\n\tContextualLigaturesOn = 18,\n\tContextualLigaturesOff = 19,\n\tHistoricalLigaturesOn = 20,\n\tHistoricalLigaturesOff = 21,\n}\n\n/**\n * Vertical position settings\n */\nexport enum VerticalPositionSetting {\n\tNormalPosition = 0,\n\tSuperiors = 1,\n\tInferiors = 2,\n\tOrdinals = 3,\n\tScientificInferiors = 4,\n}\n\n/**\n * Number case settings\n */\nexport enum NumberCaseSetting {\n\tLowerCaseNumbers = 0,\n\tUpperCaseNumbers = 1,\n}\n\n/**\n * Number spacing settings\n */\nexport enum NumberSpacingSetting {\n\tMonospacedNumbers = 0,\n\tProportionalNumbers = 1,\n\tThirdWidthNumbers = 2,\n\tQuarterWidthNumbers = 3,\n}\n\n/**\n * Fractions settings\n */\nexport enum FractionsSetting {\n\tNoFractions = 0,\n\tVerticalFractions = 1,\n\tDiagonalFractions = 2,\n}\n\n/**\n * Case-sensitive layout settings\n */\nexport enum CaseSensitiveLayoutSetting {\n\tCaseSensitiveLayoutOn = 0,\n\tCaseSensitiveLayoutOff = 1,\n\tCaseSensitiveSpacingOn = 2,\n\tCaseSensitiveSpacingOff = 3,\n}\n\n/**\n * Stylistic alternatives settings\n */\nexport enum StylisticAlternativesSetting {\n\tNoStylisticAlternates = 0,\n\tStylisticAltOneOn = 2,\n\tStylisticAltOneOff = 3,\n\tStylisticAltTwoOn = 4,\n\tStylisticAltTwoOff = 5,\n\tStylisticAltThreeOn = 6,\n\tStylisticAltThreeOff = 7,\n\tStylisticAltFourOn = 8,\n\tStylisticAltFourOff = 9,\n\tStylisticAltFiveOn = 10,\n\tStylisticAltFiveOff = 11,\n\tStylisticAltSixOn = 12,\n\tStylisticAltSixOff = 13,\n\tStylisticAltSevenOn = 14,\n\tStylisticAltSevenOff = 15,\n\tStylisticAltEightOn = 16,\n\tStylisticAltEightOff = 17,\n\tStylisticAltNineOn = 18,\n\tStylisticAltNineOff = 19,\n\tStylisticAltTenOn = 20,\n\tStylisticAltTenOff = 21,\n\tStylisticAltElevenOn = 22,\n\tStylisticAltElevenOff = 23,\n\tStylisticAltTwelveOn = 24,\n\tStylisticAltTwelveOff = 25,\n\tStylisticAltThirteenOn = 26,\n\tStylisticAltThirteenOff = 27,\n\tStylisticAltFourteenOn = 28,\n\tStylisticAltFourteenOff = 29,\n\tStylisticAltFifteenOn = 30,\n\tStylisticAltFifteenOff = 31,\n\tStylisticAltSixteenOn = 32,\n\tStylisticAltSixteenOff = 33,\n\tStylisticAltSeventeenOn = 34,\n\tStylisticAltSeventeenOff = 35,\n\tStylisticAltEighteenOn = 36,\n\tStylisticAltEighteenOff = 37,\n\tStylisticAltNineteenOn = 38,\n\tStylisticAltNineteenOff = 39,\n\tStylisticAltTwentyOn = 40,\n\tStylisticAltTwentyOff = 41,\n}\n\n/**\n * Contextual alternatives settings\n */\nexport enum ContextualAlternativesSetting {\n\tContextualAlternatesOn = 0,\n\tContextualAlternatesOff = 1,\n\tSwashAlternatesOn = 2,\n\tSwashAlternatesOff = 3,\n\tContextualSwashAlternatesOn = 4,\n\tContextualSwashAlternatesOff = 5,\n}\n\n/**\n * Lower case settings\n */\nexport enum LowerCaseSetting {\n\tDefaultLowerCase = 0,\n\tLowerCaseSmallCaps = 1,\n\tLowerCasePetiteCaps = 2,\n}\n\n/**\n * Upper case settings\n */\nexport enum UpperCaseSetting {\n\tDefaultUpperCase = 0,\n\tUpperCaseSmallCaps = 1,\n\tUpperCasePetiteCaps = 2,\n}\n\n/**\n * Smart swash settings\n */\nexport enum SmartSwashSetting {\n\tWordInitialSwashesOn = 0,\n\tWordInitialSwashesOff = 1,\n\tWordFinalSwashesOn = 2,\n\tWordFinalSwashesOff = 3,\n\tLineInitialSwashesOn = 4,\n\tLineInitialSwashesOff = 5,\n\tLineFinalSwashesOn = 6,\n\tLineFinalSwashesOff = 7,\n\tNonFinalSwashesOn = 8,\n\tNonFinalSwashesOff = 9,\n}\n\n/**\n * Diacritics settings\n */\nexport enum DiacriticsSetting {\n\tShowDiacritics = 0,\n\tHideDiacritics = 1,\n\tDecomposeDiacritics = 2,\n}\n\n/**\n * Character shape settings (CJK)\n */\nexport enum CharacterShapeSetting {\n\tTraditionalCharacters = 0,\n\tSimplifiedCharacters = 1,\n\tJIS1978Characters = 2,\n\tJIS1983Characters = 3,\n\tJIS1990Characters = 4,\n\tTraditionalAltOne = 5,\n\tTraditionalAltTwo = 6,\n\tTraditionalAltThree = 7,\n\tTraditionalAltFour = 8,\n\tTraditionalAltFive = 9,\n\tExpertCharacters = 10,\n\tNLCCharacters = 13,\n\tJIS2004Characters = 11,\n\tHojoCharacters = 12,\n}\n\n/**\n * Feature flag bits\n */\nexport enum FeatureFlags {\n\t/** Feature settings are mutually exclusive */\n\tExclusive = 0x8000,\n\t/** Use default setting index if not specified */\n\tUseDefault = 0x4000,\n}\n\n/**\n * Parse feat table\n */\nexport function parseFeat(reader: Reader): FeatTable {\n\tconst tableStart = reader.offset;\n\n\tconst version = reader.fixed();\n\tconst featureNameCount = reader.uint16();\n\treader.skip(2); // reserved\n\treader.skip(4); // reserved\n\n\tconst features: FeatureRecord[] = [];\n\n\tfor (let i = 0; i < featureNameCount; i++) {\n\t\tconst featureType = reader.uint16();\n\t\tconst nSettings = reader.uint16();\n\t\tconst settingTableOffset = reader.offset32();\n\t\tconst featureFlags = reader.uint16();\n\t\tconst defaultSettingIndex = featureFlags & 0xff;\n\t\tconst nameId = reader.uint16();\n\n\t\t// Parse settings\n\t\tconst settings: FeatureSetting[] = [];\n\t\tconst savedOffset = reader.offset;\n\n\t\treader.seek(tableStart + settingTableOffset);\n\t\tfor (let j = 0; j < nSettings; j++) {\n\t\t\tsettings.push({\n\t\t\t\tsettingValue: reader.uint16(),\n\t\t\t\tnameId: reader.uint16(),\n\t\t\t});\n\t\t}\n\n\t\treader.seek(savedOffset);\n\n\t\tfeatures.push({\n\t\t\tfeatureType,\n\t\t\tnSettings,\n\t\t\tsettingTableOffset,\n\t\t\tfeatureFlags,\n\t\t\tdefaultSettingIndex,\n\t\t\tnameId,\n\t\t\tsettings,\n\t\t});\n\t}\n\n\treturn { version, features };\n}\n\n/**\n * Get a feature by type\n */\nexport function getFeature(\n\ttable: FeatTable,\n\tfeatureType: FeatureType | uint16,\n): FeatureRecord | undefined {\n\treturn table.features.find((f) => f.featureType === featureType);\n}\n\n/**\n * Get all features of a given type\n */\nexport function getAllFeatures(table: FeatTable): FeatureRecord[] {\n\treturn table.features;\n}\n\n/**\n * Check if a feature is exclusive (only one setting can be active)\n */\nexport function isExclusiveFeature(feature: FeatureRecord): boolean {\n\treturn (feature.featureFlags & FeatureFlags.Exclusive) !== 0;\n}\n\n/**\n * Get the default setting for a feature\n */\nexport function getDefaultSetting(\n\tfeature: FeatureRecord,\n): FeatureSetting | undefined {\n\treturn feature.settings[feature.defaultSettingIndex];\n}\n\n/**\n * Get a setting by value\n */\nexport function getSettingByValue(\n\tfeature: FeatureRecord,\n\tsettingValue: uint16,\n): FeatureSetting | undefined {\n\treturn feature.settings.find((s) => s.settingValue === settingValue);\n}\n\n/**\n * Check if a feature has a specific setting\n */\nexport function hasSettingValue(\n\tfeature: FeatureRecord,\n\tsettingValue: uint16,\n): boolean {\n\treturn feature.settings.some((s) => s.settingValue === settingValue);\n}\n\n/**\n * Convert AAT feature type/setting to OpenType feature tag\n * This is a best-effort mapping as there's no 1:1 correspondence\n */\nexport function aatToOpenTypeTag(\n\tfeatureType: FeatureType | uint16,\n\tsettingValue: uint16,\n): string | null {\n\tswitch (featureType) {\n\t\tcase FeatureType.Ligatures:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase LigatureSetting.CommonLigaturesOn:\n\t\t\t\t\treturn \"liga\";\n\t\t\t\tcase LigatureSetting.RareLigaturesOn:\n\t\t\t\t\treturn \"dlig\";\n\t\t\t\tcase LigatureSetting.HistoricalLigaturesOn:\n\t\t\t\t\treturn \"hlig\";\n\t\t\t\tcase LigatureSetting.ContextualLigaturesOn:\n\t\t\t\t\treturn \"clig\";\n\t\t\t\tcase LigatureSetting.RequiredLigaturesOn:\n\t\t\t\t\treturn \"rlig\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.VerticalPosition:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase VerticalPositionSetting.Superiors:\n\t\t\t\t\treturn \"sups\";\n\t\t\t\tcase VerticalPositionSetting.Inferiors:\n\t\t\t\t\treturn \"subs\";\n\t\t\t\tcase VerticalPositionSetting.Ordinals:\n\t\t\t\t\treturn \"ordn\";\n\t\t\t\tcase VerticalPositionSetting.ScientificInferiors:\n\t\t\t\t\treturn \"sinf\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.Fractions:\n\t\t\tif (\n\t\t\t\tsettingValue === FractionsSetting.VerticalFractions ||\n\t\t\t\tsettingValue === FractionsSetting.DiagonalFractions\n\t\t\t) {\n\t\t\t\treturn \"frac\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.NumberCase:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase NumberCaseSetting.LowerCaseNumbers:\n\t\t\t\t\treturn \"onum\";\n\t\t\t\tcase NumberCaseSetting.UpperCaseNumbers:\n\t\t\t\t\treturn \"lnum\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.NumberSpacing:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase NumberSpacingSetting.MonospacedNumbers:\n\t\t\t\t\treturn \"tnum\";\n\t\t\t\tcase NumberSpacingSetting.ProportionalNumbers:\n\t\t\t\t\treturn \"pnum\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.CaseSensitiveLayout:\n\t\t\tif (settingValue === CaseSensitiveLayoutSetting.CaseSensitiveLayoutOn) {\n\t\t\t\treturn \"case\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.LowerCase:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase LowerCaseSetting.LowerCaseSmallCaps:\n\t\t\t\t\treturn \"smcp\";\n\t\t\t\tcase LowerCaseSetting.LowerCasePetiteCaps:\n\t\t\t\t\treturn \"pcap\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.UpperCase:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase UpperCaseSetting.UpperCaseSmallCaps:\n\t\t\t\t\treturn \"c2sc\";\n\t\t\t\tcase UpperCaseSetting.UpperCasePetiteCaps:\n\t\t\t\t\treturn \"c2pc\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.SmartSwashes:\n\t\t\tif (\n\t\t\t\tsettingValue === SmartSwashSetting.WordInitialSwashesOn ||\n\t\t\t\tsettingValue === SmartSwashSetting.WordFinalSwashesOn\n\t\t\t) {\n\t\t\t\treturn \"swsh\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.ContextualAlternatives:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase ContextualAlternativesSetting.ContextualAlternatesOn:\n\t\t\t\t\treturn \"calt\";\n\t\t\t\tcase ContextualAlternativesSetting.SwashAlternatesOn:\n\t\t\t\t\treturn \"swsh\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.StylisticAlternatives:\n\t\t\t// Stylistic sets ss01-ss20\n\t\t\tif (settingValue >= 2 && settingValue <= 41) {\n\t\t\t\tconst setNum = Math.floor((settingValue - 2) / 2) + 1;\n\t\t\t\tif (setNum <= 20) {\n\t\t\t\t\treturn `ss${setNum.toString().padStart(2, \"0\")}`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.CharacterShape:\n\t\t\tswitch (settingValue) {\n\t\t\t\tcase CharacterShapeSetting.TraditionalCharacters:\n\t\t\t\t\treturn \"trad\";\n\t\t\t\tcase CharacterShapeSetting.SimplifiedCharacters:\n\t\t\t\t\treturn \"smpl\";\n\t\t\t\tcase CharacterShapeSetting.JIS1978Characters:\n\t\t\t\t\treturn \"jp78\";\n\t\t\t\tcase CharacterShapeSetting.JIS1983Characters:\n\t\t\t\t\treturn \"jp83\";\n\t\t\t\tcase CharacterShapeSetting.JIS1990Characters:\n\t\t\t\t\treturn \"jp90\";\n\t\t\t\tcase CharacterShapeSetting.JIS2004Characters:\n\t\t\t\t\treturn \"jp04\";\n\t\t\t\tcase CharacterShapeSetting.NLCCharacters:\n\t\t\t\t\treturn \"nlck\";\n\t\t\t\tcase CharacterShapeSetting.ExpertCharacters:\n\t\t\t\t\treturn \"expt\";\n\t\t\t\tcase CharacterShapeSetting.HojoCharacters:\n\t\t\t\t\treturn \"hojo\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FeatureType.VerticalSubstitution:\n\t\t\treturn \"vert\";\n\t\tcase FeatureType.Annotation:\n\t\t\treturn \"nalt\";\n\t\tcase FeatureType.RubyKana:\n\t\t\treturn \"ruby\";\n\t}\n\n\treturn null;\n}\n\n/**\n * Convert OpenType feature tag to AAT feature type/setting\n * Returns null if no mapping exists\n */\nexport function openTypeTagToAat(\n\ttag: string,\n): { featureType: FeatureType; settingValue: uint16 } | null {\n\tswitch (tag) {\n\t\tcase \"liga\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.CommonLigaturesOn,\n\t\t\t};\n\t\tcase \"dlig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.RareLigaturesOn,\n\t\t\t};\n\t\tcase \"hlig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.HistoricalLigaturesOn,\n\t\t\t};\n\t\tcase \"clig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.ContextualLigaturesOn,\n\t\t\t};\n\t\tcase \"rlig\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Ligatures,\n\t\t\t\tsettingValue: LigatureSetting.RequiredLigaturesOn,\n\t\t\t};\n\t\tcase \"sups\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.Superiors,\n\t\t\t};\n\t\tcase \"subs\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.Inferiors,\n\t\t\t};\n\t\tcase \"ordn\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.Ordinals,\n\t\t\t};\n\t\tcase \"sinf\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.VerticalPosition,\n\t\t\t\tsettingValue: VerticalPositionSetting.ScientificInferiors,\n\t\t\t};\n\t\tcase \"frac\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.Fractions,\n\t\t\t\tsettingValue: FractionsSetting.DiagonalFractions,\n\t\t\t};\n\t\tcase \"onum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberCase,\n\t\t\t\tsettingValue: NumberCaseSetting.LowerCaseNumbers,\n\t\t\t};\n\t\tcase \"lnum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberCase,\n\t\t\t\tsettingValue: NumberCaseSetting.UpperCaseNumbers,\n\t\t\t};\n\t\tcase \"tnum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberSpacing,\n\t\t\t\tsettingValue: NumberSpacingSetting.MonospacedNumbers,\n\t\t\t};\n\t\tcase \"pnum\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.NumberSpacing,\n\t\t\t\tsettingValue: NumberSpacingSetting.ProportionalNumbers,\n\t\t\t};\n\t\tcase \"case\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CaseSensitiveLayout,\n\t\t\t\tsettingValue: CaseSensitiveLayoutSetting.CaseSensitiveLayoutOn,\n\t\t\t};\n\t\tcase \"smcp\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.LowerCase,\n\t\t\t\tsettingValue: LowerCaseSetting.LowerCaseSmallCaps,\n\t\t\t};\n\t\tcase \"pcap\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.LowerCase,\n\t\t\t\tsettingValue: LowerCaseSetting.LowerCasePetiteCaps,\n\t\t\t};\n\t\tcase \"c2sc\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.UpperCase,\n\t\t\t\tsettingValue: UpperCaseSetting.UpperCaseSmallCaps,\n\t\t\t};\n\t\tcase \"c2pc\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.UpperCase,\n\t\t\t\tsettingValue: UpperCaseSetting.UpperCasePetiteCaps,\n\t\t\t};\n\t\tcase \"swsh\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.SmartSwashes,\n\t\t\t\tsettingValue: SmartSwashSetting.WordInitialSwashesOn,\n\t\t\t};\n\t\tcase \"calt\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.ContextualAlternatives,\n\t\t\t\tsettingValue: ContextualAlternativesSetting.ContextualAlternatesOn,\n\t\t\t};\n\t\tcase \"trad\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.TraditionalCharacters,\n\t\t\t};\n\t\tcase \"smpl\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.SimplifiedCharacters,\n\t\t\t};\n\t\tcase \"jp78\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS1978Characters,\n\t\t\t};\n\t\tcase \"jp83\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS1983Characters,\n\t\t\t};\n\t\tcase \"jp90\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS1990Characters,\n\t\t\t};\n\t\tcase \"jp04\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.JIS2004Characters,\n\t\t\t};\n\t\tcase \"nlck\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.NLCCharacters,\n\t\t\t};\n\t\tcase \"expt\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.ExpertCharacters,\n\t\t\t};\n\t\tcase \"hojo\":\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.CharacterShape,\n\t\t\t\tsettingValue: CharacterShapeSetting.HojoCharacters,\n\t\t\t};\n\t\tcase \"vert\":\n\t\t\treturn { featureType: FeatureType.VerticalSubstitution, settingValue: 0 };\n\t\tcase \"nalt\":\n\t\t\treturn { featureType: FeatureType.Annotation, settingValue: 0 };\n\t\tcase \"ruby\":\n\t\t\treturn { featureType: FeatureType.RubyKana, settingValue: 0 };\n\t}\n\n\t// Handle stylistic sets ss01-ss20\n\tif (tag.startsWith(\"ss\") && tag.length === 4) {\n\t\tconst num = parseInt(tag.slice(2), 10);\n\t\tif (num >= 1 && num <= 20) {\n\t\t\treturn {\n\t\t\t\tfeatureType: FeatureType.StylisticAlternatives,\n\t\t\t\tsettingValue: (num - 1) * 2 + 2,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n",
    "/**\n * gasp table - Grid-fitting And Scan-conversion Procedure\n *\n * This table controls when grid-fitting (hinting) and anti-aliasing\n * should be applied based on the rendering size (ppem).\n */\n\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Gasp behavior flags\n */\nexport const GaspFlag = {\n\t/** Use grid-fitting (hinting) */\n\tGridFit: 0x0001,\n\t/** Use gray-scale rendering (anti-aliasing) */\n\tDoGray: 0x0002,\n\t/** Use symmetric grid-fitting (ClearType) */\n\tSymmetricGridFit: 0x0004,\n\t/** Use symmetric smoothing (ClearType) */\n\tSymmetricSmoothing: 0x0008,\n} as const;\n\n/**\n * A ppem range with associated behavior\n */\nexport interface GaspRange {\n\t/** Maximum ppem for this range (inclusive) */\n\tmaxPPEM: number;\n\t/** Behavior flags for this range */\n\tbehavior: number;\n}\n\n/**\n * gasp table\n */\nexport interface GaspTable {\n\t/** Version (0 or 1) */\n\tversion: number;\n\t/** Ranges sorted by maxPPEM */\n\tranges: GaspRange[];\n}\n\n/**\n * Parse gasp table\n */\nexport function parseGasp(reader: Reader): GaspTable {\n\tconst version = reader.uint16();\n\tconst numRanges = reader.uint16();\n\n\tconst ranges: GaspRange[] = [];\n\tfor (let i = 0; i < numRanges; i++) {\n\t\tconst maxPPEM = reader.uint16();\n\t\tconst behavior = reader.uint16();\n\t\tranges.push({ maxPPEM, behavior });\n\t}\n\n\t// Ranges should be sorted by maxPPEM\n\tranges.sort((a, b) => a.maxPPEM - b.maxPPEM);\n\n\treturn { version, ranges };\n}\n\n/**\n * Get behavior flags for a specific ppem\n */\nexport function getGaspBehavior(gasp: GaspTable, ppem: number): number {\n\tfor (let i = 0; i < gasp.ranges.length; i++) {\n\t\tconst range = gasp.ranges[i]!;\n\t\tif (ppem <= range.maxPPEM) {\n\t\t\treturn range.behavior;\n\t\t}\n\t}\n\n\t// Above all ranges - use last range or default to all features\n\tif (gasp.ranges.length > 0) {\n\t\treturn gasp.ranges[gasp.ranges.length - 1]?.behavior;\n\t}\n\n\treturn GaspFlag.GridFit | GaspFlag.DoGray;\n}\n\n/**\n * Check if grid-fitting should be used\n */\nexport function shouldGridFit(gasp: GaspTable, ppem: number): boolean {\n\treturn (getGaspBehavior(gasp, ppem) & GaspFlag.GridFit) !== 0;\n}\n\n/**\n * Check if gray-scale rendering should be used\n */\nexport function shouldDoGray(gasp: GaspTable, ppem: number): boolean {\n\treturn (getGaspBehavior(gasp, ppem) & GaspFlag.DoGray) !== 0;\n}\n",
    "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\n\n/** Class range record for Format 2 */\ninterface ClassRangeRecord {\n\tstartGlyphId: GlyphId;\n\tendGlyphId: GlyphId;\n\tclassValue: uint16;\n}\n\n/**\n * Class Definition table - maps glyph IDs to class values.\n *\n * IMPORTANT: This is a unified class (not interface + implementations) to ensure\n * monomorphic call sites in V8. Polymorphic calls can be 7-8x slower!\n */\nexport class ClassDef {\n\t// Format 1: array lookup\n\tprivate readonly startGlyphId: GlyphId;\n\tprivate readonly classValueArray: Uint16Array | null;\n\t// Format 2: ranges + optional hash map\n\tprivate readonly ranges: ClassRangeRecord[] | null;\n\tprivate readonly glyphMap: Map<GlyphId, number> | null;\n\t// Empty flag\n\tprivate readonly isEmpty: boolean;\n\n\tprivate constructor(\n\t\tstartGlyphId: GlyphId,\n\t\tclassValueArray: Uint16Array | null,\n\t\tranges: ClassRangeRecord[] | null,\n\t\tglyphMap: Map<GlyphId, number> | null,\n\t\tisEmpty: boolean,\n\t) {\n\t\tthis.startGlyphId = startGlyphId;\n\t\tthis.classValueArray = classValueArray;\n\t\tthis.ranges = ranges;\n\t\tthis.glyphMap = glyphMap;\n\t\tthis.isEmpty = isEmpty;\n\t}\n\n\t/**\n\t * Create an empty ClassDef\n\t * @returns Empty ClassDef instance where all glyphs return class 0\n\t */\n\tstatic empty(): ClassDef {\n\t\treturn new ClassDef(0, null, null, null, true);\n\t}\n\n\t/**\n\t * Create Format 1 ClassDef (array of class values)\n\t * @param startGlyphId - First glyph ID in the range\n\t * @param classValueArray - Array of class values indexed by (glyphId - startGlyphId)\n\t * @returns ClassDef instance using array lookup\n\t */\n\tstatic format1(\n\t\tstartGlyphId: GlyphId,\n\t\tclassValueArray: Uint16Array,\n\t): ClassDef {\n\t\treturn new ClassDef(startGlyphId, classValueArray, null, null, false);\n\t}\n\n\t/**\n\t * Create Format 2 ClassDef (ranges)\n\t * @param ranges - Array of range records mapping glyph ranges to class values\n\t * @returns ClassDef instance using hash map (for small tables) or binary search (for large tables)\n\t */\n\tstatic format2(ranges: ClassRangeRecord[]): ClassDef {\n\t\t// Calculate total glyphs covered\n\t\tlet totalGlyphs = 0;\n\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\tconst range = ranges[i]!;\n\t\t\ttotalGlyphs += range.endGlyphId - range.startGlyphId + 1;\n\t\t}\n\n\t\t// Use hash map for small-medium tables (< 10000 glyphs) for O(1) lookup\n\t\t// Very large tables stick with binary search to avoid memory overhead\n\t\tlet glyphMap: Map<GlyphId, number> | null = null;\n\t\tif (totalGlyphs < 10000) {\n\t\t\tglyphMap = new Map();\n\t\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\t\tconst range = ranges[i]!;\n\t\t\t\tfor (let g = range.startGlyphId; g <= range.endGlyphId; g++) {\n\t\t\t\t\tglyphMap.set(g, range.classValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new ClassDef(0, null, ranges, glyphMap, false);\n\t}\n\n\t/**\n\t * Get class for a glyph ID\n\t * @param glyphId - The glyph ID to look up\n\t * @returns Class value for the glyph, or 0 if not defined\n\t */\n\tget(glyphId: GlyphId): number {\n\t\t// Empty: all glyphs are class 0\n\t\tif (this.isEmpty) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Format 1: array lookup\n\t\tif (this.classValueArray) {\n\t\t\tconst index = glyphId - this.startGlyphId;\n\t\t\treturn index >= 0 && index < this.classValueArray.length\n\t\t\t\t? this.classValueArray[index]!\n\t\t\t\t: 0;\n\t\t}\n\n\t\t// Format 2: hash or binary search\n\t\tif (this.glyphMap) {\n\t\t\treturn this.glyphMap.get(glyphId) ?? 0;\n\t\t}\n\n\t\t// Binary search for large tables\n\t\tconst ranges = this.ranges!;\n\t\tlet low = 0;\n\t\tlet high = ranges.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst range = ranges[mid]!;\n\n\t\t\tif (glyphId > range.endGlyphId) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (glyphId < range.startGlyphId) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn range.classValue;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Get all glyphs in a specific class\n\t * @param classValue - The class value to search for\n\t * @returns Array of all glyph IDs assigned to this class\n\t */\n\tglyphsInClass(classValue: number): GlyphId[] {\n\t\t// Empty\n\t\tif (this.isEmpty) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Format 1\n\t\tif (this.classValueArray) {\n\t\t\tconst result: GlyphId[] = [];\n\t\t\tfor (let i = 0; i < this.classValueArray.length; i++) {\n\t\t\t\tif (this.classValueArray[i] === classValue) {\n\t\t\t\t\tresult.push(this.startGlyphId + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t// Format 2\n\t\tconst result: GlyphId[] = [];\n\t\tconst ranges = this.ranges!;\n\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\tconst range = ranges[i]!;\n\t\t\tif (range.classValue === classValue) {\n\t\t\t\tfor (let g = range.startGlyphId; g <= range.endGlyphId; g++) {\n\t\t\t\t\tresult.push(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/** Singleton empty ClassDef for external use */\nexport const EMPTY_CLASS_DEF: ClassDef = ClassDef.empty();\n\n/**\n * Parse a Class Definition table from binary data\n * @param reader - Binary reader positioned at class definition table start\n * @returns Parsed ClassDef instance (Format 1 or Format 2)\n */\nexport function parseClassDef(reader: Reader): ClassDef {\n\tconst format = reader.uint16();\n\n\tif (format === 1) {\n\t\tconst startGlyphId = reader.uint16();\n\t\tconst glyphCount = reader.uint16();\n\t\tconst classValueArray = reader.uint16Array(glyphCount);\n\t\treturn ClassDef.format1(startGlyphId, classValueArray);\n\t}\n\n\tif (format === 2) {\n\t\tconst classRangeCount = reader.uint16();\n\t\tconst ranges: ClassRangeRecord[] = new Array(classRangeCount);\n\n\t\tfor (let i = 0; i < classRangeCount; i++) {\n\t\t\tranges[i] = {\n\t\t\t\tstartGlyphId: reader.uint16(),\n\t\t\t\tendGlyphId: reader.uint16(),\n\t\t\t\tclassValue: reader.uint16(),\n\t\t\t};\n\t\t}\n\n\t\treturn ClassDef.format2(ranges);\n\t}\n\n\tthrow new Error(`Unknown ClassDef format: ${format}`);\n}\n\n/**\n * Parse ClassDef from offset, or return empty if offset is 0\n * @param reader - Binary reader positioned at parent table\n * @param offset - Offset from reader's current position to class definition table\n * @returns Parsed ClassDef instance, or empty ClassDef if offset is 0\n */\nexport function parseClassDefAt(reader: Reader, offset: number): ClassDef {\n\tif (offset === 0) {\n\t\treturn EMPTY_CLASS_DEF;\n\t}\n\treturn parseClassDef(reader.sliceFrom(offset));\n}\n",
    "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport { GlyphClass } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Attach point for a glyph */\nexport interface AttachPoint {\n\tpointIndices: uint16[];\n}\n\n/** Ligature caret for a ligature glyph */\nexport interface LigatureCaret {\n\tcaretValues: number[];\n}\n\n/** Mark glyph sets */\nexport interface MarkGlyphSets {\n\t/** Check if glyph is in mark set */\n\thas(setIndex: number, glyphId: GlyphId): boolean;\n}\n\n/** Glyph Definition table */\nexport interface GdefTable {\n\tversion: { major: number; minor: number };\n\n\t/** Glyph class definitions (Base=1, Ligature=2, Mark=3, Component=4) */\n\tglyphClassDef: ClassDef;\n\n\t/** Attachment point list (optional) */\n\tattachList: Map<GlyphId, AttachPoint> | null;\n\n\t/** Ligature caret list (optional) */\n\tligCaretList: Map<GlyphId, LigatureCaret> | null;\n\n\t/** Mark attachment class definitions */\n\tmarkAttachClassDef: ClassDef;\n\n\t/** Mark glyph sets (version 1.2+) */\n\tmarkGlyphSets: MarkGlyphSets | null;\n}\n\nexport function parseGdef(reader: Reader): GdefTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\tconst glyphClassDefOffset = reader.offset16();\n\tconst attachListOffset = reader.offset16();\n\tconst ligCaretListOffset = reader.offset16();\n\tconst markAttachClassDefOffset = reader.offset16();\n\n\tlet markGlyphSetsDefOffset = 0;\n\tif (majorVersion === 1 && minorVersion >= 2) {\n\t\tmarkGlyphSetsDefOffset = reader.offset16();\n\t}\n\n\t// Parse glyph class definitions\n\tconst glyphClassDef = parseClassDefAt(reader, glyphClassDefOffset);\n\n\t// Parse attachment list (optional)\n\tlet attachList: Map<GlyphId, AttachPoint> | null = null;\n\tif (attachListOffset !== 0) {\n\t\tattachList = parseAttachList(reader.sliceFrom(attachListOffset));\n\t}\n\n\t// Parse ligature caret list (optional)\n\tlet ligCaretList: Map<GlyphId, LigatureCaret> | null = null;\n\tif (ligCaretListOffset !== 0) {\n\t\tligCaretList = parseLigCaretList(reader.sliceFrom(ligCaretListOffset));\n\t}\n\n\t// Parse mark attachment class definitions\n\tconst markAttachClassDef = parseClassDefAt(reader, markAttachClassDefOffset);\n\n\t// Parse mark glyph sets (version 1.2+)\n\tlet markGlyphSets: MarkGlyphSets | null = null;\n\tif (markGlyphSetsDefOffset !== 0) {\n\t\tmarkGlyphSets = parseMarkGlyphSets(\n\t\t\treader.sliceFrom(markGlyphSetsDefOffset),\n\t\t);\n\t}\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tglyphClassDef,\n\t\tattachList,\n\t\tligCaretList,\n\t\tmarkAttachClassDef,\n\t\tmarkGlyphSets,\n\t};\n}\n\nexport function parseAttachList(reader: Reader): Map<GlyphId, AttachPoint> {\n\tconst coverageOffset = reader.offset16();\n\tconst glyphCount = reader.uint16();\n\n\t// Read attach point offsets\n\tconst attachPointOffsets = reader.uint16Array(glyphCount);\n\n\t// Parse coverage to get glyph IDs\n\tconst coverageReader = reader.sliceFrom(coverageOffset);\n\tconst format = coverageReader.uint16();\n\n\tconst glyphIds: GlyphId[] = [];\n\tif (format === 1) {\n\t\tconst count = coverageReader.uint16();\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tglyphIds.push(coverageReader.uint16());\n\t\t}\n\t} else if (format === 2) {\n\t\tconst rangeCount = coverageReader.uint16();\n\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\tconst start = coverageReader.uint16();\n\t\t\tconst end = coverageReader.uint16();\n\t\t\tcoverageReader.skip(2); // startCoverageIndex\n\t\t\tfor (let g = start; g <= end; g++) {\n\t\t\t\tglyphIds.push(g);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse attach points\n\tconst result = new Map<GlyphId, AttachPoint>();\n\tfor (let i = 0; i < attachPointOffsets.length; i++) {\n\t\tconst offset = attachPointOffsets[i]!;\n\t\tconst glyphId = glyphIds[i];\n\t\tif (glyphId === undefined) continue;\n\n\t\tconst pointReader = reader.sliceFrom(offset);\n\t\tconst pointCount = pointReader.uint16();\n\t\tconst typedIndices = pointReader.uint16Array(pointCount);\n\t\tconst pointIndices = new Array(typedIndices.length);\n\t\tfor (let j = 0; j < typedIndices.length; j++)\n\t\t\tpointIndices[j] = typedIndices[j];\n\n\t\tresult.set(glyphId, { pointIndices });\n\t}\n\n\treturn result;\n}\n\nexport function parseLigCaretList(reader: Reader): Map<GlyphId, LigatureCaret> {\n\tconst coverageOffset = reader.offset16();\n\tconst ligGlyphCount = reader.uint16();\n\n\t// Read ligature glyph offsets\n\tconst ligGlyphOffsets = reader.uint16Array(ligGlyphCount);\n\n\t// Parse coverage to get glyph IDs\n\tconst coverageReader = reader.sliceFrom(coverageOffset);\n\tconst format = coverageReader.uint16();\n\n\tconst glyphIds: GlyphId[] = [];\n\tif (format === 1) {\n\t\tconst count = coverageReader.uint16();\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tglyphIds.push(coverageReader.uint16());\n\t\t}\n\t} else if (format === 2) {\n\t\tconst rangeCount = coverageReader.uint16();\n\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\tconst start = coverageReader.uint16();\n\t\t\tconst end = coverageReader.uint16();\n\t\t\tcoverageReader.skip(2);\n\t\t\tfor (let g = start; g <= end; g++) {\n\t\t\t\tglyphIds.push(g);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse ligature glyphs\n\tconst result = new Map<GlyphId, LigatureCaret>();\n\tfor (let i = 0; i < ligGlyphOffsets.length; i++) {\n\t\tconst offset = ligGlyphOffsets[i]!;\n\t\tconst glyphId = glyphIds[i];\n\t\tif (glyphId === undefined) continue;\n\n\t\tconst ligReader = reader.sliceFrom(offset);\n\t\tconst caretCount = ligReader.uint16();\n\t\tconst caretValueOffsets = ligReader.uint16Array(caretCount);\n\n\t\tconst caretValues: number[] = [];\n\t\tfor (let j = 0; j < caretValueOffsets.length; j++) {\n\t\t\tconst caretOffset = caretValueOffsets[j]!;\n\t\t\tconst caretReader = reader.sliceFrom(offset + caretOffset);\n\t\t\tconst caretFormat = caretReader.uint16();\n\n\t\t\tif (caretFormat === 1) {\n\t\t\t\t// Design units\n\t\t\t\tcaretValues.push(caretReader.int16());\n\t\t\t} else if (caretFormat === 2) {\n\t\t\t\t// Contour point\n\t\t\t\tcaretValues.push(caretReader.uint16()); // point index\n\t\t\t} else if (caretFormat === 3) {\n\t\t\t\t// Design units + device table\n\t\t\t\tcaretValues.push(caretReader.int16());\n\t\t\t}\n\t\t}\n\n\t\tresult.set(glyphId, { caretValues });\n\t}\n\n\treturn result;\n}\n\nexport function parseMarkGlyphSets(reader: Reader): MarkGlyphSets {\n\tconst _format = reader.uint16();\n\tconst markSetCount = reader.uint16();\n\n\t// Read coverage offsets\n\tconst coverageOffsets = reader.uint32Array(markSetCount);\n\n\t// Parse each mark set coverage\n\tconst markSets: Set<GlyphId>[] = [];\n\tfor (let i = 0; i < coverageOffsets.length; i++) {\n\t\tconst offset = coverageOffsets[i]!;\n\t\tconst coverageReader = reader.sliceFrom(offset);\n\t\tconst coverageFormat = coverageReader.uint16();\n\n\t\tconst glyphSet = new Set<GlyphId>();\n\t\tif (coverageFormat === 1) {\n\t\t\tconst count = coverageReader.uint16();\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tglyphSet.add(coverageReader.uint16());\n\t\t\t}\n\t\t} else if (coverageFormat === 2) {\n\t\t\tconst rangeCount = coverageReader.uint16();\n\t\t\tfor (let j = 0; j < rangeCount; j++) {\n\t\t\t\tconst start = coverageReader.uint16();\n\t\t\t\tconst end = coverageReader.uint16();\n\t\t\t\tcoverageReader.skip(2);\n\t\t\t\tfor (let g = start; g <= end; g++) {\n\t\t\t\t\tglyphSet.add(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkSets.push(glyphSet);\n\t}\n\n\treturn {\n\t\thas(setIndex: number, glyphId: GlyphId): boolean {\n\t\t\tconst set = markSets[setIndex];\n\t\t\treturn set ? set.has(glyphId) : false;\n\t\t},\n\t};\n}\n\n/** Get glyph class from GDEF */\nexport function getGlyphClass(\n\tgdef: GdefTable | null,\n\tglyphId: GlyphId,\n): GlyphClass | 0 {\n\tif (!gdef) return 0;\n\tconst cls = gdef.glyphClassDef.get(glyphId);\n\treturn cls as GlyphClass | 0;\n}\n\n/** Check if glyph is a base glyph */\nexport function isBaseGlyph(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Base;\n}\n\n/** Check if glyph is a ligature */\nexport function isLigature(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Ligature;\n}\n\n/** Check if glyph is a mark */\nexport function isMark(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Mark;\n}\n\n/** Check if glyph is a component */\nexport function isComponent(gdef: GdefTable | null, glyphId: GlyphId): boolean {\n\treturn getGlyphClass(gdef, glyphId) === GlyphClass.Component;\n}\n",
    "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\n\n/** Range record for Format 2 */\ninterface RangeRecord {\n\tstartGlyphId: GlyphId;\n\tendGlyphId: GlyphId;\n\tstartCoverageIndex: uint16;\n}\n\n/**\n * Coverage table - maps glyph IDs to coverage indices.\n *\n * IMPORTANT: This is a unified class (not interface + implementations) to ensure\n * monomorphic call sites in V8. Polymorphic calls can be 7-8x slower!\n */\nexport class Coverage {\n\t// Format 1: hash map for O(1) lookup\n\tprivate readonly glyphMap: Map<GlyphId, number> | null;\n\t// Format 2: ranges for binary search\n\tprivate readonly ranges: RangeRecord[] | null;\n\t// Glyph array for Format 1 (used by glyphs())\n\tprivate readonly glyphArray: Uint16Array | null;\n\t// Cached size\n\treadonly size: number;\n\n\tprivate constructor(\n\t\tglyphMap: Map<GlyphId, number> | null,\n\t\tranges: RangeRecord[] | null,\n\t\tglyphArray: Uint16Array | null,\n\t\tsize: number,\n\t) {\n\t\tthis.glyphMap = glyphMap;\n\t\tthis.ranges = ranges;\n\t\tthis.glyphArray = glyphArray;\n\t\tthis.size = size;\n\t}\n\n\t/**\n\t * Create Format 1 coverage (individual glyphs)\n\t * @param glyphArray - Array of glyph IDs to cover\n\t * @returns Coverage instance using hash map for O(1) lookup\n\t */\n\tstatic format1(glyphArray: Uint16Array): Coverage {\n\t\tconst glyphMap = new Map<GlyphId, number>();\n\t\tfor (let i = 0; i < glyphArray.length; i++) {\n\t\t\tglyphMap.set(glyphArray[i]!, i);\n\t\t}\n\t\treturn new Coverage(glyphMap, null, glyphArray, glyphArray.length);\n\t}\n\n\t/**\n\t * Create Format 2 coverage (ranges)\n\t * @param ranges - Array of range records defining covered glyph ranges\n\t * @returns Coverage instance using binary search for range lookup\n\t */\n\tstatic format2(ranges: RangeRecord[]): Coverage {\n\t\tlet size = 0;\n\t\tif (ranges.length > 0) {\n\t\t\tconst lastRange = ranges[ranges.length - 1];\n\t\t\tif (lastRange) {\n\t\t\t\tsize =\n\t\t\t\t\tlastRange.startCoverageIndex +\n\t\t\t\t\t(lastRange.endGlyphId - lastRange.startGlyphId + 1);\n\t\t\t}\n\t\t}\n\t\treturn new Coverage(null, ranges, null, size);\n\t}\n\n\t/**\n\t * Get coverage index for a glyph ID\n\t * @param glyphId - The glyph ID to look up\n\t * @returns Coverage index (0-based) if glyph is covered, null otherwise\n\t */\n\tget(glyphId: GlyphId): number | null {\n\t\t// Format 1: O(1) hash lookup\n\t\tif (this.glyphMap) {\n\t\t\treturn this.glyphMap.get(glyphId) ?? null;\n\t\t}\n\n\t\t// Format 2: Binary search through ranges\n\t\tconst ranges = this.ranges!;\n\t\tlet low = 0;\n\t\tlet high = ranges.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst mid = (low + high) >>> 1;\n\t\t\tconst range = ranges[mid]!;\n\n\t\t\tif (glyphId > range.endGlyphId) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (glyphId < range.startGlyphId) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn range.startCoverageIndex + (glyphId - range.startGlyphId);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check if glyph is covered\n\t * @param glyphId - The glyph ID to check\n\t * @returns True if the glyph is in this coverage table\n\t */\n\tcovers(glyphId: GlyphId): boolean {\n\t\treturn this.get(glyphId) !== null;\n\t}\n\n\t/**\n\t * Get all covered glyph IDs\n\t * @returns Array of all glyph IDs in this coverage table\n\t */\n\tglyphs(): GlyphId[] {\n\t\t// Format 1 - manual copy is faster than Array.from\n\t\tif (this.glyphArray) {\n\t\t\tconst arr = this.glyphArray;\n\t\t\tconst result = new Array<GlyphId>(arr.length);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tresult[i] = arr[i]!;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t// Format 2\n\t\tconst result: GlyphId[] = [];\n\t\tconst ranges = this.ranges!;\n\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\tconst range = ranges[i]!;\n\t\t\tfor (let g = range.startGlyphId; g <= range.endGlyphId; g++) {\n\t\t\t\tresult.push(g);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Parse a Coverage table from binary data\n * @param reader - Binary reader positioned at coverage table start\n * @returns Parsed coverage instance (Format 1 or Format 2)\n */\nexport function parseCoverage(reader: Reader): Coverage {\n\tconst format = reader.uint16();\n\n\tif (format === 1) {\n\t\tconst glyphCount = reader.uint16();\n\t\tconst glyphArray = reader.uint16Array(glyphCount);\n\t\treturn Coverage.format1(glyphArray);\n\t}\n\n\tif (format === 2) {\n\t\tconst rangeCount = reader.uint16();\n\t\tconst ranges: RangeRecord[] = new Array(rangeCount);\n\n\t\tfor (let i = 0; i < rangeCount; i++) {\n\t\t\tranges[i] = {\n\t\t\t\tstartGlyphId: reader.uint16(),\n\t\t\t\tendGlyphId: reader.uint16(),\n\t\t\t\tstartCoverageIndex: reader.uint16(),\n\t\t\t};\n\t\t}\n\n\t\treturn Coverage.format2(ranges);\n\t}\n\n\tthrow new Error(`Unknown Coverage format: ${format}`);\n}\n\n/**\n * Parse Coverage from offset (creates sub-reader)\n * @param reader - Binary reader positioned at parent table\n * @param offset - Offset from reader's current position to coverage table\n * @returns Parsed coverage instance\n */\nexport function parseCoverageAt(reader: Reader, offset: number): Coverage {\n\treturn parseCoverage(reader.sliceFrom(offset));\n}\n",
    "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { int16, uint16 } from \"../../types.ts\";\n\n/**\n * Device table - pixel-level adjustments for different PPEM sizes\n * Used in GPOS for fine-tuning positioning at specific sizes\n */\n\nexport interface DeviceTable {\n\tstartSize: uint16;\n\tendSize: uint16;\n\tdeltaFormat: uint16;\n\t/** Delta values indexed by (ppem - startSize) */\n\tdeltaValues: int16[];\n}\n\n/** VariationIndex table for variable fonts (shares format with Device) */\nexport interface VariationIndexTable {\n\tdeltaSetOuterIndex: uint16;\n\tdeltaSetInnerIndex: uint16;\n}\n\n/** Combined type - can be either Device or VariationIndex */\nexport type DeviceOrVariationIndex = DeviceTable | VariationIndexTable;\n\n/**\n * Check if this is a VariationIndex table\n * @param table - The device or variation index table to check\n * @returns True if the table is a VariationIndex table, false if it's a Device table\n */\nexport function isVariationIndexTable(\n\ttable: DeviceOrVariationIndex,\n): table is VariationIndexTable {\n\treturn \"deltaSetOuterIndex\" in table;\n}\n\n/**\n * Parse Device or VariationIndex table at offset\n * @param reader - Binary reader positioned at the parent table\n * @param offset - Offset from reader's current position to the device table\n * @returns Parsed device or variation index table, or null if offset is 0\n */\nexport function parseDeviceAt(\n\treader: Reader,\n\toffset: number,\n): DeviceOrVariationIndex | null {\n\tif (offset === 0) return null;\n\treturn parseDevice(reader.sliceFrom(offset));\n}\n\n/**\n * Parse Device or VariationIndex table\n * @param reader - Binary reader positioned at the device table start\n * @returns Parsed device or variation index table\n */\nexport function parseDevice(reader: Reader): DeviceOrVariationIndex {\n\tconst startSize = reader.uint16();\n\tconst endSize = reader.uint16();\n\tconst deltaFormat = reader.uint16();\n\n\t// Format 0x8000 indicates VariationIndex table\n\tif (deltaFormat === 0x8000) {\n\t\treturn {\n\t\t\tdeltaSetOuterIndex: startSize,\n\t\t\tdeltaSetInnerIndex: endSize,\n\t\t};\n\t}\n\n\tconst deltaValues: int16[] = [];\n\n\tif (deltaFormat >= 1 && deltaFormat <= 3) {\n\t\tconst count = endSize - startSize + 1;\n\t\tconst bitsPerValue = 1 << deltaFormat; // 2, 4, or 8 bits\n\t\tconst valuesPerWord = 16 / bitsPerValue;\n\t\tconst mask = (1 << bitsPerValue) - 1;\n\t\tconst signBit = 1 << (bitsPerValue - 1);\n\n\t\tconst wordCount = Math.ceil(count / valuesPerWord);\n\t\tlet valueIndex = 0;\n\n\t\tfor (let w = 0; w < wordCount; w++) {\n\t\t\tconst word = reader.uint16();\n\n\t\t\tfor (\n\t\t\t\tlet v = 0;\n\t\t\t\tv < valuesPerWord && valueIndex < count;\n\t\t\t\tv++, valueIndex++\n\t\t\t) {\n\t\t\t\tconst shift = 16 - bitsPerValue * (v + 1);\n\t\t\t\tlet delta = (word >> shift) & mask;\n\n\t\t\t\t// Sign extend\n\t\t\t\tif (delta & signBit) {\n\t\t\t\t\tdelta = delta - (1 << bitsPerValue);\n\t\t\t\t}\n\n\t\t\t\tdeltaValues.push(delta);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tstartSize,\n\t\tendSize,\n\t\tdeltaFormat,\n\t\tdeltaValues,\n\t};\n}\n\n/**\n * Get delta adjustment for a specific PPEM size\n * @param device - The device table to query\n * @param ppem - Pixels per em size to get delta for\n * @returns Delta adjustment value, or 0 if PPEM is outside the table's range\n */\nexport function getDeviceDelta(device: DeviceTable, ppem: number): int16 {\n\tif (ppem < device.startSize || ppem > device.endSize) {\n\t\treturn 0;\n\t}\n\tconst index = ppem - device.startSize;\n\treturn device.deltaValues[index] ?? 0;\n}\n\n/**\n * Apply Device table adjustment to a value\n * @param device - The device or variation index table, or null\n * @param value - The base value to adjust\n * @param ppem - Pixels per em size for device table lookup\n * @returns Adjusted value (for Device tables) or unchanged value (for VariationIndex tables or null)\n */\nexport function applyDeviceAdjustment(\n\tdevice: DeviceOrVariationIndex | null,\n\tvalue: number,\n\tppem: number,\n): number {\n\tif (!device) return value;\n\n\tif (isVariationIndexTable(device)) {\n\t\t// VariationIndex tables need ItemVariationStore to resolve\n\t\t// For now, return value unchanged (proper support requires fvar integration)\n\t\treturn value;\n\t}\n\n\treturn value + getDeviceDelta(device, ppem);\n}\n\n/**\n * Parsed value record with resolved Device tables\n */\nexport interface ResolvedValueRecord {\n\txPlacement: number;\n\tyPlacement: number;\n\txAdvance: number;\n\tyAdvance: number;\n\txPlaDevice: DeviceOrVariationIndex | null;\n\tyPlaDevice: DeviceOrVariationIndex | null;\n\txAdvDevice: DeviceOrVariationIndex | null;\n\tyAdvDevice: DeviceOrVariationIndex | null;\n}\n\n/**\n * Apply all Device adjustments to a resolved value record\n * @param record - The value record containing placement and advance values with device tables\n * @param ppem - Pixels per em size for device table lookups\n * @returns Object containing adjusted xPlacement, yPlacement, xAdvance, and yAdvance values\n */\nexport function applyDeviceAdjustments(\n\trecord: ResolvedValueRecord,\n\tppem: number,\n): {\n\txPlacement: number;\n\tyPlacement: number;\n\txAdvance: number;\n\tyAdvance: number;\n} {\n\treturn {\n\t\txPlacement: applyDeviceAdjustment(\n\t\t\trecord.xPlaDevice,\n\t\t\trecord.xPlacement,\n\t\t\tppem,\n\t\t),\n\t\tyPlacement: applyDeviceAdjustment(\n\t\t\trecord.yPlaDevice,\n\t\t\trecord.yPlacement,\n\t\t\tppem,\n\t\t),\n\t\txAdvance: applyDeviceAdjustment(record.xAdvDevice, record.xAdvance, ppem),\n\t\tyAdvance: applyDeviceAdjustment(record.yAdvDevice, record.yAdvance, ppem),\n\t};\n}\n",
    "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { Tag, uint16 } from \"../../types.ts\";\n\n/** Language system record */\nexport interface LangSysRecord {\n\tlangSysTag: Tag;\n\tlangSys: LangSys;\n}\n\n/** Language system table */\nexport interface LangSys {\n\t/** Required feature index (0xFFFF if none) */\n\trequiredFeatureIndex: uint16;\n\t/** Feature indices */\n\tfeatureIndices: uint16[];\n}\n\n/** Script record */\nexport interface ScriptRecord {\n\tscriptTag: Tag;\n\tscript: Script;\n}\n\n/** Script table */\nexport interface Script {\n\t/** Default language system (may be null) */\n\tdefaultLangSys: LangSys | null;\n\t/** Language system records */\n\tlangSysRecords: LangSysRecord[];\n}\n\n/** Script list table */\nexport interface ScriptList {\n\tscripts: ScriptRecord[];\n}\n\n/** Feature record */\nexport interface FeatureRecord {\n\tfeatureTag: Tag;\n\tfeature: Feature;\n}\n\n/** Feature table */\nexport interface Feature {\n\t/** Feature parameters offset (usually 0) */\n\tfeatureParamsOffset: uint16;\n\t/** Lookup indices */\n\tlookupListIndices: uint16[];\n}\n\n/** Feature list table */\nexport interface FeatureList {\n\tfeatures: FeatureRecord[];\n}\n\n/** Lookup table header */\nexport interface LookupHeader {\n\tlookupType: uint16;\n\tlookupFlag: uint16;\n\tsubtableOffsets: uint16[];\n\t/** Mark filtering set (if UseMarkFilteringSet flag is set) */\n\tmarkFilteringSet?: uint16;\n}\n\n/** Lookup flags */\nexport const LookupFlag = {\n\tRightToLeft: 0x0001,\n\tIgnoreBaseGlyphs: 0x0002,\n\tIgnoreLigatures: 0x0004,\n\tIgnoreMarks: 0x0008,\n\tUseMarkFilteringSet: 0x0010,\n\t// Bits 5-7 reserved\n\tMarkAttachmentTypeMask: 0xff00,\n} as const;\n\n/** Extract mark attachment type from lookup flag */\nexport function getMarkAttachmentType(lookupFlag: uint16): number {\n\treturn (lookupFlag & LookupFlag.MarkAttachmentTypeMask) >> 8;\n}\n\n/** Parse ScriptList */\nexport function parseScriptList(reader: Reader): ScriptList {\n\tconst scriptCount = reader.uint16();\n\tconst scriptRecords: Array<{ tag: Tag; offset: uint16 }> = [];\n\n\tfor (let i = 0; i < scriptCount; i++) {\n\t\tscriptRecords.push({\n\t\t\ttag: reader.tag(),\n\t\t\toffset: reader.offset16(),\n\t\t});\n\t}\n\n\tconst scripts: ScriptRecord[] = [];\n\tfor (let i = 0; i < scriptRecords.length; i++) {\n\t\tconst record = scriptRecords[i]!;\n\t\tconst scriptReader = reader.sliceFrom(record.offset);\n\t\tconst script = parseScript(scriptReader);\n\t\tscripts.push({\n\t\t\tscriptTag: record.tag,\n\t\t\tscript,\n\t\t});\n\t}\n\n\treturn { scripts };\n}\n\nfunction parseScript(reader: Reader): Script {\n\tconst defaultLangSysOffset = reader.offset16();\n\tconst langSysCount = reader.uint16();\n\n\tconst langSysRecords: Array<{ tag: Tag; offset: uint16 }> = [];\n\tfor (let i = 0; i < langSysCount; i++) {\n\t\tlangSysRecords.push({\n\t\t\ttag: reader.tag(),\n\t\t\toffset: reader.offset16(),\n\t\t});\n\t}\n\n\t// Parse default language system\n\tlet defaultLangSys: LangSys | null = null;\n\tif (defaultLangSysOffset !== 0) {\n\t\tdefaultLangSys = parseLangSys(reader.sliceFrom(defaultLangSysOffset));\n\t}\n\n\t// Parse language system records\n\tconst parsedLangSysRecords: LangSysRecord[] = [];\n\tfor (let i = 0; i < langSysRecords.length; i++) {\n\t\tconst record = langSysRecords[i]!;\n\t\tconst langSys = parseLangSys(reader.sliceFrom(record.offset));\n\t\tparsedLangSysRecords.push({\n\t\t\tlangSysTag: record.tag,\n\t\t\tlangSys,\n\t\t});\n\t}\n\n\treturn {\n\t\tdefaultLangSys,\n\t\tlangSysRecords: parsedLangSysRecords,\n\t};\n}\n\nfunction parseLangSys(reader: Reader): LangSys {\n\tconst _lookupOrderOffset = reader.offset16(); // Reserved, always 0\n\tconst requiredFeatureIndex = reader.uint16();\n\tconst featureIndexCount = reader.uint16();\n\tconst uint16Array = reader.uint16Array(featureIndexCount);\n\tconst featureIndices: uint16[] = new Array(featureIndexCount);\n\tfor (let i = 0; i < featureIndexCount; i++) {\n\t\tfeatureIndices[i] = uint16Array[i]!;\n\t}\n\n\treturn {\n\t\trequiredFeatureIndex,\n\t\tfeatureIndices,\n\t};\n}\n\n/** Parse FeatureList */\nexport function parseFeatureList(reader: Reader): FeatureList {\n\tconst featureCount = reader.uint16();\n\tconst featureRecords: Array<{ tag: Tag; offset: uint16 }> = [];\n\n\tfor (let i = 0; i < featureCount; i++) {\n\t\tfeatureRecords.push({\n\t\t\ttag: reader.tag(),\n\t\t\toffset: reader.offset16(),\n\t\t});\n\t}\n\n\tconst features: FeatureRecord[] = [];\n\tfor (let i = 0; i < featureRecords.length; i++) {\n\t\tconst record = featureRecords[i]!;\n\t\tconst featureReader = reader.sliceFrom(record.offset);\n\t\tconst feature = parseFeature(featureReader);\n\t\tfeatures.push({\n\t\t\tfeatureTag: record.tag,\n\t\t\tfeature,\n\t\t});\n\t}\n\n\treturn { features };\n}\n\nfunction parseFeature(reader: Reader): Feature {\n\tconst featureParamsOffset = reader.offset16();\n\tconst lookupIndexCount = reader.uint16();\n\tconst uint16Array = reader.uint16Array(lookupIndexCount);\n\tconst lookupListIndices: uint16[] = new Array(lookupIndexCount);\n\tfor (let i = 0; i < lookupIndexCount; i++) {\n\t\tlookupListIndices[i] = uint16Array[i]!;\n\t}\n\n\treturn {\n\t\tfeatureParamsOffset,\n\t\tlookupListIndices,\n\t};\n}\n\n/** Parse lookup headers (does not parse subtables) */\nexport function parseLookupHeaders(reader: Reader): LookupHeader[] {\n\tconst lookupCount = reader.uint16();\n\tconst lookupOffsets = reader.uint16Array(lookupCount);\n\n\tconst headers: LookupHeader[] = [];\n\tfor (let i = 0; i < lookupOffsets.length; i++) {\n\t\tconst offset = lookupOffsets[i]!;\n\t\tconst lookupReader = reader.sliceFrom(offset);\n\t\theaders.push(parseLookupHeader(lookupReader));\n\t}\n\n\treturn headers;\n}\n\nfunction parseLookupHeader(reader: Reader): LookupHeader {\n\tconst lookupType = reader.uint16();\n\tconst lookupFlag = reader.uint16();\n\tconst subtableCount = reader.uint16();\n\tconst uint16Array = reader.uint16Array(subtableCount);\n\tconst subtableOffsets: uint16[] = new Array(subtableCount);\n\tfor (let i = 0; i < subtableCount; i++) {\n\t\tsubtableOffsets[i] = uint16Array[i]!;\n\t}\n\n\tlet markFilteringSet: uint16 | undefined;\n\tif (lookupFlag & LookupFlag.UseMarkFilteringSet) {\n\t\tmarkFilteringSet = reader.uint16();\n\t}\n\n\treturn {\n\t\tlookupType,\n\t\tlookupFlag,\n\t\tsubtableOffsets,\n\t\tmarkFilteringSet,\n\t};\n}\n\n/**\n * Find script in script list by tag\n * @param scriptList - The script list to search\n * @param scriptTag - The script tag to find (e.g., 'latn', 'arab')\n * @returns The script table if found, null otherwise\n */\nexport function findScript(\n\tscriptList: ScriptList,\n\tscriptTag: Tag,\n): Script | null {\n\tfor (let i = 0; i < scriptList.scripts.length; i++) {\n\t\tconst record = scriptList.scripts[i]!;\n\t\tif (record.scriptTag === scriptTag) {\n\t\t\treturn record.script;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Find language system in script by tag\n * @param script - The script table to search\n * @param langSysTag - The language system tag to find (e.g., 'ENG', 'ARA'), or null for default\n * @returns The language system table if found, or the default language system if langSysTag is null or not found\n */\nexport function findLangSys(\n\tscript: Script,\n\tlangSysTag: Tag | null,\n): LangSys | null {\n\tif (langSysTag === null) {\n\t\treturn script.defaultLangSys;\n\t}\n\n\tfor (let i = 0; i < script.langSysRecords.length; i++) {\n\t\tconst record = script.langSysRecords[i]!;\n\t\tif (record.langSysTag === langSysTag) {\n\t\t\treturn record.langSys;\n\t\t}\n\t}\n\n\treturn script.defaultLangSys;\n}\n\n/**\n * Get feature by index from feature list\n * @param featureList - The feature list to retrieve from\n * @param index - The zero-based feature index\n * @returns The feature record at the specified index, or null if index is out of bounds\n */\nexport function getFeature(\n\tfeatureList: FeatureList,\n\tindex: number,\n): FeatureRecord | null {\n\treturn featureList.features[index] ?? null;\n}\n",
    "import type { GlyphId } from \"../../types.ts\";\nimport type { Coverage } from \"./coverage.ts\";\n\n/**\n * Set Digest - A Bloom filter for fast O(1) glyph membership rejection.\n *\n * Uses three 64-bit masks with different bit shifts (0, 4, 9) to minimize\n * false positives. This is the same technique used by HarfBuzz/rustybuzz.\n *\n * The digest allows us to quickly reject glyphs that are definitely NOT\n * in a lookup's coverage without doing expensive Coverage table lookups.\n */\nexport class SetDigest {\n\t// Use two 32-bit numbers per mask since JS doesn't have native 64-bit integers\n\t// and BigInt is slow. We use the lower 32 bits only (6 bits per mask = 64 values)\n\tprivate mask0 = 0; // Bits 0-5 of glyphId\n\tprivate mask1 = 0; // Bits 4-9 of glyphId\n\tprivate mask2 = 0; // Bits 9-14 of glyphId\n\n\t/**\n\t * Add a single glyph to the digest\n\t * @param glyphId - The glyph ID to add\n\t */\n\tadd(glyphId: GlyphId): void {\n\t\t// Each mask uses 6 bits of the glyph ID at different positions\n\t\tthis.mask0 |= 1 << (glyphId & 0x1f);\n\t\tthis.mask1 |= 1 << ((glyphId >> 4) & 0x1f);\n\t\tthis.mask2 |= 1 << ((glyphId >> 9) & 0x1f);\n\t}\n\n\t/**\n\t * Add a range of glyphs to the digest\n\t * @param start - Start glyph ID (inclusive)\n\t * @param end - End glyph ID (inclusive)\n\t */\n\taddRange(start: GlyphId, end: GlyphId): void {\n\t\t// For small ranges, add individually\n\t\tif (end - start < 32) {\n\t\t\tfor (let gid = start; gid <= end; gid++) {\n\t\t\t\tthis.add(gid);\n\t\t\t}\n\t\t} else {\n\t\t\t// For large ranges, set all bits (approximation that allows false positives)\n\t\t\tthis.mask0 = 0xffffffff;\n\t\t\tthis.mask1 = 0xffffffff;\n\t\t\tthis.mask2 = 0xffffffff;\n\t\t}\n\t}\n\n\t/**\n\t * Fast check if glyph MAY be in the set\n\t * @param glyphId - The glyph ID to check\n\t * @returns False if glyph is definitely NOT in the set, true if glyph MAY be in the set (false positives possible)\n\t */\n\tmayHave(glyphId: GlyphId): boolean {\n\t\treturn (\n\t\t\t(this.mask0 & (1 << (glyphId & 0x1f))) !== 0 &&\n\t\t\t(this.mask1 & (1 << ((glyphId >> 4) & 0x1f))) !== 0 &&\n\t\t\t(this.mask2 & (1 << ((glyphId >> 9) & 0x1f))) !== 0\n\t\t);\n\t}\n\n\t/**\n\t * Add all glyphs from a Coverage table to this digest\n\t * @param coverage - The coverage table containing glyphs to add\n\t */\n\taddCoverage(coverage: Coverage): void {\n\t\t// Coverage.glyphs() returns all covered glyph IDs\n\t\tconst glyphs = coverage.glyphs();\n\t\tfor (let i = 0; i < glyphs.length; i++) {\n\t\t\tconst gid = glyphs[i]!;\n\t\t\tthis.add(gid);\n\t\t}\n\t}\n\n\t/**\n\t * Check if this digest MAY intersect with another digest\n\t * @param other - The other digest to check intersection with\n\t * @returns False if there is definitely NO overlap, true if there MAY be overlap (false positives possible)\n\t */\n\tmayIntersect(other: SetDigest): boolean {\n\t\treturn (\n\t\t\t(this.mask0 & other.mask0) !== 0 &&\n\t\t\t(this.mask1 & other.mask1) !== 0 &&\n\t\t\t(this.mask2 & other.mask2) !== 0\n\t\t);\n\t}\n\n\t/**\n\t * Get raw masks for external comparison\n\t * @returns Object containing the three internal mask values\n\t */\n\tgetMasks(): { mask0: number; mask1: number; mask2: number } {\n\t\treturn { mask0: this.mask0, mask1: this.mask1, mask2: this.mask2 };\n\t}\n}\n\n/**\n * Create a SetDigest from multiple Coverage tables (for a lookup with multiple subtables)\n * @param coverages - Array of coverage tables to combine into a single digest\n * @returns A new SetDigest containing all glyphs from all coverage tables\n */\nexport function createLookupDigest(coverages: Coverage[]): SetDigest {\n\tconst digest = new SetDigest();\n\tfor (let i = 0; i < coverages.length; i++) {\n\t\tconst coverage = coverages[i]!;\n\t\tdigest.addCoverage(coverage);\n\t}\n\treturn digest;\n}\n",
    "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GposLookup } from \"./gpos.ts\";\n\n/** Position lookup record - applies a lookup at a position */\nexport interface PosLookupRecord {\n\tsequenceIndex: uint16; // Position in input sequence\n\tlookupListIndex: uint16; // Lookup to apply\n}\n\n/** Context positioning lookup (Type 7) */\nexport interface ContextPosLookup extends GposLookup {\n\ttype: 7;\n\tsubtables: ContextPosSubtable[];\n}\n\nexport type ContextPosSubtable =\n\t| ContextPosFormat1\n\t| ContextPosFormat2\n\t| ContextPosFormat3;\n\n/** Format 1: Simple glyph contexts */\nexport interface ContextPosFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\truleSets: (PosContextRule[] | null)[];\n}\n\nexport interface PosContextRule {\n\tglyphCount: uint16;\n\tinputSequence: GlyphId[]; // Excludes first glyph (in coverage)\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 2: Class-based contexts */\nexport interface ContextPosFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tclassDef: ClassDef;\n\tclassRuleSets: (PosClassRule[] | null)[];\n}\n\nexport interface PosClassRule {\n\tglyphCount: uint16;\n\tinputClasses: uint16[]; // Excludes first class\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 3: Coverage-based contexts */\nexport interface ContextPosFormat3 {\n\tformat: 3;\n\tcoverages: Coverage[];\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Chaining context positioning lookup (Type 8) */\nexport interface ChainingContextPosLookup extends GposLookup {\n\ttype: 8;\n\tsubtables: ChainingContextPosSubtable[];\n}\n\nexport type ChainingContextPosSubtable =\n\t| ChainingContextPosFormat1\n\t| ChainingContextPosFormat2\n\t| ChainingContextPosFormat3;\n\n/** Format 1: Simple chaining context */\nexport interface ChainingContextPosFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\tchainRuleSets: (PosChainRule[] | null)[];\n}\n\nexport interface PosChainRule {\n\tbacktrackSequence: GlyphId[];\n\tinputSequence: GlyphId[]; // Excludes first glyph\n\tlookaheadSequence: GlyphId[];\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 2: Class-based chaining context */\nexport interface ChainingContextPosFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tbacktrackClassDef: ClassDef;\n\tinputClassDef: ClassDef;\n\tlookaheadClassDef: ClassDef;\n\tchainClassRuleSets: (PosChainClassRule[] | null)[];\n}\n\nexport interface PosChainClassRule {\n\tbacktrackClasses: uint16[];\n\tinputClasses: uint16[]; // Excludes first class\n\tlookaheadClasses: uint16[];\n\tlookupRecords: PosLookupRecord[];\n}\n\n/** Format 3: Coverage-based chaining context */\nexport interface ChainingContextPosFormat3 {\n\tformat: 3;\n\tbacktrackCoverages: Coverage[];\n\tinputCoverages: Coverage[];\n\tlookaheadCoverages: Coverage[];\n\tlookupRecords: PosLookupRecord[];\n}\n\nexport function parseContextPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ContextPosSubtable[] {\n\tconst subtables: ContextPosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseContextPosFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseContextPosFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseContextPosFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseContextPosFormat1(reader: Reader): ContextPosFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst ruleSetCount = reader.uint16();\n\tconst ruleSetOffsets = reader.uint16Array(ruleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst ruleSets: (PosContextRule[] | null)[] = [];\n\n\tfor (let i = 0; i < ruleSetOffsets.length; i++) {\n\t\tconst ruleSetOffset = ruleSetOffsets[i]!;\n\t\tif (ruleSetOffset === 0) {\n\t\t\truleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst rsReader = reader.sliceFrom(ruleSetOffset);\n\t\tconst ruleCount = rsReader.uint16();\n\t\tconst ruleOffsets = rsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosContextRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = rsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst typedArr = ruleReader.uint16Array(glyphCount - 1);\n\t\t\tconst inputSequence = new Array(typedArr.length);\n\t\t\tfor (let k = 0; k < typedArr.length; k++) inputSequence[k] = typedArr[k];\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputSequence, lookupRecords });\n\t\t}\n\n\t\truleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, ruleSets };\n}\n\nfunction parseContextPosFormat2(reader: Reader): ContextPosFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst classDefOffset = reader.offset16();\n\tconst classRuleSetCount = reader.uint16();\n\tconst classRuleSetOffsets = reader.uint16Array(classRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst classDef = parseClassDefAt(reader, classDefOffset);\n\tconst classRuleSets: (PosClassRule[] | null)[] = [];\n\n\tfor (let i = 0; i < classRuleSetOffsets.length; i++) {\n\t\tconst crsOffset = classRuleSetOffsets[i]!;\n\t\tif (crsOffset === 0) {\n\t\t\tclassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosClassRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst typedArr = ruleReader.uint16Array(glyphCount - 1);\n\t\t\tconst inputClasses = new Array(typedArr.length);\n\t\t\tfor (let k = 0; k < typedArr.length; k++) inputClasses[k] = typedArr[k];\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputClasses, lookupRecords });\n\t\t}\n\n\t\tclassRuleSets.push(rules);\n\t}\n\n\treturn { format: 2, coverage, classDef, classRuleSets };\n}\n\nfunction parseContextPosFormat3(reader: Reader): ContextPosFormat3 {\n\tconst glyphCount = reader.uint16();\n\tconst lookupCount = reader.uint16();\n\tconst coverageOffsets = reader.uint16Array(glyphCount);\n\n\tconst coverages: Coverage[] = [];\n\tfor (let i = 0; i < coverageOffsets.length; i++) {\n\t\tconst offset = coverageOffsets[i]!;\n\t\tcoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookupRecords = parsePosLookupRecords(reader, lookupCount);\n\n\treturn { format: 3, coverages, lookupRecords };\n}\n\nexport function parseChainingContextPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ChainingContextPosSubtable[] {\n\tconst subtables: ChainingContextPosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseChainingPosFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseChainingPosFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseChainingPosFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseChainingPosFormat1(reader: Reader): ChainingContextPosFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst chainRuleSetCount = reader.uint16();\n\tconst chainRuleSetOffsets = reader.uint16Array(chainRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst chainRuleSets: (PosChainRule[] | null)[] = [];\n\n\tfor (let i = 0; i < chainRuleSetOffsets.length; i++) {\n\t\tconst crsOffset = chainRuleSetOffsets[i]!;\n\t\tif (crsOffset === 0) {\n\t\t\tchainRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosChainRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackTyped = ruleReader.uint16Array(backtrackCount);\n\t\t\tconst backtrackSequence = new Array(backtrackTyped.length);\n\t\t\tfor (let k = 0; k < backtrackTyped.length; k++)\n\t\t\t\tbacktrackSequence[k] = backtrackTyped[k];\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputTyped = ruleReader.uint16Array(inputCount - 1);\n\t\t\tconst inputSequence = new Array(inputTyped.length);\n\t\t\tfor (let k = 0; k < inputTyped.length; k++)\n\t\t\t\tinputSequence[k] = inputTyped[k];\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadTyped = ruleReader.uint16Array(lookaheadCount);\n\t\t\tconst lookaheadSequence = new Array(lookaheadTyped.length);\n\t\t\tfor (let k = 0; k < lookaheadTyped.length; k++)\n\t\t\t\tlookaheadSequence[k] = lookaheadTyped[k];\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackSequence,\n\t\t\t\tinputSequence,\n\t\t\t\tlookaheadSequence,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainRuleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, chainRuleSets };\n}\n\nfunction parseChainingPosFormat2(reader: Reader): ChainingContextPosFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst backtrackClassDefOffset = reader.offset16();\n\tconst inputClassDefOffset = reader.offset16();\n\tconst lookaheadClassDefOffset = reader.offset16();\n\tconst chainClassRuleSetCount = reader.uint16();\n\tconst chainClassRuleSetOffsets = reader.uint16Array(chainClassRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst backtrackClassDef = parseClassDefAt(reader, backtrackClassDefOffset);\n\tconst inputClassDef = parseClassDefAt(reader, inputClassDefOffset);\n\tconst lookaheadClassDef = parseClassDefAt(reader, lookaheadClassDefOffset);\n\n\tconst chainClassRuleSets: (PosChainClassRule[] | null)[] = [];\n\n\tfor (let i = 0; i < chainClassRuleSetOffsets.length; i++) {\n\t\tconst ccrsOffset = chainClassRuleSetOffsets[i]!;\n\t\tif (ccrsOffset === 0) {\n\t\t\tchainClassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccrsReader = reader.sliceFrom(ccrsOffset);\n\t\tconst ruleCount = ccrsReader.uint16();\n\t\tconst ruleOffsets = ccrsReader.uint16Array(ruleCount);\n\n\t\tconst rules: PosChainClassRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = ccrsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackTyped = ruleReader.uint16Array(backtrackCount);\n\t\t\tconst backtrackClasses = new Array(backtrackTyped.length);\n\t\t\tfor (let k = 0; k < backtrackTyped.length; k++)\n\t\t\t\tbacktrackClasses[k] = backtrackTyped[k];\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputTyped = ruleReader.uint16Array(inputCount - 1);\n\t\t\tconst inputClasses = new Array(inputTyped.length);\n\t\t\tfor (let k = 0; k < inputTyped.length; k++)\n\t\t\t\tinputClasses[k] = inputTyped[k];\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadTyped = ruleReader.uint16Array(lookaheadCount);\n\t\t\tconst lookaheadClasses = new Array(lookaheadTyped.length);\n\t\t\tfor (let k = 0; k < lookaheadTyped.length; k++)\n\t\t\t\tlookaheadClasses[k] = lookaheadTyped[k];\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parsePosLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackClasses,\n\t\t\t\tinputClasses,\n\t\t\t\tlookaheadClasses,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainClassRuleSets.push(rules);\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\tbacktrackClassDef,\n\t\tinputClassDef,\n\t\tlookaheadClassDef,\n\t\tchainClassRuleSets,\n\t};\n}\n\nfunction parseChainingPosFormat3(reader: Reader): ChainingContextPosFormat3 {\n\tconst backtrackCount = reader.uint16();\n\tconst backtrackCoverageOffsets = reader.uint16Array(backtrackCount);\n\n\tconst inputCount = reader.uint16();\n\tconst inputCoverageOffsets = reader.uint16Array(inputCount);\n\n\tconst lookaheadCount = reader.uint16();\n\tconst lookaheadCoverageOffsets = reader.uint16Array(lookaheadCount);\n\n\tconst lookupCount = reader.uint16();\n\tconst lookupRecords = parsePosLookupRecords(reader, lookupCount);\n\n\tconst backtrackCoverages: Coverage[] = [];\n\tfor (let i = 0; i < backtrackCoverageOffsets.length; i++) {\n\t\tconst offset = backtrackCoverageOffsets[i]!;\n\t\tbacktrackCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst inputCoverages: Coverage[] = [];\n\tfor (let i = 0; i < inputCoverageOffsets.length; i++) {\n\t\tconst offset = inputCoverageOffsets[i]!;\n\t\tinputCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookaheadCoverages: Coverage[] = [];\n\tfor (let i = 0; i < lookaheadCoverageOffsets.length; i++) {\n\t\tconst offset = lookaheadCoverageOffsets[i]!;\n\t\tlookaheadCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\treturn {\n\t\tformat: 3,\n\t\tbacktrackCoverages,\n\t\tinputCoverages,\n\t\tlookaheadCoverages,\n\t\tlookupRecords,\n\t};\n}\n\nfunction parsePosLookupRecords(\n\treader: Reader,\n\tcount: number,\n): PosLookupRecord[] {\n\tconst records: PosLookupRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\trecords.push({\n\t\t\tsequenceIndex: reader.uint16(),\n\t\t\tlookupListIndex: reader.uint16(),\n\t\t});\n\t}\n\treturn records;\n}\n",
    "import {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport type { int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GposLookup } from \"./gpos.ts\";\n\n/** Anchor point for attachment */\nexport interface Anchor {\n\txCoordinate: int16;\n\tyCoordinate: int16;\n\t/** Contour point index (format 2) */\n\tanchorPoint?: uint16;\n\t/** Device table offsets (format 3) */\n\txDeviceOffset?: uint16;\n\tyDeviceOffset?: uint16;\n}\n\n/** Mark record */\nexport interface MarkRecord {\n\tmarkClass: uint16;\n\tmarkAnchor: Anchor;\n}\n\n/** Mark array */\nexport interface MarkArray {\n\tmarkRecords: MarkRecord[];\n}\n\n/** Base record for mark-to-base */\nexport interface BaseRecord {\n\tbaseAnchors: (Anchor | null)[]; // One per mark class\n}\n\n/** Ligature attach record */\nexport interface LigatureAttach {\n\tcomponentRecords: ComponentRecord[];\n}\n\n/** Component record for ligature */\nexport interface ComponentRecord {\n\tligatureAnchors: (Anchor | null)[]; // One per mark class\n}\n\n/** Mark2 record for mark-to-mark */\nexport interface Mark2Record {\n\tmark2Anchors: (Anchor | null)[]; // One per mark1 class\n}\n\n/** Cursive attachment lookup (Type 3) */\nexport interface CursivePosLookup extends GposLookup {\n\ttype: 3;\n\tsubtables: CursivePosSubtable[];\n}\n\nexport interface CursivePosSubtable {\n\tcoverage: Coverage;\n\tentryExitRecords: EntryExitRecord[];\n}\n\nexport interface EntryExitRecord {\n\tentryAnchor: Anchor | null;\n\texitAnchor: Anchor | null;\n}\n\n/** Mark-to-base attachment lookup (Type 4) */\nexport interface MarkBasePosLookup extends GposLookup {\n\ttype: 4;\n\tsubtables: MarkBasePosSubtable[];\n}\n\nexport interface MarkBasePosSubtable {\n\tmarkCoverage: Coverage;\n\tbaseCoverage: Coverage;\n\tmarkClassCount: uint16;\n\tmarkArray: MarkArray;\n\tbaseArray: BaseRecord[];\n}\n\n/** Mark-to-ligature attachment lookup (Type 5) */\nexport interface MarkLigaturePosLookup extends GposLookup {\n\ttype: 5;\n\tsubtables: MarkLigaturePosSubtable[];\n}\n\nexport interface MarkLigaturePosSubtable {\n\tmarkCoverage: Coverage;\n\tligatureCoverage: Coverage;\n\tmarkClassCount: uint16;\n\tmarkArray: MarkArray;\n\tligatureArray: LigatureAttach[];\n}\n\n/** Mark-to-mark attachment lookup (Type 6) */\nexport interface MarkMarkPosLookup extends GposLookup {\n\ttype: 6;\n\tsubtables: MarkMarkPosSubtable[];\n}\n\nexport interface MarkMarkPosSubtable {\n\tmark1Coverage: Coverage;\n\tmark2Coverage: Coverage;\n\tmarkClassCount: uint16;\n\tmark1Array: MarkArray;\n\tmark2Array: Mark2Record[];\n}\n\n// Parsing functions\n\nexport function parseAnchor(reader: Reader): Anchor {\n\tconst format = reader.uint16();\n\tconst xCoordinate = reader.int16();\n\tconst yCoordinate = reader.int16();\n\n\tconst anchor: Anchor = { xCoordinate, yCoordinate };\n\n\tif (format === 2) {\n\t\tanchor.anchorPoint = reader.uint16();\n\t} else if (format === 3) {\n\t\tanchor.xDeviceOffset = reader.uint16();\n\t\tanchor.yDeviceOffset = reader.uint16();\n\t}\n\n\treturn anchor;\n}\n\nexport function parseAnchorAt(reader: Reader, offset: number): Anchor | null {\n\tif (offset === 0) return null;\n\treturn parseAnchor(reader.sliceFrom(offset));\n}\n\nexport function parseMarkArray(reader: Reader): MarkArray {\n\tconst markCount = reader.uint16();\n\tconst markRecords: MarkRecord[] = [];\n\n\tconst recordData: Array<{ markClass: uint16; anchorOffset: uint16 }> = [];\n\tfor (let i = 0; i < markCount; i++) {\n\t\trecordData.push({\n\t\t\tmarkClass: reader.uint16(),\n\t\t\tanchorOffset: reader.uint16(),\n\t\t});\n\t}\n\n\tfor (let i = 0; i < recordData.length; i++) {\n\t\tconst data = recordData[i]!;\n\t\tconst markAnchor = parseAnchor(reader.sliceFrom(data.anchorOffset));\n\t\tmarkRecords.push({\n\t\t\tmarkClass: data.markClass,\n\t\t\tmarkAnchor,\n\t\t});\n\t}\n\n\treturn { markRecords };\n}\n\nexport function parseCursivePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): CursivePosSubtable[] {\n\tconst subtables: CursivePosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst entryExitCount = r.uint16();\n\n\t\t\tconst entryExitData: Array<{ entryOffset: uint16; exitOffset: uint16 }> =\n\t\t\t\t[];\n\t\t\tfor (let j = 0; j < entryExitCount; j++) {\n\t\t\t\tentryExitData.push({\n\t\t\t\t\tentryOffset: r.uint16(),\n\t\t\t\t\texitOffset: r.uint16(),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst entryExitRecords: EntryExitRecord[] = [];\n\n\t\t\tfor (let j = 0; j < entryExitData.length; j++) {\n\t\t\t\tconst data = entryExitData[j]!;\n\t\t\t\tentryExitRecords.push({\n\t\t\t\t\tentryAnchor: parseAnchorAt(r, data.entryOffset),\n\t\t\t\t\texitAnchor: parseAnchorAt(r, data.exitOffset),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, entryExitRecords });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nexport function parseMarkBasePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MarkBasePosSubtable[] {\n\tconst subtables: MarkBasePosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst markCoverageOffset = r.offset16();\n\t\t\tconst baseCoverageOffset = r.offset16();\n\t\t\tconst markClassCount = r.uint16();\n\t\t\tconst markArrayOffset = r.offset16();\n\t\t\tconst baseArrayOffset = r.offset16();\n\n\t\t\tconst markCoverage = parseCoverageAt(r, markCoverageOffset);\n\t\t\tconst baseCoverage = parseCoverageAt(r, baseCoverageOffset);\n\t\t\tconst markArray = parseMarkArray(r.sliceFrom(markArrayOffset));\n\n\t\t\t// Parse base array\n\t\t\tconst baseArrayReader = r.sliceFrom(baseArrayOffset);\n\t\t\tconst baseCount = baseArrayReader.uint16();\n\t\t\tconst baseArray: BaseRecord[] = [];\n\n\t\t\t// Read anchor offsets first\n\t\t\tconst baseRecordData: Array<uint16[]> = [];\n\t\t\tfor (let j = 0; j < baseCount; j++) {\n\t\t\t\tconst anchorOffsets: uint16[] = [];\n\t\t\t\tfor (let k = 0; k < markClassCount; k++) {\n\t\t\t\t\tanchorOffsets.push(baseArrayReader.uint16());\n\t\t\t\t}\n\t\t\t\tbaseRecordData.push(anchorOffsets);\n\t\t\t}\n\n\t\t\t// Parse anchors\n\t\t\tfor (let j = 0; j < baseRecordData.length; j++) {\n\t\t\t\tconst anchorOffsets = baseRecordData[j]!;\n\t\t\t\tconst baseAnchors: (Anchor | null)[] = [];\n\t\t\t\tfor (let k = 0; k < anchorOffsets.length; k++) {\n\t\t\t\t\tconst anchorOffset = anchorOffsets[k]!;\n\t\t\t\t\tbaseAnchors.push(parseAnchorAt(baseArrayReader, anchorOffset));\n\t\t\t\t}\n\t\t\t\tbaseArray.push({ baseAnchors });\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tmarkCoverage,\n\t\t\t\tbaseCoverage,\n\t\t\t\tmarkClassCount,\n\t\t\t\tmarkArray,\n\t\t\t\tbaseArray,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nexport function parseMarkLigaturePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MarkLigaturePosSubtable[] {\n\tconst subtables: MarkLigaturePosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst markCoverageOffset = r.offset16();\n\t\t\tconst ligatureCoverageOffset = r.offset16();\n\t\t\tconst markClassCount = r.uint16();\n\t\t\tconst markArrayOffset = r.offset16();\n\t\t\tconst ligatureArrayOffset = r.offset16();\n\n\t\t\tconst markCoverage = parseCoverageAt(r, markCoverageOffset);\n\t\t\tconst ligatureCoverage = parseCoverageAt(r, ligatureCoverageOffset);\n\t\t\tconst markArray = parseMarkArray(r.sliceFrom(markArrayOffset));\n\n\t\t\t// Parse ligature array\n\t\t\tconst ligArrayReader = r.sliceFrom(ligatureArrayOffset);\n\t\t\tconst ligatureCount = ligArrayReader.uint16();\n\t\t\tconst ligatureAttachOffsets = ligArrayReader.uint16Array(ligatureCount);\n\n\t\t\tconst ligatureArray: LigatureAttach[] = [];\n\t\t\tfor (let j = 0; j < ligatureAttachOffsets.length; j++) {\n\t\t\t\tconst ligAttachOffset = ligatureAttachOffsets[j]!;\n\t\t\t\tconst ligAttachReader = ligArrayReader.sliceFrom(ligAttachOffset);\n\t\t\t\tconst componentCount = ligAttachReader.uint16();\n\n\t\t\t\tconst componentRecords: ComponentRecord[] = [];\n\t\t\t\t// Read all anchor offsets first\n\t\t\t\tconst componentData: Array<uint16[]> = [];\n\t\t\t\tfor (let k = 0; k < componentCount; k++) {\n\t\t\t\t\tconst anchorOffsets: uint16[] = [];\n\t\t\t\t\tfor (let l = 0; l < markClassCount; l++) {\n\t\t\t\t\t\tanchorOffsets.push(ligAttachReader.uint16());\n\t\t\t\t\t}\n\t\t\t\t\tcomponentData.push(anchorOffsets);\n\t\t\t\t}\n\n\t\t\t\t// Parse anchors\n\t\t\t\tfor (let k = 0; k < componentData.length; k++) {\n\t\t\t\t\tconst anchorOffsets = componentData[k]!;\n\t\t\t\t\tconst ligatureAnchors: (Anchor | null)[] = [];\n\t\t\t\t\tfor (let l = 0; l < anchorOffsets.length; l++) {\n\t\t\t\t\t\tconst anchorOffset = anchorOffsets[l]!;\n\t\t\t\t\t\tligatureAnchors.push(parseAnchorAt(ligAttachReader, anchorOffset));\n\t\t\t\t\t}\n\t\t\t\t\tcomponentRecords.push({ ligatureAnchors });\n\t\t\t\t}\n\n\t\t\t\tligatureArray.push({ componentRecords });\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tmarkCoverage,\n\t\t\t\tligatureCoverage,\n\t\t\t\tmarkClassCount,\n\t\t\t\tmarkArray,\n\t\t\t\tligatureArray,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nexport function parseMarkMarkPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MarkMarkPosSubtable[] {\n\tconst subtables: MarkMarkPosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst mark1CoverageOffset = r.offset16();\n\t\t\tconst mark2CoverageOffset = r.offset16();\n\t\t\tconst markClassCount = r.uint16();\n\t\t\tconst mark1ArrayOffset = r.offset16();\n\t\t\tconst mark2ArrayOffset = r.offset16();\n\n\t\t\tconst mark1Coverage = parseCoverageAt(r, mark1CoverageOffset);\n\t\t\tconst mark2Coverage = parseCoverageAt(r, mark2CoverageOffset);\n\t\t\tconst mark1Array = parseMarkArray(r.sliceFrom(mark1ArrayOffset));\n\n\t\t\t// Parse mark2 array\n\t\t\tconst mark2ArrayReader = r.sliceFrom(mark2ArrayOffset);\n\t\t\tconst mark2Count = mark2ArrayReader.uint16();\n\t\t\tconst mark2Array: Mark2Record[] = [];\n\n\t\t\t// Read anchor offsets\n\t\t\tconst mark2Data: Array<uint16[]> = [];\n\t\t\tfor (let j = 0; j < mark2Count; j++) {\n\t\t\t\tconst anchorOffsets: uint16[] = [];\n\t\t\t\tfor (let k = 0; k < markClassCount; k++) {\n\t\t\t\t\tanchorOffsets.push(mark2ArrayReader.uint16());\n\t\t\t\t}\n\t\t\t\tmark2Data.push(anchorOffsets);\n\t\t\t}\n\n\t\t\t// Parse anchors\n\t\t\tfor (let j = 0; j < mark2Data.length; j++) {\n\t\t\t\tconst anchorOffsets = mark2Data[j]!;\n\t\t\t\tconst mark2Anchors: (Anchor | null)[] = [];\n\t\t\t\tfor (let k = 0; k < anchorOffsets.length; k++) {\n\t\t\t\t\tconst anchorOffset = anchorOffsets[k]!;\n\t\t\t\t\tmark2Anchors.push(parseAnchorAt(mark2ArrayReader, anchorOffset));\n\t\t\t\t}\n\t\t\t\tmark2Array.push({ mark2Anchors });\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tmark1Coverage,\n\t\t\t\tmark2Coverage,\n\t\t\t\tmarkClassCount,\n\t\t\t\tmark1Array,\n\t\t\t\tmark2Array,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n",
    "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport {\n\ttype DeviceOrVariationIndex,\n\tparseDeviceAt,\n} from \"../../layout/structures/device.ts\";\nimport {\n\ttype FeatureList,\n\tLookupFlag,\n\tparseFeatureList,\n\tparseScriptList,\n\ttype ScriptList,\n} from \"../../layout/structures/layout-common.ts\";\nimport { SetDigest } from \"../../layout/structures/set-digest.ts\";\nimport type { GlyphId, GlyphPosition, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\ttype ChainingContextPosLookup,\n\ttype ChainingContextPosSubtable,\n\ttype ContextPosLookup,\n\ttype ContextPosSubtable,\n\tparseChainingContextPos,\n\tparseContextPos,\n} from \"./gpos-contextual.ts\";\nimport {\n\ttype CursivePosSubtable,\n\ttype MarkBasePosSubtable,\n\ttype MarkLigaturePosSubtable,\n\ttype MarkMarkPosSubtable,\n\tparseCursivePos,\n\tparseMarkBasePos,\n\tparseMarkLigaturePos,\n\tparseMarkMarkPos,\n} from \"./gpos-mark.ts\";\n\n/** GPOS lookup types */\nexport enum GposLookupType {\n\tSingle = 1,\n\tPair = 2,\n\tCursive = 3,\n\tMarkToBase = 4,\n\tMarkToLigature = 5,\n\tMarkToMark = 6,\n\tContext = 7,\n\tChainingContext = 8,\n\tExtension = 9,\n}\n\n/** Value record - positioning adjustments */\nexport interface ValueRecord {\n\txPlacement?: int16;\n\tyPlacement?: int16;\n\txAdvance?: int16;\n\tyAdvance?: int16;\n\txPlaDevice?: DeviceOrVariationIndex;\n\tyPlaDevice?: DeviceOrVariationIndex;\n\txAdvDevice?: DeviceOrVariationIndex;\n\tyAdvDevice?: DeviceOrVariationIndex;\n}\n\n/** Value format flags */\nexport const ValueFormat = {\n\tXPlacement: 0x0001,\n\tYPlacement: 0x0002,\n\tXAdvance: 0x0004,\n\tYAdvance: 0x0008,\n\tXPlaDevice: 0x0010,\n\tYPlaDevice: 0x0020,\n\tXAdvDevice: 0x0040,\n\tYAdvDevice: 0x0080,\n} as const;\n\n/** Base interface for all GPOS lookups */\nexport interface GposLookup {\n\ttype: GposLookupType;\n\tflag: uint16;\n\tmarkFilteringSet?: uint16;\n\t/** Bloom filter for fast O(1) glyph rejection */\n\tdigest: SetDigest;\n}\n\n/** Single adjustment lookup (Type 1) */\nexport interface SinglePosLookup extends GposLookup {\n\ttype: GposLookupType.Single;\n\tsubtables: SinglePosSubtable[];\n}\n\nexport interface SinglePosSubtable {\n\tformat: 1 | 2;\n\tcoverage: Coverage;\n\tvalueFormat: uint16;\n\tvalue?: ValueRecord;\n\tvalues?: ValueRecord[];\n}\n\n/** Pair adjustment lookup (Type 2) - kerning */\nexport interface PairPosLookup extends GposLookup {\n\ttype: GposLookupType.Pair;\n\tsubtables: PairPosSubtable[];\n}\n\nexport type PairPosSubtable = PairPosFormat1 | PairPosFormat2;\n\nexport interface PairPosFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\tvalueFormat1: uint16;\n\tvalueFormat2: uint16;\n\tpairSets: PairSet[];\n}\n\nexport interface PairSet {\n\tpairValueRecords: PairValueRecord[];\n}\n\nexport interface PairValueRecord {\n\tsecondGlyph: GlyphId;\n\tvalue1: ValueRecord;\n\tvalue2: ValueRecord;\n}\n\nexport interface PairPosFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tvalueFormat1: uint16;\n\tvalueFormat2: uint16;\n\tclassDef1: ClassDef;\n\tclassDef2: ClassDef;\n\tclass1Count: uint16;\n\tclass2Count: uint16;\n\tclass1Records: Class1Record[];\n}\n\nexport interface Class1Record {\n\tclass2Records: Class2Record[];\n}\n\nexport interface Class2Record {\n\tvalue1: ValueRecord;\n\tvalue2: ValueRecord;\n}\n\n/** Cursive attachment lookup (Type 3) */\nexport interface CursivePosLookup extends GposLookup {\n\ttype: GposLookupType.Cursive;\n\tsubtables: CursivePosSubtable[];\n}\n\n/** Mark-to-base attachment lookup (Type 4) */\nexport interface MarkBasePosLookup extends GposLookup {\n\ttype: GposLookupType.MarkToBase;\n\tsubtables: MarkBasePosSubtable[];\n}\n\n/** Mark-to-ligature attachment lookup (Type 5) */\nexport interface MarkLigaturePosLookup extends GposLookup {\n\ttype: GposLookupType.MarkToLigature;\n\tsubtables: MarkLigaturePosSubtable[];\n}\n\n/** Mark-to-mark attachment lookup (Type 6) */\nexport interface MarkMarkPosLookup extends GposLookup {\n\ttype: GposLookupType.MarkToMark;\n\tsubtables: MarkMarkPosSubtable[];\n}\n\n/** Union of all GPOS lookup types */\nexport type AnyGposLookup =\n\t| SinglePosLookup\n\t| PairPosLookup\n\t| CursivePosLookup\n\t| MarkBasePosLookup\n\t| MarkLigaturePosLookup\n\t| MarkMarkPosLookup\n\t| ContextPosLookup\n\t| ChainingContextPosLookup;\n\n/** GPOS table */\nexport interface GposTable {\n\tversion: { major: number; minor: number };\n\tscriptList: ScriptList;\n\tfeatureList: FeatureList;\n\tlookups: AnyGposLookup[];\n}\n\n// Re-export mark types\nexport type { Anchor, MarkArray } from \"./gpos-mark.ts\";\n\nexport function parseGpos(reader: Reader): GposTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\tconst scriptListOffset = reader.offset16();\n\tconst featureListOffset = reader.offset16();\n\tconst lookupListOffset = reader.offset16();\n\n\tif (majorVersion === 1 && minorVersion >= 1) {\n\t\treader.offset32(); // featureVariationsOffset\n\t}\n\n\tconst scriptList = parseScriptList(reader.sliceFrom(scriptListOffset));\n\tconst featureList = parseFeatureList(reader.sliceFrom(featureListOffset));\n\n\tconst lookupListReader = reader.sliceFrom(lookupListOffset);\n\tconst lookupCount = lookupListReader.uint16();\n\tconst lookupOffsets = lookupListReader.uint16Array(lookupCount);\n\n\tconst lookups: AnyGposLookup[] = [];\n\tfor (let i = 0; i < lookupOffsets.length; i++) {\n\t\tconst lookupOffset = lookupOffsets[i]!;\n\t\tconst lookupReader = lookupListReader.sliceFrom(lookupOffset);\n\t\tconst lookup = parseGposLookup(lookupReader);\n\t\tif (lookup) {\n\t\t\tlookups.push(lookup);\n\t\t}\n\t}\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tscriptList,\n\t\tfeatureList,\n\t\tlookups,\n\t};\n}\n\nfunction parseGposLookup(reader: Reader): AnyGposLookup | null {\n\tconst lookupType = reader.uint16();\n\tconst lookupFlag = reader.uint16();\n\tconst subtableCount = reader.uint16();\n\tconst typedOffsets = reader.uint16Array(subtableCount);\n\tconst subtableOffsets = new Array(typedOffsets.length);\n\tfor (let i = 0; i < typedOffsets.length; i++)\n\t\tsubtableOffsets[i] = typedOffsets[i];\n\n\tlet markFilteringSet: uint16 | undefined;\n\tif (lookupFlag & LookupFlag.UseMarkFilteringSet) {\n\t\tmarkFilteringSet = reader.uint16();\n\t}\n\n\tconst baseProps = { flag: lookupFlag, markFilteringSet };\n\n\t// Helper to build digest from subtables with coverage\n\tconst buildDigest = (subtables: { coverage: Coverage }[]): SetDigest => {\n\t\tconst digest = new SetDigest();\n\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\tconst st = subtables[i]!;\n\t\t\tdigest.addCoverage(st.coverage);\n\t\t}\n\t\treturn digest;\n\t};\n\n\t// Helper for mark lookups (need markCoverage)\n\tconst buildMarkDigest = (\n\t\tsubtables: { markCoverage: Coverage }[],\n\t): SetDigest => {\n\t\tconst digest = new SetDigest();\n\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\tconst st = subtables[i]!;\n\t\t\tdigest.addCoverage(st.markCoverage);\n\t\t}\n\t\treturn digest;\n\t};\n\n\tswitch (lookupType) {\n\t\tcase GposLookupType.Single: {\n\t\t\tconst subtables = parseSinglePos(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Single,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Pair: {\n\t\t\tconst subtables = parsePairPos(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Pair,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Cursive: {\n\t\t\tconst subtables = parseCursivePos(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Cursive,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.MarkToBase: {\n\t\t\tconst subtables = parseMarkBasePos(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToBase,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildMarkDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.MarkToLigature: {\n\t\t\tconst subtables = parseMarkLigaturePos(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToLigature,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildMarkDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.MarkToMark: {\n\t\t\tconst subtables = parseMarkMarkPos(reader, subtableOffsets);\n\t\t\t// MarkMark uses mark1Coverage for the first mark\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tdigest.addCoverage(st.mark1Coverage);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToMark,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Context: {\n\t\t\tconst subtables = parseContextPos(reader, subtableOffsets);\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Context,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.ChainingContext: {\n\t\t\tconst subtables = parseChainingContextPos(reader, subtableOffsets);\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t} else if (\"inputCoverages\" in st && st.inputCoverages?.[0]) {\n\t\t\t\t\tdigest.addCoverage(st.inputCoverages[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.ChainingContext,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Extension:\n\t\t\treturn parseExtensionLookup(reader, subtableOffsets, baseProps);\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\nfunction parseValueRecord(\n\treader: Reader,\n\tvalueFormat: uint16,\n\tsubtableReader?: Reader,\n): ValueRecord {\n\tconst record: ValueRecord = {};\n\n\tif (valueFormat & ValueFormat.XPlacement) record.xPlacement = reader.int16();\n\tif (valueFormat & ValueFormat.YPlacement) record.yPlacement = reader.int16();\n\tif (valueFormat & ValueFormat.XAdvance) record.xAdvance = reader.int16();\n\tif (valueFormat & ValueFormat.YAdvance) record.yAdvance = reader.int16();\n\n\t// Parse Device tables if we have a subtable reader to resolve offsets\n\tconst deviceReader = subtableReader ?? reader;\n\tif (valueFormat & ValueFormat.XPlaDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.xPlaDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\tif (valueFormat & ValueFormat.YPlaDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.yPlaDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\tif (valueFormat & ValueFormat.XAdvDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.xAdvDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\tif (valueFormat & ValueFormat.YAdvDevice) {\n\t\tconst offset = reader.uint16();\n\t\tif (offset !== 0)\n\t\t\trecord.yAdvDevice = parseDeviceAt(deviceReader, offset) ?? undefined;\n\t}\n\n\treturn record;\n}\n\nfunction parseSinglePos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): SinglePosSubtable[] {\n\tconst subtables: SinglePosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst subtableReader = reader.sliceFrom(offset);\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst valueFormat = r.uint16();\n\t\t\tconst value = parseValueRecord(r, valueFormat, subtableReader);\n\t\t\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\t\t\tsubtables.push({ format: 1, coverage, valueFormat, value });\n\t\t} else if (format === 2) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst valueFormat = r.uint16();\n\t\t\tconst valueCount = r.uint16();\n\t\t\tconst values: ValueRecord[] = [];\n\t\t\tfor (let j = 0; j < valueCount; j++) {\n\t\t\t\tvalues.push(parseValueRecord(r, valueFormat, subtableReader));\n\t\t\t}\n\t\t\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\t\t\tsubtables.push({ format: 2, coverage, valueFormat, values });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parsePairPos(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): PairPosSubtable[] {\n\tconst subtables: PairPosSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst subtableReader = reader.sliceFrom(offset);\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tsubtables.push(parsePairPosFormat1(r, subtableReader));\n\t\t} else if (format === 2) {\n\t\t\tsubtables.push(parsePairPosFormat2(r, subtableReader));\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parsePairPosFormat1(\n\treader: Reader,\n\tsubtableReader: Reader,\n): PairPosFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst valueFormat1 = reader.uint16();\n\tconst valueFormat2 = reader.uint16();\n\tconst pairSetCount = reader.uint16();\n\tconst pairSetOffsets = reader.uint16Array(pairSetCount);\n\n\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\tconst pairSets: PairSet[] = [];\n\n\tfor (let i = 0; i < pairSetOffsets.length; i++) {\n\t\tconst pairSetOffset = pairSetOffsets[i]!;\n\t\tconst pairSetReader = subtableReader.sliceFrom(pairSetOffset);\n\t\tconst r = subtableReader.sliceFrom(pairSetOffset);\n\t\tconst pairValueCount = r.uint16();\n\t\tconst pairValueRecords: PairValueRecord[] = [];\n\n\t\tfor (let j = 0; j < pairValueCount; j++) {\n\t\t\tconst secondGlyph = r.uint16();\n\t\t\tconst value1 = parseValueRecord(r, valueFormat1, pairSetReader);\n\t\t\tconst value2 = parseValueRecord(r, valueFormat2, pairSetReader);\n\t\t\tpairValueRecords.push({ secondGlyph, value1, value2 });\n\t\t}\n\n\t\tpairSets.push({ pairValueRecords });\n\t}\n\n\treturn { format: 1, coverage, valueFormat1, valueFormat2, pairSets };\n}\n\nfunction parsePairPosFormat2(\n\treader: Reader,\n\tsubtableReader: Reader,\n): PairPosFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst valueFormat1 = reader.uint16();\n\tconst valueFormat2 = reader.uint16();\n\tconst classDef1Offset = reader.offset16();\n\tconst classDef2Offset = reader.offset16();\n\tconst class1Count = reader.uint16();\n\tconst class2Count = reader.uint16();\n\n\tconst coverage = parseCoverageAt(subtableReader, coverageOffset);\n\tconst classDef1 = parseClassDefAt(subtableReader, classDef1Offset);\n\tconst classDef2 = parseClassDefAt(subtableReader, classDef2Offset);\n\n\tconst class1Records: Class1Record[] = [];\n\tfor (let i = 0; i < class1Count; i++) {\n\t\tconst class2Records: Class2Record[] = [];\n\t\tfor (let j = 0; j < class2Count; j++) {\n\t\t\tconst value1 = parseValueRecord(reader, valueFormat1, subtableReader);\n\t\t\tconst value2 = parseValueRecord(reader, valueFormat2, subtableReader);\n\t\t\tclass2Records.push({ value1, value2 });\n\t\t}\n\t\tclass1Records.push({ class2Records });\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\tvalueFormat1,\n\t\tvalueFormat2,\n\t\tclassDef1,\n\t\tclassDef2,\n\t\tclass1Count,\n\t\tclass2Count,\n\t\tclass1Records,\n\t};\n}\n\nfunction parseExtensionLookup(\n\treader: Reader,\n\tsubtableOffsets: number[],\n\tbaseProps: { flag: uint16; markFilteringSet?: uint16 },\n): AnyGposLookup | null {\n\tif (subtableOffsets.length === 0) return null;\n\n\tconst extSubtables: Array<{ type: number; reader: Reader }> = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst extReader = reader.sliceFrom(offset);\n\t\tconst format = extReader.uint16();\n\t\tif (format !== 1) continue;\n\n\t\tconst extensionLookupType = extReader.uint16();\n\t\tconst extensionOffset = extReader.uint32();\n\n\t\t// extensionOffset is relative to start of extension subtable\n\t\textSubtables.push({\n\t\t\ttype: extensionLookupType,\n\t\t\treader: extReader.sliceFrom(extensionOffset),\n\t\t});\n\t}\n\n\tif (extSubtables.length === 0) return null;\n\n\tconst actualType = extSubtables[0]?.type;\n\n\t// Helper to build digest from subtables with coverage\n\tconst buildDigest = (subtables: { coverage: Coverage }[]): SetDigest => {\n\t\tconst digest = new SetDigest();\n\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\tconst st = subtables[i]!;\n\t\t\tdigest.addCoverage(st.coverage);\n\t\t}\n\t\treturn digest;\n\t};\n\n\t// Helper for mark lookups (need markCoverage)\n\tconst buildMarkDigest = (\n\t\tsubtables: { markCoverage: Coverage }[],\n\t): SetDigest => {\n\t\tconst digest = new SetDigest();\n\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\tconst st = subtables[i]!;\n\t\t\tdigest.addCoverage(st.markCoverage);\n\t\t}\n\t\treturn digest;\n\t};\n\n\tswitch (actualType) {\n\t\tcase GposLookupType.Single: {\n\t\t\tconst subtables: SinglePosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseSinglePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Single,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Pair: {\n\t\t\tconst subtables: PairPosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parsePairPos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Pair,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Cursive: {\n\t\t\tconst subtables: CursivePosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseCursivePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.Cursive,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.MarkToBase: {\n\t\t\tconst subtables: MarkBasePosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseMarkBasePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToBase,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildMarkDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.MarkToLigature: {\n\t\t\tconst subtables: MarkLigaturePosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseMarkLigaturePos(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToLigature,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildMarkDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.MarkToMark: {\n\t\t\tconst subtables: MarkMarkPosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseMarkMarkPos(ext.reader, [0]));\n\t\t\t}\n\t\t\t// MarkMark uses mark1Coverage for the first mark\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tdigest.addCoverage(st.mark1Coverage);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.MarkToMark,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GposLookupType.Context: {\n\t\t\tconst subtables: ContextPosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseContextPos(ext.reader, [0]));\n\t\t\t}\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { type: GposLookupType.Context, ...baseProps, subtables, digest };\n\t\t}\n\n\t\tcase GposLookupType.ChainingContext: {\n\t\t\tconst subtables: ChainingContextPosSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseChainingContextPos(ext.reader, [0]));\n\t\t\t}\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t} else if (\"inputCoverages\" in st && st.inputCoverages?.[0]) {\n\t\t\t\t\tdigest.addCoverage(st.inputCoverages[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GposLookupType.ChainingContext,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n// Utility functions\n\n/**\n * Binary search for pair value record in a PairSet.\n * PairValueRecords are sorted by secondGlyph per OpenType spec.\n * Note: We trust the array is well-formed (no sparse entries) for performance.\n */\nfunction findPairValueRecord(\n\trecords: readonly PairValueRecord[],\n\tsecondGlyph: GlyphId,\n): PairValueRecord | null {\n\tlet low = 0;\n\tlet high = records.length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = (low + high) >>> 1;\n\t\tconst record = records[mid]!; // Trust array bounds - no null check needed\n\t\tconst sg = record.secondGlyph;\n\n\t\tif (sg < secondGlyph) {\n\t\t\tlow = mid + 1;\n\t\t} else if (sg > secondGlyph) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn record;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getKerning(\n\tlookup: PairPosLookup,\n\tfirstGlyph: GlyphId,\n\tsecondGlyph: GlyphId,\n): { xAdvance1: number; xAdvance2: number } | null {\n\tfor (let i = 0; i < lookup.subtables.length; i++) {\n\t\tconst subtable = lookup.subtables[i]!;\n\t\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\t\tif (coverageIndex === null) continue;\n\n\t\tif (subtable.format === 1) {\n\t\t\tconst pairSet = subtable.pairSets[coverageIndex];\n\t\t\tif (!pairSet) continue;\n\n\t\t\t// Binary search for secondGlyph (records are sorted)\n\t\t\tconst record = findPairValueRecord(pairSet.pairValueRecords, secondGlyph);\n\t\t\tif (record) {\n\t\t\t\treturn {\n\t\t\t\t\txAdvance1: record.value1.xAdvance ?? 0,\n\t\t\t\t\txAdvance2: record.value2.xAdvance ?? 0,\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (subtable.format === 2) {\n\t\t\tconst class1 = subtable.classDef1.get(firstGlyph);\n\t\t\t// Early bounds check before array access\n\t\t\tconst class1Records = subtable.class1Records;\n\t\t\tif (class1 >= class1Records.length) continue;\n\n\t\t\tconst class1Record = class1Records[class1]!;\n\t\t\tconst class2 = subtable.classDef2.get(secondGlyph);\n\t\t\tconst class2Records = class1Record.class2Records;\n\t\t\tif (class2 >= class2Records.length) continue;\n\n\t\t\tconst class2Record = class2Records[class2]!;\n\n\t\t\treturn {\n\t\t\t\txAdvance1: class2Record.value1.xAdvance ?? 0,\n\t\t\t\txAdvance2: class2Record.value2.xAdvance ?? 0,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Apply kerning directly to positions, avoiding object allocation.\n * Returns true if kerning was applied, false otherwise.\n */\nexport function applyKerningDirect(\n\tlookup: PairPosLookup,\n\tfirstGlyph: GlyphId,\n\tsecondGlyph: GlyphId,\n\tpos1: GlyphPosition,\n\tpos2: GlyphPosition,\n): boolean {\n\tfor (let i = 0; i < lookup.subtables.length; i++) {\n\t\tconst subtable = lookup.subtables[i]!;\n\t\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\t\tif (coverageIndex === null) continue;\n\n\t\tif (subtable.format === 1) {\n\t\t\tconst pairSet = subtable.pairSets[coverageIndex];\n\t\t\tif (!pairSet) continue;\n\n\t\t\tconst record = findPairValueRecord(pairSet.pairValueRecords, secondGlyph);\n\t\t\tif (record) {\n\t\t\t\tconst xAdv1 = record.value1.xAdvance;\n\t\t\t\tconst xAdv2 = record.value2.xAdvance;\n\t\t\t\tif (xAdv1) pos1.xAdvance += xAdv1;\n\t\t\t\tif (xAdv2) pos2.xAdvance += xAdv2;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (subtable.format === 2) {\n\t\t\tconst class1 = subtable.classDef1.get(firstGlyph);\n\t\t\t// Early bounds check before array access\n\t\t\tconst class1Records = subtable.class1Records;\n\t\t\tif (class1 >= class1Records.length) continue;\n\n\t\t\tconst class1Record = class1Records[class1]!;\n\t\t\tconst class2 = subtable.classDef2.get(secondGlyph);\n\t\t\tconst class2Records = class1Record.class2Records;\n\t\t\tif (class2 >= class2Records.length) continue;\n\n\t\t\tconst class2Record = class2Records[class2]!;\n\t\t\tconst xAdv1 = class2Record.value1.xAdvance;\n\t\t\tconst xAdv2 = class2Record.value2.xAdvance;\n\t\t\tif (xAdv1) pos1.xAdvance += xAdv1;\n\t\t\tif (xAdv2) pos2.xAdvance += xAdv2;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// Export internal functions for testing\nexport const __testing = {\n\tparseGposLookup,\n\tparseExtensionLookup,\n\tparseSinglePos,\n\tparsePairPos,\n\tparseValueRecord,\n};\n",
    "import {\n\ttype ClassDef,\n\tparseClassDefAt,\n} from \"../../layout/structures/class-def.ts\";\nimport {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport type { GsubLookup } from \"./gsub.ts\";\n\n/** Sequence lookup record - applies a lookup at a position */\nexport interface SequenceLookupRecord {\n\tsequenceIndex: uint16; // Position in input sequence\n\tlookupListIndex: uint16; // Lookup to apply\n}\n\n/** Context substitution lookup (Type 5) */\nexport interface ContextSubstLookup extends GsubLookup {\n\ttype: 5;\n\tsubtables: ContextSubstSubtable[];\n}\n\nexport type ContextSubstSubtable =\n\t| ContextSubstFormat1\n\t| ContextSubstFormat2\n\t| ContextSubstFormat3;\n\n/** Format 1: Simple glyph contexts */\nexport interface ContextSubstFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\truleSets: (ContextRule[] | null)[];\n}\n\nexport interface ContextRule {\n\tglyphCount: uint16;\n\tinputSequence: GlyphId[]; // Excludes first glyph (in coverage)\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 2: Class-based contexts */\nexport interface ContextSubstFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tclassDef: ClassDef;\n\tclassRuleSets: (ClassRule[] | null)[];\n}\n\nexport interface ClassRule {\n\tglyphCount: uint16;\n\tinputClasses: uint16[]; // Excludes first class\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 3: Coverage-based contexts */\nexport interface ContextSubstFormat3 {\n\tformat: 3;\n\tcoverages: Coverage[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Chaining context substitution lookup (Type 6) */\nexport interface ChainingContextSubstLookup extends GsubLookup {\n\ttype: 6;\n\tsubtables: ChainingContextSubstSubtable[];\n}\n\nexport type ChainingContextSubstSubtable =\n\t| ChainingContextFormat1\n\t| ChainingContextFormat2\n\t| ChainingContextFormat3;\n\n/** Format 1: Simple chaining context */\nexport interface ChainingContextFormat1 {\n\tformat: 1;\n\tcoverage: Coverage;\n\tchainRuleSets: (ChainRule[] | null)[];\n}\n\nexport interface ChainRule {\n\tbacktrackSequence: GlyphId[];\n\tinputSequence: GlyphId[]; // Excludes first glyph\n\tlookaheadSequence: GlyphId[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 2: Class-based chaining context */\nexport interface ChainingContextFormat2 {\n\tformat: 2;\n\tcoverage: Coverage;\n\tbacktrackClassDef: ClassDef;\n\tinputClassDef: ClassDef;\n\tlookaheadClassDef: ClassDef;\n\tchainClassRuleSets: (ChainClassRule[] | null)[];\n}\n\nexport interface ChainClassRule {\n\tbacktrackClasses: uint16[];\n\tinputClasses: uint16[]; // Excludes first class\n\tlookaheadClasses: uint16[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\n/** Format 3: Coverage-based chaining context */\nexport interface ChainingContextFormat3 {\n\tformat: 3;\n\tbacktrackCoverages: Coverage[];\n\tinputCoverages: Coverage[];\n\tlookaheadCoverages: Coverage[];\n\tlookupRecords: SequenceLookupRecord[];\n}\n\nexport function parseContextSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ContextSubstSubtable[] {\n\tconst subtables: ContextSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseContextFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseContextFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseContextFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseContextFormat1(reader: Reader): ContextSubstFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst ruleSetCount = reader.uint16();\n\tconst ruleSetOffsets = reader.uint16Array(ruleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst ruleSets: (ContextRule[] | null)[] = [];\n\n\tfor (let i = 0; i < ruleSetOffsets.length; i++) {\n\t\tconst ruleSetOffset = ruleSetOffsets[i]!;\n\t\tif (ruleSetOffset === 0) {\n\t\t\truleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst rsReader = reader.sliceFrom(ruleSetOffset);\n\t\tconst ruleCount = rsReader.uint16();\n\t\tconst ruleOffsets = rsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ContextRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = rsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst typedArr = ruleReader.uint16Array(glyphCount - 1);\n\t\t\tconst inputSequence = new Array(typedArr.length);\n\t\t\tfor (let k = 0; k < typedArr.length; k++) inputSequence[k] = typedArr[k];\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputSequence, lookupRecords });\n\t\t}\n\n\t\truleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, ruleSets };\n}\n\nfunction parseContextFormat2(reader: Reader): ContextSubstFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst classDefOffset = reader.offset16();\n\tconst classRuleSetCount = reader.uint16();\n\tconst classRuleSetOffsets = reader.uint16Array(classRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst classDef = parseClassDefAt(reader, classDefOffset);\n\tconst classRuleSets: (ClassRule[] | null)[] = [];\n\n\tfor (let i = 0; i < classRuleSetOffsets.length; i++) {\n\t\tconst crsOffset = classRuleSetOffsets[i]!;\n\t\tif (crsOffset === 0) {\n\t\t\tclassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ClassRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\t\t\tconst glyphCount = ruleReader.uint16();\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst typedArr = ruleReader.uint16Array(glyphCount - 1);\n\t\t\tconst inputClasses = new Array(typedArr.length);\n\t\t\tfor (let k = 0; k < typedArr.length; k++) inputClasses[k] = typedArr[k];\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({ glyphCount, inputClasses, lookupRecords });\n\t\t}\n\n\t\tclassRuleSets.push(rules);\n\t}\n\n\treturn { format: 2, coverage, classDef, classRuleSets };\n}\n\nfunction parseContextFormat3(reader: Reader): ContextSubstFormat3 {\n\tconst glyphCount = reader.uint16();\n\tconst lookupCount = reader.uint16();\n\tconst coverageOffsets = reader.uint16Array(glyphCount);\n\n\tconst coverages: Coverage[] = [];\n\tfor (let i = 0; i < coverageOffsets.length; i++) {\n\t\tconst offset = coverageOffsets[i]!;\n\t\tcoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookupRecords = parseLookupRecords(reader, lookupCount);\n\n\treturn { format: 3, coverages, lookupRecords };\n}\n\nexport function parseChainingContextSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ChainingContextSubstSubtable[] {\n\tconst subtables: ChainingContextSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tswitch (format) {\n\t\t\tcase 1:\n\t\t\t\tsubtables.push(parseChainingFormat1(r));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsubtables.push(parseChainingFormat2(r));\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tsubtables.push(parseChainingFormat3(r));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseChainingFormat1(reader: Reader): ChainingContextFormat1 {\n\tconst coverageOffset = reader.offset16();\n\tconst chainRuleSetCount = reader.uint16();\n\tconst chainRuleSetOffsets = reader.uint16Array(chainRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst chainRuleSets: (ChainRule[] | null)[] = [];\n\n\tfor (let i = 0; i < chainRuleSetOffsets.length; i++) {\n\t\tconst crsOffset = chainRuleSetOffsets[i]!;\n\t\tif (crsOffset === 0) {\n\t\t\tchainRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst crsReader = reader.sliceFrom(crsOffset);\n\t\tconst ruleCount = crsReader.uint16();\n\t\tconst ruleOffsets = crsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ChainRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = crsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackTyped = ruleReader.uint16Array(backtrackCount);\n\t\t\tconst backtrackSequence = new Array(backtrackTyped.length);\n\t\t\tfor (let k = 0; k < backtrackTyped.length; k++)\n\t\t\t\tbacktrackSequence[k] = backtrackTyped[k];\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputTyped = ruleReader.uint16Array(inputCount - 1);\n\t\t\tconst inputSequence = new Array(inputTyped.length);\n\t\t\tfor (let k = 0; k < inputTyped.length; k++)\n\t\t\t\tinputSequence[k] = inputTyped[k];\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadTyped = ruleReader.uint16Array(lookaheadCount);\n\t\t\tconst lookaheadSequence = new Array(lookaheadTyped.length);\n\t\t\tfor (let k = 0; k < lookaheadTyped.length; k++)\n\t\t\t\tlookaheadSequence[k] = lookaheadTyped[k];\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackSequence,\n\t\t\t\tinputSequence,\n\t\t\t\tlookaheadSequence,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainRuleSets.push(rules);\n\t}\n\n\treturn { format: 1, coverage, chainRuleSets };\n}\n\nfunction parseChainingFormat2(reader: Reader): ChainingContextFormat2 {\n\tconst coverageOffset = reader.offset16();\n\tconst backtrackClassDefOffset = reader.offset16();\n\tconst inputClassDefOffset = reader.offset16();\n\tconst lookaheadClassDefOffset = reader.offset16();\n\tconst chainClassRuleSetCount = reader.uint16();\n\tconst chainClassRuleSetOffsets = reader.uint16Array(chainClassRuleSetCount);\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\tconst backtrackClassDef = parseClassDefAt(reader, backtrackClassDefOffset);\n\tconst inputClassDef = parseClassDefAt(reader, inputClassDefOffset);\n\tconst lookaheadClassDef = parseClassDefAt(reader, lookaheadClassDefOffset);\n\n\tconst chainClassRuleSets: (ChainClassRule[] | null)[] = [];\n\n\tfor (let i = 0; i < chainClassRuleSetOffsets.length; i++) {\n\t\tconst ccrsOffset = chainClassRuleSetOffsets[i]!;\n\t\tif (ccrsOffset === 0) {\n\t\t\tchainClassRuleSets.push(null);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccrsReader = reader.sliceFrom(ccrsOffset);\n\t\tconst ruleCount = ccrsReader.uint16();\n\t\tconst ruleOffsets = ccrsReader.uint16Array(ruleCount);\n\n\t\tconst rules: ChainClassRule[] = [];\n\t\tfor (let j = 0; j < ruleOffsets.length; j++) {\n\t\t\tconst ruleOffset = ruleOffsets[j]!;\n\t\t\tconst ruleReader = ccrsReader.sliceFrom(ruleOffset);\n\n\t\t\tconst backtrackCount = ruleReader.uint16();\n\t\t\tconst backtrackTyped = ruleReader.uint16Array(backtrackCount);\n\t\t\tconst backtrackClasses = new Array(backtrackTyped.length);\n\t\t\tfor (let k = 0; k < backtrackTyped.length; k++)\n\t\t\t\tbacktrackClasses[k] = backtrackTyped[k];\n\n\t\t\tconst inputCount = ruleReader.uint16();\n\t\t\tconst inputTyped = ruleReader.uint16Array(inputCount - 1);\n\t\t\tconst inputClasses = new Array(inputTyped.length);\n\t\t\tfor (let k = 0; k < inputTyped.length; k++)\n\t\t\t\tinputClasses[k] = inputTyped[k];\n\n\t\t\tconst lookaheadCount = ruleReader.uint16();\n\t\t\tconst lookaheadTyped = ruleReader.uint16Array(lookaheadCount);\n\t\t\tconst lookaheadClasses = new Array(lookaheadTyped.length);\n\t\t\tfor (let k = 0; k < lookaheadTyped.length; k++)\n\t\t\t\tlookaheadClasses[k] = lookaheadTyped[k];\n\n\t\t\tconst lookupCount = ruleReader.uint16();\n\t\t\tconst lookupRecords = parseLookupRecords(ruleReader, lookupCount);\n\n\t\t\trules.push({\n\t\t\t\tbacktrackClasses,\n\t\t\t\tinputClasses,\n\t\t\t\tlookaheadClasses,\n\t\t\t\tlookupRecords,\n\t\t\t});\n\t\t}\n\n\t\tchainClassRuleSets.push(rules);\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\tbacktrackClassDef,\n\t\tinputClassDef,\n\t\tlookaheadClassDef,\n\t\tchainClassRuleSets,\n\t};\n}\n\nfunction parseChainingFormat3(reader: Reader): ChainingContextFormat3 {\n\tconst backtrackCount = reader.uint16();\n\tconst backtrackCoverageOffsets = reader.uint16Array(backtrackCount);\n\n\tconst inputCount = reader.uint16();\n\tconst inputCoverageOffsets = reader.uint16Array(inputCount);\n\n\tconst lookaheadCount = reader.uint16();\n\tconst lookaheadCoverageOffsets = reader.uint16Array(lookaheadCount);\n\n\tconst lookupCount = reader.uint16();\n\tconst lookupRecords = parseLookupRecords(reader, lookupCount);\n\n\tconst backtrackCoverages: Coverage[] = [];\n\tfor (let i = 0; i < backtrackCoverageOffsets.length; i++) {\n\t\tconst offset = backtrackCoverageOffsets[i]!;\n\t\tbacktrackCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst inputCoverages: Coverage[] = [];\n\tfor (let i = 0; i < inputCoverageOffsets.length; i++) {\n\t\tconst offset = inputCoverageOffsets[i]!;\n\t\tinputCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\tconst lookaheadCoverages: Coverage[] = [];\n\tfor (let i = 0; i < lookaheadCoverageOffsets.length; i++) {\n\t\tconst offset = lookaheadCoverageOffsets[i]!;\n\t\tlookaheadCoverages.push(parseCoverageAt(reader, offset));\n\t}\n\n\treturn {\n\t\tformat: 3,\n\t\tbacktrackCoverages,\n\t\tinputCoverages,\n\t\tlookaheadCoverages,\n\t\tlookupRecords,\n\t};\n}\n\nfunction parseLookupRecords(\n\treader: Reader,\n\tcount: number,\n): SequenceLookupRecord[] {\n\tconst records: SequenceLookupRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\trecords.push({\n\t\t\tsequenceIndex: reader.uint16(),\n\t\t\tlookupListIndex: reader.uint16(),\n\t\t});\n\t}\n\treturn records;\n}\n",
    "import {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport {\n\ttype FeatureList,\n\tLookupFlag,\n\tparseFeatureList,\n\tparseScriptList,\n\ttype ScriptList,\n} from \"../../layout/structures/layout-common.ts\";\nimport { SetDigest } from \"../../layout/structures/set-digest.ts\";\nimport type { GlyphId, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\ttype ChainingContextSubstSubtable,\n\ttype ContextSubstSubtable,\n\tparseChainingContextSubst,\n\tparseContextSubst,\n} from \"./gsub-contextual.ts\";\n\n/** GSUB lookup types */\nexport enum GsubLookupType {\n\tSingle = 1,\n\tMultiple = 2,\n\tAlternate = 3,\n\tLigature = 4,\n\tContext = 5,\n\tChainingContext = 6,\n\tExtension = 7,\n\tReverseChainingSingle = 8,\n}\n\n/** Base interface for all GSUB lookups */\nexport interface GsubLookup {\n\ttype: GsubLookupType;\n\tflag: uint16;\n\tmarkFilteringSet?: uint16;\n\t/** Bloom filter for fast O(1) glyph rejection */\n\tdigest: SetDigest;\n}\n\n/** Single substitution lookup (Type 1) */\nexport interface SingleSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Single;\n\tsubtables: SingleSubstSubtable[];\n}\n\nexport interface SingleSubstSubtable {\n\tformat: 1 | 2;\n\tcoverage: Coverage;\n\tdeltaGlyphId?: number;\n\tsubstituteGlyphIds?: GlyphId[];\n}\n\n/** Multiple substitution lookup (Type 2) */\nexport interface MultipleSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Multiple;\n\tsubtables: MultipleSubstSubtable[];\n}\n\nexport interface MultipleSubstSubtable {\n\tcoverage: Coverage;\n\tsequences: GlyphId[][];\n}\n\n/** Alternate substitution lookup (Type 3) */\nexport interface AlternateSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Alternate;\n\tsubtables: AlternateSubstSubtable[];\n}\n\nexport interface AlternateSubstSubtable {\n\tcoverage: Coverage;\n\talternateSets: GlyphId[][];\n}\n\n/** Ligature substitution lookup (Type 4) */\nexport interface LigatureSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Ligature;\n\tsubtables: LigatureSubstSubtable[];\n}\n\nexport interface LigatureSubstSubtable {\n\tcoverage: Coverage;\n\tligatureSets: LigatureSet[];\n}\n\nexport interface LigatureSet {\n\tligatures: Ligature[];\n}\n\nexport interface Ligature {\n\tligatureGlyph: GlyphId;\n\tcomponentGlyphIds: GlyphId[];\n}\n\n/** Context substitution lookup (Type 5) */\nexport interface ContextSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.Context;\n\tsubtables: ContextSubstSubtable[];\n}\n\n/** Chaining context substitution lookup (Type 6) */\nexport interface ChainingContextSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.ChainingContext;\n\tsubtables: ChainingContextSubstSubtable[];\n}\n\n/** Reverse chaining single substitution lookup (Type 8) */\nexport interface ReverseChainingSingleSubstLookup extends GsubLookup {\n\ttype: GsubLookupType.ReverseChainingSingle;\n\tsubtables: ReverseChainingSingleSubstSubtable[];\n}\n\nexport interface ReverseChainingSingleSubstSubtable {\n\tcoverage: Coverage;\n\tbacktrackCoverages: Coverage[];\n\tlookaheadCoverages: Coverage[];\n\tsubstituteGlyphIds: GlyphId[];\n}\n\n/** Union of all GSUB lookup types */\nexport type AnyGsubLookup =\n\t| SingleSubstLookup\n\t| MultipleSubstLookup\n\t| AlternateSubstLookup\n\t| LigatureSubstLookup\n\t| ContextSubstLookup\n\t| ChainingContextSubstLookup\n\t| ReverseChainingSingleSubstLookup;\n\n/** GSUB table */\nexport interface GsubTable {\n\tversion: { major: number; minor: number };\n\tscriptList: ScriptList;\n\tfeatureList: FeatureList;\n\tlookups: AnyGsubLookup[];\n}\n\n// Re-export for use in shaper\nexport type { SequenceLookupRecord } from \"./gsub-contextual.ts\";\n\nexport function parseGsub(reader: Reader): GsubTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\n\tconst scriptListOffset = reader.offset16();\n\tconst featureListOffset = reader.offset16();\n\tconst lookupListOffset = reader.offset16();\n\n\tif (majorVersion === 1 && minorVersion >= 1) {\n\t\treader.offset32(); // featureVariationsOffset\n\t}\n\n\tconst scriptList = parseScriptList(reader.sliceFrom(scriptListOffset));\n\tconst featureList = parseFeatureList(reader.sliceFrom(featureListOffset));\n\n\tconst lookupListReader = reader.sliceFrom(lookupListOffset);\n\tconst lookupCount = lookupListReader.uint16();\n\tconst lookupOffsets = lookupListReader.uint16Array(lookupCount);\n\n\tconst lookups: AnyGsubLookup[] = [];\n\tfor (let i = 0; i < lookupOffsets.length; i++) {\n\t\tconst lookupOffset = lookupOffsets[i]!;\n\t\tconst lookupReader = lookupListReader.sliceFrom(lookupOffset);\n\t\tconst lookup = parseGsubLookup(\n\t\t\tlookupReader,\n\t\t\tlookupListReader,\n\t\t\tlookupOffset,\n\t\t);\n\t\tif (lookup) {\n\t\t\tlookups.push(lookup);\n\t\t}\n\t}\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tscriptList,\n\t\tfeatureList,\n\t\tlookups,\n\t};\n}\n\nfunction parseGsubLookup(\n\treader: Reader,\n\t_lookupListReader: Reader,\n\t_lookupOffset: number,\n): AnyGsubLookup | null {\n\tconst lookupType = reader.uint16();\n\tconst lookupFlag = reader.uint16();\n\tconst subtableCount = reader.uint16();\n\tconst typedOffsets = reader.uint16Array(subtableCount);\n\tconst subtableOffsets = new Array(typedOffsets.length);\n\tfor (let i = 0; i < typedOffsets.length; i++)\n\t\tsubtableOffsets[i] = typedOffsets[i];\n\n\tlet markFilteringSet: uint16 | undefined;\n\tif (lookupFlag & LookupFlag.UseMarkFilteringSet) {\n\t\tmarkFilteringSet = reader.uint16();\n\t}\n\n\tconst baseProps = { flag: lookupFlag, markFilteringSet };\n\n\t// Helper to build digest from subtables with coverage\n\tconst buildDigest = (subtables: { coverage: Coverage }[]): SetDigest => {\n\t\tconst digest = new SetDigest();\n\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\tconst st = subtables[i]!;\n\t\t\tdigest.addCoverage(st.coverage);\n\t\t}\n\t\treturn digest;\n\t};\n\n\tswitch (lookupType) {\n\t\tcase GsubLookupType.Single: {\n\t\t\tconst subtables = parseSingleSubst(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Single,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Multiple: {\n\t\t\tconst subtables = parseMultipleSubst(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Multiple,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Alternate: {\n\t\t\tconst subtables = parseAlternateSubst(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Alternate,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Ligature: {\n\t\t\tconst subtables = parseLigatureSubst(reader, subtableOffsets);\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Ligature,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Context: {\n\t\t\tconst subtables = parseContextSubst(reader, subtableOffsets);\n\t\t\t// Context subtables may not have direct coverage - use empty digest\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Context,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.ChainingContext: {\n\t\t\tconst subtables = parseChainingContextSubst(reader, subtableOffsets);\n\t\t\t// Chaining context - use input coverage if available\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t} else if (\"inputCoverages\" in st && st.inputCoverages?.[0]) {\n\t\t\t\t\tdigest.addCoverage(st.inputCoverages[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ChainingContext,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Extension:\n\t\t\treturn parseExtensionLookup(reader, subtableOffsets, baseProps);\n\n\t\tcase GsubLookupType.ReverseChainingSingle: {\n\t\t\tconst subtables = parseReverseChainingSingleSubst(\n\t\t\t\treader,\n\t\t\t\tsubtableOffsets,\n\t\t\t);\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ReverseChainingSingle,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\nfunction parseSingleSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): SingleSubstSubtable[] {\n\tconst subtables: SingleSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst deltaGlyphId = r.int16();\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tsubtables.push({ format: 1, coverage, deltaGlyphId });\n\t\t} else if (format === 2) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst glyphCount = r.uint16();\n\t\t\tconst typedIds = r.uint16Array(glyphCount);\n\t\t\tconst substituteGlyphIds = new Array(typedIds.length);\n\t\t\tfor (let j = 0; j < typedIds.length; j++)\n\t\t\t\tsubstituteGlyphIds[j] = typedIds[j];\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tsubtables.push({ format: 2, coverage, substituteGlyphIds });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseMultipleSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): MultipleSubstSubtable[] {\n\tconst subtables: MultipleSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst sequenceCount = r.uint16();\n\t\t\tconst sequenceOffsets = r.uint16Array(sequenceCount);\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst sequences: GlyphId[][] = [];\n\n\t\t\tfor (let j = 0; j < sequenceOffsets.length; j++) {\n\t\t\t\tconst seqOffset = sequenceOffsets[j]!;\n\t\t\t\tconst seqReader = r.sliceFrom(seqOffset);\n\t\t\t\tconst glyphCount = seqReader.uint16();\n\t\t\t\tconst typedSeq = seqReader.uint16Array(glyphCount);\n\t\t\t\tconst seq = new Array(typedSeq.length);\n\t\t\t\tfor (let k = 0; k < typedSeq.length; k++) seq[k] = typedSeq[k];\n\t\t\t\tsequences.push(seq);\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, sequences });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseAlternateSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): AlternateSubstSubtable[] {\n\tconst subtables: AlternateSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst alternateSetCount = r.uint16();\n\t\t\tconst alternateSetOffsets = r.uint16Array(alternateSetCount);\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst alternateSets: GlyphId[][] = [];\n\n\t\t\tfor (let j = 0; j < alternateSetOffsets.length; j++) {\n\t\t\t\tconst altOffset = alternateSetOffsets[j]!;\n\t\t\t\tconst altReader = r.sliceFrom(altOffset);\n\t\t\t\tconst glyphCount = altReader.uint16();\n\t\t\t\tconst typedAlts = altReader.uint16Array(glyphCount);\n\t\t\t\tconst alts = new Array(typedAlts.length);\n\t\t\t\tfor (let k = 0; k < typedAlts.length; k++) alts[k] = typedAlts[k];\n\t\t\t\talternateSets.push(alts);\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, alternateSets });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseLigatureSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): LigatureSubstSubtable[] {\n\tconst subtables: LigatureSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\t\t\tconst ligatureSetCount = r.uint16();\n\t\t\tconst ligatureSetOffsets = r.uint16Array(ligatureSetCount);\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\t\t\tconst ligatureSets: LigatureSet[] = [];\n\n\t\t\tfor (let j = 0; j < ligatureSetOffsets.length; j++) {\n\t\t\t\tconst setOffset = ligatureSetOffsets[j]!;\n\t\t\t\tconst setReader = r.sliceFrom(setOffset);\n\t\t\t\tconst ligatureCount = setReader.uint16();\n\t\t\t\tconst ligatureOffsets = setReader.uint16Array(ligatureCount);\n\n\t\t\t\tconst ligatures: Ligature[] = [];\n\t\t\t\tfor (let k = 0; k < ligatureOffsets.length; k++) {\n\t\t\t\t\tconst ligOffset = ligatureOffsets[k]!;\n\t\t\t\t\tconst ligReader = setReader.sliceFrom(ligOffset);\n\t\t\t\t\tconst ligatureGlyph = ligReader.uint16();\n\t\t\t\t\tconst componentCount = ligReader.uint16();\n\t\t\t\t\tconst typedComps = ligReader.uint16Array(componentCount - 1);\n\t\t\t\t\tconst componentGlyphIds = new Array(typedComps.length);\n\t\t\t\t\tfor (let m = 0; m < typedComps.length; m++)\n\t\t\t\t\t\tcomponentGlyphIds[m] = typedComps[m];\n\t\t\t\t\tligatures.push({ ligatureGlyph, componentGlyphIds });\n\t\t\t\t}\n\n\t\t\t\tligatureSets.push({ ligatures });\n\t\t\t}\n\n\t\t\tsubtables.push({ coverage, ligatureSets });\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseReverseChainingSingleSubst(\n\treader: Reader,\n\tsubtableOffsets: number[],\n): ReverseChainingSingleSubstSubtable[] {\n\tconst subtables: ReverseChainingSingleSubstSubtable[] = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst r = reader.sliceFrom(offset);\n\t\tconst format = r.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconst coverageOffset = r.offset16();\n\n\t\t\tconst backtrackCount = r.uint16();\n\t\t\tconst backtrackCoverageOffsets = r.uint16Array(backtrackCount);\n\n\t\t\tconst lookaheadCount = r.uint16();\n\t\t\tconst lookaheadCoverageOffsets = r.uint16Array(lookaheadCount);\n\n\t\t\tconst glyphCount = r.uint16();\n\t\t\tconst typedIds = r.uint16Array(glyphCount);\n\t\t\tconst substituteGlyphIds = new Array(typedIds.length);\n\t\t\tfor (let j = 0; j < typedIds.length; j++)\n\t\t\t\tsubstituteGlyphIds[j] = typedIds[j];\n\n\t\t\tconst coverage = parseCoverageAt(r, coverageOffset);\n\n\t\t\tconst backtrackCoverages: Coverage[] = [];\n\t\t\tfor (let j = 0; j < backtrackCoverageOffsets.length; j++) {\n\t\t\t\tconst covOffset = backtrackCoverageOffsets[j]!;\n\t\t\t\tbacktrackCoverages.push(parseCoverageAt(r, covOffset));\n\t\t\t}\n\n\t\t\tconst lookaheadCoverages: Coverage[] = [];\n\t\t\tfor (let j = 0; j < lookaheadCoverageOffsets.length; j++) {\n\t\t\t\tconst covOffset = lookaheadCoverageOffsets[j]!;\n\t\t\t\tlookaheadCoverages.push(parseCoverageAt(r, covOffset));\n\t\t\t}\n\n\t\t\tsubtables.push({\n\t\t\t\tcoverage,\n\t\t\t\tbacktrackCoverages,\n\t\t\t\tlookaheadCoverages,\n\t\t\t\tsubstituteGlyphIds,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn subtables;\n}\n\nfunction parseExtensionLookup(\n\treader: Reader,\n\tsubtableOffsets: number[],\n\tbaseProps: { flag: uint16; markFilteringSet?: uint16 },\n): AnyGsubLookup | null {\n\tif (subtableOffsets.length === 0) return null;\n\n\t// Parse all extension subtables\n\tconst extSubtables: Array<{ type: number; reader: Reader }> = [];\n\n\tfor (let i = 0; i < subtableOffsets.length; i++) {\n\t\tconst offset = subtableOffsets[i]!;\n\t\tconst extReader = reader.sliceFrom(offset);\n\t\tconst format = extReader.uint16();\n\t\tif (format !== 1) continue;\n\n\t\tconst extensionLookupType = extReader.uint16();\n\t\tconst extensionOffset = extReader.uint32();\n\n\t\t// extensionOffset is relative to start of extension subtable\n\t\textSubtables.push({\n\t\t\ttype: extensionLookupType,\n\t\t\treader: extReader.sliceFrom(extensionOffset),\n\t\t});\n\t}\n\n\tif (extSubtables.length === 0) return null;\n\n\tconst actualType = extSubtables[0]?.type;\n\tconst _actualOffsets = extSubtables.map((_, _i) => 0); // All at offset 0 of their readers\n\n\t// Helper to build digest from subtables with coverage\n\tconst buildDigest = (subtables: { coverage: Coverage }[]): SetDigest => {\n\t\tconst digest = new SetDigest();\n\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\tconst st = subtables[i]!;\n\t\t\tdigest.addCoverage(st.coverage);\n\t\t}\n\t\treturn digest;\n\t};\n\n\t// Create a combined reader for all subtables\n\tswitch (actualType) {\n\t\tcase GsubLookupType.Single: {\n\t\t\tconst subtables: SingleSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseSingleSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Single,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Multiple: {\n\t\t\tconst subtables: MultipleSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseMultipleSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Multiple,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Alternate: {\n\t\t\tconst subtables: AlternateSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseAlternateSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Alternate,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Ligature: {\n\t\t\tconst subtables: LigatureSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseLigatureSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.Ligature,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.Context: {\n\t\t\tconst subtables: ContextSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseContextSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { type: GsubLookupType.Context, ...baseProps, subtables, digest };\n\t\t}\n\n\t\tcase GsubLookupType.ChainingContext: {\n\t\t\tconst subtables: ChainingContextSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseChainingContextSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\tconst digest = new SetDigest();\n\t\t\tfor (let i = 0; i < subtables.length; i++) {\n\t\t\t\tconst st = subtables[i]!;\n\t\t\t\tif (\"coverage\" in st && st.coverage) {\n\t\t\t\t\tdigest.addCoverage(st.coverage);\n\t\t\t\t} else if (\"inputCoverages\" in st && st.inputCoverages?.[0]) {\n\t\t\t\t\tdigest.addCoverage(st.inputCoverages[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ChainingContext,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest,\n\t\t\t};\n\t\t}\n\n\t\tcase GsubLookupType.ReverseChainingSingle: {\n\t\t\tconst subtables: ReverseChainingSingleSubstSubtable[] = [];\n\t\t\tfor (let i = 0; i < extSubtables.length; i++) {\n\t\t\t\tconst ext = extSubtables[i]!;\n\t\t\t\tsubtables.push(...parseReverseChainingSingleSubst(ext.reader, [0]));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: GsubLookupType.ReverseChainingSingle,\n\t\t\t\t...baseProps,\n\t\t\t\tsubtables,\n\t\t\t\tdigest: buildDigest(subtables),\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n// Utility functions for applying lookups\n\nexport function applySingleSubst(\n\tlookup: SingleSubstLookup,\n\tglyphId: GlyphId,\n): GlyphId | null {\n\tfor (let i = 0; i < lookup.subtables.length; i++) {\n\t\tconst subtable = lookup.subtables[i]!;\n\t\tconst coverageIndex = subtable.coverage.get(glyphId);\n\t\tif (coverageIndex === null) continue;\n\n\t\tif (subtable.format === 1 && subtable.deltaGlyphId !== undefined) {\n\t\t\treturn (glyphId + subtable.deltaGlyphId) & 0xffff;\n\t\t}\n\n\t\tif (subtable.format === 2 && subtable.substituteGlyphIds) {\n\t\t\treturn subtable.substituteGlyphIds[coverageIndex] ?? null;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function applyLigatureSubst(\n\tlookup: LigatureSubstLookup,\n\tglyphIds: GlyphId[],\n\tstartIndex: number,\n): { ligatureGlyph: GlyphId; consumed: number } | null {\n\tconst firstGlyph = glyphIds[startIndex];\n\tif (firstGlyph === undefined) return null;\n\n\tfor (let i = 0; i < lookup.subtables.length; i++) {\n\t\tconst subtable = lookup.subtables[i]!;\n\t\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\t\tif (coverageIndex === null) continue;\n\n\t\tconst ligatureSet = subtable.ligatureSets[coverageIndex];\n\t\tif (!ligatureSet) continue;\n\n\t\tfor (let j = 0; j < ligatureSet.ligatures.length; j++) {\n\t\t\tconst ligature = ligatureSet.ligatures[j]!;\n\t\t\tconst componentCount = ligature.componentGlyphIds.length;\n\n\t\t\tif (startIndex + 1 + componentCount > glyphIds.length) continue;\n\n\t\t\tlet matches = true;\n\t\t\tfor (let k = 0; k < componentCount; k++) {\n\t\t\t\tif (glyphIds[startIndex + 1 + k] !== ligature.componentGlyphIds[k]) {\n\t\t\t\t\tmatches = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matches) {\n\t\t\t\treturn {\n\t\t\t\t\tligatureGlyph: ligature.ligatureGlyph,\n\t\t\t\t\tconsumed: 1 + componentCount,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Apply ligature substitution using a Uint16Array directly (avoids Array.from allocation).\n * glyphIds is a pre-allocated typed array, matchLen is the valid length to consider.\n */\nexport function applyLigatureSubstDirect(\n\tlookup: LigatureSubstLookup,\n\tglyphIds: Uint16Array,\n\tmatchLen: number,\n\tstartIndex: number,\n): { ligatureGlyph: GlyphId; consumed: number } | null {\n\tconst firstGlyph = glyphIds[startIndex];\n\tif (firstGlyph === undefined) return null;\n\n\tfor (let i = 0; i < lookup.subtables.length; i++) {\n\t\tconst subtable = lookup.subtables[i]!;\n\t\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\t\tif (coverageIndex === null) continue;\n\n\t\tconst ligatureSet = subtable.ligatureSets[coverageIndex];\n\t\tif (!ligatureSet) continue;\n\n\t\tfor (let j = 0; j < ligatureSet.ligatures.length; j++) {\n\t\t\tconst ligature = ligatureSet.ligatures[j]!;\n\t\t\tconst componentCount = ligature.componentGlyphIds.length;\n\n\t\t\tif (startIndex + 1 + componentCount > matchLen) continue;\n\n\t\t\tlet matches = true;\n\t\t\tfor (let k = 0; k < componentCount; k++) {\n\t\t\t\tif (glyphIds[startIndex + 1 + k] !== ligature.componentGlyphIds[k]) {\n\t\t\t\t\tmatches = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matches) {\n\t\t\t\treturn {\n\t\t\t\t\tligatureGlyph: ligature.ligatureGlyph,\n\t\t\t\t\tconsumed: 1 + componentCount,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Export internal functions for testing\nexport const __testing = {\n\tparseGsubLookup,\n\tparseExtensionLookup,\n};\n",
    "import type { Fixed, FWord, int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\nconst HEAD_MAGIC_NUMBER = 0x5f0f3cf5;\n\n/** Font header table */\nexport interface HeadTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tfontRevision: Fixed;\n\tchecksumAdjustment: uint32;\n\tmagicNumber: uint32;\n\tflags: uint16;\n\tunitsPerEm: uint16;\n\tcreated: bigint;\n\tmodified: bigint;\n\txMin: FWord;\n\tyMin: FWord;\n\txMax: FWord;\n\tyMax: FWord;\n\tmacStyle: uint16;\n\tlowestRecPPEM: uint16;\n\tfontDirectionHint: int16;\n\t/** 0 = short offsets (uint16), 1 = long offsets (uint32) in loca table */\n\tindexToLocFormat: int16;\n\tglyphDataFormat: int16;\n}\n\n/** Head table flags */\nexport const HeadFlags = {\n\tBaselineAtY0: 0x0001,\n\tLeftSidebearingAtX0: 0x0002,\n\tInstructionsDependOnPointSize: 0x0004,\n\tForcePPEMToInteger: 0x0008,\n\tInstructionsAlterAdvanceWidth: 0x0010,\n\tLossless: 0x0800,\n\tConverted: 0x1000,\n\tOptimizedForClearType: 0x2000,\n\tLastResortFont: 0x4000,\n} as const;\n\n/** Mac style flags */\nexport const MacStyle = {\n\tBold: 0x0001,\n\tItalic: 0x0002,\n\tUnderline: 0x0004,\n\tOutline: 0x0008,\n\tShadow: 0x0010,\n\tCondensed: 0x0020,\n\tExtended: 0x0040,\n} as const;\n\n/**\n * Parse head table - font header with global metrics\n * @param reader - Reader positioned at start of head table\n * @returns Parsed head table\n */\nexport function parseHead(reader: Reader): HeadTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst fontRevision = reader.fixed();\n\tconst checksumAdjustment = reader.uint32();\n\tconst magicNumber = reader.uint32();\n\n\tif (magicNumber !== HEAD_MAGIC_NUMBER) {\n\t\tthrow new Error(\n\t\t\t`Invalid head table magic number: 0x${magicNumber.toString(16)}`,\n\t\t);\n\t}\n\n\tconst flags = reader.uint16();\n\tconst unitsPerEm = reader.uint16();\n\tconst created = reader.longDateTime();\n\tconst modified = reader.longDateTime();\n\tconst xMin = reader.fword();\n\tconst yMin = reader.fword();\n\tconst xMax = reader.fword();\n\tconst yMax = reader.fword();\n\tconst macStyle = reader.uint16();\n\tconst lowestRecPPEM = reader.uint16();\n\tconst fontDirectionHint = reader.int16();\n\tconst indexToLocFormat = reader.int16();\n\tconst glyphDataFormat = reader.int16();\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tfontRevision,\n\t\tchecksumAdjustment,\n\t\tmagicNumber,\n\t\tflags,\n\t\tunitsPerEm,\n\t\tcreated,\n\t\tmodified,\n\t\txMin,\n\t\tyMin,\n\t\txMax,\n\t\tyMax,\n\t\tmacStyle,\n\t\tlowestRecPPEM,\n\t\tfontDirectionHint,\n\t\tindexToLocFormat,\n\t\tglyphDataFormat,\n\t};\n}\n",
    "import type { FWord, int16, UFWord, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Horizontal header table */\nexport interface HheaTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tascender: FWord;\n\tdescender: FWord;\n\tlineGap: FWord;\n\tadvanceWidthMax: UFWord;\n\tminLeftSideBearing: FWord;\n\tminRightSideBearing: FWord;\n\txMaxExtent: FWord;\n\tcaretSlopeRise: int16;\n\tcaretSlopeRun: int16;\n\tcaretOffset: int16;\n\treserved1: int16;\n\treserved2: int16;\n\treserved3: int16;\n\treserved4: int16;\n\tmetricDataFormat: int16;\n\tnumberOfHMetrics: uint16;\n}\n\n/**\n * Parse hhea table - horizontal header with metrics for horizontal layout\n * @param reader - Reader positioned at start of hhea table\n * @returns Parsed hhea table\n */\nexport function parseHhea(reader: Reader): HheaTable {\n\treturn {\n\t\tmajorVersion: reader.uint16(),\n\t\tminorVersion: reader.uint16(),\n\t\tascender: reader.fword(),\n\t\tdescender: reader.fword(),\n\t\tlineGap: reader.fword(),\n\t\tadvanceWidthMax: reader.ufword(),\n\t\tminLeftSideBearing: reader.fword(),\n\t\tminRightSideBearing: reader.fword(),\n\t\txMaxExtent: reader.fword(),\n\t\tcaretSlopeRise: reader.int16(),\n\t\tcaretSlopeRun: reader.int16(),\n\t\tcaretOffset: reader.int16(),\n\t\treserved1: reader.int16(),\n\t\treserved2: reader.int16(),\n\t\treserved3: reader.int16(),\n\t\treserved4: reader.int16(),\n\t\tmetricDataFormat: reader.int16(),\n\t\tnumberOfHMetrics: reader.uint16(),\n\t};\n}\n",
    "import type { Reader } from \"../binary/reader.ts\";\n\n/**\n * fpgm table - Font program\n * Contains TrueType instructions to be executed once when the font is loaded\n */\nexport interface FpgmTable {\n\t/** Raw bytecode instructions */\n\tinstructions: Uint8Array;\n}\n\n/**\n * prep table - CVT program (Control Value Program)\n * Contains TrueType instructions executed whenever the font size or transformation changes\n */\nexport interface PrepTable {\n\t/** Raw bytecode instructions */\n\tinstructions: Uint8Array;\n}\n\n/**\n * cvt table - Control Value Table\n * Contains values referenced by TrueType instructions for consistent spacing/positioning\n * Values are in FUnits (font design units)\n */\nexport interface CvtTable {\n\t/** Control values (FWORD, i.e., int16 in font units) */\n\tvalues: Int16Array;\n}\n\n/**\n * Parse fpgm table\n */\nexport function parseFpgm(reader: Reader): FpgmTable {\n\tconst instructions = reader.bytes(reader.remaining);\n\treturn { instructions };\n}\n\n/**\n * Parse prep table\n */\nexport function parsePrep(reader: Reader): PrepTable {\n\tconst instructions = reader.bytes(reader.remaining);\n\treturn { instructions };\n}\n\n/**\n * Parse cvt table\n */\nexport function parseCvt(reader: Reader): CvtTable {\n\tconst count = Math.floor(reader.remaining / 2);\n\tconst values = new Int16Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tvalues[i] = reader.int16();\n\t}\n\treturn { values };\n}\n",
    "import type { FWord, GlyphId, UFWord } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Horizontal metric for a glyph */\nexport interface LongHorMetric {\n\tadvanceWidth: UFWord;\n\tlsb: FWord; // left side bearing\n}\n\n/** Horizontal metrics table */\nexport interface HmtxTable {\n\thMetrics: LongHorMetric[];\n\tleftSideBearings: FWord[];\n}\n\n/**\n * Parse hmtx table.\n * @param reader - Reader positioned at hmtx table start\n * @param numberOfHMetrics - From hhea table\n * @param numGlyphs - From maxp table\n */\nexport function parseHmtx(\n\treader: Reader,\n\tnumberOfHMetrics: number,\n\tnumGlyphs: number,\n): HmtxTable {\n\t// Read full metrics (advanceWidth + lsb)\n\tconst hMetrics: LongHorMetric[] = new Array(numberOfHMetrics);\n\tfor (let i = 0; i < numberOfHMetrics; i++) {\n\t\thMetrics[i] = {\n\t\t\tadvanceWidth: reader.ufword(),\n\t\t\tlsb: reader.fword(),\n\t\t};\n\t}\n\n\t// Remaining glyphs share the last advanceWidth, only store lsb\n\tconst numLeftSideBearings = numGlyphs - numberOfHMetrics;\n\tconst leftSideBearings: FWord[] = new Array(numLeftSideBearings);\n\tfor (let i = 0; i < numLeftSideBearings; i++) {\n\t\tleftSideBearings[i] = reader.fword();\n\t}\n\n\treturn { hMetrics, leftSideBearings };\n}\n\n/** Get advance width for a glyph */\nexport function getAdvanceWidth(hmtx: HmtxTable, glyphId: GlyphId): number {\n\tif (glyphId < hmtx.hMetrics.length) {\n\t\treturn hmtx.hMetrics[glyphId]?.advanceWidth;\n\t}\n\t// Use last advanceWidth for remaining glyphs\n\treturn hmtx.hMetrics[hmtx.hMetrics.length - 1]?.advanceWidth;\n}\n\n/** Get left side bearing for a glyph */\nexport function getLeftSideBearing(hmtx: HmtxTable, glyphId: GlyphId): number {\n\tif (glyphId < hmtx.hMetrics.length) {\n\t\treturn hmtx.hMetrics[glyphId]?.lsb;\n\t}\n\tconst idx = glyphId - hmtx.hMetrics.length;\n\treturn hmtx.leftSideBearings[idx] ?? 0;\n}\n",
    "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * JSTF table - Justification data\n * Provides justification alternatives for scripts\n */\n\n/** Justification priority levels */\nexport const JstfPriority = {\n\t/** Shrink GPOS lookups */\n\tShrinkGpos: 0,\n\t/** Disable GPOS lookups */\n\tDisableGpos: 1,\n\t/** Shrink GSUB lookups */\n\tShrinkGsub: 2,\n\t/** Disable GSUB lookups */\n\tDisableGsub: 3,\n\t/** Enable GPOS lookups */\n\tEnableGpos: 4,\n\t/** Enable GSUB lookups */\n\tEnableGsub: 5,\n\t/** Max extension GPOS lookups */\n\tMaxExtendGpos: 6,\n\t/** Max extension GSUB lookups */\n\tMaxExtendGsub: 7,\n} as const;\n\n/** JstfMax table - lookup indices for maximum extension */\nexport interface JstfMax {\n\tlookupIndices: uint16[];\n}\n\n/** JstfModList - enable/disable lookup list */\nexport interface JstfModList {\n\tlookupIndices: uint16[];\n}\n\n/** Justification priority record */\nexport interface JstfPriorityRecord {\n\t/** GSUB lookups to enable for shrinkage */\n\tshrinkageEnableGsub: JstfModList | null;\n\t/** GSUB lookups to disable for shrinkage */\n\tshrinkageDisableGsub: JstfModList | null;\n\t/** GPOS lookups to enable for shrinkage */\n\tshrinkageEnableGpos: JstfModList | null;\n\t/** GPOS lookups to disable for shrinkage */\n\tshrinkageDisableGpos: JstfModList | null;\n\t/** Maximum shrinkage GSUB */\n\tshrinkageJstfMax: JstfMax | null;\n\t/** GSUB lookups to enable for extension */\n\textensionEnableGsub: JstfModList | null;\n\t/** GSUB lookups to disable for extension */\n\textensionDisableGsub: JstfModList | null;\n\t/** GPOS lookups to enable for extension */\n\textensionEnableGpos: JstfModList | null;\n\t/** GPOS lookups to disable for extension */\n\textensionDisableGpos: JstfModList | null;\n\t/** Maximum extension GSUB */\n\textensionJstfMax: JstfMax | null;\n}\n\n/** Justification language system */\nexport interface JstfLangSys {\n\tpriorities: JstfPriorityRecord[];\n}\n\n/** Justification script record */\nexport interface JstfScriptRecord {\n\tscriptTag: number;\n\t/** Extender glyphs for Kashida-like justification */\n\textenderGlyphs: uint16[];\n\t/** Default language system */\n\tdefaultLangSys: JstfLangSys | null;\n\t/** Language-specific systems */\n\tlangSysRecords: Map<number, JstfLangSys>;\n}\n\n/** JSTF table */\nexport interface JstfTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tscripts: JstfScriptRecord[];\n}\n\nfunction parseJstfModList(reader: Reader, offset: number): JstfModList | null {\n\tif (offset === 0) return null;\n\n\tconst modReader = reader.sliceFrom(offset);\n\tconst lookupCount = modReader.uint16();\n\tconst lookupIndices: uint16[] = [];\n\n\tfor (let i = 0; i < lookupCount; i++) {\n\t\tlookupIndices.push(modReader.uint16());\n\t}\n\n\treturn { lookupIndices };\n}\n\nfunction parseJstfMax(reader: Reader, offset: number): JstfMax | null {\n\tif (offset === 0) return null;\n\n\tconst maxReader = reader.sliceFrom(offset);\n\tconst lookupCount = maxReader.uint16();\n\tconst lookupIndices: uint16[] = [];\n\n\tfor (let i = 0; i < lookupCount; i++) {\n\t\tlookupIndices.push(maxReader.uint16());\n\t}\n\n\treturn { lookupIndices };\n}\n\nfunction parseJstfPriority(reader: Reader, offset: number): JstfPriorityRecord {\n\tconst priReader = reader.sliceFrom(offset);\n\n\tconst shrinkageEnableGsubOffset = priReader.uint16();\n\tconst shrinkageDisableGsubOffset = priReader.uint16();\n\tconst shrinkageEnableGposOffset = priReader.uint16();\n\tconst shrinkageDisableGposOffset = priReader.uint16();\n\tconst shrinkageJstfMaxOffset = priReader.uint16();\n\tconst extensionEnableGsubOffset = priReader.uint16();\n\tconst extensionDisableGsubOffset = priReader.uint16();\n\tconst extensionEnableGposOffset = priReader.uint16();\n\tconst extensionDisableGposOffset = priReader.uint16();\n\tconst extensionJstfMaxOffset = priReader.uint16();\n\n\treturn {\n\t\tshrinkageEnableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageEnableGsubOffset,\n\t\t),\n\t\tshrinkageDisableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageDisableGsubOffset,\n\t\t),\n\t\tshrinkageEnableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageEnableGposOffset,\n\t\t),\n\t\tshrinkageDisableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + shrinkageDisableGposOffset,\n\t\t),\n\t\tshrinkageJstfMax: parseJstfMax(reader, offset + shrinkageJstfMaxOffset),\n\t\textensionEnableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionEnableGsubOffset,\n\t\t),\n\t\textensionDisableGsub: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionDisableGsubOffset,\n\t\t),\n\t\textensionEnableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionEnableGposOffset,\n\t\t),\n\t\textensionDisableGpos: parseJstfModList(\n\t\t\treader,\n\t\t\toffset + extensionDisableGposOffset,\n\t\t),\n\t\textensionJstfMax: parseJstfMax(reader, offset + extensionJstfMaxOffset),\n\t};\n}\n\nfunction parseJstfLangSys(reader: Reader, offset: number): JstfLangSys {\n\tconst langReader = reader.sliceFrom(offset);\n\tconst jstfPriorityCount = langReader.uint16();\n\n\tconst priorityOffsets: uint16[] = [];\n\tfor (let i = 0; i < jstfPriorityCount; i++) {\n\t\tpriorityOffsets.push(langReader.uint16());\n\t}\n\n\tconst priorities: JstfPriorityRecord[] = [];\n\tfor (let i = 0; i < priorityOffsets.length; i++) {\n\t\tconst priOffset = priorityOffsets[i]!;\n\t\tpriorities.push(parseJstfPriority(reader, offset + priOffset));\n\t}\n\n\treturn { priorities };\n}\n\nfunction parseJstfScript(\n\treader: Reader,\n\toffset: number,\n): Omit<JstfScriptRecord, \"scriptTag\"> {\n\tconst scriptReader = reader.sliceFrom(offset);\n\tconst extenderGlyphOffset = scriptReader.uint16();\n\tconst defJstfLangSysOffset = scriptReader.uint16();\n\tconst jstfLangSysCount = scriptReader.uint16();\n\n\t// Parse language system records\n\tconst langSysData: Array<{ tag: number; offset: number }> = [];\n\tfor (let i = 0; i < jstfLangSysCount; i++) {\n\t\tconst tag = scriptReader.uint32();\n\t\tconst langOffset = scriptReader.uint16();\n\t\tlangSysData.push({ tag, offset: langOffset });\n\t}\n\n\t// Parse extender glyphs\n\tconst extenderGlyphs: uint16[] = [];\n\tif (extenderGlyphOffset !== 0) {\n\t\tconst extReader = reader.sliceFrom(offset + extenderGlyphOffset);\n\t\tconst glyphCount = extReader.uint16();\n\t\tfor (let i = 0; i < glyphCount; i++) {\n\t\t\textenderGlyphs.push(extReader.uint16());\n\t\t}\n\t}\n\n\t// Parse default lang sys\n\tconst defaultLangSys =\n\t\tdefJstfLangSysOffset !== 0\n\t\t\t? parseJstfLangSys(reader, offset + defJstfLangSysOffset)\n\t\t\t: null;\n\n\t// Parse language-specific systems\n\tconst langSysRecords = new Map<number, JstfLangSys>();\n\tfor (let i = 0; i < langSysData.length; i++) {\n\t\tconst { tag, offset: langOffset } = langSysData[i]!;\n\t\tlangSysRecords.set(tag, parseJstfLangSys(reader, offset + langOffset));\n\t}\n\n\treturn { extenderGlyphs, defaultLangSys, langSysRecords };\n}\n\nexport function parseJstf(reader: Reader): JstfTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst jstfScriptCount = reader.uint16();\n\n\t// Read script record offsets\n\tconst scriptData: Array<{ tag: number; offset: number }> = [];\n\tfor (let i = 0; i < jstfScriptCount; i++) {\n\t\tconst tag = reader.uint32();\n\t\tconst offset = reader.uint16();\n\t\tscriptData.push({ tag, offset });\n\t}\n\n\t// Parse scripts\n\tconst scripts: JstfScriptRecord[] = [];\n\tfor (let i = 0; i < scriptData.length; i++) {\n\t\tconst { tag, offset } = scriptData[i]!;\n\t\tconst script = parseJstfScript(reader, offset);\n\t\tscripts.push({ scriptTag: tag, ...script });\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tscripts,\n\t};\n}\n\n/** Get extender glyphs for a script (e.g., Kashida for Arabic) */\nexport function getExtenderGlyphs(\n\tjstf: JstfTable,\n\tscriptTag: number,\n): uint16[] {\n\tconst script = jstf.scripts.find((s) => s.scriptTag === scriptTag);\n\treturn script?.extenderGlyphs ?? [];\n}\n\n/** Get justification priorities for a script/language */\nexport function getJstfPriorities(\n\tjstf: JstfTable,\n\tscriptTag: number,\n\tlanguageTag?: number,\n): JstfPriorityRecord[] {\n\tconst script = jstf.scripts.find((s) => s.scriptTag === scriptTag);\n\tif (!script) return [];\n\n\t// Try language-specific first\n\tif (languageTag !== undefined) {\n\t\tconst langSys = script.langSysRecords.get(languageTag);\n\t\tif (langSys) return langSys.priorities;\n\t}\n\n\t// Fall back to default\n\treturn script.defaultLangSys?.priorities ?? [];\n}\n\n/** Get lookup modifications for shrinkage at a given priority level */\nexport function getShrinkageMods(priority: JstfPriorityRecord): {\n\tenableGsub: uint16[];\n\tdisableGsub: uint16[];\n\tenableGpos: uint16[];\n\tdisableGpos: uint16[];\n\tmaxLookups: uint16[];\n} {\n\treturn {\n\t\tenableGsub: priority.shrinkageEnableGsub?.lookupIndices ?? [],\n\t\tdisableGsub: priority.shrinkageDisableGsub?.lookupIndices ?? [],\n\t\tenableGpos: priority.shrinkageEnableGpos?.lookupIndices ?? [],\n\t\tdisableGpos: priority.shrinkageDisableGpos?.lookupIndices ?? [],\n\t\tmaxLookups: priority.shrinkageJstfMax?.lookupIndices ?? [],\n\t};\n}\n\n/** Get lookup modifications for extension at a given priority level */\nexport function getExtensionMods(priority: JstfPriorityRecord): {\n\tenableGsub: uint16[];\n\tdisableGsub: uint16[];\n\tenableGpos: uint16[];\n\tdisableGpos: uint16[];\n\tmaxLookups: uint16[];\n} {\n\treturn {\n\t\tenableGsub: priority.extensionEnableGsub?.lookupIndices ?? [],\n\t\tdisableGsub: priority.extensionDisableGsub?.lookupIndices ?? [],\n\t\tenableGpos: priority.extensionEnableGpos?.lookupIndices ?? [],\n\t\tdisableGpos: priority.extensionDisableGpos?.lookupIndices ?? [],\n\t\tmaxLookups: priority.extensionJstfMax?.lookupIndices ?? [],\n\t};\n}\n",
    "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Legacy kern table for kerning pairs\n * Used when GPOS kerning is not available\n */\nexport interface KernTable {\n\tversion: number;\n\tsubtables: KernSubtable[];\n}\n\nexport type KernSubtable = KernFormat0 | KernFormat2;\n\n/**\n * Format 0: Ordered list of kerning pairs\n */\nexport interface KernFormat0 {\n\tformat: 0;\n\tcoverage: KernCoverage;\n\tpairs: Map<number, int16>; // key = (left << 16) | right, value = kerning\n}\n\n/**\n * Format 2: Class-based kerning (two-dimensional array)\n */\nexport interface KernFormat2 {\n\tformat: 2;\n\tcoverage: KernCoverage;\n\trowWidth: uint16;\n\tleftClassTable: Map<GlyphId, uint16>;\n\trightClassTable: Map<GlyphId, uint16>;\n\tkerningValues: int16[][];\n}\n\nexport interface KernCoverage {\n\thorizontal: boolean;\n\tminimum: boolean;\n\tcrossStream: boolean;\n\toverride: boolean;\n}\n\n/**\n * Parse kern table\n */\nexport function parseKern(reader: Reader): KernTable {\n\tconst version = reader.uint16();\n\tconst subtables: KernSubtable[] = [];\n\n\tif (version === 0) {\n\t\t// Microsoft format\n\t\tconst nTables = reader.uint16();\n\t\tfor (let i = 0; i < nTables; i++) {\n\t\t\tconst subtable = parseKernSubtable(reader);\n\t\t\tif (subtable) subtables.push(subtable);\n\t\t}\n\t} else if (version === 1) {\n\t\t// Apple format (version is actually 0x00010000)\n\t\treader.skip(2); // Skip rest of version\n\t\tconst nTables = reader.uint32();\n\t\tfor (let i = 0; i < nTables; i++) {\n\t\t\tconst subtable = parseAppleKernSubtable(reader);\n\t\t\tif (subtable) subtables.push(subtable);\n\t\t}\n\t}\n\n\treturn { version, subtables };\n}\n\nfunction parseKernSubtable(reader: Reader): KernSubtable | null {\n\tconst _version = reader.uint16();\n\tconst length = reader.uint16();\n\tconst coverageBits = reader.uint16();\n\n\tconst coverage: KernCoverage = {\n\t\thorizontal: (coverageBits & 0x0001) !== 0,\n\t\tminimum: (coverageBits & 0x0002) !== 0,\n\t\tcrossStream: (coverageBits & 0x0004) !== 0,\n\t\toverride: (coverageBits & 0x0008) !== 0,\n\t};\n\n\tconst format = (coverageBits >> 8) & 0xff;\n\n\tif (format === 0) {\n\t\treturn parseKernFormat0(reader, coverage);\n\t} else if (format === 2) {\n\t\treturn parseKernFormat2(reader, coverage, length - 6);\n\t}\n\n\t// Skip unknown format\n\treader.skip(length - 6);\n\treturn null;\n}\n\nfunction parseAppleKernSubtable(reader: Reader): KernSubtable | null {\n\tconst length = reader.uint32();\n\tconst coverageBits = reader.uint16();\n\tconst _tupleIndex = reader.uint16();\n\n\tconst coverage: KernCoverage = {\n\t\thorizontal: (coverageBits & 0x8000) === 0, // bit 15: 0=horizontal\n\t\tminimum: false,\n\t\tcrossStream: (coverageBits & 0x4000) !== 0,\n\t\toverride: (coverageBits & 0x2000) !== 0,\n\t};\n\n\tconst format = coverageBits & 0x00ff;\n\n\tif (format === 0) {\n\t\treturn parseKernFormat0(reader, coverage);\n\t} else if (format === 2) {\n\t\treturn parseKernFormat2(reader, coverage, length - 8);\n\t}\n\n\t// Skip unknown format\n\treader.skip(length - 8);\n\treturn null;\n}\n\nfunction parseKernFormat0(reader: Reader, coverage: KernCoverage): KernFormat0 {\n\tconst nPairs = reader.uint16();\n\treader.skip(6); // searchRange, entrySelector, rangeShift\n\n\tconst pairs = new Map<number, int16>();\n\n\tfor (let i = 0; i < nPairs; i++) {\n\t\tconst left = reader.uint16();\n\t\tconst right = reader.uint16();\n\t\tconst value = reader.int16();\n\t\tconst key = (left << 16) | right;\n\t\tpairs.set(key, value);\n\t}\n\n\treturn { format: 0, coverage, pairs };\n}\n\nfunction parseKernFormat2(\n\treader: Reader,\n\tcoverage: KernCoverage,\n\tdataLength: number,\n): KernFormat2 {\n\tconst startOffset = reader.offset;\n\tconst rowWidth = reader.uint16();\n\tconst leftClassOffset = reader.uint16();\n\tconst rightClassOffset = reader.uint16();\n\tconst arrayOffset = reader.uint16();\n\n\t// Parse left class table\n\tconst leftClassTable = new Map<GlyphId, uint16>();\n\treader.seek(startOffset + leftClassOffset);\n\tconst leftFirstGlyph = reader.uint16();\n\tconst leftNGlyphs = reader.uint16();\n\tfor (let i = 0; i < leftNGlyphs; i++) {\n\t\tconst classValue = reader.uint16();\n\t\tif (classValue !== 0) {\n\t\t\tleftClassTable.set(leftFirstGlyph + i, classValue);\n\t\t}\n\t}\n\n\t// Parse right class table\n\tconst rightClassTable = new Map<GlyphId, uint16>();\n\treader.seek(startOffset + rightClassOffset);\n\tconst rightFirstGlyph = reader.uint16();\n\tconst rightNGlyphs = reader.uint16();\n\tfor (let i = 0; i < rightNGlyphs; i++) {\n\t\tconst classValue = reader.uint16();\n\t\tif (classValue !== 0) {\n\t\t\trightClassTable.set(rightFirstGlyph + i, classValue);\n\t\t}\n\t}\n\n\t// Parse kerning array\n\treader.seek(startOffset + arrayOffset);\n\tconst numRows = rowWidth > 0 ? Math.floor(dataLength / rowWidth) : 0;\n\tconst numCols = rowWidth / 2;\n\tconst kerningValues: int16[][] = [];\n\n\tfor (let row = 0; row < numRows; row++) {\n\t\tconst rowValues: int16[] = [];\n\t\tfor (let col = 0; col < numCols; col++) {\n\t\t\trowValues.push(reader.int16());\n\t\t}\n\t\tkerningValues.push(rowValues);\n\t}\n\n\treturn {\n\t\tformat: 2,\n\t\tcoverage,\n\t\trowWidth,\n\t\tleftClassTable,\n\t\trightClassTable,\n\t\tkerningValues,\n\t};\n}\n\n/**\n * Get kerning value from kern table\n */\nexport function getKernValue(\n\tkern: KernTable,\n\tleft: GlyphId,\n\tright: GlyphId,\n): number {\n\tlet total = 0;\n\n\tfor (let i = 0; i < kern.subtables.length; i++) {\n\t\tconst subtable = kern.subtables[i]!;\n\t\tif (!subtable.coverage.horizontal) continue; // Only horizontal for now\n\n\t\tif (subtable.format === 0) {\n\t\t\tconst key = (left << 16) | right;\n\t\t\tconst value = subtable.pairs.get(key);\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (subtable.coverage.override) {\n\t\t\t\t\ttotal = value;\n\t\t\t\t} else {\n\t\t\t\t\ttotal += value;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (subtable.format === 2) {\n\t\t\tconst leftClass = subtable.leftClassTable.get(left) ?? 0;\n\t\t\tconst rightClass = subtable.rightClassTable.get(right) ?? 0;\n\n\t\t\tif (leftClass > 0 && rightClass > 0) {\n\t\t\t\tconst rowIndex = Math.floor(leftClass / 2);\n\t\t\t\tconst colIndex = Math.floor(rightClass / 2);\n\t\t\t\tconst row = subtable.kerningValues[rowIndex];\n\t\t\t\tif (row) {\n\t\t\t\t\tconst value = row[colIndex];\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tif (subtable.coverage.override) {\n\t\t\t\t\t\t\ttotal = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttotal += value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn total;\n}\n",
    "import type { GlyphId, int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Extended Kerning table (kerx)\n * Apple Advanced Typography kerning\n */\nexport interface KerxTable {\n\tversion: uint16;\n\tnTables: uint32;\n\tsubtables: KerxSubtable[];\n}\n\n/**\n * kerx subtable types\n */\nexport enum KerxSubtableType {\n\tOrderedList = 0,\n\tStateTable = 1,\n\tSimpleArray = 2,\n\tControlPoint = 4,\n\tFormat6 = 6,\n}\n\n/**\n * Coverage flags\n */\nexport interface KerxCoverage {\n\tvertical: boolean;\n\tcrossStream: boolean;\n\tvariation: boolean;\n}\n\n/**\n * Base subtable\n */\nexport interface KerxSubtableBase {\n\tlength: uint32;\n\tcoverage: KerxCoverage;\n\ttupleCount: uint16;\n}\n\nexport type KerxSubtable =\n\t| KerxOrderedListSubtable\n\t| KerxStateTableSubtable\n\t| KerxSimpleArraySubtable\n\t| KerxControlPointSubtable\n\t| KerxFormat6Subtable;\n\n/**\n * Format 0: Ordered list of kerning pairs\n */\nexport interface KerxOrderedListSubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.OrderedList;\n\tnPairs: uint32;\n\tpairs: KerxPair[];\n}\n\nexport interface KerxPair {\n\tleft: GlyphId;\n\tright: GlyphId;\n\tvalue: int16;\n}\n\n/**\n * Format 1: State table\n */\nexport interface KerxStateTableSubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.StateTable;\n\tstateHeader: KerxStateHeader;\n\t// State machine data\n}\n\nexport interface KerxStateHeader {\n\tnClasses: uint32;\n\tclassTableOffset: uint32;\n\tstateArrayOffset: uint32;\n\tentryTableOffset: uint32;\n\tvalueTableOffset: uint32;\n}\n\n/**\n * Format 2: Simple array\n */\nexport interface KerxSimpleArraySubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.SimpleArray;\n\trowWidth: uint16;\n\tleftClassTable: KerxClassTable;\n\trightClassTable: KerxClassTable;\n\tkerningArray: Int16Array;\n}\n\nexport interface KerxClassTable {\n\tfirstGlyph: GlyphId;\n\tnGlyphs: uint16;\n\tclasses: Uint8Array;\n}\n\n/**\n * Format 4: Control point actions\n */\nexport interface KerxControlPointSubtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.ControlPoint;\n\tflags: uint32;\n\t// Control point data\n}\n\n/**\n * Format 6: Extended kerning pairs\n */\nexport interface KerxFormat6Subtable extends KerxSubtableBase {\n\tformat: KerxSubtableType.Format6;\n\tflags: uint32;\n\trowCount: uint16;\n\tcolumnCount: uint16;\n\trowIndexTableOffset: uint32;\n\tcolumnIndexTableOffset: uint32;\n\tkerningArrayOffset: uint32;\n\tkerningVectorOffset: uint32;\n}\n\n/**\n * Parse kerx table\n */\nexport function parseKerx(reader: Reader): KerxTable {\n\tconst version = reader.uint16();\n\treader.skip(2); // padding\n\tconst nTables = reader.uint32();\n\n\tconst subtables: KerxSubtable[] = [];\n\n\tfor (let i = 0; i < nTables; i++) {\n\t\tconst subtable = parseKerxSubtable(reader);\n\t\tif (subtable) subtables.push(subtable);\n\t}\n\n\treturn { version, nTables, subtables };\n}\n\nfunction parseKerxSubtable(reader: Reader): KerxSubtable | null {\n\tconst length = reader.uint32();\n\tconst coverageAndFormat = reader.uint32();\n\tconst tupleCount = reader.uint16();\n\treader.skip(2); // padding\n\n\tconst format = coverageAndFormat & 0xff;\n\tconst coverage: KerxCoverage = {\n\t\tvertical: (coverageAndFormat & 0x80000000) !== 0,\n\t\tcrossStream: (coverageAndFormat & 0x40000000) !== 0,\n\t\tvariation: (coverageAndFormat & 0x20000000) !== 0,\n\t};\n\n\tconst base: KerxSubtableBase = { length, coverage, tupleCount };\n\tconst subtableEnd = reader.offset + length - 12; // Already read 12 bytes\n\n\tlet subtable: KerxSubtable | null = null;\n\n\tswitch (format) {\n\t\tcase KerxSubtableType.OrderedList:\n\t\t\tsubtable = parseKerxFormat0(reader, base);\n\t\t\tbreak;\n\t\tcase KerxSubtableType.StateTable:\n\t\t\tsubtable = parseKerxFormat1(reader, base);\n\t\t\tbreak;\n\t\tcase KerxSubtableType.SimpleArray:\n\t\t\tsubtable = parseKerxFormat2(reader, base);\n\t\t\tbreak;\n\t\tcase KerxSubtableType.Format6:\n\t\t\tsubtable = parseKerxFormat6(reader, base);\n\t\t\tbreak;\n\t}\n\n\t// Skip to end of subtable\n\treader.seek(subtableEnd);\n\n\treturn subtable;\n}\n\nfunction parseKerxFormat0(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxOrderedListSubtable {\n\tconst nPairs = reader.uint32();\n\treader.skip(12); // searchRange, entrySelector, rangeShift\n\n\tconst pairs: KerxPair[] = [];\n\tfor (let i = 0; i < nPairs; i++) {\n\t\tpairs.push({\n\t\t\tleft: reader.uint16(),\n\t\t\tright: reader.uint16(),\n\t\t\tvalue: reader.int16(),\n\t\t});\n\t\treader.skip(2); // padding\n\t}\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.OrderedList,\n\t\tnPairs,\n\t\tpairs,\n\t};\n}\n\nfunction parseKerxFormat1(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxStateTableSubtable {\n\tconst stateHeader: KerxStateHeader = {\n\t\tnClasses: reader.uint32(),\n\t\tclassTableOffset: reader.offset32(),\n\t\tstateArrayOffset: reader.offset32(),\n\t\tentryTableOffset: reader.offset32(),\n\t\tvalueTableOffset: reader.offset32(),\n\t};\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.StateTable,\n\t\tstateHeader,\n\t};\n}\n\nfunction parseKerxFormat2(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxSimpleArraySubtable {\n\tconst rowWidth = reader.uint16();\n\treader.skip(2); // padding\n\n\tconst leftClassTableOffset = reader.offset32();\n\tconst rightClassTableOffset = reader.offset32();\n\tconst kerningArrayOffset = reader.offset32();\n\n\t// Parse class tables\n\tconst leftClassTable = parseKerxClassTable(\n\t\treader.sliceFrom(leftClassTableOffset),\n\t);\n\tconst rightClassTable = parseKerxClassTable(\n\t\treader.sliceFrom(rightClassTableOffset),\n\t);\n\n\t// Parse kerning array\n\tconst arrayReader = reader.sliceFrom(kerningArrayOffset);\n\tconst numRows =\n\t\tleftClassTable.nGlyphs > 0\n\t\t\t? Math.max(...[...leftClassTable.classes]) + 1\n\t\t\t: 0;\n\tconst numCols = rowWidth / 2;\n\tconst kerningArray = new Int16Array(numRows * numCols);\n\n\tfor (let i = 0; i < kerningArray.length; i++) {\n\t\tkerningArray[i] = arrayReader.int16();\n\t}\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.SimpleArray,\n\t\trowWidth,\n\t\tleftClassTable,\n\t\trightClassTable,\n\t\tkerningArray,\n\t};\n}\n\nfunction parseKerxClassTable(reader: Reader): KerxClassTable {\n\tconst firstGlyph = reader.uint16();\n\tconst nGlyphs = reader.uint16();\n\tconst classes = new Uint8Array(nGlyphs);\n\n\tfor (let i = 0; i < nGlyphs; i++) {\n\t\tclasses[i] = reader.uint8();\n\t}\n\n\treturn { firstGlyph, nGlyphs, classes };\n}\n\nfunction parseKerxFormat6(\n\treader: Reader,\n\tbase: KerxSubtableBase,\n): KerxFormat6Subtable {\n\tconst flags = reader.uint32();\n\tconst rowCount = reader.uint16();\n\tconst columnCount = reader.uint16();\n\tconst rowIndexTableOffset = reader.offset32();\n\tconst columnIndexTableOffset = reader.offset32();\n\tconst kerningArrayOffset = reader.offset32();\n\tconst kerningVectorOffset = reader.offset32();\n\n\treturn {\n\t\t...base,\n\t\tformat: KerxSubtableType.Format6,\n\t\tflags,\n\t\trowCount,\n\t\tcolumnCount,\n\t\trowIndexTableOffset,\n\t\tcolumnIndexTableOffset,\n\t\tkerningArrayOffset,\n\t\tkerningVectorOffset,\n\t};\n}\n\n/**\n * Get kerning value from kerx table\n */\nexport function getKerxValue(\n\tkerx: KerxTable,\n\tleft: GlyphId,\n\tright: GlyphId,\n): number {\n\tfor (let i = 0; i < kerx.subtables.length; i++) {\n\t\tconst subtable = kerx.subtables[i]!;\n\t\tif (subtable.coverage.vertical) continue; // Skip vertical kerning\n\n\t\tswitch (subtable.format) {\n\t\t\tcase KerxSubtableType.OrderedList: {\n\t\t\t\t// Binary search for the pair\n\t\t\t\tconst pairs = subtable.pairs;\n\t\t\t\tlet lo = 0;\n\t\t\t\tlet hi = pairs.length - 1;\n\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tconst mid = (lo + hi) >> 1;\n\t\t\t\t\tconst pair = pairs[mid];\n\t\t\t\t\tif (!pair) break;\n\n\t\t\t\t\tconst key = (pair.left << 16) | pair.right;\n\t\t\t\t\tconst target = (left << 16) | right;\n\n\t\t\t\t\tif (key === target) {\n\t\t\t\t\t\treturn pair.value;\n\t\t\t\t\t} else if (key < target) {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase KerxSubtableType.SimpleArray: {\n\t\t\t\tconst leftTable = subtable.leftClassTable;\n\t\t\t\tconst rightTable = subtable.rightClassTable;\n\n\t\t\t\tif (\n\t\t\t\t\tleft < leftTable.firstGlyph ||\n\t\t\t\t\tleft >= leftTable.firstGlyph + leftTable.nGlyphs\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tright < rightTable.firstGlyph ||\n\t\t\t\t\tright >= rightTable.firstGlyph + rightTable.nGlyphs\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst leftClass = leftTable.classes[left - leftTable.firstGlyph];\n\t\t\t\tconst rightClass = rightTable.classes[right - rightTable.firstGlyph];\n\t\t\t\tif (leftClass === undefined || rightClass === undefined) continue;\n\n\t\t\t\tconst numCols = subtable.rowWidth / 2;\n\t\t\t\tconst index = leftClass * numCols + rightClass;\n\n\t\t\t\tif (index < subtable.kerningArray.length) {\n\t\t\t\t\tconst value = subtable.kerningArray[index];\n\t\t\t\t\tif (value !== undefined && value !== 0) return value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
    "import {\n\ttype Coverage,\n\tparseCoverageAt,\n} from \"../../layout/structures/coverage.ts\";\nimport {\n\ttype DeviceOrVariationIndex,\n\tparseDeviceAt,\n} from \"../../layout/structures/device.ts\";\nimport type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * MATH table - Mathematical typesetting data\n * Provides metrics and glyph information for math layout\n */\n\n/** MathValueRecord - value with optional device correction */\nexport interface MathValueRecord {\n\tvalue: int16;\n\tdevice: DeviceOrVariationIndex | null;\n}\n\n/** MathConstants - global math constants */\nexport interface MathConstants {\n\tscriptPercentScaleDown: int16;\n\tscriptScriptPercentScaleDown: int16;\n\tdelimitedSubFormulaMinHeight: uint16;\n\tdisplayOperatorMinHeight: uint16;\n\tmathLeading: MathValueRecord;\n\taxisHeight: MathValueRecord;\n\taccentBaseHeight: MathValueRecord;\n\tflattenedAccentBaseHeight: MathValueRecord;\n\tsubscriptShiftDown: MathValueRecord;\n\tsubscriptTopMax: MathValueRecord;\n\tsubscriptBaselineDropMin: MathValueRecord;\n\tsuperscriptShiftUp: MathValueRecord;\n\tsuperscriptShiftUpCramped: MathValueRecord;\n\tsuperscriptBottomMin: MathValueRecord;\n\tsuperscriptBaselineDropMax: MathValueRecord;\n\tsubSuperscriptGapMin: MathValueRecord;\n\tsuperscriptBottomMaxWithSubscript: MathValueRecord;\n\tspaceAfterScript: MathValueRecord;\n\tupperLimitGapMin: MathValueRecord;\n\tupperLimitBaselineRiseMin: MathValueRecord;\n\tlowerLimitGapMin: MathValueRecord;\n\tlowerLimitBaselineDropMin: MathValueRecord;\n\tstackTopShiftUp: MathValueRecord;\n\tstackTopDisplayStyleShiftUp: MathValueRecord;\n\tstackBottomShiftDown: MathValueRecord;\n\tstackBottomDisplayStyleShiftDown: MathValueRecord;\n\tstackGapMin: MathValueRecord;\n\tstackDisplayStyleGapMin: MathValueRecord;\n\tstretchStackTopShiftUp: MathValueRecord;\n\tstretchStackBottomShiftDown: MathValueRecord;\n\tstretchStackGapAboveMin: MathValueRecord;\n\tstretchStackGapBelowMin: MathValueRecord;\n\tfractionNumeratorShiftUp: MathValueRecord;\n\tfractionNumeratorDisplayStyleShiftUp: MathValueRecord;\n\tfractionDenominatorShiftDown: MathValueRecord;\n\tfractionDenominatorDisplayStyleShiftDown: MathValueRecord;\n\tfractionNumeratorGapMin: MathValueRecord;\n\tfractionNumDisplayStyleGapMin: MathValueRecord;\n\tfractionRuleThickness: MathValueRecord;\n\tfractionDenominatorGapMin: MathValueRecord;\n\tfractionDenomDisplayStyleGapMin: MathValueRecord;\n\tskewedFractionHorizontalGap: MathValueRecord;\n\tskewedFractionVerticalGap: MathValueRecord;\n\toverbarVerticalGap: MathValueRecord;\n\toverbarRuleThickness: MathValueRecord;\n\toverbarExtraAscender: MathValueRecord;\n\tunderbarVerticalGap: MathValueRecord;\n\tunderbarRuleThickness: MathValueRecord;\n\tunderbarExtraDescender: MathValueRecord;\n\tradicalVerticalGap: MathValueRecord;\n\tradicalDisplayStyleVerticalGap: MathValueRecord;\n\tradicalRuleThickness: MathValueRecord;\n\tradicalExtraAscender: MathValueRecord;\n\tradicalKernBeforeDegree: MathValueRecord;\n\tradicalKernAfterDegree: MathValueRecord;\n\tradicalDegreeBottomRaisePercent: int16;\n}\n\n/** Italic correction info */\nexport interface MathItalicsCorrection {\n\tcoverage: Coverage;\n\tvalues: MathValueRecord[];\n}\n\n/** Top accent attachment */\nexport interface MathTopAccentAttachment {\n\tcoverage: Coverage;\n\tvalues: MathValueRecord[];\n}\n\n/** Extended shape coverage */\nexport interface ExtendedShapeCoverage {\n\tcoverage: Coverage;\n}\n\n/** Math kern record for corner kerns */\nexport interface MathKernRecord {\n\tcorrectionHeights: MathValueRecord[];\n\tkernValues: MathValueRecord[];\n}\n\n/** Math kern info for a glyph */\nexport interface MathKernInfo {\n\ttopRight: MathKernRecord | null;\n\ttopLeft: MathKernRecord | null;\n\tbottomRight: MathKernRecord | null;\n\tbottomLeft: MathKernRecord | null;\n}\n\n/** Math kern info table */\nexport interface MathKernInfoTable {\n\tcoverage: Coverage;\n\tkernInfo: MathKernInfo[];\n}\n\n/** MathGlyphInfo - per-glyph math info */\nexport interface MathGlyphInfo {\n\titalicsCorrection: MathItalicsCorrection | null;\n\ttopAccentAttachment: MathTopAccentAttachment | null;\n\textendedShapeCoverage: ExtendedShapeCoverage | null;\n\tkernInfo: MathKernInfoTable | null;\n}\n\n/** Glyph part record for assembly */\nexport interface GlyphPartRecord {\n\tglyphId: GlyphId;\n\tstartConnectorLength: uint16;\n\tendConnectorLength: uint16;\n\tfullAdvance: uint16;\n\tpartFlags: uint16;\n}\n\n/** Glyph assembly */\nexport interface GlyphAssembly {\n\titalicsCorrection: MathValueRecord;\n\tparts: GlyphPartRecord[];\n}\n\n/** Math glyph construction */\nexport interface MathGlyphConstruction {\n\tglyphAssembly: GlyphAssembly | null;\n\tvariants: Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }>;\n}\n\n/** MathVariants - glyph variants and construction */\nexport interface MathVariants {\n\tminConnectorOverlap: uint16;\n\tvertGlyphCoverage: Coverage | null;\n\thorizGlyphCoverage: Coverage | null;\n\tvertGlyphConstruction: MathGlyphConstruction[];\n\thorizGlyphConstruction: MathGlyphConstruction[];\n}\n\n/** MATH table */\nexport interface MathTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tconstants: MathConstants | null;\n\tglyphInfo: MathGlyphInfo | null;\n\tvariants: MathVariants | null;\n}\n\nfunction parseMathValueRecord(\n\treader: Reader,\n\ttableReader: Reader,\n): MathValueRecord {\n\tconst value = reader.int16();\n\tconst deviceOffset = reader.uint16();\n\treturn {\n\t\tvalue,\n\t\tdevice: parseDeviceAt(tableReader, deviceOffset),\n\t};\n}\n\nfunction parseMathConstants(reader: Reader): MathConstants {\n\tconst tableReader = reader;\n\tconst scriptPercentScaleDown = reader.int16();\n\tconst scriptScriptPercentScaleDown = reader.int16();\n\tconst delimitedSubFormulaMinHeight = reader.uint16();\n\tconst displayOperatorMinHeight = reader.uint16();\n\n\treturn {\n\t\tscriptPercentScaleDown,\n\t\tscriptScriptPercentScaleDown,\n\t\tdelimitedSubFormulaMinHeight,\n\t\tdisplayOperatorMinHeight,\n\t\tmathLeading: parseMathValueRecord(reader, tableReader),\n\t\taxisHeight: parseMathValueRecord(reader, tableReader),\n\t\taccentBaseHeight: parseMathValueRecord(reader, tableReader),\n\t\tflattenedAccentBaseHeight: parseMathValueRecord(reader, tableReader),\n\t\tsubscriptShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tsubscriptTopMax: parseMathValueRecord(reader, tableReader),\n\t\tsubscriptBaselineDropMin: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptShiftUpCramped: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptBottomMin: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptBaselineDropMax: parseMathValueRecord(reader, tableReader),\n\t\tsubSuperscriptGapMin: parseMathValueRecord(reader, tableReader),\n\t\tsuperscriptBottomMaxWithSubscript: parseMathValueRecord(\n\t\t\treader,\n\t\t\ttableReader,\n\t\t),\n\t\tspaceAfterScript: parseMathValueRecord(reader, tableReader),\n\t\tupperLimitGapMin: parseMathValueRecord(reader, tableReader),\n\t\tupperLimitBaselineRiseMin: parseMathValueRecord(reader, tableReader),\n\t\tlowerLimitGapMin: parseMathValueRecord(reader, tableReader),\n\t\tlowerLimitBaselineDropMin: parseMathValueRecord(reader, tableReader),\n\t\tstackTopShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tstackTopDisplayStyleShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tstackBottomShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tstackBottomDisplayStyleShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tstackGapMin: parseMathValueRecord(reader, tableReader),\n\t\tstackDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackTopShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackBottomShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackGapAboveMin: parseMathValueRecord(reader, tableReader),\n\t\tstretchStackGapBelowMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionNumeratorShiftUp: parseMathValueRecord(reader, tableReader),\n\t\tfractionNumeratorDisplayStyleShiftUp: parseMathValueRecord(\n\t\t\treader,\n\t\t\ttableReader,\n\t\t),\n\t\tfractionDenominatorShiftDown: parseMathValueRecord(reader, tableReader),\n\t\tfractionDenominatorDisplayStyleShiftDown: parseMathValueRecord(\n\t\t\treader,\n\t\t\ttableReader,\n\t\t),\n\t\tfractionNumeratorGapMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionNumDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\tfractionDenominatorGapMin: parseMathValueRecord(reader, tableReader),\n\t\tfractionDenomDisplayStyleGapMin: parseMathValueRecord(reader, tableReader),\n\t\tskewedFractionHorizontalGap: parseMathValueRecord(reader, tableReader),\n\t\tskewedFractionVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\toverbarVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\toverbarRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\toverbarExtraAscender: parseMathValueRecord(reader, tableReader),\n\t\tunderbarVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\tunderbarRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\tunderbarExtraDescender: parseMathValueRecord(reader, tableReader),\n\t\tradicalVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\tradicalDisplayStyleVerticalGap: parseMathValueRecord(reader, tableReader),\n\t\tradicalRuleThickness: parseMathValueRecord(reader, tableReader),\n\t\tradicalExtraAscender: parseMathValueRecord(reader, tableReader),\n\t\tradicalKernBeforeDegree: parseMathValueRecord(reader, tableReader),\n\t\tradicalKernAfterDegree: parseMathValueRecord(reader, tableReader),\n\t\tradicalDegreeBottomRaisePercent: reader.int16(),\n\t};\n}\n\nfunction parseMathItalicsCorrection(reader: Reader): MathItalicsCorrection {\n\tconst coverageOffset = reader.uint16();\n\tconst count = reader.uint16();\n\n\tconst values: MathValueRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tvalues.push(parseMathValueRecord(reader, reader));\n\t}\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\n\treturn { coverage, values };\n}\n\nfunction parseMathTopAccentAttachment(reader: Reader): MathTopAccentAttachment {\n\tconst coverageOffset = reader.uint16();\n\tconst count = reader.uint16();\n\n\tconst values: MathValueRecord[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tvalues.push(parseMathValueRecord(reader, reader));\n\t}\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\n\treturn { coverage, values };\n}\n\nfunction parseMathKernRecord(reader: Reader, offset: number): MathKernRecord {\n\tconst kernReader = reader.sliceFrom(offset);\n\tconst heightCount = kernReader.uint16();\n\n\tconst correctionHeights: MathValueRecord[] = [];\n\tfor (let i = 0; i < heightCount; i++) {\n\t\tcorrectionHeights.push(parseMathValueRecord(kernReader, kernReader));\n\t}\n\n\tconst kernValues: MathValueRecord[] = [];\n\tfor (let i = 0; i < heightCount + 1; i++) {\n\t\tkernValues.push(parseMathValueRecord(kernReader, kernReader));\n\t}\n\n\treturn { correctionHeights, kernValues };\n}\n\nfunction parseMathKernInfoTable(reader: Reader): MathKernInfoTable {\n\tconst coverageOffset = reader.uint16();\n\tconst count = reader.uint16();\n\n\tconst kernInfoRecords: Array<{\n\t\ttopRightOffset: uint16;\n\t\ttopLeftOffset: uint16;\n\t\tbottomRightOffset: uint16;\n\t\tbottomLeftOffset: uint16;\n\t}> = [];\n\n\tfor (let i = 0; i < count; i++) {\n\t\tkernInfoRecords.push({\n\t\t\ttopRightOffset: reader.uint16(),\n\t\t\ttopLeftOffset: reader.uint16(),\n\t\t\tbottomRightOffset: reader.uint16(),\n\t\t\tbottomLeftOffset: reader.uint16(),\n\t\t});\n\t}\n\n\tconst coverage = parseCoverageAt(reader, coverageOffset);\n\n\tconst kernInfo: MathKernInfo[] = kernInfoRecords.map((record) => ({\n\t\ttopRight:\n\t\t\trecord.topRightOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.topRightOffset)\n\t\t\t\t: null,\n\t\ttopLeft:\n\t\t\trecord.topLeftOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.topLeftOffset)\n\t\t\t\t: null,\n\t\tbottomRight:\n\t\t\trecord.bottomRightOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.bottomRightOffset)\n\t\t\t\t: null,\n\t\tbottomLeft:\n\t\t\trecord.bottomLeftOffset !== 0\n\t\t\t\t? parseMathKernRecord(reader, record.bottomLeftOffset)\n\t\t\t\t: null,\n\t}));\n\n\treturn { coverage, kernInfo };\n}\n\nfunction parseMathGlyphInfo(reader: Reader): MathGlyphInfo {\n\tconst italicsCorrectionOffset = reader.uint16();\n\tconst topAccentAttachmentOffset = reader.uint16();\n\tconst extendedShapeCoverageOffset = reader.uint16();\n\tconst kernInfoOffset = reader.uint16();\n\n\tlet italicsCorrection: MathItalicsCorrection | null = null;\n\tif (italicsCorrectionOffset !== 0) {\n\t\titalicsCorrection = parseMathItalicsCorrection(\n\t\t\treader.sliceFrom(italicsCorrectionOffset),\n\t\t);\n\t}\n\n\tlet topAccentAttachment: MathTopAccentAttachment | null = null;\n\tif (topAccentAttachmentOffset !== 0) {\n\t\ttopAccentAttachment = parseMathTopAccentAttachment(\n\t\t\treader.sliceFrom(topAccentAttachmentOffset),\n\t\t);\n\t}\n\n\tlet extendedShapeCoverage: ExtendedShapeCoverage | null = null;\n\tif (extendedShapeCoverageOffset !== 0) {\n\t\tconst coverage = parseCoverageAt(reader, extendedShapeCoverageOffset);\n\t\textendedShapeCoverage = { coverage };\n\t}\n\n\tlet kernInfo: MathKernInfoTable | null = null;\n\tif (kernInfoOffset !== 0) {\n\t\tkernInfo = parseMathKernInfoTable(reader.sliceFrom(kernInfoOffset));\n\t}\n\n\treturn {\n\t\titalicsCorrection,\n\t\ttopAccentAttachment,\n\t\textendedShapeCoverage,\n\t\tkernInfo,\n\t};\n}\n\nfunction parseGlyphAssembly(reader: Reader): GlyphAssembly {\n\tconst italicsCorrection = parseMathValueRecord(reader, reader);\n\tconst partCount = reader.uint16();\n\n\tconst parts: GlyphPartRecord[] = [];\n\tfor (let i = 0; i < partCount; i++) {\n\t\tparts.push({\n\t\t\tglyphId: reader.uint16(),\n\t\t\tstartConnectorLength: reader.uint16(),\n\t\t\tendConnectorLength: reader.uint16(),\n\t\t\tfullAdvance: reader.uint16(),\n\t\t\tpartFlags: reader.uint16(),\n\t\t});\n\t}\n\n\treturn { italicsCorrection, parts };\n}\n\nfunction parseMathGlyphConstruction(reader: Reader): MathGlyphConstruction {\n\tconst glyphAssemblyOffset = reader.uint16();\n\tconst variantCount = reader.uint16();\n\n\tconst variants: Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }> =\n\t\t[];\n\tfor (let i = 0; i < variantCount; i++) {\n\t\tvariants.push({\n\t\t\tvariantGlyph: reader.uint16(),\n\t\t\tadvanceMeasurement: reader.uint16(),\n\t\t});\n\t}\n\n\tlet glyphAssembly: GlyphAssembly | null = null;\n\tif (glyphAssemblyOffset !== 0) {\n\t\tglyphAssembly = parseGlyphAssembly(reader.sliceFrom(glyphAssemblyOffset));\n\t}\n\n\treturn { glyphAssembly, variants };\n}\n\nfunction parseMathVariants(reader: Reader): MathVariants {\n\tconst minConnectorOverlap = reader.uint16();\n\tconst vertGlyphCoverageOffset = reader.uint16();\n\tconst horizGlyphCoverageOffset = reader.uint16();\n\tconst vertGlyphCount = reader.uint16();\n\tconst horizGlyphCount = reader.uint16();\n\n\tconst vertGlyphConstructionOffsets: uint16[] = [];\n\tfor (let i = 0; i < vertGlyphCount; i++) {\n\t\tvertGlyphConstructionOffsets.push(reader.uint16());\n\t}\n\n\tconst horizGlyphConstructionOffsets: uint16[] = [];\n\tfor (let i = 0; i < horizGlyphCount; i++) {\n\t\thorizGlyphConstructionOffsets.push(reader.uint16());\n\t}\n\n\tconst vertGlyphCoverage =\n\t\tvertGlyphCoverageOffset !== 0\n\t\t\t? parseCoverageAt(reader, vertGlyphCoverageOffset)\n\t\t\t: null;\n\n\tconst horizGlyphCoverage =\n\t\thorizGlyphCoverageOffset !== 0\n\t\t\t? parseCoverageAt(reader, horizGlyphCoverageOffset)\n\t\t\t: null;\n\n\tconst vertGlyphConstruction = vertGlyphConstructionOffsets.map((offset) =>\n\t\tparseMathGlyphConstruction(reader.sliceFrom(offset)),\n\t);\n\n\tconst horizGlyphConstruction = horizGlyphConstructionOffsets.map((offset) =>\n\t\tparseMathGlyphConstruction(reader.sliceFrom(offset)),\n\t);\n\n\treturn {\n\t\tminConnectorOverlap,\n\t\tvertGlyphCoverage,\n\t\thorizGlyphCoverage,\n\t\tvertGlyphConstruction,\n\t\thorizGlyphConstruction,\n\t};\n}\n\nexport function parseMath(reader: Reader): MathTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst mathConstantsOffset = reader.uint16();\n\tconst mathGlyphInfoOffset = reader.uint16();\n\tconst mathVariantsOffset = reader.uint16();\n\n\tlet constants: MathConstants | null = null;\n\tif (mathConstantsOffset !== 0) {\n\t\tconstants = parseMathConstants(reader.sliceFrom(mathConstantsOffset));\n\t}\n\n\tlet glyphInfo: MathGlyphInfo | null = null;\n\tif (mathGlyphInfoOffset !== 0) {\n\t\tglyphInfo = parseMathGlyphInfo(reader.sliceFrom(mathGlyphInfoOffset));\n\t}\n\n\tlet variants: MathVariants | null = null;\n\tif (mathVariantsOffset !== 0) {\n\t\tvariants = parseMathVariants(reader.sliceFrom(mathVariantsOffset));\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tconstants,\n\t\tglyphInfo,\n\t\tvariants,\n\t};\n}\n\n// Helper functions\n\n/** Get italic correction for a glyph */\nexport function getItalicsCorrection(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): MathValueRecord | null {\n\tconst italics = math.glyphInfo?.italicsCorrection;\n\tif (!italics) return null;\n\n\tconst index = italics.coverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn italics.values[index] ?? null;\n}\n\n/** Get top accent attachment for a glyph */\nexport function getTopAccentAttachment(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): MathValueRecord | null {\n\tconst attachment = math.glyphInfo?.topAccentAttachment;\n\tif (!attachment) return null;\n\n\tconst index = attachment.coverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn attachment.values[index] ?? null;\n}\n\n/** Check if glyph is an extended shape */\nexport function isExtendedShape(math: MathTable, glyphId: GlyphId): boolean {\n\tconst extended = math.glyphInfo?.extendedShapeCoverage;\n\tif (!extended) return false;\n\n\treturn extended.coverage.get(glyphId) !== null;\n}\n\n/** Get vertical glyph variants */\nexport function getVerticalVariants(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }> | null {\n\tconst variants = math.variants;\n\tif (!variants?.vertGlyphCoverage) return null;\n\n\tconst index = variants.vertGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.vertGlyphConstruction[index]?.variants ?? null;\n}\n\n/** Get horizontal glyph variants */\nexport function getHorizontalVariants(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): Array<{ variantGlyph: GlyphId; advanceMeasurement: uint16 }> | null {\n\tconst variants = math.variants;\n\tif (!variants?.horizGlyphCoverage) return null;\n\n\tconst index = variants.horizGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.horizGlyphConstruction[index]?.variants ?? null;\n}\n\n/** Get vertical glyph assembly */\nexport function getVerticalAssembly(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): GlyphAssembly | null {\n\tconst variants = math.variants;\n\tif (!variants?.vertGlyphCoverage) return null;\n\n\tconst index = variants.vertGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.vertGlyphConstruction[index]?.glyphAssembly ?? null;\n}\n\n/** Get horizontal glyph assembly */\nexport function getHorizontalAssembly(\n\tmath: MathTable,\n\tglyphId: GlyphId,\n): GlyphAssembly | null {\n\tconst variants = math.variants;\n\tif (!variants?.horizGlyphCoverage) return null;\n\n\tconst index = variants.horizGlyphCoverage.get(glyphId);\n\tif (index === null) return null;\n\n\treturn variants.horizGlyphConstruction[index]?.glyphAssembly ?? null;\n}\n",
    "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Maximum profile table (version 0.5 - CFF) */\nexport interface MaxpTable05 {\n\tversion: 0x00005000;\n\tnumGlyphs: uint16;\n}\n\n/** Maximum profile table (version 1.0 - TrueType) */\nexport interface MaxpTable10 {\n\tversion: 0x00010000;\n\tnumGlyphs: uint16;\n\tmaxPoints: uint16;\n\tmaxContours: uint16;\n\tmaxCompositePoints: uint16;\n\tmaxCompositeContours: uint16;\n\tmaxZones: uint16;\n\tmaxTwilightPoints: uint16;\n\tmaxStorage: uint16;\n\tmaxFunctionDefs: uint16;\n\tmaxInstructionDefs: uint16;\n\tmaxStackElements: uint16;\n\tmaxSizeOfInstructions: uint16;\n\tmaxComponentElements: uint16;\n\tmaxComponentDepth: uint16;\n}\n\nexport type MaxpTable = MaxpTable05 | MaxpTable10;\n\n/**\n * Parse maxp table - maximum profile with glyph count and limits\n * @param reader - Reader positioned at start of maxp table\n * @returns Parsed maxp table (version 0.5 for CFF or 1.0 for TrueType)\n */\nexport function parseMaxp(reader: Reader): MaxpTable {\n\tconst version = reader.uint32();\n\tconst numGlyphs = reader.uint16();\n\n\tif (version === 0x00005000) {\n\t\t// Version 0.5 (CFF fonts)\n\t\treturn { version, numGlyphs };\n\t}\n\n\tif (version === 0x00010000) {\n\t\t// Version 1.0 (TrueType fonts)\n\t\treturn {\n\t\t\tversion,\n\t\t\tnumGlyphs,\n\t\t\tmaxPoints: reader.uint16(),\n\t\t\tmaxContours: reader.uint16(),\n\t\t\tmaxCompositePoints: reader.uint16(),\n\t\t\tmaxCompositeContours: reader.uint16(),\n\t\t\tmaxZones: reader.uint16(),\n\t\t\tmaxTwilightPoints: reader.uint16(),\n\t\t\tmaxStorage: reader.uint16(),\n\t\t\tmaxFunctionDefs: reader.uint16(),\n\t\t\tmaxInstructionDefs: reader.uint16(),\n\t\t\tmaxStackElements: reader.uint16(),\n\t\t\tmaxSizeOfInstructions: reader.uint16(),\n\t\t\tmaxComponentElements: reader.uint16(),\n\t\t\tmaxComponentDepth: reader.uint16(),\n\t\t};\n\t}\n\n\tthrow new Error(`Unknown maxp version: 0x${version.toString(16)}`);\n}\n",
    "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Extended Glyph Metamorphosis table (morx)\n * Apple Advanced Typography substitution\n */\nexport interface MorxTable {\n\tversion: number;\n\tchains: MorxChain[];\n}\n\n/**\n * Feature chain in morx\n */\nexport interface MorxChain {\n\tdefaultFlags: uint32;\n\tfeatures: MorxFeature[];\n\tsubtables: MorxSubtable[];\n}\n\n/**\n * Feature entry\n */\nexport interface MorxFeature {\n\tfeatureType: uint16;\n\tfeatureSetting: uint16;\n\tenableFlags: uint32;\n\tdisableFlags: uint32;\n}\n\n/**\n * Subtable types\n */\nexport enum MorxSubtableType {\n\tRearrangement = 0,\n\tContextual = 1,\n\tLigature = 2,\n\tNonContextual = 4,\n\tInsertion = 5,\n}\n\n/**\n * Base subtable\n */\nexport interface MorxSubtableBase {\n\ttype: MorxSubtableType;\n\tcoverage: MorxCoverage;\n\tsubFeatureFlags: uint32;\n}\n\nexport interface MorxCoverage {\n\tvertical: boolean;\n\tdescending: boolean;\n\tlogical: boolean;\n}\n\nexport type MorxSubtable =\n\t| MorxRearrangementSubtable\n\t| MorxContextualSubtable\n\t| MorxLigatureSubtable\n\t| MorxNonContextualSubtable\n\t| MorxInsertionSubtable;\n\n/**\n * Type 0: Rearrangement (reorders glyphs)\n */\nexport interface MorxRearrangementSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Rearrangement;\n\tstateTable: StateTable<RearrangementEntry>;\n}\n\nexport interface RearrangementEntry {\n\tnewState: uint16;\n\tflags: uint16;\n}\n\n/**\n * Type 1: Contextual substitution\n */\nexport interface MorxContextualSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Contextual;\n\tstateTable: StateTable<ContextualEntry>;\n\tsubstitutionTable: Map<GlyphId, GlyphId>[];\n}\n\nexport interface ContextualEntry {\n\tnewState: uint16;\n\tflags: uint16;\n\tmarkIndex: uint16;\n\tcurrentIndex: uint16;\n}\n\n/**\n * Type 2: Ligature\n */\nexport interface MorxLigatureSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Ligature;\n\tstateTable: StateTable<LigatureEntry>;\n\tligatureActions: uint32[];\n\tcomponents: uint16[];\n\tligatures: GlyphId[];\n}\n\nexport interface LigatureEntry {\n\tnewState: uint16;\n\tflags: uint16;\n\tligActionIndex: uint16;\n}\n\n/**\n * Type 4: Non-contextual (simple substitution)\n */\nexport interface MorxNonContextualSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.NonContextual;\n\tlookupTable: LookupTable;\n}\n\n/**\n * Type 5: Insertion\n */\nexport interface MorxInsertionSubtable extends MorxSubtableBase {\n\ttype: MorxSubtableType.Insertion;\n\tstateTable: StateTable<InsertionEntry>;\n\tinsertionGlyphs: GlyphId[];\n}\n\nexport interface InsertionEntry {\n\tnewState: uint16;\n\tflags: uint16;\n\tcurrentInsertIndex: uint16;\n\tmarkedInsertIndex: uint16;\n}\n\n/**\n * State table for state machine processing\n */\nexport interface StateTable<E> {\n\tnClasses: uint32;\n\tclassTable: ClassTable;\n\tstateArray: E[][];\n}\n\n/**\n * Class lookup table\n */\nexport interface ClassTable {\n\tformat: number;\n\tclassArray: number[]; // Maps glyph ID to class\n}\n\n/**\n * Lookup table for substitutions\n */\nexport interface LookupTable {\n\tformat: number;\n\tmapping: Map<GlyphId, GlyphId>;\n}\n\n/**\n * Parse morx table\n */\nexport function parseMorx(reader: Reader): MorxTable {\n\tconst version = reader.uint16();\n\treader.skip(2); // unused\n\n\tif (version < 2) {\n\t\t// Version 1 (mort) - not supported\n\t\treturn { version, chains: [] };\n\t}\n\n\tconst nChains = reader.uint32();\n\tconst chains: MorxChain[] = [];\n\n\tfor (let i = 0; i < nChains; i++) {\n\t\tconst chain = parseMorxChain(reader);\n\t\tchains.push(chain);\n\t}\n\n\treturn { version, chains };\n}\n\nfunction parseMorxChain(reader: Reader): MorxChain {\n\tconst defaultFlags = reader.uint32();\n\tconst _chainLength = reader.uint32();\n\tconst nFeatureEntries = reader.uint32();\n\tconst nSubtables = reader.uint32();\n\n\t// Parse features\n\tconst features: MorxFeature[] = [];\n\tfor (let i = 0; i < nFeatureEntries; i++) {\n\t\tfeatures.push({\n\t\t\tfeatureType: reader.uint16(),\n\t\t\tfeatureSetting: reader.uint16(),\n\t\t\tenableFlags: reader.uint32(),\n\t\t\tdisableFlags: reader.uint32(),\n\t\t});\n\t}\n\n\t// Parse subtables\n\tconst subtables: MorxSubtable[] = [];\n\tfor (let i = 0; i < nSubtables; i++) {\n\t\tconst subtable = parseMorxSubtable(reader);\n\t\tif (subtable) subtables.push(subtable);\n\t}\n\n\treturn { defaultFlags, features, subtables };\n}\n\nfunction parseMorxSubtable(reader: Reader): MorxSubtable | null {\n\tconst length = reader.uint32();\n\tconst coverageBits = reader.uint32();\n\tconst subFeatureFlags = reader.uint32();\n\n\tconst type = coverageBits & 0xff;\n\tconst coverage: MorxCoverage = {\n\t\tvertical: (coverageBits & 0x80000000) !== 0,\n\t\tdescending: (coverageBits & 0x40000000) !== 0,\n\t\tlogical: (coverageBits & 0x10000000) !== 0,\n\t};\n\n\tconst subtableStart = reader.offset;\n\tconst subtableEnd = subtableStart + length - 12;\n\n\tlet subtable: MorxSubtable | null = null;\n\n\tswitch (type) {\n\t\tcase MorxSubtableType.Rearrangement:\n\t\t\tsubtable = parseRearrangementSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.Contextual:\n\t\t\tsubtable = parseContextualSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.Ligature:\n\t\t\tsubtable = parseLigatureSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.NonContextual:\n\t\t\tsubtable = parseNonContextualSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t\tcase MorxSubtableType.Insertion:\n\t\t\tsubtable = parseInsertionSubtable(reader, coverage, subFeatureFlags);\n\t\t\tbreak;\n\t}\n\n\t// Skip to end of subtable\n\treader.seek(subtableEnd);\n\n\treturn subtable;\n}\n\nfunction parseNonContextualSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxNonContextualSubtable {\n\tconst lookupTable = parseLookupTable(reader);\n\n\treturn {\n\t\ttype: MorxSubtableType.NonContextual,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tlookupTable,\n\t};\n}\n\nfunction parseContextualSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxContextualSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst _stateArrayOffset = reader.offset32();\n\tconst _entryTableOffset = reader.offset32();\n\tconst _substitutionTableOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// Parse state array and entries (simplified)\n\tconst stateTable: StateTable<ContextualEntry> = {\n\t\tnClasses,\n\t\tclassTable,\n\t\tstateArray: [],\n\t};\n\n\tconst substitutionTable: Map<GlyphId, GlyphId>[] = [];\n\n\treturn {\n\t\ttype: MorxSubtableType.Contextual,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable,\n\t\tsubstitutionTable,\n\t};\n}\n\nfunction parseLigatureSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxLigatureSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst _stateArrayOffset = reader.offset32();\n\tconst _entryTableOffset = reader.offset32();\n\tconst _ligatureActionsOffset = reader.offset32();\n\tconst _componentsOffset = reader.offset32();\n\tconst _ligaturesOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// State table (simplified)\n\tconst stateTable: StateTable<LigatureEntry> = {\n\t\tnClasses,\n\t\tclassTable,\n\t\tstateArray: [],\n\t};\n\n\treturn {\n\t\ttype: MorxSubtableType.Ligature,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable,\n\t\tligatureActions: [],\n\t\tcomponents: [],\n\t\tligatures: [],\n\t};\n}\n\nfunction parseRearrangementSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxRearrangementSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst stateArrayOffset = reader.offset32();\n\tconst entryTableOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// Parse state array\n\tconst stateArrayReader = reader.sliceFrom(\n\t\tstateTableOffset + stateArrayOffset,\n\t);\n\tconst entryReader = reader.sliceFrom(stateTableOffset + entryTableOffset);\n\n\t// Parse entries (each entry is 4 bytes: newState uint16, flags uint16)\n\tconst entries: RearrangementEntry[] = [];\n\tconst entryCount = 256; // Reasonable max\n\tfor (let i = 0; i < entryCount; i++) {\n\t\tentries.push({\n\t\t\tnewState: entryReader.uint16(),\n\t\t\tflags: entryReader.uint16(),\n\t\t});\n\t}\n\n\t// Build state array\n\tconst stateArray: RearrangementEntry[][] = [];\n\tconst stateCount = Math.min(\n\t\t256,\n\t\tMath.ceil((entryTableOffset - stateArrayOffset) / (nClasses * 2)),\n\t);\n\tfor (let s = 0; s < stateCount; s++) {\n\t\tconst row: RearrangementEntry[] = [];\n\t\tfor (let c = 0; c < nClasses; c++) {\n\t\t\tconst entryIndex = stateArrayReader.uint16();\n\t\t\trow.push(entries[entryIndex] ?? { newState: 0, flags: 0 });\n\t\t}\n\t\tstateArray.push(row);\n\t}\n\n\treturn {\n\t\ttype: MorxSubtableType.Rearrangement,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable: {\n\t\t\tnClasses,\n\t\t\tclassTable,\n\t\t\tstateArray,\n\t\t},\n\t};\n}\n\nfunction parseInsertionSubtable(\n\treader: Reader,\n\tcoverage: MorxCoverage,\n\tsubFeatureFlags: uint32,\n): MorxInsertionSubtable {\n\tconst stateTableOffset = reader.offset;\n\tconst nClasses = reader.uint32();\n\tconst classTableOffset = reader.offset32();\n\tconst stateArrayOffset = reader.offset32();\n\tconst entryTableOffset = reader.offset32();\n\tconst insertionActionOffset = reader.offset32();\n\n\t// Parse class table\n\tconst classTable = parseClassTable(\n\t\treader.sliceFrom(stateTableOffset + classTableOffset),\n\t);\n\n\t// Parse insertion glyphs array\n\tconst insertionReader = reader.sliceFrom(\n\t\tstateTableOffset + insertionActionOffset,\n\t);\n\tconst insertionGlyphs: GlyphId[] = [];\n\t// Read a reasonable number of insertion glyphs\n\tconst maxInsertionGlyphs = 1024;\n\tfor (let i = 0; i < maxInsertionGlyphs; i++) {\n\t\ttry {\n\t\t\tinsertionGlyphs.push(insertionReader.uint16());\n\t\t} catch {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Parse entries\n\tconst entryReader = reader.sliceFrom(stateTableOffset + entryTableOffset);\n\tconst entries: InsertionEntry[] = [];\n\tconst entryCount = 256;\n\tfor (let i = 0; i < entryCount; i++) {\n\t\tentries.push({\n\t\t\tnewState: entryReader.uint16(),\n\t\t\tflags: entryReader.uint16(),\n\t\t\tcurrentInsertIndex: entryReader.uint16(),\n\t\t\tmarkedInsertIndex: entryReader.uint16(),\n\t\t});\n\t}\n\n\t// Build state array\n\tconst stateArrayReader = reader.sliceFrom(\n\t\tstateTableOffset + stateArrayOffset,\n\t);\n\tconst stateArray: InsertionEntry[][] = [];\n\tconst stateCount = Math.min(\n\t\t256,\n\t\tMath.ceil((entryTableOffset - stateArrayOffset) / (nClasses * 2)),\n\t);\n\tfor (let s = 0; s < stateCount; s++) {\n\t\tconst row: InsertionEntry[] = [];\n\t\tfor (let c = 0; c < nClasses; c++) {\n\t\t\tconst entryIndex = stateArrayReader.uint16();\n\t\t\trow.push(\n\t\t\t\tentries[entryIndex] ?? {\n\t\t\t\t\tnewState: 0,\n\t\t\t\t\tflags: 0,\n\t\t\t\t\tcurrentInsertIndex: 0xffff,\n\t\t\t\t\tmarkedInsertIndex: 0xffff,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\tstateArray.push(row);\n\t}\n\n\treturn {\n\t\ttype: MorxSubtableType.Insertion,\n\t\tcoverage,\n\t\tsubFeatureFlags,\n\t\tstateTable: {\n\t\t\tnClasses,\n\t\t\tclassTable,\n\t\t\tstateArray,\n\t\t},\n\t\tinsertionGlyphs,\n\t};\n}\n\nfunction parseLookupTable(reader: Reader): LookupTable {\n\tconst format = reader.uint16();\n\tconst mapping = new Map<GlyphId, GlyphId>();\n\n\tswitch (format) {\n\t\tcase 0: {\n\t\t\t// Simple array\n\t\t\t// Format 0 uses lookup by glyph index directly\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\t// Segment single\n\t\t\tconst _unitSize = reader.uint16();\n\t\t\tconst nUnits = reader.uint16();\n\t\t\treader.skip(6); // searchRange, entrySelector, rangeShift\n\n\t\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\t\tconst lastGlyph = reader.uint16();\n\t\t\t\tconst firstGlyph = reader.uint16();\n\t\t\t\tconst value = reader.uint16();\n\n\t\t\t\tfor (let g = firstGlyph; g <= lastGlyph; g++) {\n\t\t\t\t\tmapping.set(g, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 4: {\n\t\t\t// Segment array\n\t\t\tconst _unitSize = reader.uint16();\n\t\t\tconst nUnits = reader.uint16();\n\t\t\treader.skip(6);\n\n\t\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\t\tconst _lastGlyph = reader.uint16();\n\t\t\t\tconst _firstGlyph = reader.uint16();\n\t\t\t\tconst _valueOffset = reader.uint16();\n\n\t\t\t\t// Values would be read from valueOffset\n\t\t\t\t// Simplified: skip for now\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 6: {\n\t\t\t// Single table\n\t\t\tconst _unitSize = reader.uint16();\n\t\t\tconst nUnits = reader.uint16();\n\t\t\treader.skip(6);\n\n\t\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\t\tconst glyph = reader.uint16();\n\t\t\t\tconst value = reader.uint16();\n\t\t\t\tmapping.set(glyph, value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 8: {\n\t\t\t// Trimmed array\n\t\t\tconst firstGlyph = reader.uint16();\n\t\t\tconst glyphCount = reader.uint16();\n\n\t\t\tfor (let i = 0; i < glyphCount; i++) {\n\t\t\t\tconst value = reader.uint16();\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\tmapping.set(firstGlyph + i, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn { format, mapping };\n}\n\nfunction parseClassTable(reader: Reader): ClassTable {\n\tconst format = reader.uint16();\n\tconst classArray: number[] = [];\n\n\tif (format === 2) {\n\t\t// Binary search segments\n\t\tconst _unitSize = reader.uint16();\n\t\tconst nUnits = reader.uint16();\n\t\treader.skip(6);\n\n\t\tconst segments: { first: number; last: number; classValue: number }[] = [];\n\t\tfor (let i = 0; i < nUnits; i++) {\n\t\t\tsegments.push({\n\t\t\t\tlast: reader.uint16(),\n\t\t\t\tfirst: reader.uint16(),\n\t\t\t\tclassValue: reader.uint16(),\n\t\t\t});\n\t\t}\n\n\t\t// Build class array (simplified, might be large)\n\t\tconst maxGlyph = Math.max(...segments.map((s) => s.last), 0);\n\t\tfor (let g = 0; g <= maxGlyph; g++) {\n\t\t\tconst seg = segments.find((s) => g >= s.first && g <= s.last);\n\t\t\tclassArray[g] = seg?.classValue ?? 1; // Class 1 = out of bounds\n\t\t}\n\t}\n\n\treturn { format, classArray };\n}\n\n/**\n * Apply non-contextual substitution\n */\nexport function applyNonContextual(\n\tsubtable: MorxNonContextualSubtable,\n\tglyphId: GlyphId,\n): GlyphId | null {\n\treturn subtable.lookupTable.mapping.get(glyphId) ?? null;\n}\n",
    "import type { Tag, uint16, uint32 } from \"../../types.ts\";\nimport { tag } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\tcalculateRegionScalar,\n\ttype ItemVariationStore,\n\ttype VariationRegion,\n} from \"./hvar.ts\";\n\n/**\n * Metrics Variations table (MVAR)\n * Provides variations for global font metrics\n */\nexport interface MvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\titemVariationStore: ItemVariationStore;\n\tvalueRecords: MvarValueRecord[];\n}\n\nexport interface MvarValueRecord {\n\tvalueTag: Tag;\n\tdeltaSetOuterIndex: number;\n\tdeltaSetInnerIndex: number;\n}\n\n/**\n * Common MVAR value tags\n */\nexport const MvarTags = {\n\t// Horizontal metrics\n\thasc: tag(\"hasc\"), // horizontal ascender\n\thdsc: tag(\"hdsc\"), // horizontal descender\n\thlgp: tag(\"hlgp\"), // horizontal line gap\n\thcla: tag(\"hcla\"), // horizontal clipping ascent\n\thcld: tag(\"hcld\"), // horizontal clipping descent\n\thcof: tag(\"hcof\"), // horizontal caret offset\n\thcrn: tag(\"hcrn\"), // horizontal caret run\n\thcrs: tag(\"hcrs\"), // horizontal caret rise\n\n\t// Vertical metrics\n\tvasc: tag(\"vasc\"), // vertical ascender\n\tvdsc: tag(\"vdsc\"), // vertical descender\n\tvlgp: tag(\"vlgp\"), // vertical line gap\n\tvcof: tag(\"vcof\"), // vertical caret offset\n\tvcrn: tag(\"vcrn\"), // vertical caret run\n\tvcrs: tag(\"vcrs\"), // vertical caret rise\n\n\t// OS/2 table values\n\txhgt: tag(\"xhgt\"), // x height\n\tcpht: tag(\"cpht\"), // cap height\n\tsbxs: tag(\"sbxs\"), // subscript x size\n\tsbys: tag(\"sbys\"), // subscript y size\n\tsbxo: tag(\"sbxo\"), // subscript x offset\n\tsbyo: tag(\"sbyo\"), // subscript y offset\n\tspxs: tag(\"spxs\"), // superscript x size\n\tspys: tag(\"spys\"), // superscript y size\n\tspxo: tag(\"spxo\"), // superscript x offset\n\tspyo: tag(\"spyo\"), // superscript y offset\n\tstrs: tag(\"strs\"), // strikeout size\n\tstro: tag(\"stro\"), // strikeout offset\n\tundo: tag(\"undo\"), // underline offset\n\tunds: tag(\"unds\"), // underline size\n\n\t// Glyph bounds\n\tgsp0: tag(\"gsp0\"), // glyph bounding box x min\n\tgsp1: tag(\"gsp1\"), // glyph bounding box y min\n\tgsp2: tag(\"gsp2\"), // glyph bounding box x max\n\tgsp3: tag(\"gsp3\"), // glyph bounding box y max\n} as const;\n\n/**\n * Parse MVAR table\n */\nexport function parseMvar(reader: Reader): MvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\treader.uint16(); // reserved\n\tconst valueRecordSize = reader.uint16();\n\tconst valueRecordCount = reader.uint16();\n\tconst itemVariationStoreOffset = reader.offset16();\n\n\t// Parse value records\n\tconst valueRecords: MvarValueRecord[] = [];\n\tfor (let i = 0; i < valueRecordCount; i++) {\n\t\tvalueRecords.push({\n\t\t\tvalueTag: reader.tag(),\n\t\t\tdeltaSetOuterIndex: reader.uint16(),\n\t\t\tdeltaSetInnerIndex: reader.uint16(),\n\t\t});\n\t\t// Skip any additional bytes if valueRecordSize > 8\n\t\tif (valueRecordSize > 8) {\n\t\t\treader.skip(valueRecordSize - 8);\n\t\t}\n\t}\n\n\t// Parse item variation store\n\tconst itemVariationStore = parseItemVariationStore(\n\t\treader.sliceFrom(itemVariationStoreOffset),\n\t);\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\titemVariationStore,\n\t\tvalueRecords,\n\t};\n}\n\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.offset32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: uint32[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.offset32());\n\t}\n\n\t// Parse variation regions\n\tconst regionReader = reader.sliceFrom(variationRegionListOffset);\n\tconst axisCount = regionReader.uint16();\n\tconst regionCount = regionReader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: {\n\t\t\tstartCoord: number;\n\t\t\tpeakCoord: number;\n\t\t\tendCoord: number;\n\t\t}[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: regionReader.f2dot14(),\n\t\t\t\tpeakCoord: regionReader.f2dot14(),\n\t\t\t\tendCoord: regionReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data\n\tconst itemVariationData: {\n\t\titemCount: uint16;\n\t\tregionIndexes: uint16[];\n\t\tdeltaSets: number[][];\n\t}[] = [];\n\tfor (let i = 0; i < itemVariationDataOffsets.length; i++) {\n\t\tconst offset = itemVariationDataOffsets[i]!;\n\t\tconst dataReader = reader.sliceFrom(offset);\n\t\tconst itemCount = dataReader.uint16();\n\t\tconst wordDeltaCount = dataReader.uint16();\n\t\tconst regionIndexCount = dataReader.uint16();\n\n\t\tconst regionIndexes: uint16[] = [];\n\t\tfor (let i = 0; i < regionIndexCount; i++) {\n\t\t\tregionIndexes.push(dataReader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\t\tconst shortCount = regionIndexCount - wordCount;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let i = 0; i < itemCount; i++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\t// Read word-sized deltas\n\t\t\tfor (let j = 0; j < wordCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int32());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read short-sized deltas\n\t\t\tfor (let j = 0; j < shortCount; j++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({ itemCount, regionIndexes, deltaSets });\n\t}\n\n\treturn { format, variationRegions, itemVariationData };\n}\n\n/**\n * Get metric delta by tag\n */\nexport function getMetricDelta(\n\tmvar: MvarTable,\n\tvalueTag: Tag,\n\tcoords: number[],\n): number {\n\t// Find value record for this tag\n\tconst record = mvar.valueRecords.find((r) => r.valueTag === valueTag);\n\tif (!record) return 0;\n\n\tconst outer = record.deltaSetOuterIndex;\n\tconst inner = record.deltaSetInnerIndex;\n\n\tconst varData = mvar.itemVariationStore.itemVariationData[outer];\n\tif (!varData || inner >= varData.itemCount) {\n\t\treturn 0;\n\t}\n\n\tconst deltaSet = varData.deltaSets[inner];\n\tif (!deltaSet) {\n\t\treturn 0;\n\t}\n\n\t// Calculate total delta\n\tlet delta = 0;\n\tfor (let i = 0; i < varData.regionIndexes.length; i++) {\n\t\tconst regionIndex = varData.regionIndexes[i]!;\n\t\tconst region = mvar.itemVariationStore.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\tconst scalar = calculateRegionScalar(region, coords);\n\t\tconst regionDelta = deltaSet[i] ?? 0;\n\t\tdelta += scalar * regionDelta;\n\t}\n\n\treturn Math.round(delta);\n}\n\n/**\n * Get horizontal ascender delta\n */\nexport function getHAscenderDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.hasc, coords);\n}\n\n/**\n * Get horizontal descender delta\n */\nexport function getHDescenderDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.hdsc, coords);\n}\n\n/**\n * Get horizontal line gap delta\n */\nexport function getHLineGapDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.hlgp, coords);\n}\n\n/**\n * Get x-height delta\n */\nexport function getXHeightDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.xhgt, coords);\n}\n\n/**\n * Get cap height delta\n */\nexport function getCapHeightDelta(mvar: MvarTable, coords: number[]): number {\n\treturn getMetricDelta(mvar, MvarTags.cpht, coords);\n}\n\n/**\n * Get underline offset delta\n */\nexport function getUnderlineOffsetDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.undo, coords);\n}\n\n/**\n * Get underline size delta\n */\nexport function getUnderlineSizeDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.unds, coords);\n}\n\n/**\n * Get strikeout offset delta\n */\nexport function getStrikeoutOffsetDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.stro, coords);\n}\n\n/**\n * Get strikeout size delta\n */\nexport function getStrikeoutSizeDelta(\n\tmvar: MvarTable,\n\tcoords: number[],\n): number {\n\treturn getMetricDelta(mvar, MvarTags.strs, coords);\n}\n",
    "import type { uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Name IDs */\nexport const NameId = {\n\tCopyright: 0,\n\tFontFamily: 1,\n\tFontSubfamily: 2,\n\tUniqueID: 3,\n\tFullName: 4,\n\tVersion: 5,\n\tPostScriptName: 6,\n\tTrademark: 7,\n\tManufacturer: 8,\n\tDesigner: 9,\n\tDescription: 10,\n\tManufacturerURL: 11,\n\tDesignerURL: 12,\n\tLicense: 13,\n\tLicenseURL: 14,\n\tReserved: 15,\n\tTypographicFamily: 16,\n\tTypographicSubfamily: 17,\n\tCompatibleFullName: 18,\n\tSampleText: 19,\n\tPostScriptCIDFindfontName: 20,\n\tWWSFamily: 21,\n\tWWSSubfamily: 22,\n\tLightBackgroundPalette: 23,\n\tDarkBackgroundPalette: 24,\n\tVariationsPostScriptNamePrefix: 25,\n} as const;\n\n/** Platform IDs */\nexport const PlatformId = {\n\tUnicode: 0,\n\tMacintosh: 1,\n\tReserved: 2,\n\tWindows: 3,\n} as const;\n\n/** Windows encoding IDs */\nexport const WindowsEncodingId = {\n\tSymbol: 0,\n\tUnicodeBMP: 1,\n\tShiftJIS: 2,\n\tPRC: 3,\n\tBig5: 4,\n\tWansung: 5,\n\tJohab: 6,\n\tUnicodeFullRepertoire: 10,\n} as const;\n\n/** A single name record */\nexport interface NameRecord {\n\tplatformId: uint16;\n\tencodingId: uint16;\n\tlanguageId: uint16;\n\tnameId: uint16;\n\tvalue: string;\n}\n\n/** Name table */\nexport interface NameTable {\n\tformat: uint16;\n\trecords: NameRecord[];\n}\n\n/**\n * Parse name table - font naming information in multiple languages\n * @param reader - Reader positioned at start of name table\n * @returns Parsed name table with decoded name records\n */\nexport function parseName(reader: Reader): NameTable {\n\tconst format = reader.uint16();\n\tconst count = reader.uint16();\n\tconst stringOffset = reader.uint16();\n\n\tconst records: NameRecord[] = [];\n\n\t// Parse name records\n\tconst recordData: Array<{\n\t\tplatformId: uint16;\n\t\tencodingId: uint16;\n\t\tlanguageId: uint16;\n\t\tnameId: uint16;\n\t\tlength: uint16;\n\t\toffset: uint16;\n\t}> = [];\n\n\tfor (let i = 0; i < count; i++) {\n\t\trecordData.push({\n\t\t\tplatformId: reader.uint16(),\n\t\t\tencodingId: reader.uint16(),\n\t\t\tlanguageId: reader.uint16(),\n\t\t\tnameId: reader.uint16(),\n\t\t\tlength: reader.uint16(),\n\t\t\toffset: reader.uint16(),\n\t\t});\n\t}\n\n\t// Decode strings\n\tfor (let i = 0; i < recordData.length; i++) {\n\t\tconst rd = recordData[i]!;\n\t\tconst strReader = reader.sliceFrom(stringOffset + rd.offset);\n\t\tconst value = decodeNameString(\n\t\t\tstrReader,\n\t\t\trd.length,\n\t\t\trd.platformId,\n\t\t\trd.encodingId,\n\t\t);\n\n\t\tif (value !== null) {\n\t\t\trecords.push({\n\t\t\t\tplatformId: rd.platformId,\n\t\t\t\tencodingId: rd.encodingId,\n\t\t\t\tlanguageId: rd.languageId,\n\t\t\t\tnameId: rd.nameId,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn { format, records };\n}\n\n/** Decode name string based on platform and encoding */\nfunction decodeNameString(\n\treader: Reader,\n\tlength: number,\n\tplatformId: number,\n\tencodingId: number,\n): string | null {\n\t// Unicode platform or Windows platform with Unicode encoding\n\tif (\n\t\tplatformId === PlatformId.Unicode ||\n\t\t(platformId === PlatformId.Windows &&\n\t\t\t(encodingId === 1 || encodingId === 10))\n\t) {\n\t\t// UTF-16BE\n\t\tconst chars: string[] = [];\n\t\tfor (let i = 0; i < length; i += 2) {\n\t\t\tconst code = reader.uint16();\n\t\t\tchars.push(String.fromCharCode(code));\n\t\t}\n\t\treturn chars.join(\"\");\n\t}\n\n\t// Macintosh Roman (basic ASCII-compatible)\n\tif (platformId === PlatformId.Macintosh && encodingId === 0) {\n\t\tconst bytes: number[] = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tbytes.push(reader.uint8());\n\t\t}\n\t\t// Simple ASCII decoding for Mac Roman (limited support)\n\t\treturn String.fromCharCode(...bytes);\n\t}\n\n\t// Skip unsupported encodings\n\treturn null;\n}\n\n/** Get a specific name by ID, preferring Windows Unicode */\nexport function getNameById(\n\ttable: NameTable,\n\tnameId: number,\n\tlanguageId?: number,\n): string | null {\n\t// Prefer Windows Unicode (platform 3, encoding 1)\n\tfor (let i = 0; i < table.records.length; i++) {\n\t\tconst record = table.records[i]!;\n\t\tif (record.nameId !== nameId) continue;\n\t\tif (record.platformId === PlatformId.Windows && record.encodingId === 1) {\n\t\t\tif (languageId === undefined || record.languageId === languageId) {\n\t\t\t\treturn record.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to Unicode platform\n\tfor (let i = 0; i < table.records.length; i++) {\n\t\tconst record = table.records[i]!;\n\t\tif (record.nameId !== nameId) continue;\n\t\tif (record.platformId === PlatformId.Unicode) {\n\t\t\tif (languageId === undefined || record.languageId === languageId) {\n\t\t\t\treturn record.value;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to any platform\n\tfor (let i = 0; i < table.records.length; i++) {\n\t\tconst record = table.records[i]!;\n\t\tif (record.nameId !== nameId) continue;\n\t\tif (languageId === undefined || record.languageId === languageId) {\n\t\t\treturn record.value;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/** Get font family name */\nexport function getFontFamily(table: NameTable): string | null {\n\t// Prefer typographic family (16) over basic family (1)\n\treturn (\n\t\tgetNameById(table, NameId.TypographicFamily) ??\n\t\tgetNameById(table, NameId.FontFamily)\n\t);\n}\n\n/** Get font subfamily (style) */\nexport function getFontSubfamily(table: NameTable): string | null {\n\treturn (\n\t\tgetNameById(table, NameId.TypographicSubfamily) ??\n\t\tgetNameById(table, NameId.FontSubfamily)\n\t);\n}\n\n/** Get full font name */\nexport function getFullName(table: NameTable): string | null {\n\treturn getNameById(table, NameId.FullName);\n}\n\n/** Get PostScript name */\nexport function getPostScriptName(table: NameTable): string | null {\n\treturn getNameById(table, NameId.PostScriptName);\n}\n\n/** Get version string */\nexport function getVersion(table: NameTable): string | null {\n\treturn getNameById(table, NameId.Version);\n}\n",
    "import type { int16, uint8, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * OS/2 table - Font metrics and classification\n * Contains Windows-specific metrics and font embedding information\n */\nexport interface Os2Table {\n\tversion: uint16;\n\txAvgCharWidth: int16;\n\tusWeightClass: uint16;\n\tusWidthClass: uint16;\n\tfsType: uint16;\n\tySubscriptXSize: int16;\n\tySubscriptYSize: int16;\n\tySubscriptXOffset: int16;\n\tySubscriptYOffset: int16;\n\tySuperscriptXSize: int16;\n\tySuperscriptYSize: int16;\n\tySuperscriptXOffset: int16;\n\tySuperscriptYOffset: int16;\n\tyStrikeoutSize: int16;\n\tyStrikeoutPosition: int16;\n\tsFamilyClass: int16;\n\tpanose: uint8[];\n\tulUnicodeRange1: uint32;\n\tulUnicodeRange2: uint32;\n\tulUnicodeRange3: uint32;\n\tulUnicodeRange4: uint32;\n\tachVendID: string;\n\tfsSelection: uint16;\n\tusFirstCharIndex: uint16;\n\tusLastCharIndex: uint16;\n\tsTypoAscender: int16;\n\tsTypoDescender: int16;\n\tsTypoLineGap: int16;\n\tusWinAscent: uint16;\n\tusWinDescent: uint16;\n\t// Version 1+\n\tulCodePageRange1?: uint32;\n\tulCodePageRange2?: uint32;\n\t// Version 2+\n\tsxHeight?: int16;\n\tsCapHeight?: int16;\n\tusDefaultChar?: uint16;\n\tusBreakChar?: uint16;\n\tusMaxContext?: uint16;\n\t// Version 5+\n\tusLowerOpticalPointSize?: uint16;\n\tusUpperOpticalPointSize?: uint16;\n}\n\n/** Weight class constants */\nexport const WeightClass = {\n\tThin: 100,\n\tExtraLight: 200,\n\tLight: 300,\n\tNormal: 400,\n\tMedium: 500,\n\tSemiBold: 600,\n\tBold: 700,\n\tExtraBold: 800,\n\tBlack: 900,\n} as const;\n\n/** Width class constants */\nexport const WidthClass = {\n\tUltraCondensed: 1,\n\tExtraCondensed: 2,\n\tCondensed: 3,\n\tSemiCondensed: 4,\n\tNormal: 5,\n\tSemiExpanded: 6,\n\tExpanded: 7,\n\tExtraExpanded: 8,\n\tUltraExpanded: 9,\n} as const;\n\n/** Font selection flags (fsSelection) */\nexport const FsSelection = {\n\tItalic: 0x0001,\n\tUnderscore: 0x0002,\n\tNegative: 0x0004,\n\tOutlined: 0x0008,\n\tStrikeout: 0x0010,\n\tBold: 0x0020,\n\tRegular: 0x0040,\n\tUseTypoMetrics: 0x0080,\n\tWWS: 0x0100,\n\tOblique: 0x0200,\n} as const;\n\n/** Font embedding permissions (fsType) */\nexport const FsType = {\n\tInstallableEmbedding: 0x0000,\n\tRestrictedLicense: 0x0002,\n\tPreviewAndPrint: 0x0004,\n\tEditable: 0x0008,\n\tNoSubsetting: 0x0100,\n\tBitmapOnly: 0x0200,\n} as const;\n\n/**\n * Parse OS/2 table - Windows-specific metrics, weight, width, and classification\n * @param reader - Reader positioned at start of OS/2 table\n * @returns Parsed OS/2 table\n */\nexport function parseOs2(reader: Reader): Os2Table {\n\tconst version = reader.uint16();\n\tconst xAvgCharWidth = reader.int16();\n\tconst usWeightClass = reader.uint16();\n\tconst usWidthClass = reader.uint16();\n\tconst fsType = reader.uint16();\n\tconst ySubscriptXSize = reader.int16();\n\tconst ySubscriptYSize = reader.int16();\n\tconst ySubscriptXOffset = reader.int16();\n\tconst ySubscriptYOffset = reader.int16();\n\tconst ySuperscriptXSize = reader.int16();\n\tconst ySuperscriptYSize = reader.int16();\n\tconst ySuperscriptXOffset = reader.int16();\n\tconst ySuperscriptYOffset = reader.int16();\n\tconst yStrikeoutSize = reader.int16();\n\tconst yStrikeoutPosition = reader.int16();\n\tconst sFamilyClass = reader.int16();\n\n\t// PANOSE classification (10 bytes)\n\tconst panose: uint8[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tpanose.push(reader.uint8());\n\t}\n\n\tconst ulUnicodeRange1 = reader.uint32();\n\tconst ulUnicodeRange2 = reader.uint32();\n\tconst ulUnicodeRange3 = reader.uint32();\n\tconst ulUnicodeRange4 = reader.uint32();\n\n\t// Vendor ID (4 bytes as ASCII)\n\tconst achVendID = String.fromCharCode(\n\t\treader.uint8(),\n\t\treader.uint8(),\n\t\treader.uint8(),\n\t\treader.uint8(),\n\t);\n\n\tconst fsSelection = reader.uint16();\n\tconst usFirstCharIndex = reader.uint16();\n\tconst usLastCharIndex = reader.uint16();\n\tconst sTypoAscender = reader.int16();\n\tconst sTypoDescender = reader.int16();\n\tconst sTypoLineGap = reader.int16();\n\tconst usWinAscent = reader.uint16();\n\tconst usWinDescent = reader.uint16();\n\n\tconst result: Os2Table = {\n\t\tversion,\n\t\txAvgCharWidth,\n\t\tusWeightClass,\n\t\tusWidthClass,\n\t\tfsType,\n\t\tySubscriptXSize,\n\t\tySubscriptYSize,\n\t\tySubscriptXOffset,\n\t\tySubscriptYOffset,\n\t\tySuperscriptXSize,\n\t\tySuperscriptYSize,\n\t\tySuperscriptXOffset,\n\t\tySuperscriptYOffset,\n\t\tyStrikeoutSize,\n\t\tyStrikeoutPosition,\n\t\tsFamilyClass,\n\t\tpanose,\n\t\tulUnicodeRange1,\n\t\tulUnicodeRange2,\n\t\tulUnicodeRange3,\n\t\tulUnicodeRange4,\n\t\tachVendID,\n\t\tfsSelection,\n\t\tusFirstCharIndex,\n\t\tusLastCharIndex,\n\t\tsTypoAscender,\n\t\tsTypoDescender,\n\t\tsTypoLineGap,\n\t\tusWinAscent,\n\t\tusWinDescent,\n\t};\n\n\t// Version 1+ fields\n\tif (version >= 1) {\n\t\tresult.ulCodePageRange1 = reader.uint32();\n\t\tresult.ulCodePageRange2 = reader.uint32();\n\t}\n\n\t// Version 2+ fields\n\tif (version >= 2) {\n\t\tresult.sxHeight = reader.int16();\n\t\tresult.sCapHeight = reader.int16();\n\t\tresult.usDefaultChar = reader.uint16();\n\t\tresult.usBreakChar = reader.uint16();\n\t\tresult.usMaxContext = reader.uint16();\n\t}\n\n\t// Version 5+ fields\n\tif (version >= 5) {\n\t\tresult.usLowerOpticalPointSize = reader.uint16();\n\t\tresult.usUpperOpticalPointSize = reader.uint16();\n\t}\n\n\treturn result;\n}\n\n/** Check if font is italic */\nexport function isItalic(os2: Os2Table): boolean {\n\treturn (os2.fsSelection & FsSelection.Italic) !== 0;\n}\n\n/** Check if font is bold */\nexport function isBold(os2: Os2Table): boolean {\n\treturn (os2.fsSelection & FsSelection.Bold) !== 0;\n}\n\n/** Check if USE_TYPO_METRICS flag is set */\nexport function useTypoMetrics(os2: Os2Table): boolean {\n\treturn (os2.fsSelection & FsSelection.UseTypoMetrics) !== 0;\n}\n\n/** Get embedding permission level */\nexport function getEmbeddingPermission(\n\tos2: Os2Table,\n): \"installable\" | \"restricted\" | \"preview\" | \"editable\" {\n\tconst fsType = os2.fsType;\n\tif ((fsType & FsType.RestrictedLicense) !== 0) return \"restricted\";\n\tif ((fsType & FsType.PreviewAndPrint) !== 0) return \"preview\";\n\tif ((fsType & FsType.Editable) !== 0) return \"editable\";\n\treturn \"installable\";\n}\n",
    "import type { int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * post table - PostScript font information\n * Contains additional PostScript info like glyph names and italic angle\n */\nexport interface PostTable {\n\tversion: number;\n\titalicAngle: number;\n\tunderlinePosition: int16;\n\tunderlineThickness: int16;\n\tisFixedPitch: uint32;\n\tminMemType42: uint32;\n\tmaxMemType42: uint32;\n\tminMemType1: uint32;\n\tmaxMemType1: uint32;\n\t// Version 2.0 only\n\tnumberOfGlyphs?: uint16;\n\tglyphNameIndex?: uint16[];\n\tnames?: string[];\n}\n\n/** Standard PostScript glyph names (first 258) */\nconst standardNames: string[] = [\n\t\".notdef\",\n\t\".null\",\n\t\"nonmarkingreturn\",\n\t\"space\",\n\t\"exclam\",\n\t\"quotedbl\",\n\t\"numbersign\",\n\t\"dollar\",\n\t\"percent\",\n\t\"ampersand\",\n\t\"quotesingle\",\n\t\"parenleft\",\n\t\"parenright\",\n\t\"asterisk\",\n\t\"plus\",\n\t\"comma\",\n\t\"hyphen\",\n\t\"period\",\n\t\"slash\",\n\t\"zero\",\n\t\"one\",\n\t\"two\",\n\t\"three\",\n\t\"four\",\n\t\"five\",\n\t\"six\",\n\t\"seven\",\n\t\"eight\",\n\t\"nine\",\n\t\"colon\",\n\t\"semicolon\",\n\t\"less\",\n\t\"equal\",\n\t\"greater\",\n\t\"question\",\n\t\"at\",\n\t\"A\",\n\t\"B\",\n\t\"C\",\n\t\"D\",\n\t\"E\",\n\t\"F\",\n\t\"G\",\n\t\"H\",\n\t\"I\",\n\t\"J\",\n\t\"K\",\n\t\"L\",\n\t\"M\",\n\t\"N\",\n\t\"O\",\n\t\"P\",\n\t\"Q\",\n\t\"R\",\n\t\"S\",\n\t\"T\",\n\t\"U\",\n\t\"V\",\n\t\"W\",\n\t\"X\",\n\t\"Y\",\n\t\"Z\",\n\t\"bracketleft\",\n\t\"backslash\",\n\t\"bracketright\",\n\t\"asciicircum\",\n\t\"underscore\",\n\t\"grave\",\n\t\"a\",\n\t\"b\",\n\t\"c\",\n\t\"d\",\n\t\"e\",\n\t\"f\",\n\t\"g\",\n\t\"h\",\n\t\"i\",\n\t\"j\",\n\t\"k\",\n\t\"l\",\n\t\"m\",\n\t\"n\",\n\t\"o\",\n\t\"p\",\n\t\"q\",\n\t\"r\",\n\t\"s\",\n\t\"t\",\n\t\"u\",\n\t\"v\",\n\t\"w\",\n\t\"x\",\n\t\"y\",\n\t\"z\",\n\t\"braceleft\",\n\t\"bar\",\n\t\"braceright\",\n\t\"asciitilde\",\n\t\"Adieresis\",\n\t\"Aring\",\n\t\"Ccedilla\",\n\t\"Eacute\",\n\t\"Ntilde\",\n\t\"Odieresis\",\n\t\"Udieresis\",\n\t\"aacute\",\n\t\"agrave\",\n\t\"acircumflex\",\n\t\"adieresis\",\n\t\"atilde\",\n\t\"aring\",\n\t\"ccedilla\",\n\t\"eacute\",\n\t\"egrave\",\n\t\"ecircumflex\",\n\t\"edieresis\",\n\t\"iacute\",\n\t\"igrave\",\n\t\"icircumflex\",\n\t\"idieresis\",\n\t\"ntilde\",\n\t\"oacute\",\n\t\"ograve\",\n\t\"ocircumflex\",\n\t\"odieresis\",\n\t\"otilde\",\n\t\"uacute\",\n\t\"ugrave\",\n\t\"ucircumflex\",\n\t\"udieresis\",\n\t\"dagger\",\n\t\"degree\",\n\t\"cent\",\n\t\"sterling\",\n\t\"section\",\n\t\"bullet\",\n\t\"paragraph\",\n\t\"germandbls\",\n\t\"registered\",\n\t\"copyright\",\n\t\"trademark\",\n\t\"acute\",\n\t\"dieresis\",\n\t\"notequal\",\n\t\"AE\",\n\t\"Oslash\",\n\t\"infinity\",\n\t\"plusminus\",\n\t\"lessequal\",\n\t\"greaterequal\",\n\t\"yen\",\n\t\"mu\",\n\t\"partialdiff\",\n\t\"summation\",\n\t\"product\",\n\t\"pi\",\n\t\"integral\",\n\t\"ordfeminine\",\n\t\"ordmasculine\",\n\t\"Omega\",\n\t\"ae\",\n\t\"oslash\",\n\t\"questiondown\",\n\t\"exclamdown\",\n\t\"logicalnot\",\n\t\"radical\",\n\t\"florin\",\n\t\"approxequal\",\n\t\"Delta\",\n\t\"guillemotleft\",\n\t\"guillemotright\",\n\t\"ellipsis\",\n\t\"nonbreakingspace\",\n\t\"Agrave\",\n\t\"Atilde\",\n\t\"Otilde\",\n\t\"OE\",\n\t\"oe\",\n\t\"endash\",\n\t\"emdash\",\n\t\"quotedblleft\",\n\t\"quotedblright\",\n\t\"quoteleft\",\n\t\"quoteright\",\n\t\"divide\",\n\t\"lozenge\",\n\t\"ydieresis\",\n\t\"Ydieresis\",\n\t\"fraction\",\n\t\"currency\",\n\t\"guilsinglleft\",\n\t\"guilsinglright\",\n\t\"fi\",\n\t\"fl\",\n\t\"daggerdbl\",\n\t\"periodcentered\",\n\t\"quotesinglbase\",\n\t\"quotedblbase\",\n\t\"perthousand\",\n\t\"Acircumflex\",\n\t\"Ecircumflex\",\n\t\"Aacute\",\n\t\"Edieresis\",\n\t\"Egrave\",\n\t\"Iacute\",\n\t\"Icircumflex\",\n\t\"Idieresis\",\n\t\"Igrave\",\n\t\"Oacute\",\n\t\"Ocircumflex\",\n\t\"apple\",\n\t\"Ograve\",\n\t\"Uacute\",\n\t\"Ucircumflex\",\n\t\"Ugrave\",\n\t\"dotlessi\",\n\t\"circumflex\",\n\t\"tilde\",\n\t\"macron\",\n\t\"breve\",\n\t\"dotaccent\",\n\t\"ring\",\n\t\"cedilla\",\n\t\"hungarumlaut\",\n\t\"ogonek\",\n\t\"caron\",\n\t\"Lslash\",\n\t\"lslash\",\n\t\"Scaron\",\n\t\"scaron\",\n\t\"Zcaron\",\n\t\"zcaron\",\n\t\"brokenbar\",\n\t\"Eth\",\n\t\"eth\",\n\t\"Yacute\",\n\t\"yacute\",\n\t\"Thorn\",\n\t\"thorn\",\n\t\"minus\",\n\t\"multiply\",\n\t\"onesuperior\",\n\t\"twosuperior\",\n\t\"threesuperior\",\n\t\"onehalf\",\n\t\"onequarter\",\n\t\"threequarters\",\n\t\"franc\",\n\t\"Gbreve\",\n\t\"gbreve\",\n\t\"Idotaccent\",\n\t\"Scedilla\",\n\t\"scedilla\",\n\t\"Cacute\",\n\t\"cacute\",\n\t\"Ccaron\",\n\t\"ccaron\",\n\t\"dcroat\",\n];\n\n/**\n * Parse post table - PostScript information including glyph names\n * @param reader - Reader positioned at start of post table\n * @returns Parsed post table\n */\nexport function parsePost(reader: Reader): PostTable {\n\tconst versionMajor = reader.uint16();\n\tconst versionMinor = reader.uint16();\n\tconst version = versionMajor + versionMinor / 0x10000;\n\n\tconst italicAngle = reader.fixed();\n\tconst underlinePosition = reader.int16();\n\tconst underlineThickness = reader.int16();\n\tconst isFixedPitch = reader.uint32();\n\tconst minMemType42 = reader.uint32();\n\tconst maxMemType42 = reader.uint32();\n\tconst minMemType1 = reader.uint32();\n\tconst maxMemType1 = reader.uint32();\n\n\tconst result: PostTable = {\n\t\tversion,\n\t\titalicAngle,\n\t\tunderlinePosition,\n\t\tunderlineThickness,\n\t\tisFixedPitch,\n\t\tminMemType42,\n\t\tmaxMemType42,\n\t\tminMemType1,\n\t\tmaxMemType1,\n\t};\n\n\t// Version 2.0: includes glyph names\n\tif (version === 2.0) {\n\t\tconst numberOfGlyphs = reader.uint16();\n\t\tconst glyphNameIndex: uint16[] = [];\n\n\t\tfor (let i = 0; i < numberOfGlyphs; i++) {\n\t\t\tglyphNameIndex.push(reader.uint16());\n\t\t}\n\n\t\t// Collect custom names (indexes >= 258)\n\t\tconst customNames: string[] = [];\n\t\tlet maxIndex = 0;\n\t\tfor (let i = 0; i < glyphNameIndex.length; i++) {\n\t\t\tconst idx = glyphNameIndex[i]!;\n\t\t\tif (idx >= 258 && idx > maxIndex) {\n\t\t\t\tmaxIndex = idx;\n\t\t\t}\n\t\t}\n\n\t\t// Read custom names\n\t\tconst numCustomNames = maxIndex >= 258 ? maxIndex - 257 : 0;\n\t\tfor (let i = 0; i < numCustomNames; i++) {\n\t\t\tconst length = reader.uint8();\n\t\t\tconst chars: string[] = [];\n\t\t\tfor (let j = 0; j < length; j++) {\n\t\t\t\tchars.push(String.fromCharCode(reader.uint8()));\n\t\t\t}\n\t\t\tcustomNames.push(chars.join(\"\"));\n\t\t}\n\n\t\tresult.numberOfGlyphs = numberOfGlyphs;\n\t\tresult.glyphNameIndex = glyphNameIndex;\n\t\tresult.names = customNames;\n\t}\n\n\treturn result;\n}\n\n/** Get glyph name by glyph ID */\nexport function getGlyphName(post: PostTable, glyphId: number): string | null {\n\t// Version 1: standard 258 names\n\tif (post.version === 1.0) {\n\t\tconst name = standardNames[glyphId];\n\t\treturn name !== undefined ? name : null;\n\t}\n\n\t// Version 2: indexed names\n\tif (post.version === 2.0 && post.glyphNameIndex) {\n\t\tconst index = post.glyphNameIndex[glyphId];\n\t\tif (index === undefined) return null;\n\n\t\t// Standard name\n\t\tif (index < 258) {\n\t\t\treturn standardNames[index] ?? null;\n\t\t}\n\n\t\t// Custom name\n\t\tconst customIndex = index - 258;\n\t\treturn post.names?.[customIndex] ?? null;\n\t}\n\n\t// Version 3: no names stored\n\treturn null;\n}\n\n/** Check if font is monospaced */\nexport function isMonospaced(post: PostTable): boolean {\n\treturn post.isFixedPitch !== 0;\n}\n",
    "import type { GlyphId, int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Standard Bitmap Graphics table (sbix)\n * Apple's bitmap/PNG glyph table for color emoji and bitmap fonts\n */\nexport interface SbixTable {\n\tversion: uint16;\n\tflags: uint16;\n\tstrikes: SbixStrike[];\n}\n\n/**\n * Strike (bitmap size) in sbix\n */\nexport interface SbixStrike {\n\tppem: uint16;\n\tppi: uint16;\n\tglyphData: Map<GlyphId, SbixGlyph>;\n}\n\n/**\n * Glyph data in sbix\n */\nexport interface SbixGlyph {\n\toriginOffsetX: int16;\n\toriginOffsetY: int16;\n\tgraphicType: string; // 4-char tag: 'png ', 'jpg ', 'tiff', 'pdf ', etc.\n\tdata: Uint8Array;\n}\n\n/**\n * Common graphic types in sbix\n */\nexport const SbixGraphicType = {\n\tPNG: \"png \",\n\tJPG: \"jpg \",\n\tTIFF: \"tiff\",\n\tPDF: \"pdf \",\n\tMASK: \"mask\", // Mask for another glyph\n\tDUPE: \"dupe\", // Duplicate of another glyph (data is glyph ID)\n} as const;\n\n/**\n * Parse sbix table\n */\nexport function parseSbix(reader: Reader, numGlyphs: number): SbixTable {\n\tconst tableStart = reader.offset;\n\tconst version = reader.uint16();\n\tconst flags = reader.uint16();\n\tconst numStrikes = reader.uint32();\n\n\t// Read strike offsets\n\tconst strikeOffsets: uint32[] = [];\n\tfor (let i = 0; i < numStrikes; i++) {\n\t\tstrikeOffsets.push(reader.uint32());\n\t}\n\n\t// Parse each strike\n\tconst strikes: SbixStrike[] = [];\n\tfor (let i = 0; i < strikeOffsets.length; i++) {\n\t\tconst strikeOffset = strikeOffsets[i]!;\n\t\tconst strike = parseStrike(reader, tableStart + strikeOffset, numGlyphs);\n\t\tstrikes.push(strike);\n\t}\n\n\treturn { version, flags, strikes };\n}\n\nfunction parseStrike(\n\treader: Reader,\n\tstrikeOffset: number,\n\tnumGlyphs: number,\n): SbixStrike {\n\tconst strikeReader = reader.sliceFrom(strikeOffset);\n\tconst ppem = strikeReader.uint16();\n\tconst ppi = strikeReader.uint16();\n\n\t// Read glyph data offsets (numGlyphs + 1 for sentinel)\n\tconst glyphDataOffsets: uint32[] = [];\n\tfor (let i = 0; i <= numGlyphs; i++) {\n\t\tglyphDataOffsets.push(strikeReader.uint32());\n\t}\n\n\t// Parse glyph data\n\tconst glyphData = new Map<GlyphId, SbixGlyph>();\n\n\tfor (let glyphId = 0; glyphId < numGlyphs; glyphId++) {\n\t\tconst offset = glyphDataOffsets[glyphId];\n\t\tconst nextOffset = glyphDataOffsets[glyphId + 1];\n\t\tif (offset === undefined || nextOffset === undefined) continue;\n\t\tconst dataLength = nextOffset - offset;\n\n\t\tif (dataLength <= 8) {\n\t\t\t// No data or just header (minimum is 8 bytes for header)\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst glyphReader = reader.sliceFrom(strikeOffset + offset);\n\t\tconst originOffsetX = glyphReader.int16();\n\t\tconst originOffsetY = glyphReader.int16();\n\t\tconst graphicType = glyphReader.tagString();\n\n\t\t// Read actual image data\n\t\tconst imageDataLength = dataLength - 8;\n\t\tconst data = glyphReader.bytes(imageDataLength);\n\n\t\tglyphData.set(glyphId, {\n\t\t\toriginOffsetX,\n\t\t\toriginOffsetY,\n\t\t\tgraphicType,\n\t\t\tdata,\n\t\t});\n\t}\n\n\treturn { ppem, ppi, glyphData };\n}\n\n/**\n * Get glyph bitmap for a specific ppem\n * Returns the best matching strike\n */\nexport function getGlyphBitmap(\n\tsbix: SbixTable,\n\tglyphId: GlyphId,\n\tppem: number,\n): SbixGlyph | null {\n\t// Find best matching strike\n\tlet bestStrike: SbixStrike | null = null;\n\tlet bestDiff = Infinity;\n\n\tfor (let i = 0; i < sbix.strikes.length; i++) {\n\t\tconst strike = sbix.strikes[i]!;\n\t\tconst diff = Math.abs(strike.ppem - ppem);\n\t\tif (diff < bestDiff) {\n\t\t\tbestDiff = diff;\n\t\t\tbestStrike = strike;\n\t\t}\n\t}\n\n\tif (!bestStrike) return null;\n\n\treturn bestStrike.glyphData.get(glyphId) ?? null;\n}\n\n/**\n * Get exact ppem strike\n */\nexport function getStrikeForPpem(\n\tsbix: SbixTable,\n\tppem: number,\n): SbixStrike | null {\n\treturn sbix.strikes.find((s) => s.ppem === ppem) ?? null;\n}\n\n/**\n * Get all available ppem sizes\n */\nexport function getAvailablePpemSizes(sbix: SbixTable): number[] {\n\treturn sbix.strikes.map((s) => s.ppem).sort((a, b) => a - b);\n}\n\n/**\n * Check if glyph has bitmap data\n */\nexport function hasGlyphBitmap(\n\tsbix: SbixTable,\n\tglyphId: GlyphId,\n\tppem?: number,\n): boolean {\n\tif (ppem !== undefined) {\n\t\tconst strike = getStrikeForPpem(sbix, ppem);\n\t\treturn strike?.glyphData.has(glyphId) ?? false;\n\t}\n\n\t// Check any strike\n\tfor (let i = 0; i < sbix.strikes.length; i++) {\n\t\tconst strike = sbix.strikes[i]!;\n\t\tif (strike.glyphData.has(glyphId)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Resolve dupe graphic type\n * Returns the actual glyph data for duplicates\n */\nexport function resolveDupeGlyph(\n\tsbix: SbixTable,\n\tstrike: SbixStrike,\n\tglyph: SbixGlyph,\n): SbixGlyph | null {\n\tif (glyph.graphicType !== SbixGraphicType.DUPE) {\n\t\treturn glyph;\n\t}\n\n\t// Data contains the glyph ID to reference\n\tif (glyph.data.length < 2) return null;\n\n\tconst dupeGlyphId = ((glyph.data[0] ?? 0) << 8) | (glyph.data[1] ?? 0);\n\tconst resolved = strike.glyphData.get(dupeGlyphId);\n\n\tif (!resolved) return null;\n\n\t// Recursively resolve if it's also a dupe\n\tif (resolved.graphicType === SbixGraphicType.DUPE) {\n\t\treturn resolveDupeGlyph(sbix, strike, resolved);\n\t}\n\n\treturn resolved;\n}\n",
    "import type { TableRecord, Tag } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/** Supported sfnt version tags */\nconst SFNT_VERSION_TRUETYPE = 0x00010000; // TrueType\nconst SFNT_VERSION_OPENTYPE = 0x4f54544f; // 'OTTO' - CFF\nconst SFNT_VERSION_TRUE = 0x74727565; // 'true' - Apple TrueType\n\n/** Font directory containing table records */\nexport interface FontDirectory {\n\tsfntVersion: number;\n\tnumTables: number;\n\tsearchRange: number;\n\tentrySelector: number;\n\trangeShift: number;\n\ttables: Map<Tag, TableRecord>;\n}\n\n/**\n * Parse the sfnt font directory (table of contents).\n * This is the first thing read from any TrueType/OpenType font.\n */\nexport function parseFontDirectory(reader: Reader): FontDirectory {\n\tconst sfntVersion = reader.uint32();\n\n\t// Validate sfnt version\n\tif (\n\t\tsfntVersion !== SFNT_VERSION_TRUETYPE &&\n\t\tsfntVersion !== SFNT_VERSION_OPENTYPE &&\n\t\tsfntVersion !== SFNT_VERSION_TRUE\n\t) {\n\t\tthrow new Error(\n\t\t\t`Invalid sfnt version: 0x${sfntVersion.toString(16).padStart(8, \"0\")}`,\n\t\t);\n\t}\n\n\tconst numTables = reader.uint16();\n\tconst searchRange = reader.uint16();\n\tconst entrySelector = reader.uint16();\n\tconst rangeShift = reader.uint16();\n\n\tconst tables = new Map<Tag, TableRecord>();\n\n\tfor (let i = 0; i < numTables; i++) {\n\t\tconst tag = reader.tag();\n\t\tconst checksum = reader.uint32();\n\t\tconst offset = reader.uint32();\n\t\tconst length = reader.uint32();\n\n\t\ttables.set(tag, { tag, checksum, offset, length });\n\t}\n\n\treturn {\n\t\tsfntVersion,\n\t\tnumTables,\n\t\tsearchRange,\n\t\tentrySelector,\n\t\trangeShift,\n\t\ttables,\n\t};\n}\n\n/** Check if this is a TrueType font (vs CFF) */\nexport function isTrueType(directory: FontDirectory): boolean {\n\treturn (\n\t\tdirectory.sfntVersion === SFNT_VERSION_TRUETYPE ||\n\t\tdirectory.sfntVersion === SFNT_VERSION_TRUE\n\t);\n}\n\n/** Check if this is a CFF font */\nexport function isCFF(directory: FontDirectory): boolean {\n\treturn directory.sfntVersion === SFNT_VERSION_OPENTYPE;\n}\n",
    "import type { Tag, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Style Attributes table (STAT)\n * Provides style information for variable fonts\n * Used for font selection and naming\n */\nexport interface StatTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tdesignAxisCount: uint16;\n\tdesignAxes: AxisRecord[];\n\taxisValueCount: uint16;\n\taxisValues: AxisValue[];\n\telidedFallbackNameID?: uint16;\n}\n\n/**\n * Design axis record\n */\nexport interface AxisRecord {\n\taxisTag: Tag;\n\taxisNameID: uint16;\n\taxisOrdering: uint16;\n}\n\n/**\n * Axis value flags\n */\nexport const AxisValueFlags = {\n\tOlderSiblingFontAttribute: 0x0001,\n\tElidableAxisValueName: 0x0002,\n} as const;\n\n/**\n * Base axis value\n */\nexport interface AxisValueBase {\n\tformat: number;\n\taxisIndex: uint16;\n\tflags: uint16;\n\tvalueNameID: uint16;\n}\n\n/**\n * Format 1: Single axis value\n */\nexport interface AxisValueFormat1 extends AxisValueBase {\n\tformat: 1;\n\tvalue: number; // Fixed 16.16\n}\n\n/**\n * Format 2: Axis value range\n */\nexport interface AxisValueFormat2 extends AxisValueBase {\n\tformat: 2;\n\tnominalValue: number;\n\trangeMinValue: number;\n\trangeMaxValue: number;\n}\n\n/**\n * Format 3: Linked axis value\n */\nexport interface AxisValueFormat3 extends AxisValueBase {\n\tformat: 3;\n\tvalue: number;\n\tlinkedValue: number;\n}\n\n/**\n * Format 4: Multiple axis values\n */\nexport interface AxisValueFormat4 {\n\tformat: 4;\n\taxisCount: uint16;\n\tflags: uint16;\n\tvalueNameID: uint16;\n\taxisValues: { axisIndex: uint16; value: number }[];\n}\n\nexport type AxisValue =\n\t| AxisValueFormat1\n\t| AxisValueFormat2\n\t| AxisValueFormat3\n\t| AxisValueFormat4;\n\n/**\n * Parse STAT table\n */\nexport function parseStat(reader: Reader): StatTable {\n\tconst tableStart = reader.offset;\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst designAxisSize = reader.uint16();\n\tconst designAxisCount = reader.uint16();\n\tconst designAxesOffset = reader.offset32();\n\tconst axisValueCount = reader.uint16();\n\tconst axisValueArrayOffset = reader.offset32();\n\n\tlet elidedFallbackNameID: uint16 | undefined;\n\tif (majorVersion >= 1 && minorVersion >= 1) {\n\t\telidedFallbackNameID = reader.uint16();\n\t}\n\n\t// Parse design axes\n\tconst designAxes: AxisRecord[] = [];\n\tif (designAxesOffset !== 0) {\n\t\tconst axesReader = reader.sliceFrom(tableStart + designAxesOffset);\n\t\tfor (let i = 0; i < designAxisCount; i++) {\n\t\t\tdesignAxes.push({\n\t\t\t\taxisTag: axesReader.tag(),\n\t\t\t\taxisNameID: axesReader.uint16(),\n\t\t\t\taxisOrdering: axesReader.uint16(),\n\t\t\t});\n\t\t\t// Skip any additional bytes if designAxisSize > 8\n\t\t\tif (designAxisSize > 8) {\n\t\t\t\taxesReader.skip(designAxisSize - 8);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse axis values\n\tconst axisValues: AxisValue[] = [];\n\tif (axisValueArrayOffset !== 0 && axisValueCount > 0) {\n\t\tconst arrayReader = reader.sliceFrom(tableStart + axisValueArrayOffset);\n\n\t\t// Read axis value offsets\n\t\tconst axisValueOffsets: uint16[] = [];\n\t\tfor (let i = 0; i < axisValueCount; i++) {\n\t\t\taxisValueOffsets.push(arrayReader.uint16());\n\t\t}\n\n\t\t// Parse each axis value\n\t\tfor (let i = 0; i < axisValueOffsets.length; i++) {\n\t\t\tconst offset = axisValueOffsets[i]!;\n\t\t\tconst valueReader = reader.sliceFrom(\n\t\t\t\ttableStart + axisValueArrayOffset + offset,\n\t\t\t);\n\t\t\tconst axisValue = parseAxisValue(valueReader);\n\t\t\tif (axisValue) {\n\t\t\t\taxisValues.push(axisValue);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tdesignAxisCount,\n\t\tdesignAxes,\n\t\taxisValueCount,\n\t\taxisValues,\n\t\telidedFallbackNameID,\n\t};\n}\n\nfunction parseAxisValue(reader: Reader): AxisValue | null {\n\tconst format = reader.uint16();\n\n\tswitch (format) {\n\t\tcase 1: {\n\t\t\treturn {\n\t\t\t\tformat: 1,\n\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\tflags: reader.uint16(),\n\t\t\t\tvalueNameID: reader.uint16(),\n\t\t\t\tvalue: reader.fixed(),\n\t\t\t};\n\t\t}\n\t\tcase 2: {\n\t\t\treturn {\n\t\t\t\tformat: 2,\n\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\tflags: reader.uint16(),\n\t\t\t\tvalueNameID: reader.uint16(),\n\t\t\t\tnominalValue: reader.fixed(),\n\t\t\t\trangeMinValue: reader.fixed(),\n\t\t\t\trangeMaxValue: reader.fixed(),\n\t\t\t};\n\t\t}\n\t\tcase 3: {\n\t\t\treturn {\n\t\t\t\tformat: 3,\n\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\tflags: reader.uint16(),\n\t\t\t\tvalueNameID: reader.uint16(),\n\t\t\t\tvalue: reader.fixed(),\n\t\t\t\tlinkedValue: reader.fixed(),\n\t\t\t};\n\t\t}\n\t\tcase 4: {\n\t\t\tconst axisCount = reader.uint16();\n\t\t\tconst flags = reader.uint16();\n\t\t\tconst valueNameID = reader.uint16();\n\n\t\t\tconst axisValues: { axisIndex: uint16; value: number }[] = [];\n\t\t\tfor (let i = 0; i < axisCount; i++) {\n\t\t\t\taxisValues.push({\n\t\t\t\t\taxisIndex: reader.uint16(),\n\t\t\t\t\tvalue: reader.fixed(),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tformat: 4,\n\t\t\t\taxisCount,\n\t\t\t\tflags,\n\t\t\t\tvalueNameID,\n\t\t\t\taxisValues,\n\t\t\t};\n\t\t}\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Get axis record by tag\n */\nexport function getAxisRecord(\n\tstat: StatTable,\n\taxisTag: Tag,\n): AxisRecord | null {\n\treturn stat.designAxes.find((a) => a.axisTag === axisTag) ?? null;\n}\n\n/**\n * Get axis index by tag\n */\nexport function getAxisIndex(stat: StatTable, axisTag: Tag): number {\n\treturn stat.designAxes.findIndex((a) => a.axisTag === axisTag);\n}\n\n/**\n * Get axis values for a specific axis\n */\nexport function getAxisValuesForAxis(\n\tstat: StatTable,\n\taxisIndex: number,\n): AxisValue[] {\n\treturn stat.axisValues.filter((v) => {\n\t\tif (v.format === 4) {\n\t\t\treturn v.axisValues.some((av) => av.axisIndex === axisIndex);\n\t\t}\n\t\treturn v.axisIndex === axisIndex;\n\t});\n}\n\n/**\n * Find axis value by name ID\n */\nexport function findAxisValueByNameId(\n\tstat: StatTable,\n\tnameId: uint16,\n): AxisValue | null {\n\treturn stat.axisValues.find((v) => v.valueNameID === nameId) ?? null;\n}\n\n/**\n * Check if axis value is elidable\n */\nexport function isElidableAxisValue(axisValue: AxisValue): boolean {\n\treturn (axisValue.flags & AxisValueFlags.ElidableAxisValueName) !== 0;\n}\n\n/**\n * Check if axis value represents an older sibling font\n */\nexport function isOlderSiblingFont(axisValue: AxisValue): boolean {\n\treturn (axisValue.flags & AxisValueFlags.OlderSiblingFontAttribute) !== 0;\n}\n\n/**\n * Get the value for a format 1-3 axis value\n */\nexport function getAxisValueNumber(axisValue: AxisValue): number | null {\n\tswitch (axisValue.format) {\n\t\tcase 1:\n\t\tcase 3:\n\t\t\treturn axisValue.value;\n\t\tcase 2:\n\t\t\treturn axisValue.nominalValue;\n\t\tcase 4:\n\t\t\treturn null; // Format 4 has multiple values\n\t}\n}\n\n/**\n * Match axis value to coordinates\n * Returns true if the axis value matches the given coordinates\n */\nexport function matchAxisValue(\n\taxisValue: AxisValue,\n\tcoords: Map<number, number>,\n): boolean {\n\tswitch (axisValue.format) {\n\t\tcase 1:\n\t\tcase 3: {\n\t\t\tconst coord = coords.get(axisValue.axisIndex);\n\t\t\treturn coord !== undefined && coord === axisValue.value;\n\t\t}\n\t\tcase 2: {\n\t\t\tconst coord = coords.get(axisValue.axisIndex);\n\t\t\treturn (\n\t\t\t\tcoord !== undefined &&\n\t\t\t\tcoord >= axisValue.rangeMinValue &&\n\t\t\t\tcoord <= axisValue.rangeMaxValue\n\t\t\t);\n\t\t}\n\t\tcase 4: {\n\t\t\treturn axisValue.axisValues.every((av) => {\n\t\t\t\tconst coord = coords.get(av.axisIndex);\n\t\t\t\treturn coord !== undefined && coord === av.value;\n\t\t\t});\n\t\t}\n\t}\n}\n",
    "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * SVG table\n * Contains SVG documents for color glyph rendering\n */\nexport interface SvgTable {\n\tversion: uint16;\n\tdocumentRecords: SvgDocumentRecord[];\n}\n\n/**\n * SVG document record\n * Maps a range of glyphs to an SVG document\n */\nexport interface SvgDocumentRecord {\n\tstartGlyphID: GlyphId;\n\tendGlyphID: GlyphId;\n\tsvgDoc: string;\n}\n\n/**\n * Parse SVG table\n */\nexport function parseSvg(reader: Reader): SvgTable {\n\tconst version = reader.uint16();\n\n\t// SVG Document List offset (from start of SVG table)\n\tconst svgDocumentListOffset = reader.offset32();\n\n\t// Reserved\n\treader.skip(4);\n\n\t// Parse document list\n\tconst listReader = reader.sliceFrom(svgDocumentListOffset);\n\tconst numEntries = listReader.uint16();\n\n\t// No entries: return empty table\n\tif (numEntries === 0) {\n\t\treturn { version, documentRecords: [] };\n\t}\n\n\t// Read document index entries\n\tconst entries: {\n\t\tstartGlyphID: uint16;\n\t\tendGlyphID: uint16;\n\t\tsvgDocOffset: uint32;\n\t\tsvgDocLength: uint32;\n\t}[] = [];\n\n\tfor (let i = 0; i < numEntries; i++) {\n\t\tentries.push({\n\t\t\tstartGlyphID: listReader.uint16(),\n\t\t\tendGlyphID: listReader.uint16(),\n\t\t\tsvgDocOffset: listReader.offset32(),\n\t\t\tsvgDocLength: listReader.uint32(),\n\t\t});\n\t}\n\n\t// Parse SVG documents\n\tconst documentRecords: SvgDocumentRecord[] = [];\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tfor (let i = 0; i < entries.length; i++) {\n\t\tconst entry = entries[i]!;\n\t\t// SVG doc offset is relative to SVG Document List\n\t\tconst docReader = listReader.sliceFrom(entry.svgDocOffset);\n\t\tconst svgBytes = docReader.bytes(entry.svgDocLength);\n\n\t\t// Decompress if gzipped (starts with 0x1F 0x8B)\n\t\tlet svgDoc: string;\n\t\tif (svgBytes[0] === 0x1f && svgBytes[1] === 0x8b) {\n\t\t\t// Gzipped SVG - need to decompress\n\t\t\ttry {\n\t\t\t\tconst decompressed = decompressGzip(svgBytes);\n\t\t\t\tsvgDoc = decoder.decode(decompressed);\n\t\t\t} catch {\n\t\t\t\t// If decompression fails, try as plain text\n\t\t\t\tsvgDoc = decoder.decode(svgBytes);\n\t\t\t}\n\t\t} else {\n\t\t\tsvgDoc = decoder.decode(svgBytes);\n\t\t}\n\n\t\tdocumentRecords.push({\n\t\t\tstartGlyphID: entry.startGlyphID,\n\t\t\tendGlyphID: entry.endGlyphID,\n\t\t\tsvgDoc,\n\t\t});\n\t}\n\n\treturn { version, documentRecords };\n}\n\n/**\n * Get SVG document for a glyph\n * Returns null if no SVG exists for this glyph\n */\nexport function getSvgDocument(svg: SvgTable, glyphId: GlyphId): string | null {\n\tfor (let i = 0; i < svg.documentRecords.length; i++) {\n\t\tconst record = svg.documentRecords[i]!;\n\t\tif (glyphId >= record.startGlyphID && glyphId <= record.endGlyphID) {\n\t\t\treturn record.svgDoc;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Check if a glyph has an SVG representation\n */\nexport function hasSvgGlyph(svg: SvgTable, glyphId: GlyphId): boolean {\n\treturn getSvgDocument(svg, glyphId) !== null;\n}\n\n/**\n * Get all glyph IDs that have SVG representations\n */\nexport function getSvgGlyphIds(svg: SvgTable): GlyphId[] {\n\tconst glyphIds: GlyphId[] = [];\n\n\tfor (let i = 0; i < svg.documentRecords.length; i++) {\n\t\tconst record = svg.documentRecords[i]!;\n\t\tfor (let gid = record.startGlyphID; gid <= record.endGlyphID; gid++) {\n\t\t\tglyphIds.push(gid);\n\t\t}\n\t}\n\n\treturn glyphIds;\n}\n\n/**\n * Simple gzip decompression using DecompressionStream (if available)\n * Falls back to returning original data if not supported\n */\nfunction decompressGzip(data: Uint8Array): Uint8Array {\n\t// Use DecompressionStream if available (modern browsers/Bun)\n\tif (typeof DecompressionStream !== \"undefined\") {\n\t\t// This is async in nature, but we need sync.\n\t\t// For now, return original - proper implementation needs async\n\t\t// In practice, most SVG fonts use uncompressed SVG\n\t\treturn data;\n\t}\n\n\t// No decompression available, return as-is\n\treturn data;\n}\n\n/**\n * Async version of gzip decompression\n */\nexport async function decompressSvgDocument(data: Uint8Array): Promise<string> {\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\t// Not enough bytes or no magic -> plain decode\n\tif (data.length < 2 || data[0] !== 0x1f || data[1] !== 0x8b) {\n\t\treturn decoder.decode(data);\n\t}\n\n\t// Try gzip decompress; on any failure, fall back to plain decode\n\tif (typeof DecompressionStream !== \"undefined\") {\n\t\ttry {\n\t\t\tconst stream = new DecompressionStream(\"gzip\");\n\t\t\tconst writer = stream.writable.getWriter();\n\t\t\tconst reader = stream.readable.getReader();\n\n\t\t\tawait writer.write(data as unknown as BufferSource);\n\t\t\tawait writer.close();\n\n\t\t\tconst chunks: Uint8Array[] = [];\n\t\t\tlet result = await reader.read();\n\t\t\twhile (!result.done) {\n\t\t\t\tchunks.push(result.value);\n\t\t\t\tresult = await reader.read();\n\t\t\t}\n\n\t\t\tconst totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n\t\t\tconst decompressed = new Uint8Array(totalLength);\n\t\t\tlet offset = 0;\n\t\t\tfor (let i = 0; i < chunks.length; i++) {\n\t\t\t\tconst chunk = chunks[i]!;\n\t\t\t\tdecompressed.set(chunk, offset);\n\t\t\t\toffset += chunk.length;\n\t\t\t}\n\n\t\t\treturn decoder.decode(decompressed);\n\t\t} catch {\n\t\t\t// fall through to plain decode\n\t\t}\n\t}\n\n\treturn decoder.decode(data);\n}\n",
    "import type { int16, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Tracking table (trak)\n * Apple Advanced Typography tracking\n */\nexport interface TrakTable {\n\tversion: number;\n\tformat: uint16;\n\thorizData: TrackData | null;\n\tvertData: TrackData | null;\n}\n\n/**\n * Track data for one direction\n */\nexport interface TrackData {\n\tnTracks: uint16;\n\tnSizes: uint16;\n\tsizeTableOffset: uint32;\n\ttrackTable: TrackTableEntry[];\n\tsizeTable: number[]; // Fixed point sizes\n}\n\n/**\n * Track table entry\n */\nexport interface TrackTableEntry {\n\ttrack: number; // Fixed 16.16\n\tnameIndex: uint16;\n\toffset: uint16;\n\tperSizeTracking: int16[];\n}\n\n/**\n * Parse trak table\n */\nexport function parseTrak(reader: Reader): TrakTable {\n\tconst tableReader = reader; // Keep reference to table start for offset resolution\n\tconst version = reader.uint32() / 65536; // Fixed 16.16\n\tconst format = reader.uint16();\n\tconst horizOffset = reader.offset16();\n\tconst vertOffset = reader.offset16();\n\treader.skip(2); // reserved\n\n\tlet horizData: TrackData | null = null;\n\tlet vertData: TrackData | null = null;\n\n\tif (horizOffset !== 0) {\n\t\thorizData = parseTrackData(reader.sliceFrom(horizOffset), tableReader);\n\t}\n\n\tif (vertOffset !== 0) {\n\t\tvertData = parseTrackData(reader.sliceFrom(vertOffset), tableReader);\n\t}\n\n\treturn {\n\t\tversion,\n\t\tformat,\n\t\thorizData,\n\t\tvertData,\n\t};\n}\n\nfunction parseTrackData(reader: Reader, tableReader: Reader): TrackData {\n\tconst nTracks = reader.uint16();\n\tconst nSizes = reader.uint16();\n\tconst sizeTableOffset = reader.offset32();\n\n\tconst trackTable: TrackTableEntry[] = [];\n\n\t// Read track entries\n\tfor (let i = 0; i < nTracks; i++) {\n\t\tconst track = reader.int32() / 65536; // Fixed 16.16\n\t\tconst nameIndex = reader.uint16();\n\t\tconst offset = reader.uint16();\n\n\t\ttrackTable.push({\n\t\t\ttrack,\n\t\t\tnameIndex,\n\t\t\toffset,\n\t\t\tperSizeTracking: [],\n\t\t});\n\t}\n\n\t// Read per-size tracking values for each track\n\t// Note: offsets are relative to table start, not trackData start\n\tfor (let i = 0; i < trackTable.length; i++) {\n\t\tconst entry = trackTable[i]!;\n\t\tconst trackReader = tableReader.sliceFrom(entry.offset);\n\t\tentry.perSizeTracking = [];\n\t\tfor (let j = 0; j < nSizes; j++) {\n\t\t\tentry.perSizeTracking.push(trackReader.int16());\n\t\t}\n\t}\n\n\t// Read size table (offset is relative to table start, not trackData start)\n\tconst sizeReader = tableReader.sliceFrom(sizeTableOffset);\n\tconst sizeTable: number[] = [];\n\tfor (let i = 0; i < nSizes; i++) {\n\t\tsizeTable.push(sizeReader.int32() / 65536); // Fixed 16.16\n\t}\n\n\treturn {\n\t\tnTracks,\n\t\tnSizes,\n\t\tsizeTableOffset,\n\t\ttrackTable,\n\t\tsizeTable,\n\t};\n}\n\n/**\n * Get tracking value for a given track and point size\n */\nexport function getTrackingValue(\n\ttrackData: TrackData,\n\ttrack: number,\n\tpointSize: number,\n): number {\n\t// Find the track entry\n\tlet trackEntry: TrackTableEntry | null = null;\n\n\tfor (let i = 0; i < trackData.trackTable.length; i++) {\n\t\tconst entry = trackData.trackTable[i]!;\n\t\tif (entry.track === track) {\n\t\t\ttrackEntry = entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If exact track not found, interpolate between nearest\n\tif (!trackEntry) {\n\t\tlet lower: TrackTableEntry | null = null;\n\t\tlet upper: TrackTableEntry | null = null;\n\n\t\tfor (let i = 0; i < trackData.trackTable.length; i++) {\n\t\t\tconst entry = trackData.trackTable[i]!;\n\t\t\tif (entry.track <= track && (!lower || entry.track > lower.track)) {\n\t\t\t\tlower = entry;\n\t\t\t}\n\t\t\tif (entry.track >= track && (!upper || entry.track < upper.track)) {\n\t\t\t\tupper = entry;\n\t\t\t}\n\t\t}\n\n\t\tif (lower && upper && lower !== upper) {\n\t\t\t// Interpolate between tracks\n\t\t\tconst t = (track - lower.track) / (upper.track - lower.track);\n\t\t\tconst lowerValue = getSizeValue(trackData, lower, pointSize);\n\t\t\tconst upperValue = getSizeValue(trackData, upper, pointSize);\n\t\t\treturn Math.round(lowerValue + t * (upperValue - lowerValue));\n\t\t} else if (lower) {\n\t\t\ttrackEntry = lower;\n\t\t} else if (upper) {\n\t\t\ttrackEntry = upper;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!trackEntry) return 0;\n\n\treturn getSizeValue(trackData, trackEntry, pointSize);\n}\n\nfunction getSizeValue(\n\ttrackData: TrackData,\n\tentry: TrackTableEntry,\n\tpointSize: number,\n): number {\n\tconst sizes = trackData.sizeTable;\n\tconst values = entry.perSizeTracking;\n\n\tif (sizes.length === 0 || values.length === 0) return 0;\n\n\tconst firstSize = sizes[0];\n\tconst firstValue = values[0];\n\tif (firstSize === undefined || firstValue === undefined) return 0;\n\n\t// Find size range\n\tif (pointSize <= firstSize) {\n\t\treturn firstValue;\n\t}\n\n\tconst lastSize = sizes[sizes.length - 1];\n\tconst lastValue = values[values.length - 1];\n\tif (lastSize === undefined || lastValue === undefined) return 0;\n\n\tif (pointSize >= lastSize) {\n\t\treturn lastValue;\n\t}\n\n\t// Interpolate\n\tfor (let i = 0; i < sizes.length - 1; i++) {\n\t\tconst size1 = sizes[i];\n\t\tconst size2 = sizes[i + 1];\n\t\tconst value1 = values[i];\n\t\tconst value2 = values[i + 1];\n\t\tif (\n\t\t\tsize1 === undefined ||\n\t\t\tsize2 === undefined ||\n\t\t\tvalue1 === undefined ||\n\t\t\tvalue2 === undefined\n\t\t)\n\t\t\tcontinue;\n\n\t\tif (pointSize >= size1 && pointSize <= size2) {\n\t\t\tconst t = (pointSize - size1) / (size2 - size1);\n\t\t\treturn Math.round(value1 + t * (value2 - value1));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Apply tracking to advance widths\n */\nexport function applyTracking(\n\ttrak: TrakTable,\n\tadvances: number[],\n\tpointSize: number,\n\ttrack: number = 0,\n\tvertical: boolean = false,\n): void {\n\tconst trackData = vertical ? trak.vertData : trak.horizData;\n\tif (!trackData) return;\n\n\tconst trackingValue = getTrackingValue(trackData, track, pointSize);\n\tif (trackingValue === 0) return;\n\n\t// Add tracking to each advance\n\tfor (let i = 0; i < advances.length; i++) {\n\t\tconst advance = advances[i];\n\t\tadvances[i] = (advance ?? 0) + trackingValue;\n\t}\n}\n",
    "import type { FWord, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Vertical Header table (vhea)\n * Contains information for vertical layout\n */\nexport interface VheaTable {\n\t/** Table version (1.0 or 1.1) */\n\tversion: { major: number; minor: number };\n\t/** Typographic ascent (vertical) */\n\tascender: FWord;\n\t/** Typographic descent (vertical) */\n\tdescender: FWord;\n\t/** Typographic line gap (vertical) */\n\tlineGap: FWord;\n\t/** Maximum advance height */\n\tadvanceHeightMax: uint16;\n\t/** Minimum top side bearing */\n\tminTopSideBearing: FWord;\n\t/** Minimum bottom side bearing */\n\tminBottomSideBearing: FWord;\n\t/** Maximum y extent (yMax - yMin) */\n\tyMaxExtent: FWord;\n\t/** Caret slope rise (for vertical text) */\n\tcaretSlopeRise: int16;\n\t/** Caret slope run */\n\tcaretSlopeRun: int16;\n\t/** Caret offset */\n\tcaretOffset: int16;\n\t/** Metric data format (0 for current) */\n\tmetricDataFormat: int16;\n\t/** Number of vertical metrics in vmtx */\n\tnumberOfVMetrics: uint16;\n}\n\n/**\n * Parse vhea table\n */\nexport function parseVhea(reader: Reader): VheaTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst ascender = reader.fword();\n\tconst descender = reader.fword();\n\tconst lineGap = reader.fword();\n\tconst advanceHeightMax = reader.uint16();\n\tconst minTopSideBearing = reader.fword();\n\tconst minBottomSideBearing = reader.fword();\n\tconst yMaxExtent = reader.fword();\n\tconst caretSlopeRise = reader.int16();\n\tconst caretSlopeRun = reader.int16();\n\tconst caretOffset = reader.int16();\n\n\t// Skip reserved fields\n\treader.skip(8);\n\n\tconst metricDataFormat = reader.int16();\n\tconst numberOfVMetrics = reader.uint16();\n\n\treturn {\n\t\tversion: { major: majorVersion, minor: minorVersion },\n\t\tascender,\n\t\tdescender,\n\t\tlineGap,\n\t\tadvanceHeightMax,\n\t\tminTopSideBearing,\n\t\tminBottomSideBearing,\n\t\tyMaxExtent,\n\t\tcaretSlopeRise,\n\t\tcaretSlopeRun,\n\t\tcaretOffset,\n\t\tmetricDataFormat,\n\t\tnumberOfVMetrics,\n\t};\n}\n",
    "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Vertical Metrics table (vmtx)\n * Contains vertical metrics for each glyph\n */\nexport interface VmtxTable {\n\t/** Vertical metrics (advance height + top side bearing) */\n\tvMetrics: VerticalMetric[];\n\t/** Top side bearings for remaining glyphs */\n\ttopSideBearings: int16[];\n}\n\n/**\n * Vertical metric record\n */\nexport interface VerticalMetric {\n\t/** Advance height in font units */\n\tadvanceHeight: uint16;\n\t/** Top side bearing in font units */\n\ttopSideBearing: int16;\n}\n\n/**\n * Parse vmtx table\n * @param reader Binary reader\n * @param numberOfVMetrics From vhea table\n * @param numGlyphs Total number of glyphs\n */\nexport function parseVmtx(\n\treader: Reader,\n\tnumberOfVMetrics: number,\n\tnumGlyphs: number,\n): VmtxTable {\n\tconst vMetrics: VerticalMetric[] = [];\n\n\t// Read full vertical metrics\n\tfor (let i = 0; i < numberOfVMetrics; i++) {\n\t\tvMetrics.push({\n\t\t\tadvanceHeight: reader.uint16(),\n\t\t\ttopSideBearing: reader.int16(),\n\t\t});\n\t}\n\n\t// Read additional top side bearings\n\tconst topSideBearings: int16[] = [];\n\tconst remaining = numGlyphs - numberOfVMetrics;\n\n\tfor (let i = 0; i < remaining; i++) {\n\t\ttopSideBearings.push(reader.int16());\n\t}\n\n\treturn { vMetrics, topSideBearings };\n}\n\n/**\n * Get vertical metrics for a glyph\n */\nexport function getVerticalMetrics(\n\tvmtx: VmtxTable,\n\tglyphId: GlyphId,\n): { advanceHeight: number; topSideBearing: number } {\n\tif (glyphId < vmtx.vMetrics.length) {\n\t\tconst metric = vmtx.vMetrics[glyphId];\n\t\tif (metric) {\n\t\t\treturn {\n\t\t\t\tadvanceHeight: metric.advanceHeight,\n\t\t\t\ttopSideBearing: metric.topSideBearing,\n\t\t\t};\n\t\t}\n\t}\n\n\t// Use last advance height, get TSB from array\n\tconst lastMetric = vmtx.vMetrics[vmtx.vMetrics.length - 1];\n\tconst advanceHeight = lastMetric?.advanceHeight ?? 0;\n\tconst tsbIndex = glyphId - vmtx.vMetrics.length;\n\tconst topSideBearing = vmtx.topSideBearings[tsbIndex] ?? 0;\n\n\treturn { advanceHeight, topSideBearing };\n}\n",
    "import type { GlyphId, int16, uint16 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\n\n/**\n * Vertical Origin table (VORG)\n * Provides y-coordinate of vertical origin for CFF fonts\n * Used for proper vertical text layout in CJK fonts\n */\nexport interface VorgTable {\n\tmajorVersion: uint16;\n\tminorVersion: uint16;\n\tdefaultVertOriginY: int16;\n\tvertOriginYMetrics: VertOriginYMetric[];\n}\n\n/**\n * Vertical origin metric for a specific glyph\n */\nexport interface VertOriginYMetric {\n\tglyphIndex: GlyphId;\n\tvertOriginY: int16;\n}\n\n/**\n * Parse VORG table\n */\nexport function parseVorg(reader: Reader): VorgTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst defaultVertOriginY = reader.int16();\n\tconst numVertOriginYMetrics = reader.uint16();\n\n\tconst vertOriginYMetrics: VertOriginYMetric[] = [];\n\tfor (let i = 0; i < numVertOriginYMetrics; i++) {\n\t\tvertOriginYMetrics.push({\n\t\t\tglyphIndex: reader.uint16(),\n\t\t\tvertOriginY: reader.int16(),\n\t\t});\n\t}\n\n\t// Sort by glyph index for binary search\n\tvertOriginYMetrics.sort((a, b) => a.glyphIndex - b.glyphIndex);\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tdefaultVertOriginY,\n\t\tvertOriginYMetrics,\n\t};\n}\n\n/**\n * Get vertical origin Y coordinate for a glyph\n * Returns the y-coordinate of the glyph's vertical origin\n */\nexport function getVertOriginY(vorg: VorgTable, glyphId: GlyphId): int16 {\n\t// Binary search for the glyph\n\tconst metrics = vorg.vertOriginYMetrics;\n\tlet lo = 0;\n\tlet hi = metrics.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst metric = metrics[mid];\n\t\tif (metric === undefined) break;\n\n\t\tif (metric.glyphIndex === glyphId) {\n\t\t\treturn metric.vertOriginY;\n\t\t} else if (metric.glyphIndex < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\t// Not found, use default\n\treturn vorg.defaultVertOriginY;\n}\n\n/**\n * Check if a glyph has a specific vertical origin entry\n */\nexport function hasVertOriginY(vorg: VorgTable, glyphId: GlyphId): boolean {\n\tconst metrics = vorg.vertOriginYMetrics;\n\tlet lo = 0;\n\tlet hi = metrics.length - 1;\n\n\twhile (lo <= hi) {\n\t\tconst mid = (lo + hi) >>> 1;\n\t\tconst metric = metrics[mid];\n\t\tif (metric === undefined) break;\n\n\t\tif (metric.glyphIndex === glyphId) {\n\t\t\treturn true;\n\t\t} else if (metric.glyphIndex < glyphId) {\n\t\t\tlo = mid + 1;\n\t\t} else {\n\t\t\thi = mid - 1;\n\t\t}\n\t}\n\n\treturn false;\n}\n",
    "import type { GlyphId, uint16, uint32 } from \"../../types.ts\";\nimport type { Reader } from \"../binary/reader.ts\";\nimport {\n\tcalculateRegionScalar,\n\ttype DeltaSetIndexMap,\n\ttype ItemVariationStore,\n\ttype VariationRegion,\n} from \"./hvar.ts\";\n\n/**\n * Vertical Metrics Variations table (VVAR)\n * Provides variations for vertical advance heights and side bearings\n */\nexport interface VvarTable {\n\tmajorVersion: number;\n\tminorVersion: number;\n\titemVariationStore: ItemVariationStore;\n\tadvanceHeightMapping: DeltaSetIndexMap | null;\n\ttsbMapping: DeltaSetIndexMap | null; // Top side bearing\n\tbsbMapping: DeltaSetIndexMap | null; // Bottom side bearing\n\tvOrgMapping: DeltaSetIndexMap | null; // Vertical origin\n}\n\n/**\n * Parse VVAR table\n */\nexport function parseVvar(reader: Reader): VvarTable {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst itemVariationStoreOffset = reader.offset32();\n\tconst advanceHeightMappingOffset = reader.offset32();\n\tconst tsbMappingOffset = reader.offset32();\n\tconst bsbMappingOffset = reader.offset32();\n\tconst vOrgMappingOffset = reader.offset32();\n\n\t// Parse item variation store\n\tconst itemVariationStore = parseItemVariationStore(\n\t\treader.sliceFrom(itemVariationStoreOffset),\n\t);\n\n\t// Parse mappings\n\tconst advanceHeightMapping =\n\t\tadvanceHeightMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(advanceHeightMappingOffset))\n\t\t\t: null;\n\n\tconst tsbMapping =\n\t\ttsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(tsbMappingOffset))\n\t\t\t: null;\n\n\tconst bsbMapping =\n\t\tbsbMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(bsbMappingOffset))\n\t\t\t: null;\n\n\tconst vOrgMapping =\n\t\tvOrgMappingOffset !== 0\n\t\t\t? parseDeltaSetIndexMap(reader.sliceFrom(vOrgMappingOffset))\n\t\t\t: null;\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\titemVariationStore,\n\t\tadvanceHeightMapping,\n\t\ttsbMapping,\n\t\tbsbMapping,\n\t\tvOrgMapping,\n\t};\n}\n\nfunction parseItemVariationStore(reader: Reader): ItemVariationStore {\n\tconst format = reader.uint16();\n\tconst variationRegionListOffset = reader.offset32();\n\tconst itemVariationDataCount = reader.uint16();\n\n\tconst itemVariationDataOffsets: uint32[] = [];\n\tfor (let i = 0; i < itemVariationDataCount; i++) {\n\t\titemVariationDataOffsets.push(reader.offset32());\n\t}\n\n\t// Parse variation regions\n\tconst regionReader = reader.sliceFrom(variationRegionListOffset);\n\tconst axisCount = regionReader.uint16();\n\tconst regionCount = regionReader.uint16();\n\n\tconst variationRegions: VariationRegion[] = [];\n\tfor (let i = 0; i < regionCount; i++) {\n\t\tconst regionAxes: {\n\t\t\tstartCoord: number;\n\t\t\tpeakCoord: number;\n\t\t\tendCoord: number;\n\t\t}[] = [];\n\t\tfor (let j = 0; j < axisCount; j++) {\n\t\t\tregionAxes.push({\n\t\t\t\tstartCoord: regionReader.f2dot14(),\n\t\t\t\tpeakCoord: regionReader.f2dot14(),\n\t\t\t\tendCoord: regionReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t\tvariationRegions.push({ regionAxes });\n\t}\n\n\t// Parse item variation data\n\tconst itemVariationData: {\n\t\titemCount: uint16;\n\t\tregionIndexes: uint16[];\n\t\tdeltaSets: number[][];\n\t}[] = [];\n\tfor (let i = 0; i < itemVariationDataOffsets.length; i++) {\n\t\tconst offset = itemVariationDataOffsets[i]!;\n\t\tconst dataReader = reader.sliceFrom(offset);\n\t\tconst itemCount = dataReader.uint16();\n\t\tconst wordDeltaCount = dataReader.uint16();\n\t\tconst regionIndexCount = dataReader.uint16();\n\n\t\tconst regionIndexes: uint16[] = [];\n\t\tfor (let j = 0; j < regionIndexCount; j++) {\n\t\t\tregionIndexes.push(dataReader.uint16());\n\t\t}\n\n\t\t// Parse delta sets\n\t\tconst longWords = (wordDeltaCount & 0x8000) !== 0;\n\t\tconst wordCount = wordDeltaCount & 0x7fff;\n\t\tconst shortCount = regionIndexCount - wordCount;\n\n\t\tconst deltaSets: number[][] = [];\n\t\tfor (let j = 0; j < itemCount; j++) {\n\t\t\tconst deltas: number[] = [];\n\t\t\t// Read word-sized deltas\n\t\t\tfor (let k = 0; k < wordCount; k++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int32());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read short-sized deltas\n\t\t\tfor (let k = 0; k < shortCount; k++) {\n\t\t\t\tif (longWords) {\n\t\t\t\t\tdeltas.push(dataReader.int16());\n\t\t\t\t} else {\n\t\t\t\t\tdeltas.push(dataReader.int8());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeltaSets.push(deltas);\n\t\t}\n\n\t\titemVariationData.push({ itemCount, regionIndexes, deltaSets });\n\t}\n\n\treturn { format, variationRegions, itemVariationData };\n}\n\nfunction parseDeltaSetIndexMap(reader: Reader): DeltaSetIndexMap {\n\tconst format = reader.uint8();\n\tconst entryFormat = reader.uint8();\n\tconst mapCount = format === 0 ? reader.uint16() : reader.uint32();\n\n\tconst innerIndexBitCount = (entryFormat & 0x0f) + 1;\n\tconst mapEntrySize = ((entryFormat >> 4) & 0x03) + 1;\n\n\tconst mapData: { outer: number; inner: number }[] = [];\n\tfor (let i = 0; i < mapCount; i++) {\n\t\tlet entry = 0;\n\t\tfor (let j = 0; j < mapEntrySize; j++) {\n\t\t\tentry = (entry << 8) | reader.uint8();\n\t\t}\n\n\t\tconst inner = entry & ((1 << innerIndexBitCount) - 1);\n\t\tconst outer = entry >> innerIndexBitCount;\n\t\tmapData.push({ outer, inner });\n\t}\n\n\treturn { format, mapCount, entryFormat, innerIndexBitCount, mapData };\n}\n\n/**\n * Get advance height delta for a glyph at given variation coordinates\n */\nexport function getAdvanceHeightDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.advanceHeightMapping;\n\n\t// Get outer/inner index\n\tlet outer: number;\n\tlet inner: number;\n\n\tif (mapping && glyphId < mapping.mapData.length) {\n\t\tconst entry = mapping.mapData[glyphId];\n\t\tif (!entry) {\n\t\t\treturn 0;\n\t\t}\n\t\touter = entry.outer;\n\t\tinner = entry.inner;\n\t} else {\n\t\t// Direct mapping: outer = 0, inner = glyphId\n\t\touter = 0;\n\t\tinner = glyphId;\n\t}\n\n\treturn calculateDelta(vvar.itemVariationStore, outer, inner, coords);\n}\n\n/**\n * Get top side bearing delta for a glyph at given variation coordinates\n */\nexport function getTsbDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.tsbMapping;\n\tif (!mapping) return 0;\n\n\tif (glyphId >= mapping.mapData.length) return 0;\n\n\tconst entry = mapping.mapData[glyphId];\n\tif (!entry) return 0;\n\n\treturn calculateDelta(\n\t\tvvar.itemVariationStore,\n\t\tentry.outer,\n\t\tentry.inner,\n\t\tcoords,\n\t);\n}\n\n/**\n * Get bottom side bearing delta for a glyph at given variation coordinates\n */\nexport function getBsbDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.bsbMapping;\n\tif (!mapping) return 0;\n\n\tif (glyphId >= mapping.mapData.length) return 0;\n\n\tconst entry = mapping.mapData[glyphId];\n\tif (!entry) return 0;\n\n\treturn calculateDelta(\n\t\tvvar.itemVariationStore,\n\t\tentry.outer,\n\t\tentry.inner,\n\t\tcoords,\n\t);\n}\n\n/**\n * Get vertical origin delta for a glyph at given variation coordinates\n */\nexport function getVorgDelta(\n\tvvar: VvarTable,\n\tglyphId: GlyphId,\n\tcoords: number[],\n): number {\n\tconst mapping = vvar.vOrgMapping;\n\tif (!mapping) return 0;\n\n\tif (glyphId >= mapping.mapData.length) return 0;\n\n\tconst entry = mapping.mapData[glyphId];\n\tif (!entry) return 0;\n\n\treturn calculateDelta(\n\t\tvvar.itemVariationStore,\n\t\tentry.outer,\n\t\tentry.inner,\n\t\tcoords,\n\t);\n}\n\n/**\n * Calculate delta from variation store\n */\nfunction calculateDelta(\n\tstore: ItemVariationStore,\n\touter: number,\n\tinner: number,\n\tcoords: number[],\n): number {\n\tconst varData = store.itemVariationData[outer];\n\tif (!varData || inner >= varData.itemCount) {\n\t\treturn 0;\n\t}\n\n\tconst deltaSet = varData.deltaSets[inner];\n\tif (!deltaSet) {\n\t\treturn 0;\n\t}\n\n\t// Calculate total delta\n\tlet delta = 0;\n\tfor (let i = 0; i < varData.regionIndexes.length; i++) {\n\t\tconst regionIndex = varData.regionIndexes[i]!;\n\t\tconst region = store.variationRegions[regionIndex];\n\t\tif (!region) continue;\n\n\t\tconst scalar = calculateRegionScalar(region, coords);\n\t\tconst regionDelta = deltaSet[i] ?? 0;\n\t\tdelta += scalar * regionDelta;\n\t}\n\n\treturn Math.round(delta);\n}\n",
    "import type { GlyphId, TableRecord, Tag } from \"../types.ts\";\nimport { Tags, tagToString } from \"../types.ts\";\nimport { Reader } from \"./binary/reader.ts\";\nimport { isTtc, type TtcHeader, parseTtcHeader } from \"./ttc.ts\";\nimport { woff2ToSfnt } from \"./woff2.ts\";\n\n// WOFF/WOFF2 magic numbers\nconst WOFF_MAGIC = 0x774f4646; // 'wOFF'\nconst WOFF2_MAGIC = 0x774f4632; // 'wOF2'\n\n/** Check if buffer is WOFF2 format */\nfunction isWoff2(buffer: ArrayBuffer): boolean {\n\tconst view = new DataView(buffer);\n\treturn view.getUint32(0, false) === WOFF2_MAGIC;\n}\n\n/** Check if buffer is WOFF format */\nfunction isWoff(buffer: ArrayBuffer): boolean {\n\tconst view = new DataView(buffer);\n\treturn view.getUint32(0, false) === WOFF_MAGIC;\n}\n\nimport { type AvarTable, parseAvar } from \"./tables/avar.ts\";\nimport { type BaseTable, parseBase } from \"./tables/base.ts\";\nimport {\n\ttype CbdtTable,\n\ttype CblcTable,\n\tparseCbdt,\n\tparseCblc,\n} from \"./tables/cbdt.ts\";\nimport { type CffTable, parseCff } from \"./tables/cff.ts\";\nimport {\n\texecuteCff2CharString,\n\texecuteCffCharString,\n} from \"./tables/cff-charstring.ts\";\nimport { type Cff2Table, parseCff2 } from \"./tables/cff2.ts\";\nimport { type CmapTable, getGlyphId, parseCmap } from \"./tables/cmap.ts\";\nimport { type ColrTable, parseColr } from \"./tables/colr.ts\";\nimport { type CpalTable, parseCpal } from \"./tables/cpal.ts\";\nimport { type FeatTable, parseFeat } from \"./tables/feat.ts\";\nimport { type FvarTable, parseFvar } from \"./tables/fvar.ts\";\nimport { type GaspTable, parseGasp } from \"./tables/gasp.ts\";\nimport { type GdefTable, parseGdef } from \"./tables/gdef.ts\";\nimport {\n\ttype Contour,\n\ttype GlyfTable,\n\ttype Glyph,\n\tgetGlyphBounds,\n\tgetGlyphContours,\n\tgetGlyphContoursAndBounds,\n\tgetGlyphContoursWithVariation,\n\tparseGlyf,\n\tparseGlyph,\n} from \"./tables/glyf.ts\";\nimport { type GposTable, parseGpos } from \"./tables/gpos.ts\";\nimport { type GsubTable, parseGsub } from \"./tables/gsub.ts\";\nimport { type GvarTable, parseGvar } from \"./tables/gvar.ts\";\nimport { type HeadTable, parseHead } from \"./tables/head.ts\";\nimport { type HheaTable, parseHhea } from \"./tables/hhea.ts\";\nimport {\n\ttype CvtTable,\n\ttype FpgmTable,\n\ttype PrepTable,\n\tparseCvt,\n\tparseFpgm,\n\tparsePrep,\n} from \"./tables/hinting.ts\";\nimport {\n\tgetAdvanceWidth,\n\tgetLeftSideBearing,\n\ttype HmtxTable,\n\tparseHmtx,\n} from \"./tables/hmtx.ts\";\nimport { type HvarTable, parseHvar } from \"./tables/hvar.ts\";\nimport { type JstfTable, parseJstf } from \"./tables/jstf.ts\";\nimport { type KernTable, parseKern } from \"./tables/kern.ts\";\nimport { type KerxTable, parseKerx } from \"./tables/kerx.ts\";\nimport { type LocaTable, parseLoca } from \"./tables/loca.ts\";\nimport { type MathTable, parseMath } from \"./tables/math.ts\";\nimport { type MaxpTable, parseMaxp } from \"./tables/maxp.ts\";\nimport { type MorxTable, parseMorx } from \"./tables/morx.ts\";\nimport { type MvarTable, parseMvar } from \"./tables/mvar.ts\";\nimport {\n\tgetNameById,\n\tNameId,\n\ttype NameTable,\n\tparseName,\n} from \"./tables/name.ts\";\nimport { type Os2Table, parseOs2 } from \"./tables/os2.ts\";\nimport { type PostTable, parsePost } from \"./tables/post.ts\";\nimport { parseSbix, type SbixTable } from \"./tables/sbix.ts\";\nimport {\n\ttype FontDirectory,\n\tisTrueType,\n\tparseFontDirectory,\n} from \"./tables/sfnt.ts\";\nimport { parseStat, type StatTable } from \"./tables/stat.ts\";\nimport { parseSvg, type SvgTable } from \"./tables/svg.ts\";\nimport { parseTrak, type TrakTable } from \"./tables/trak.ts\";\nimport { parseVhea, type VheaTable } from \"./tables/vhea.ts\";\nimport { parseVmtx, type VmtxTable } from \"./tables/vmtx.ts\";\nimport { parseVorg, type VorgTable } from \"./tables/vorg.ts\";\nimport { parseVvar, type VvarTable } from \"./tables/vvar.ts\";\n\n/** Font loading options */\nexport interface FontLoadOptions {\n\t/** Tables to parse eagerly (default: lazy) */\n\teagerTables?: Tag[];\n\t/** TTC collection index (default: 0 when loading a TTC) */\n\tcollectionIndex?: number;\n}\n\nexport interface CollectionFaceName {\n\tindex: number;\n\tfullName?: string;\n\tfamily?: string;\n\tsubfamily?: string;\n\tpostScriptName?: string;\n}\n\nexport class FontCollection {\n\tprivate readonly buffer: ArrayBuffer;\n\tprivate readonly header: TtcHeader;\n\tprivate readonly loadFace: (index: number, options?: FontLoadOptions) => Font;\n\tprivate namesCache: CollectionFaceName[] | null = null;\n\n\tconstructor(\n\t\tbuffer: ArrayBuffer,\n\t\theader: TtcHeader,\n\t\tloadFace: (index: number, options?: FontLoadOptions) => Font,\n\t) {\n\t\tthis.buffer = buffer;\n\t\tthis.header = header;\n\t\tthis.loadFace = loadFace;\n\t}\n\n\tget count(): number {\n\t\treturn this.header.numFonts;\n\t}\n\n\tget(index: number, options?: FontLoadOptions): Font {\n\t\treturn this.loadFace(index, options);\n\t}\n\n\tnames(): CollectionFaceName[] {\n\t\tif (this.namesCache) return this.namesCache;\n\n\t\tconst names: CollectionFaceName[] = [];\n\t\tconst reader = new Reader(this.buffer);\n\n\t\tfor (let i = 0; i < this.header.numFonts; i++) {\n\t\t\tconst offset = this.header.offsets[i] ?? 0;\n\t\t\tconst entry: CollectionFaceName = { index: i };\n\n\t\t\tif (offset >= 0 && offset < this.buffer.byteLength) {\n\t\t\t\ttry {\n\t\t\t\t\tconst directory = parseFontDirectory(new Reader(this.buffer, offset));\n\t\t\t\t\tconst record = directory.tables.get(Tags.name);\n\t\t\t\t\tif (record) {\n\t\t\t\t\t\tconst nameReader = reader.slice(record.offset, record.length);\n\t\t\t\t\t\tconst table = parseName(nameReader);\n\t\t\t\t\t\tentry.fullName = getNameById(table, NameId.FullName) ?? undefined;\n\t\t\t\t\t\tentry.family = getNameById(table, NameId.FontFamily) ?? undefined;\n\t\t\t\t\t\tentry.subfamily =\n\t\t\t\t\t\t\tgetNameById(table, NameId.FontSubfamily) ?? undefined;\n\t\t\t\t\t\tentry.postScriptName =\n\t\t\t\t\t\t\tgetNameById(table, NameId.PostScriptName) ?? undefined;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Ignore invalid subfont entries.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnames.push(entry);\n\t\t}\n\n\t\tthis.namesCache = names;\n\t\treturn names;\n\t}\n}\n\n/**\n * Represents a loaded font file.\n * Tables are parsed lazily on first access.\n */\nexport class Font {\n\tprivate readonly reader: Reader;\n\tprivate readonly directory: FontDirectory;\n\n\t// Lazy-loaded tables\n\tprivate _head: HeadTable | null = null;\n\tprivate _maxp: MaxpTable | null = null;\n\tprivate _hhea: HheaTable | null = null;\n\tprivate _hmtx: HmtxTable | null = null;\n\tprivate _cmap: CmapTable | null = null;\n\tprivate _gdef: GdefTable | null | undefined = undefined;\n\tprivate _gsub: GsubTable | null | undefined = undefined;\n\tprivate _gpos: GposTable | null | undefined = undefined;\n\tprivate _kern: KernTable | null | undefined = undefined;\n\tprivate _fvar: FvarTable | null | undefined = undefined;\n\tprivate _hvar: HvarTable | null | undefined = undefined;\n\tprivate _vhea: VheaTable | null | undefined = undefined;\n\tprivate _vmtx: VmtxTable | null | undefined = undefined;\n\tprivate _morx: MorxTable | null | undefined = undefined;\n\tprivate _gvar: GvarTable | null | undefined = undefined;\n\tprivate _avar: AvarTable | null | undefined = undefined;\n\tprivate _kerx: KerxTable | null | undefined = undefined;\n\tprivate _trak: TrakTable | null | undefined = undefined;\n\tprivate _cff: CffTable | null | undefined = undefined;\n\tprivate _cff2: Cff2Table | null | undefined = undefined;\n\tprivate _colr: ColrTable | null | undefined = undefined;\n\tprivate _cpal: CpalTable | null | undefined = undefined;\n\tprivate _vvar: VvarTable | null | undefined = undefined;\n\tprivate _mvar: MvarTable | null | undefined = undefined;\n\tprivate _os2: Os2Table | null | undefined = undefined;\n\tprivate _name: NameTable | null | undefined = undefined;\n\tprivate _post: PostTable | null | undefined = undefined;\n\tprivate _base: BaseTable | null | undefined = undefined;\n\tprivate _jstf: JstfTable | null | undefined = undefined;\n\tprivate _math: MathTable | null | undefined = undefined;\n\tprivate _loca: LocaTable | null | undefined = undefined;\n\tprivate _glyf: GlyfTable | null | undefined = undefined;\n\tprivate _svg: SvgTable | null | undefined = undefined;\n\tprivate _vorg: VorgTable | null | undefined = undefined;\n\tprivate _sbix: SbixTable | null | undefined = undefined;\n\tprivate _stat: StatTable | null | undefined = undefined;\n\tprivate _cbdt: CbdtTable | null | undefined = undefined;\n\tprivate _cblc: CblcTable | null | undefined = undefined;\n\tprivate _feat: FeatTable | null | undefined = undefined;\n\tprivate _fpgm: FpgmTable | null | undefined = undefined;\n\tprivate _prep: PrepTable | null | undefined = undefined;\n\tprivate _cvt: CvtTable | null | undefined = undefined;\n\tprivate _gasp: GaspTable | null | undefined = undefined;\n\n\tprivate constructor(\n\t\treader: Reader,\n\t\tdirectory: FontDirectory,\n\t\t_options: FontLoadOptions = {},\n\t) {\n\t\tthis.reader = reader;\n\t\tthis.directory = directory;\n\t}\n\n\t/** Load font from ArrayBuffer (sync - WOFF2 requires async loading) */\n\tstatic load(buffer: ArrayBuffer, options?: FontLoadOptions): Font {\n\t\tif (isWoff2(buffer)) {\n\t\t\tthrow new Error(\n\t\t\t\t\"WOFF2 requires async loading. Use Font.loadAsync() instead.\",\n\t\t\t);\n\t\t}\n\t\tif (isWoff(buffer)) {\n\t\t\tthrow new Error(\n\t\t\t\t\"WOFF format is not supported. Please use TTF, OTF, or WOFF2.\",\n\t\t\t);\n\t\t}\n\t\treturn Font.loadFromBuffer(buffer, options);\n\t}\n\n\t/** Load font from ArrayBuffer with WOFF2 support (async) */\n\tstatic async loadAsync(\n\t\tbuffer: ArrayBuffer,\n\t\toptions?: FontLoadOptions,\n\t): Promise<Font> {\n\t\tif (isWoff2(buffer)) {\n\t\t\tbuffer = await woff2ToSfnt(buffer);\n\t\t} else if (isWoff(buffer)) {\n\t\t\tthrow new Error(\n\t\t\t\t\"WOFF format is not supported. Please use TTF, OTF, or WOFF2.\",\n\t\t\t);\n\t\t}\n\t\treturn Font.loadFromBuffer(buffer, options);\n\t}\n\n\t/** Load font from URL (works in browser and Bun, supports WOFF2) */\n\tstatic async fromURL(url: string, options?: FontLoadOptions): Promise<Font> {\n\t\tconst response = await fetch(url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(\n\t\t\t\t`Failed to fetch font: ${response.status} ${response.statusText}`,\n\t\t\t);\n\t\t}\n\t\tconst buffer = await response.arrayBuffer();\n\t\treturn Font.loadAsync(buffer, options);\n\t}\n\n\t/** Load font from file path (Bun only, supports WOFF2) */\n\tstatic async fromFile(\n\t\tpath: string,\n\t\toptions?: FontLoadOptions,\n\t): Promise<Font> {\n\t\tconst file = Bun.file(path);\n\t\tconst buffer = await file.arrayBuffer();\n\t\treturn Font.loadAsync(buffer, options);\n\t}\n\n\t/** Create a TTC collection helper if buffer is a TrueType Collection */\n\tstatic collection(buffer: ArrayBuffer): FontCollection | null {\n\t\tif (!isTtc(buffer)) return null;\n\t\tconst header = parseTtcHeader(buffer);\n\t\treturn new FontCollection(buffer, header, (index, options) =>\n\t\t\tFont.loadFromTtc(buffer, options, header, index),\n\t\t);\n\t}\n\n\tprivate static loadFromBuffer(\n\t\tbuffer: ArrayBuffer,\n\t\toptions?: FontLoadOptions,\n\t): Font {\n\t\tif (isTtc(buffer)) {\n\t\t\treturn Font.loadFromTtc(buffer, options);\n\t\t}\n\t\tconst reader = new Reader(buffer);\n\t\tconst directory = parseFontDirectory(reader);\n\t\treturn new Font(reader, directory, options);\n\t}\n\n\tprivate static loadFromTtc(\n\t\tbuffer: ArrayBuffer,\n\t\toptions?: FontLoadOptions,\n\t\theader?: TtcHeader,\n\t\tindexOverride?: number,\n\t): Font {\n\t\tconst ttcHeader = header ?? parseTtcHeader(buffer);\n\t\tconst index = indexOverride ?? options?.collectionIndex ?? 0;\n\t\tif (!Number.isInteger(index) || index < 0) {\n\t\t\tthrow new Error(`Invalid TTC collection index: ${index}`);\n\t\t}\n\t\tif (index >= ttcHeader.numFonts) {\n\t\t\tthrow new Error(\n\t\t\t\t`TTC collection index out of range: ${index} (count ${ttcHeader.numFonts})`,\n\t\t\t);\n\t\t}\n\t\tconst offset = ttcHeader.offsets[index] ?? 0;\n\t\tif (!Number.isFinite(offset) || offset < 0 || offset >= buffer.byteLength) {\n\t\t\tthrow new Error(`Invalid TTC font offset: ${offset}`);\n\t\t}\n\t\tconst reader = new Reader(buffer);\n\t\tconst directory = parseFontDirectory(new Reader(buffer, offset));\n\t\treturn new Font(reader, directory, options);\n\t}\n\n\t// Table accessors\n\n\t/** Check if font has a specific table */\n\thasTable(tag: Tag): boolean {\n\t\treturn this.directory.tables.has(tag);\n\t}\n\n\t/** Get table record */\n\tgetTableRecord(tag: Tag): TableRecord | undefined {\n\t\treturn this.directory.tables.get(tag);\n\t}\n\n\t/** Get reader for a table */\n\tgetTableReader(tag: Tag): Reader | null {\n\t\tconst record = this.directory.tables.get(tag);\n\t\tif (!record) return null;\n\t\treturn this.reader.slice(record.offset, record.length);\n\t}\n\n\t// Required tables (lazy-loaded)\n\n\tget head(): HeadTable {\n\t\tif (!this._head) {\n\t\t\tconst reader = this.getTableReader(Tags.head);\n\t\t\tif (!reader) throw new Error(\"Missing required 'head' table\");\n\t\t\tthis._head = parseHead(reader);\n\t\t}\n\t\treturn this._head;\n\t}\n\n\tget maxp(): MaxpTable {\n\t\tif (!this._maxp) {\n\t\t\tconst reader = this.getTableReader(Tags.maxp);\n\t\t\tif (!reader) throw new Error(\"Missing required 'maxp' table\");\n\t\t\tthis._maxp = parseMaxp(reader);\n\t\t}\n\t\treturn this._maxp;\n\t}\n\n\tget hhea(): HheaTable {\n\t\tif (!this._hhea) {\n\t\t\tconst reader = this.getTableReader(Tags.hhea);\n\t\t\tif (!reader) throw new Error(\"Missing required 'hhea' table\");\n\t\t\tthis._hhea = parseHhea(reader);\n\t\t}\n\t\treturn this._hhea;\n\t}\n\n\tget hmtx(): HmtxTable {\n\t\tif (!this._hmtx) {\n\t\t\tconst reader = this.getTableReader(Tags.hmtx);\n\t\t\tif (!reader) throw new Error(\"Missing required 'hmtx' table\");\n\t\t\tthis._hmtx = parseHmtx(\n\t\t\t\treader,\n\t\t\t\tthis.hhea.numberOfHMetrics,\n\t\t\t\tthis.numGlyphs,\n\t\t\t);\n\t\t}\n\t\treturn this._hmtx;\n\t}\n\n\tget cmap(): CmapTable {\n\t\tif (!this._cmap) {\n\t\t\tconst record = this.getTableRecord(Tags.cmap);\n\t\t\tconst reader = this.getTableReader(Tags.cmap);\n\t\t\tif (!reader || !record) throw new Error(\"Missing required 'cmap' table\");\n\t\t\tthis._cmap = parseCmap(reader, record.length);\n\t\t}\n\t\treturn this._cmap;\n\t}\n\n\tget gdef(): GdefTable | null {\n\t\tif (this._gdef === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.GDEF);\n\t\t\tthis._gdef = reader ? parseGdef(reader) : null;\n\t\t}\n\t\treturn this._gdef;\n\t}\n\n\tget gsub(): GsubTable | null {\n\t\tif (this._gsub === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.GSUB);\n\t\t\tthis._gsub = reader ? parseGsub(reader) : null;\n\t\t}\n\t\treturn this._gsub;\n\t}\n\n\tget gpos(): GposTable | null {\n\t\tif (this._gpos === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.GPOS);\n\t\t\tthis._gpos = reader ? parseGpos(reader) : null;\n\t\t}\n\t\treturn this._gpos;\n\t}\n\n\tget kern(): KernTable | null {\n\t\tif (this._kern === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.kern);\n\t\t\tthis._kern = reader ? parseKern(reader) : null;\n\t\t}\n\t\treturn this._kern;\n\t}\n\n\tget fvar(): FvarTable | null {\n\t\tif (this._fvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.fvar);\n\t\t\tthis._fvar = reader ? parseFvar(reader) : null;\n\t\t}\n\t\treturn this._fvar;\n\t}\n\n\tget hvar(): HvarTable | null {\n\t\tif (this._hvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.HVAR);\n\t\t\tthis._hvar = reader ? parseHvar(reader) : null;\n\t\t}\n\t\treturn this._hvar;\n\t}\n\n\tget vhea(): VheaTable | null {\n\t\tif (this._vhea === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.vhea);\n\t\t\tthis._vhea = reader ? parseVhea(reader) : null;\n\t\t}\n\t\treturn this._vhea;\n\t}\n\n\tget vmtx(): VmtxTable | null {\n\t\tif (this._vmtx === undefined) {\n\t\t\tconst vhea = this.vhea;\n\t\t\tif (!vhea) {\n\t\t\t\tthis._vmtx = null;\n\t\t\t} else {\n\t\t\t\tconst reader = this.getTableReader(Tags.vmtx);\n\t\t\t\tthis._vmtx = reader\n\t\t\t\t\t? parseVmtx(reader, vhea.numberOfVMetrics, this.numGlyphs)\n\t\t\t\t\t: null;\n\t\t\t}\n\t\t}\n\t\treturn this._vmtx;\n\t}\n\n\tget morx(): MorxTable | null {\n\t\tif (this._morx === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.morx);\n\t\t\tthis._morx = reader ? parseMorx(reader) : null;\n\t\t}\n\t\treturn this._morx;\n\t}\n\n\tget gvar(): GvarTable | null {\n\t\tif (this._gvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.gvar);\n\t\t\tthis._gvar = reader ? parseGvar(reader, this.numGlyphs) : null;\n\t\t}\n\t\treturn this._gvar;\n\t}\n\n\tget avar(): AvarTable | null {\n\t\tif (this._avar === undefined) {\n\t\t\tconst fvar = this.fvar;\n\t\t\tif (!fvar) {\n\t\t\t\tthis._avar = null;\n\t\t\t} else {\n\t\t\t\tconst reader = this.getTableReader(Tags.avar);\n\t\t\t\tthis._avar = reader ? parseAvar(reader, fvar.axes.length) : null;\n\t\t\t}\n\t\t}\n\t\treturn this._avar;\n\t}\n\n\tget kerx(): KerxTable | null {\n\t\tif (this._kerx === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.kerx);\n\t\t\tthis._kerx = reader ? parseKerx(reader) : null;\n\t\t}\n\t\treturn this._kerx;\n\t}\n\n\tget trak(): TrakTable | null {\n\t\tif (this._trak === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.trak);\n\t\t\tthis._trak = reader ? parseTrak(reader) : null;\n\t\t}\n\t\treturn this._trak;\n\t}\n\n\tget cff(): CffTable | null {\n\t\tif (this._cff === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CFF);\n\t\t\tthis._cff = reader ? parseCff(reader) : null;\n\t\t}\n\t\treturn this._cff;\n\t}\n\n\tget cff2(): Cff2Table | null {\n\t\tif (this._cff2 === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CFF2);\n\t\t\tthis._cff2 = reader ? parseCff2(reader) : null;\n\t\t}\n\t\treturn this._cff2;\n\t}\n\n\tget colr(): ColrTable | null {\n\t\tif (this._colr === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.COLR);\n\t\t\tthis._colr = reader ? parseColr(reader) : null;\n\t\t}\n\t\treturn this._colr;\n\t}\n\n\tget cpal(): CpalTable | null {\n\t\tif (this._cpal === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CPAL);\n\t\t\tthis._cpal = reader ? parseCpal(reader) : null;\n\t\t}\n\t\treturn this._cpal;\n\t}\n\n\tget vvar(): VvarTable | null {\n\t\tif (this._vvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.VVAR);\n\t\t\tthis._vvar = reader ? parseVvar(reader) : null;\n\t\t}\n\t\treturn this._vvar;\n\t}\n\n\tget mvar(): MvarTable | null {\n\t\tif (this._mvar === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.MVAR);\n\t\t\tthis._mvar = reader ? parseMvar(reader) : null;\n\t\t}\n\t\treturn this._mvar;\n\t}\n\n\tget os2(): Os2Table | null {\n\t\tif (this._os2 === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.OS2);\n\t\t\tthis._os2 = reader ? parseOs2(reader) : null;\n\t\t}\n\t\treturn this._os2;\n\t}\n\n\tget name(): NameTable | null {\n\t\tif (this._name === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.name);\n\t\t\tthis._name = reader ? parseName(reader) : null;\n\t\t}\n\t\treturn this._name;\n\t}\n\n\tget post(): PostTable | null {\n\t\tif (this._post === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.post);\n\t\t\tthis._post = reader ? parsePost(reader) : null;\n\t\t}\n\t\treturn this._post;\n\t}\n\n\tget base(): BaseTable | null {\n\t\tif (this._base === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.BASE);\n\t\t\tthis._base = reader ? parseBase(reader) : null;\n\t\t}\n\t\treturn this._base;\n\t}\n\n\tget jstf(): JstfTable | null {\n\t\tif (this._jstf === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.JSTF);\n\t\t\tthis._jstf = reader ? parseJstf(reader) : null;\n\t\t}\n\t\treturn this._jstf;\n\t}\n\n\tget math(): MathTable | null {\n\t\tif (this._math === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.MATH);\n\t\t\tthis._math = reader ? parseMath(reader) : null;\n\t\t}\n\t\treturn this._math;\n\t}\n\n\tget loca(): LocaTable | null {\n\t\tif (this._loca === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.loca);\n\t\t\tthis._loca = reader\n\t\t\t\t? parseLoca(reader, this.numGlyphs, this.head.indexToLocFormat)\n\t\t\t\t: null;\n\t\t}\n\t\treturn this._loca;\n\t}\n\n\tget glyf(): GlyfTable | null {\n\t\tif (this._glyf === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.glyf);\n\t\t\tthis._glyf = reader ? parseGlyf(reader) : null;\n\t\t}\n\t\treturn this._glyf;\n\t}\n\n\tget svg(): SvgTable | null {\n\t\tif (this._svg === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.SVG);\n\t\t\tthis._svg = reader ? parseSvg(reader) : null;\n\t\t}\n\t\treturn this._svg;\n\t}\n\n\tget vorg(): VorgTable | null {\n\t\tif (this._vorg === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.VORG);\n\t\t\tthis._vorg = reader ? parseVorg(reader) : null;\n\t\t}\n\t\treturn this._vorg;\n\t}\n\n\tget sbix(): SbixTable | null {\n\t\tif (this._sbix === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.sbix);\n\t\t\tthis._sbix = reader ? parseSbix(reader, this.numGlyphs) : null;\n\t\t}\n\t\treturn this._sbix;\n\t}\n\n\tget stat(): StatTable | null {\n\t\tif (this._stat === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.STAT);\n\t\t\tthis._stat = reader ? parseStat(reader) : null;\n\t\t}\n\t\treturn this._stat;\n\t}\n\n\tget cblc(): CblcTable | null {\n\t\tif (this._cblc === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CBLC);\n\t\t\tthis._cblc = reader ? parseCblc(reader) : null;\n\t\t}\n\t\treturn this._cblc;\n\t}\n\n\tget cbdt(): CbdtTable | null {\n\t\tif (this._cbdt === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.CBDT);\n\t\t\tthis._cbdt = reader ? parseCbdt(reader) : null;\n\t\t}\n\t\treturn this._cbdt;\n\t}\n\n\tget feat(): FeatTable | null {\n\t\tif (this._feat === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.feat);\n\t\t\tthis._feat = reader ? parseFeat(reader) : null;\n\t\t}\n\t\treturn this._feat;\n\t}\n\n\tget fpgm(): FpgmTable | null {\n\t\tif (this._fpgm === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.fpgm);\n\t\t\tthis._fpgm = reader ? parseFpgm(reader) : null;\n\t\t}\n\t\treturn this._fpgm;\n\t}\n\n\tget prep(): PrepTable | null {\n\t\tif (this._prep === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.prep);\n\t\t\tthis._prep = reader ? parsePrep(reader) : null;\n\t\t}\n\t\treturn this._prep;\n\t}\n\n\tget cvtTable(): CvtTable | null {\n\t\tif (this._cvt === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.cvt);\n\t\t\tthis._cvt = reader ? parseCvt(reader) : null;\n\t\t}\n\t\treturn this._cvt;\n\t}\n\n\tget gasp(): GaspTable | null {\n\t\tif (this._gasp === undefined) {\n\t\t\tconst reader = this.getTableReader(Tags.gasp);\n\t\t\tthis._gasp = reader ? parseGasp(reader) : null;\n\t\t}\n\t\treturn this._gasp;\n\t}\n\n\t// Convenience properties\n\n\t/** Number of glyphs in the font */\n\tget numGlyphs(): number {\n\t\treturn this.maxp.numGlyphs;\n\t}\n\n\t/** Units per em */\n\tget unitsPerEm(): number {\n\t\treturn this.head.unitsPerEm;\n\t}\n\n\t/** Ascender (from hhea) */\n\tget ascender(): number {\n\t\treturn this.hhea.ascender;\n\t}\n\n\t/** Descender (from hhea) */\n\tget descender(): number {\n\t\treturn this.hhea.descender;\n\t}\n\n\t/** Line gap (from hhea) */\n\tget lineGap(): number {\n\t\treturn this.hhea.lineGap;\n\t}\n\n\t/** Line height (ascender - descender + lineGap for TrueType, ascender - descender for CFF) */\n\tget height(): number {\n\t\tconst baseHeight = this.ascender - this.descender;\n\t\treturn baseHeight;\n\t}\n\n\t/**\n\t * Get scale factor for converting font units to pixels\n\t * @param sizePx Target size in pixels\n\t * @param mode Sizing mode: \"em\" (default) or \"height\"\n\t * @returns Scale factor to multiply font units by\n\t */\n\tscaleForSize(sizePx: number, mode?: \"em\" | \"height\"): number {\n\t\tif (mode === \"height\") {\n\t\t\tconst h = this.height;\n\t\t\tif (!Number.isFinite(h) || h <= 0) return sizePx / this.unitsPerEm;\n\t\t\treturn sizePx / h;\n\t\t}\n\t\treturn sizePx / this.unitsPerEm;\n\t}\n\n\t/** Is this a TrueType font (vs CFF)? */\n\tget isTrueType(): boolean {\n\t\treturn isTrueType(this.directory);\n\t}\n\n\t/** Is this a CFF font? */\n\tget isCFF(): boolean {\n\t\treturn this.hasTable(Tags.CFF) || this.hasTable(Tags.CFF2);\n\t}\n\n\t/** Is this a variable font? */\n\tget isVariable(): boolean {\n\t\treturn this.hasTable(Tags.fvar);\n\t}\n\n\t/** Has OpenType layout tables? */\n\tget hasOpenTypeLayout(): boolean {\n\t\treturn this.hasTable(Tags.GSUB) || this.hasTable(Tags.GPOS);\n\t}\n\n\t/** Has AAT layout tables? */\n\tget hasAATLayout(): boolean {\n\t\treturn this.hasTable(Tags.morx) || this.hasTable(Tags.kerx);\n\t}\n\n\t/** Is this a color font? */\n\tget isColorFont(): boolean {\n\t\treturn (\n\t\t\tthis.hasTable(Tags.COLR) ||\n\t\t\tthis.hasTable(Tags.SVG) ||\n\t\t\tthis.hasTable(Tags.sbix) ||\n\t\t\tthis.hasTable(Tags.CBDT)\n\t\t);\n\t}\n\n\t/** Does this font have TrueType hinting? */\n\tget hasHinting(): boolean {\n\t\treturn (\n\t\t\tthis.isTrueType && (this.hasTable(Tags.fpgm) || this.hasTable(Tags.prep))\n\t\t);\n\t}\n\n\t// Glyph operations\n\n\t/** Get glyph ID for a Unicode codepoint */\n\tglyphId(codepoint: number): GlyphId {\n\t\treturn getGlyphId(this.cmap, codepoint);\n\t}\n\n\t/** Get glyph ID for a character */\n\tglyphIdForChar(char: string): GlyphId {\n\t\tconst codepoint = char.codePointAt(0);\n\t\tif (codepoint === undefined) return 0;\n\t\treturn this.glyphId(codepoint);\n\t}\n\n\t/** Get advance width for a glyph */\n\tadvanceWidth(glyphId: GlyphId): number {\n\t\treturn getAdvanceWidth(this.hmtx, glyphId);\n\t}\n\n\t/** Get left side bearing for a glyph */\n\tleftSideBearing(glyphId: GlyphId): number {\n\t\treturn getLeftSideBearing(this.hmtx, glyphId);\n\t}\n\n\t/** List all table tags in the font */\n\tlistTables(): string[] {\n\t\treturn [...this.directory.tables.keys()].map(tagToString);\n\t}\n\n\t// Glyph outline operations\n\n\t/** Get raw glyph data (simple or composite) - TrueType only */\n\tgetGlyph(glyphId: GlyphId): Glyph | null {\n\t\tif (!this.glyf || !this.loca) return null;\n\t\treturn parseGlyph(this.glyf, this.loca, glyphId);\n\t}\n\n\t/** Get flattened contours for a glyph (resolves composites) */\n\tgetGlyphContours(glyphId: GlyphId): Contour[] | null {\n\t\t// Try TrueType first\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphContours(this.glyf, this.loca, glyphId);\n\t\t}\n\t\t// Try CFF\n\t\tif (this.cff) {\n\t\t\treturn executeCffCharString(this.cff, glyphId, 0);\n\t\t}\n\t\t// Try CFF2\n\t\tif (this.cff2) {\n\t\t\treturn executeCff2CharString(this.cff2, glyphId, null);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Get bounding box for a glyph */\n\tgetGlyphBounds(\n\t\tglyphId: GlyphId,\n\t): { xMin: number; yMin: number; xMax: number; yMax: number } | null {\n\t\t// Try TrueType first\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphBounds(this.glyf, this.loca, glyphId);\n\t\t}\n\t\t// For CFF, compute bounds from contours\n\t\tconst contours = this.getGlyphContours(glyphId);\n\t\tif (!contours || contours.length === 0) return null;\n\n\t\tlet xMin = Infinity;\n\t\tlet yMin = Infinity;\n\t\tlet xMax = -Infinity;\n\t\tlet yMax = -Infinity;\n\n\t\tfor (let i = 0; i < contours.length; i++) {\n\t\t\tconst contour = contours[i]!;\n\t\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\t\tconst point = contour[j]!;\n\t\t\t\txMin = Math.min(xMin, point.x);\n\t\t\t\tyMin = Math.min(yMin, point.y);\n\t\t\t\txMax = Math.max(xMax, point.x);\n\t\t\t\tyMax = Math.max(yMax, point.y);\n\t\t\t}\n\t\t}\n\n\t\tif (xMin === Infinity) return null;\n\t\treturn { xMin, yMin, xMax, yMax };\n\t}\n\n\t/**\n\t * Get contours and bounds for a glyph in a single operation.\n\t * More efficient than calling getGlyphContours + getGlyphBounds separately\n\t * as it only parses the glyph once.\n\t */\n\tgetGlyphContoursAndBounds(glyphId: GlyphId): {\n\t\tcontours: Contour[];\n\t\tbounds: { xMin: number; yMin: number; xMax: number; yMax: number } | null;\n\t} | null {\n\t\t// TrueType - use optimized combined function\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphContoursAndBounds(this.glyf, this.loca, glyphId);\n\t\t}\n\t\t// CFF - get contours and compute bounds\n\t\tconst contours = this.getGlyphContours(glyphId);\n\t\tif (!contours) return null;\n\t\tif (contours.length === 0) {\n\t\t\treturn { contours, bounds: null };\n\t\t}\n\n\t\tlet xMin = Infinity;\n\t\tlet yMin = Infinity;\n\t\tlet xMax = -Infinity;\n\t\tlet yMax = -Infinity;\n\n\t\tfor (let i = 0; i < contours.length; i++) {\n\t\t\tconst contour = contours[i]!;\n\t\t\tfor (let j = 0; j < contour.length; j++) {\n\t\t\t\tconst point = contour[j]!;\n\t\t\t\txMin = Math.min(xMin, point.x);\n\t\t\t\tyMin = Math.min(yMin, point.y);\n\t\t\t\txMax = Math.max(xMax, point.x);\n\t\t\t\tyMax = Math.max(yMax, point.y);\n\t\t\t}\n\t\t}\n\n\t\tconst bounds = xMin === Infinity ? null : { xMin, yMin, xMax, yMax };\n\t\treturn { contours, bounds };\n\t}\n\n\t/** Get contours for a glyph with variation applied */\n\tgetGlyphContoursWithVariation(\n\t\tglyphId: GlyphId,\n\t\taxisCoords: number[],\n\t): Contour[] | null {\n\t\t// Try TrueType first\n\t\tif (this.glyf && this.loca) {\n\t\t\treturn getGlyphContoursWithVariation(\n\t\t\t\tthis.glyf,\n\t\t\t\tthis.loca,\n\t\t\t\tthis.gvar,\n\t\t\t\tglyphId,\n\t\t\t\taxisCoords,\n\t\t\t);\n\t\t}\n\t\t// Try CFF2 with variation\n\t\tif (this.cff2) {\n\t\t\treturn executeCff2CharString(this.cff2, glyphId, axisCoords);\n\t\t}\n\t\t// CFF doesn't support variations\n\t\treturn this.getGlyphContours(glyphId);\n\t}\n}\n",
    "import { GlyphBuffer } from \"../buffer/glyph-buffer.ts\";\nimport type { Font } from \"../font/font.ts\";\nimport {\n\tgetExtenderGlyphs,\n\tgetExtensionMods,\n\tgetJstfPriorities,\n\tgetShrinkageMods,\n} from \"../font/tables/jstf.ts\";\nimport type { GlyphId, Tag } from \"../types.ts\";\nimport { tag } from \"../types.ts\";\n\n/**\n * Justification mode\n */\nexport enum JustifyMode {\n\t/** Shrink text to fit */\n\tShrink = \"shrink\",\n\t/** Extend text to fit */\n\tExtend = \"extend\",\n\t/** Auto-select based on delta */\n\tAuto = \"auto\",\n}\n\n/**\n * Justification options\n */\nexport interface JustifyOptions {\n\t/** Target line width */\n\ttargetWidth: number;\n\t/** Script tag */\n\tscript?: Tag;\n\t/** Language tag */\n\tlanguage?: Tag;\n\t/** Justification mode */\n\tmode?: JustifyMode;\n\t/** Maximum priority level to use (0-based) */\n\tmaxPriority?: number;\n\t/** Enable Kashida insertion for Arabic */\n\tenableKashida?: boolean;\n\t/** Minimum word spacing factor (default: 0.8) */\n\tminWordSpacingFactor?: number;\n\t/** Maximum word spacing factor (default: 1.5) */\n\tmaxWordSpacingFactor?: number;\n\t/** Enable inter-character spacing adjustment */\n\tenableLetterSpacing?: boolean;\n\t/** Maximum letter spacing in font units */\n\tmaxLetterSpacing?: number;\n}\n\n/**\n * Justification result\n */\nexport interface JustifyResult {\n\t/** Whether justification succeeded */\n\tsuccess: boolean;\n\t/** Final line width after justification */\n\tfinalWidth: number;\n\t/** Delta from target (positive = too wide, negative = too narrow) */\n\tdelta: number;\n\t/** Priority level used */\n\tpriorityLevel: number;\n\t/** Adjustments applied */\n\tadjustments: JustifyAdjustment[];\n}\n\n/**\n * Individual justification adjustment\n */\nexport interface JustifyAdjustment {\n\ttype: \"spacing\" | \"kashida\" | \"lookup\";\n\t/** Glyph indices affected */\n\tglyphIndices: number[];\n\t/** Adjustment value */\n\tvalue: number;\n}\n\n/**\n * Calculate current line width from glyph buffer\n * @param buffer - The glyph buffer to measure\n * @returns Total line width in font units (sum of all xAdvance values)\n */\nexport function calculateLineWidth(buffer: GlyphBuffer): number {\n\tlet width = 0;\n\tfor (let i = 0; i < buffer.positions.length; i++) {\n\t\tconst pos = buffer.positions[i]!;\n\t\twidth += pos.xAdvance;\n\t}\n\treturn width;\n}\n\n/**\n * Justify a shaped glyph buffer to fit a target width\n * @param font - The font containing JSTF and glyph metrics\n * @param buffer - The shaped glyph buffer to justify (modified in place)\n * @param options - Justification options including target width and mode\n * @returns Result containing success status, final width, and applied adjustments\n */\nexport function justify(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\toptions: JustifyOptions,\n): JustifyResult {\n\tconst {\n\t\ttargetWidth,\n\t\tscript = tag(\"DFLT\"),\n\t\tlanguage,\n\t\tmode = JustifyMode.Auto,\n\t\tmaxPriority = 10,\n\t\tenableKashida = true,\n\t\tminWordSpacingFactor = 0.8,\n\t\tmaxWordSpacingFactor = 1.5,\n\t\tenableLetterSpacing = true,\n\t\tmaxLetterSpacing = 100,\n\t} = options;\n\n\tconst currentWidth = calculateLineWidth(buffer);\n\tconst delta = targetWidth - currentWidth;\n\n\t// Already at target width\n\tif (Math.abs(delta) < 1) {\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tfinalWidth: currentWidth,\n\t\t\tdelta: 0,\n\t\t\tpriorityLevel: 0,\n\t\t\tadjustments: [],\n\t\t};\n\t}\n\n\t// Determine mode\n\tlet actualMode: JustifyMode.Shrink | JustifyMode.Extend;\n\tif (mode === JustifyMode.Auto) {\n\t\tactualMode = delta > 0 ? JustifyMode.Extend : JustifyMode.Shrink;\n\t} else {\n\t\tactualMode = mode as JustifyMode.Shrink | JustifyMode.Extend;\n\t}\n\n\tconst adjustments: JustifyAdjustment[] = [];\n\tlet remainingDelta = delta;\n\tlet priorityLevel = 0;\n\n\t// Try JSTF-based justification first\n\tconst jstf = font.jstf;\n\tif (jstf) {\n\t\tconst priorities = getJstfPriorities(jstf, script, language);\n\n\t\tfor (let i = 0; i < Math.min(priorities.length, maxPriority); i++) {\n\t\t\tconst priority = priorities[i];\n\t\t\tconst mods =\n\t\t\t\tactualMode === JustifyMode.Shrink\n\t\t\t\t\t? getShrinkageMods(priority)\n\t\t\t\t\t: getExtensionMods(priority);\n\n\t\t\t// Apply JSTF lookup modifications\n\t\t\t// Note: This would require reshaping with modified lookups\n\t\t\t// For now, we just record the modifications needed\n\t\t\tif (\n\t\t\t\tmods.enableGsub.length > 0 ||\n\t\t\t\tmods.disableGsub.length > 0 ||\n\t\t\t\tmods.enableGpos.length > 0 ||\n\t\t\t\tmods.disableGpos.length > 0\n\t\t\t) {\n\t\t\t\tadjustments.push({\n\t\t\t\t\ttype: \"lookup\",\n\t\t\t\t\tglyphIndices: [],\n\t\t\t\t\tvalue: i,\n\t\t\t\t});\n\t\t\t\tpriorityLevel = i;\n\t\t\t}\n\t\t}\n\n\t\t// Kashida insertion for Arabic\n\t\tif (enableKashida && actualMode === JustifyMode.Extend) {\n\t\t\tconst extenderGlyphs = getExtenderGlyphs(jstf, script);\n\t\t\tif (extenderGlyphs.length > 0) {\n\t\t\t\tconst kashidaResult = insertKashida(\n\t\t\t\t\tbuffer,\n\t\t\t\t\textenderGlyphs[0],\n\t\t\t\t\tremainingDelta,\n\t\t\t\t\tfont,\n\t\t\t\t);\n\t\t\t\tremainingDelta -= kashidaResult.totalExtension;\n\t\t\t\tadjustments.push(...kashidaResult.adjustments);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply word spacing adjustment\n\tconst spaceGlyphId = font.glyphId(0x0020); // Space character\n\tif (spaceGlyphId !== 0) {\n\t\tconst spaceResult = adjustWordSpacing(\n\t\t\tbuffer,\n\t\t\tspaceGlyphId,\n\t\t\tremainingDelta,\n\t\t\tactualMode === JustifyMode.Shrink\n\t\t\t\t? minWordSpacingFactor\n\t\t\t\t: maxWordSpacingFactor,\n\t\t);\n\t\tremainingDelta -= spaceResult.totalAdjustment;\n\t\tadjustments.push(...spaceResult.adjustments);\n\t}\n\n\t// Apply letter spacing if still needed\n\tif (enableLetterSpacing && Math.abs(remainingDelta) > 1) {\n\t\tconst letterResult = adjustLetterSpacing(\n\t\t\tbuffer,\n\t\t\tremainingDelta,\n\t\t\tmaxLetterSpacing,\n\t\t);\n\t\tremainingDelta -= letterResult.totalAdjustment;\n\t\tadjustments.push(...letterResult.adjustments);\n\t}\n\n\tconst finalWidth = calculateLineWidth(buffer);\n\n\treturn {\n\t\tsuccess: Math.abs(remainingDelta) < 1,\n\t\tfinalWidth,\n\t\tdelta: targetWidth - finalWidth,\n\t\tpriorityLevel,\n\t\tadjustments,\n\t};\n}\n\n/**\n * Insert Kashida (tatweel) characters for Arabic justification\n * @param buffer - The glyph buffer to extend (modified in place)\n * @param kashidaGlyph - The glyph ID of the Kashida character\n * @param targetExtension - Target width to extend by in font units\n * @param font - The font containing glyph metrics\n * @returns Object containing total extension achieved and list of adjustments\n */\nfunction insertKashida(\n\tbuffer: GlyphBuffer,\n\tkashidaGlyph: GlyphId,\n\ttargetExtension: number,\n\tfont: Font,\n): { totalExtension: number; adjustments: JustifyAdjustment[] } {\n\tconst adjustments: JustifyAdjustment[] = [];\n\tlet totalExtension = 0;\n\n\t// Find valid Kashida insertion points (between Arabic letters)\n\tconst insertionPoints: number[] = [];\n\tfor (let i = 0; i < buffer.infos.length - 1; i++) {\n\t\tconst info = buffer.infos[i];\n\t\t// Check if this is a valid insertion point\n\t\t// (between joining Arabic characters)\n\t\tif (isValidKashidaPoint(info.codepoint)) {\n\t\t\tinsertionPoints.push(i);\n\t\t}\n\t}\n\n\tif (insertionPoints.length === 0) {\n\t\treturn { totalExtension: 0, adjustments: [] };\n\t}\n\n\t// Get Kashida width\n\tconst kashidaWidth = font.advanceWidth(kashidaGlyph);\n\tif (kashidaWidth <= 0) {\n\t\treturn { totalExtension: 0, adjustments: [] };\n\t}\n\n\t// Distribute Kashida evenly\n\tconst kashidaPerPoint = Math.ceil(\n\t\ttargetExtension / kashidaWidth / insertionPoints.length,\n\t);\n\tconst adjustmentPerPoint = Math.min(\n\t\tkashidaPerPoint * kashidaWidth,\n\t\ttargetExtension / insertionPoints.length,\n\t);\n\n\tfor (let i = 0; i < insertionPoints.length; i++) {\n\t\tif (totalExtension >= targetExtension) break;\n\n\t\tconst point = insertionPoints[i]!;\n\t\t// Add Kashida extension via xAdvance\n\t\tbuffer.positions[point].xAdvance += adjustmentPerPoint;\n\t\ttotalExtension += adjustmentPerPoint;\n\n\t\tadjustments.push({\n\t\t\ttype: \"kashida\",\n\t\t\tglyphIndices: [point],\n\t\t\tvalue: adjustmentPerPoint,\n\t\t});\n\t}\n\n\treturn { totalExtension, adjustments };\n}\n\n/**\n * Check if a codepoint is a valid Kashida insertion point\n * @param codepoint - Unicode codepoint to check\n * @returns True if this is an Arabic character that can have Kashida after it\n */\nfunction isValidKashidaPoint(codepoint: number): boolean {\n\t// Arabic letters that can have Kashida after them\n\t// Simplified check - in reality need to check joining behavior\n\treturn codepoint >= 0x0620 && codepoint <= 0x06ff;\n}\n\n/**\n * Adjust word spacing (space character width)\n * @param buffer - The glyph buffer to adjust (modified in place)\n * @param spaceGlyph - The glyph ID of the space character\n * @param targetAdjustment - Target total adjustment in font units (positive to expand, negative to shrink)\n * @param limitFactor - Maximum spacing factor relative to original space width (e.g., 1.5 allows 150% of original)\n * @returns Object containing total adjustment achieved and list of adjustments\n */\nfunction adjustWordSpacing(\n\tbuffer: GlyphBuffer,\n\tspaceGlyph: GlyphId,\n\ttargetAdjustment: number,\n\tlimitFactor: number,\n): { totalAdjustment: number; adjustments: JustifyAdjustment[] } {\n\tconst adjustments: JustifyAdjustment[] = [];\n\tlet totalAdjustment = 0;\n\n\t// Find all space glyphs\n\tconst spaceIndices: number[] = [];\n\tlet totalSpaceWidth = 0;\n\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tif (buffer.infos[i]?.glyphId === spaceGlyph) {\n\t\t\tspaceIndices.push(i);\n\t\t\ttotalSpaceWidth += buffer.positions[i]?.xAdvance;\n\t\t}\n\t}\n\n\tif (spaceIndices.length === 0) {\n\t\treturn { totalAdjustment: 0, adjustments: [] };\n\t}\n\n\t// Calculate adjustment per space\n\tconst adjustmentPerSpace = targetAdjustment / spaceIndices.length;\n\tconst originalSpaceWidth = totalSpaceWidth / spaceIndices.length;\n\tconst maxAdjustment = originalSpaceWidth * (limitFactor - 1);\n\n\tconst clampedAdjustment =\n\t\ttargetAdjustment > 0\n\t\t\t? Math.min(adjustmentPerSpace, maxAdjustment)\n\t\t\t: Math.max(adjustmentPerSpace, -maxAdjustment);\n\n\tfor (let i = 0; i < spaceIndices.length; i++) {\n\t\tconst idx = spaceIndices[i]!;\n\t\tbuffer.positions[idx].xAdvance += clampedAdjustment;\n\t\ttotalAdjustment += clampedAdjustment;\n\t}\n\n\tif (totalAdjustment !== 0) {\n\t\tadjustments.push({\n\t\t\ttype: \"spacing\",\n\t\t\tglyphIndices: spaceIndices,\n\t\t\tvalue: clampedAdjustment,\n\t\t});\n\t}\n\n\treturn { totalAdjustment, adjustments };\n}\n\n/**\n * Adjust letter spacing (inter-character spacing)\n * @param buffer - The glyph buffer to adjust (modified in place)\n * @param targetAdjustment - Target total adjustment in font units (positive to expand, negative to shrink)\n * @param maxAdjustment - Maximum adjustment per gap in font units\n * @returns Object containing total adjustment achieved and list of adjustments\n */\nfunction adjustLetterSpacing(\n\tbuffer: GlyphBuffer,\n\ttargetAdjustment: number,\n\tmaxAdjustment: number,\n): { totalAdjustment: number; adjustments: JustifyAdjustment[] } {\n\tconst adjustments: JustifyAdjustment[] = [];\n\n\tconst numGlyphs = buffer.infos.length;\n\tif (numGlyphs <= 1) {\n\t\treturn { totalAdjustment: 0, adjustments: [] };\n\t}\n\n\t// Distribute across all inter-glyph gaps (n-1 gaps for n glyphs)\n\tconst numGaps = numGlyphs - 1;\n\tconst adjustmentPerGap = targetAdjustment / numGaps;\n\n\t// Clamp to max\n\tconst clampedAdjustment =\n\t\ttargetAdjustment > 0\n\t\t\t? Math.min(adjustmentPerGap, maxAdjustment)\n\t\t\t: Math.max(adjustmentPerGap, -maxAdjustment);\n\n\tconst affectedIndices: number[] = [];\n\tlet totalAdjustment = 0;\n\n\tfor (let i = 0; i < numGlyphs - 1; i++) {\n\t\tbuffer.positions[i].xAdvance += clampedAdjustment;\n\t\ttotalAdjustment += clampedAdjustment;\n\t\taffectedIndices.push(i);\n\t}\n\n\tif (totalAdjustment !== 0) {\n\t\tadjustments.push({\n\t\t\ttype: \"spacing\",\n\t\t\tglyphIndices: affectedIndices,\n\t\t\tvalue: clampedAdjustment,\n\t\t});\n\t}\n\n\treturn { totalAdjustment, adjustments };\n}\n\n/**\n * Simple line breaking for multi-line text\n */\nexport interface LineBreakResult {\n\tlines: GlyphBuffer[];\n\tbreakPoints: number[];\n}\n\n/**\n * Break shaped text into lines at a given width using simple greedy algorithm\n * @param buffer - The shaped glyph buffer to break into lines\n * @param maxWidth - Maximum line width in font units\n * @param spaceGlyph - Optional glyph ID of space character for word boundary detection\n * @returns Object containing array of line buffers and break point indices\n */\nexport function breakIntoLines(\n\tbuffer: GlyphBuffer,\n\tmaxWidth: number,\n\tspaceGlyph?: GlyphId,\n): LineBreakResult {\n\tconst lines: GlyphBuffer[] = [];\n\tconst breakPoints: number[] = [];\n\n\tif (buffer.infos.length === 0) {\n\t\treturn { lines: [], breakPoints: [] };\n\t}\n\n\tlet lineStart = 0;\n\tlet currentWidth = 0;\n\tlet lastBreakPoint = -1;\n\tlet _lastBreakWidth = 0;\n\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst pos = buffer.positions[i];\n\t\tconst info = buffer.infos[i];\n\n\t\tcurrentWidth += pos.xAdvance;\n\n\t\t// Track potential break points (after spaces)\n\t\tif (spaceGlyph !== undefined && info.glyphId === spaceGlyph) {\n\t\t\tlastBreakPoint = i;\n\t\t\t_lastBreakWidth = currentWidth;\n\t\t}\n\n\t\t// Check if we need to break\n\t\tif (currentWidth > maxWidth && lineStart < i) {\n\t\t\tlet breakAt: number;\n\n\t\t\tif (lastBreakPoint > lineStart) {\n\t\t\t\t// Break at last space\n\t\t\t\tbreakAt = lastBreakPoint + 1;\n\t\t\t} else {\n\t\t\t\t// Force break at current position\n\t\t\t\tbreakAt = i;\n\t\t\t}\n\n\t\t\t// Create line buffer\n\t\t\tconst lineBuffer = createLineBuffer(buffer, lineStart, breakAt);\n\t\t\tlines.push(lineBuffer);\n\t\t\tbreakPoints.push(breakAt);\n\n\t\t\t// Start new line\n\t\t\tlineStart = breakAt;\n\t\t\tcurrentWidth = 0;\n\t\t\tlastBreakPoint = -1;\n\n\t\t\t// Recalculate width from line start\n\t\t\tfor (let j = lineStart; j <= i; j++) {\n\t\t\t\tcurrentWidth += buffer.positions[j]?.xAdvance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add final line\n\tif (lineStart < buffer.infos.length) {\n\t\tconst lineBuffer = createLineBuffer(buffer, lineStart, buffer.infos.length);\n\t\tlines.push(lineBuffer);\n\t}\n\n\treturn { lines, breakPoints };\n}\n\n/**\n * Create a new GlyphBuffer from a slice of an existing buffer\n * @param source - The source glyph buffer to copy from\n * @param start - Start index (inclusive)\n * @param end - End index (exclusive)\n * @returns New glyph buffer containing the specified range\n */\nfunction createLineBuffer(\n\tsource: GlyphBuffer,\n\tstart: number,\n\tend: number,\n): GlyphBuffer {\n\tconst lineBuffer = new GlyphBuffer();\n\tlineBuffer.direction = source.direction;\n\tlineBuffer.script = source.script;\n\tlineBuffer.language = source.language;\n\n\tfor (let i = start; i < end; i++) {\n\t\tlineBuffer.infos.push({ ...source.infos[i] });\n\t\tlineBuffer.positions.push({ ...source.positions[i] });\n\t}\n\n\treturn lineBuffer;\n}\n\n/**\n * Justify all lines in a paragraph to the same width\n * @param font - The font containing JSTF and glyph metrics\n * @param lines - Array of glyph buffers representing lines (modified in place)\n * @param options - Justification options including target width and mode\n * @returns Array of justification results, one per line\n */\nexport function justifyParagraph(\n\tfont: Font,\n\tlines: GlyphBuffer[],\n\toptions: JustifyOptions,\n): JustifyResult[] {\n\tconst results: JustifyResult[] = [];\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i];\n\t\tconst isLastLine = i === lines.length - 1;\n\n\t\t// Don't justify the last line (or justify less aggressively)\n\t\tif (isLastLine) {\n\t\t\tresults.push({\n\t\t\t\tsuccess: true,\n\t\t\t\tfinalWidth: calculateLineWidth(line),\n\t\t\t\tdelta: 0,\n\t\t\t\tpriorityLevel: 0,\n\t\t\t\tadjustments: [],\n\t\t\t});\n\t\t} else {\n\t\t\tresults.push(justify(font, line, options));\n\t\t}\n\t}\n\n\treturn results;\n}\n",
    "import type { Reader } from \"../../font/binary/reader.ts\";\nimport type { Tag, uint16, uint32 } from \"../../types.ts\";\n\n/**\n * FeatureVariations table\n * Allows different feature substitutions based on variation axis coordinates\n * Used in GSUB/GPOS for variable fonts\n */\nexport interface FeatureVariations {\n\tmajorVersion: number;\n\tminorVersion: number;\n\tfeatureVariationRecords: FeatureVariationRecord[];\n}\n\n/**\n * Feature variation record\n * Contains a condition set and feature substitutions to apply when conditions are met\n */\nexport interface FeatureVariationRecord {\n\tconditionSet: ConditionSet;\n\tfeatureTableSubstitution: FeatureTableSubstitution;\n}\n\n/**\n * Condition set - all conditions must be met\n */\nexport interface ConditionSet {\n\tconditions: Condition[];\n}\n\n/**\n * Single axis condition\n */\nexport interface Condition {\n\tformat: number;\n\taxisIndex: uint16;\n\tfilterRangeMinValue: number; // F2DOT14\n\tfilterRangeMaxValue: number; // F2DOT14\n}\n\n/**\n * Feature table substitution\n * Maps feature indices to replacement feature tables\n */\nexport interface FeatureTableSubstitution {\n\tmajorVersion: number;\n\tminorVersion: number;\n\tsubstitutions: FeatureSubstitutionRecord[];\n}\n\n/**\n * Single feature substitution record\n */\nexport interface FeatureSubstitutionRecord {\n\tfeatureIndex: uint16;\n\talternateFeature: AlternateFeature;\n}\n\n/**\n * Alternate feature table\n */\nexport interface AlternateFeature {\n\tfeatureParamsOffset: uint16;\n\tlookupListIndices: uint16[];\n}\n\n/**\n * Parse FeatureVariations table\n */\nexport function parseFeatureVariations(reader: Reader): FeatureVariations {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst featureVariationRecordCount = reader.uint32();\n\n\tconst recordOffsets: {\n\t\tconditionSetOffset: uint32;\n\t\tfeatureSubstOffset: uint32;\n\t}[] = [];\n\tfor (let i = 0; i < featureVariationRecordCount; i++) {\n\t\trecordOffsets.push({\n\t\t\tconditionSetOffset: reader.offset32(),\n\t\t\tfeatureSubstOffset: reader.offset32(),\n\t\t});\n\t}\n\n\tconst featureVariationRecords: FeatureVariationRecord[] = [];\n\tfor (let i = 0; i < recordOffsets.length; i++) {\n\t\tconst offsets = recordOffsets[i]!;\n\t\tconst conditionSet = parseConditionSet(\n\t\t\treader.sliceFrom(offsets.conditionSetOffset),\n\t\t);\n\t\tconst featureTableSubstitution = parseFeatureTableSubstitution(\n\t\t\treader.sliceFrom(offsets.featureSubstOffset),\n\t\t);\n\n\t\tfeatureVariationRecords.push({\n\t\t\tconditionSet,\n\t\t\tfeatureTableSubstitution,\n\t\t});\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tfeatureVariationRecords,\n\t};\n}\n\n/**\n * Parse condition set from binary data\n * @param reader - Binary reader positioned at condition set start\n * @returns Parsed condition set containing all axis conditions\n */\nfunction parseConditionSet(reader: Reader): ConditionSet {\n\tconst conditionCount = reader.uint16();\n\tconst conditionOffsets: uint32[] = [];\n\tfor (let i = 0; i < conditionCount; i++) {\n\t\tconditionOffsets.push(reader.offset32());\n\t}\n\n\tconst conditions: Condition[] = [];\n\tfor (let i = 0; i < conditionOffsets.length; i++) {\n\t\tconst offset = conditionOffsets[i]!;\n\t\tconst condReader = reader.sliceFrom(offset);\n\t\tconst format = condReader.uint16();\n\n\t\tif (format === 1) {\n\t\t\tconditions.push({\n\t\t\t\tformat,\n\t\t\t\taxisIndex: condReader.uint16(),\n\t\t\t\tfilterRangeMinValue: condReader.f2dot14(),\n\t\t\t\tfilterRangeMaxValue: condReader.f2dot14(),\n\t\t\t});\n\t\t}\n\t}\n\n\treturn { conditions };\n}\n\n/**\n * Parse feature table substitution from binary data\n * @param reader - Binary reader positioned at feature table substitution start\n * @returns Parsed feature table substitution containing all feature substitution records\n */\nfunction parseFeatureTableSubstitution(\n\treader: Reader,\n): FeatureTableSubstitution {\n\tconst majorVersion = reader.uint16();\n\tconst minorVersion = reader.uint16();\n\tconst substitutionCount = reader.uint16();\n\n\tconst substitutionRecords: { featureIndex: uint16; offset: uint32 }[] = [];\n\tfor (let i = 0; i < substitutionCount; i++) {\n\t\tsubstitutionRecords.push({\n\t\t\tfeatureIndex: reader.uint16(),\n\t\t\toffset: reader.offset32(),\n\t\t});\n\t}\n\n\tconst substitutions: FeatureSubstitutionRecord[] = [];\n\tfor (let i = 0; i < substitutionRecords.length; i++) {\n\t\tconst record = substitutionRecords[i]!;\n\t\tconst featureReader = reader.sliceFrom(record.offset);\n\t\tconst featureParamsOffset = featureReader.offset16();\n\t\tconst lookupIndexCount = featureReader.uint16();\n\t\tconst uint16Array = featureReader.uint16Array(lookupIndexCount);\n\t\tconst lookupListIndices: uint16[] = new Array(lookupIndexCount);\n\t\tfor (let j = 0; j < lookupIndexCount; j++) {\n\t\t\tlookupListIndices[j] = uint16Array[j]!;\n\t\t}\n\n\t\tsubstitutions.push({\n\t\t\tfeatureIndex: record.featureIndex,\n\t\t\talternateFeature: {\n\t\t\t\tfeatureParamsOffset,\n\t\t\t\tlookupListIndices,\n\t\t\t},\n\t\t});\n\t}\n\n\treturn {\n\t\tmajorVersion,\n\t\tminorVersion,\n\t\tsubstitutions,\n\t};\n}\n\n/**\n * Evaluate condition set against axis coordinates\n * Returns true if all conditions are met\n */\nexport function evaluateConditionSet(\n\tconditionSet: ConditionSet,\n\taxisCoords: number[],\n): boolean {\n\tfor (let i = 0; i < conditionSet.conditions.length; i++) {\n\t\tconst condition = conditionSet.conditions[i]!;\n\t\tconst axisValue = axisCoords[condition.axisIndex] ?? 0;\n\t\tif (\n\t\t\taxisValue < condition.filterRangeMinValue ||\n\t\t\taxisValue > condition.filterRangeMaxValue\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Find matching feature variation record for given axis coordinates\n * Returns the first matching record, or null if none match\n */\nexport function findMatchingFeatureVariation(\n\tfeatureVariations: FeatureVariations,\n\taxisCoords: number[],\n): FeatureVariationRecord | null {\n\tfor (let i = 0; i < featureVariations.featureVariationRecords.length; i++) {\n\t\tconst record = featureVariations.featureVariationRecords[i]!;\n\t\tif (evaluateConditionSet(record.conditionSet, axisCoords)) {\n\t\t\treturn record;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Get substituted lookup list indices for a feature\n * Returns the original lookups if no substitution applies\n */\nexport function getSubstitutedLookups(\n\tfeatureVariations: FeatureVariations | null,\n\tfeatureIndex: number,\n\toriginalLookups: uint16[],\n\taxisCoords: number[] | null,\n): uint16[] {\n\tif (!featureVariations || !axisCoords) {\n\t\treturn originalLookups;\n\t}\n\n\tconst matchingRecord = findMatchingFeatureVariation(\n\t\tfeatureVariations,\n\t\taxisCoords,\n\t);\n\tif (!matchingRecord) {\n\t\treturn originalLookups;\n\t}\n\n\t// Check if this feature has a substitution\n\tconst substitution =\n\t\tmatchingRecord.featureTableSubstitution.substitutions.find(\n\t\t\t(s) => s.featureIndex === featureIndex,\n\t\t);\n\n\tif (substitution) {\n\t\treturn substitution.alternateFeature.lookupListIndices;\n\t}\n\n\treturn originalLookups;\n}\n\n/**\n * Apply feature variations to a feature list\n * Returns a modified feature list with substituted lookup indices\n */\nexport function applyFeatureVariations(\n\tfeatureVariations: FeatureVariations | null,\n\tfeatureLookups: Map<Tag, uint16[]>,\n\tfeatureIndices: Map<Tag, number>,\n\taxisCoords: number[] | null,\n): Map<Tag, uint16[]> {\n\tif (!featureVariations || !axisCoords) {\n\t\treturn featureLookups;\n\t}\n\n\tconst matchingRecord = findMatchingFeatureVariation(\n\t\tfeatureVariations,\n\t\taxisCoords,\n\t);\n\tif (!matchingRecord) {\n\t\treturn featureLookups;\n\t}\n\n\t// Create a new map with substituted lookups\n\tconst result = new Map(featureLookups);\n\n\tconst substitutions = matchingRecord.featureTableSubstitution.substitutions;\n\tfor (let i = 0; i < substitutions.length; i++) {\n\t\tconst substitution = substitutions[i]!;\n\t\t// Find the feature tag for this index\n\t\tconst entries = [...featureIndices.entries()];\n\t\tfor (let j = 0; j < entries.length; j++) {\n\t\t\tconst [tag, index] = entries[j]!;\n\t\t\tif (index === substitution.featureIndex) {\n\t\t\t\tresult.set(tag, substitution.alternateFeature.lookupListIndices);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n",
    "/**\n * LCD subpixel rendering support\n *\n * LCD displays have RGB subpixels that can be individually addressed\n * to achieve higher effective resolution. This module provides:\n * 1. Subpixel rendering (3x horizontal resolution)\n * 2. FIR filtering to reduce color fringing\n */\n\nimport type { GlyphPath } from \"../render/path.ts\";\nimport { GrayRaster } from \"./gray-raster.ts\";\nimport { decomposePath } from \"./outline-decompose.ts\";\nimport type { Bitmap } from \"./types.ts\";\nimport { createBitmap, PixelMode } from \"./types.ts\";\n\n/**\n * LCD filter weights for reducing color fringing\n * These are based on FreeType's default LCD filter\n */\nexport const LCD_FILTER_LIGHT: number[] = [0, 85, 86, 85, 0];\nexport const LCD_FILTER_DEFAULT: number[] = [8, 77, 86, 77, 8];\nexport const LCD_FILTER_LEGACY: number[] = [0, 64, 128, 64, 0];\n\n/**\n * LCD rendering mode\n */\nexport enum LcdMode {\n\t/** Horizontal RGB subpixels (most common) */\n\tRGB = 0,\n\t/** Horizontal BGR subpixels */\n\tBGR = 1,\n\t/** Vertical RGB subpixels */\n\tRGB_V = 2,\n\t/** Vertical BGR subpixels */\n\tBGR_V = 3,\n}\n\n/**\n * Rasterize a glyph with LCD subpixel rendering\n *\n * The algorithm:\n * 1. Render at 3x horizontal resolution\n * 2. Apply FIR filter to reduce color fringing\n * 3. Output RGB values per pixel\n *\n * @param path Glyph path to rasterize\n * @param width Width in pixels\n * @param height Height in pixels\n * @param scale Scale factor from font units to pixels\n * @param offsetX X offset in pixels\n * @param offsetY Y offset in pixels\n * @param mode LCD subpixel mode (RGB, BGR, RGB_V, BGR_V)\n * @param filterWeights FIR filter coefficients for reducing color fringing\n * @returns Bitmap with LCD subpixel data (3 bytes per pixel)\n */\nexport function rasterizeLcd(\n\tpath: GlyphPath,\n\twidth: number,\n\theight: number,\n\tscale: number,\n\toffsetX: number,\n\toffsetY: number,\n\tmode: LcdMode = LcdMode.RGB,\n\tfilterWeights: number[] = LCD_FILTER_DEFAULT,\n): Bitmap {\n\tconst isVertical = mode === LcdMode.RGB_V || mode === LcdMode.BGR_V;\n\n\tif (isVertical) {\n\t\treturn rasterizeLcdVertical(\n\t\t\tpath,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tscale,\n\t\t\toffsetX,\n\t\t\toffsetY,\n\t\t\tmode,\n\t\t\tfilterWeights,\n\t\t);\n\t}\n\n\t// Render at 3x width\n\tconst subpixelWidth = width * 3;\n\tconst grayscale = createBitmap(subpixelWidth, height, PixelMode.Gray);\n\n\tconst raster = new GrayRaster();\n\traster.setClip(0, 0, subpixelWidth, height);\n\traster.reset();\n\n\t// Scale x by 3 for subpixel resolution\n\t// The outline is shifted by 1/3 pixel for each RGB channel\n\tdecomposePath(raster, path, scale * 3, offsetX * 3, offsetY, true);\n\traster.sweep(grayscale);\n\n\t// Apply LCD filter and pack into RGB\n\tconst lcd = createBitmap(width, height, PixelMode.LCD);\n\tconst isBgr = mode === LcdMode.BGR;\n\n\tapplyLcdFilterHorizontal(grayscale, lcd, filterWeights, isBgr);\n\n\treturn lcd;\n}\n\n/**\n * Rasterize with vertical LCD subpixels\n */\nfunction rasterizeLcdVertical(\n\tpath: GlyphPath,\n\twidth: number,\n\theight: number,\n\tscale: number,\n\toffsetX: number,\n\toffsetY: number,\n\tmode: LcdMode,\n\tfilterWeights: number[],\n): Bitmap {\n\t// Render at 3x height\n\tconst subpixelHeight = height * 3;\n\tconst grayscale = createBitmap(width, subpixelHeight, PixelMode.Gray);\n\n\tconst raster = new GrayRaster();\n\traster.setClip(0, 0, width, subpixelHeight);\n\traster.reset();\n\n\t// Scale y by 3 for subpixel resolution\n\tdecomposePath(raster, path, scale, offsetX, offsetY * 3, true);\n\traster.sweep(grayscale);\n\n\t// Apply LCD filter and pack into RGB\n\tconst lcd = createBitmap(width, height, PixelMode.LCD_V);\n\tconst isBgr = mode === LcdMode.BGR_V;\n\n\tapplyLcdFilterVertical(grayscale, lcd, filterWeights, isBgr);\n\n\treturn lcd;\n}\n\n/**\n * Apply 5-tap FIR filter horizontally and pack to RGB\n */\nfunction applyLcdFilterHorizontal(\n\tsrc: Bitmap,\n\tdst: Bitmap,\n\tweights: number[],\n\tisBgr: boolean,\n): void {\n\tconst [w0, w1, w2, w3, w4] = weights;\n\tconst weightSum = w0 + w1 + w2 + w3 + w4;\n\n\tfor (let y = 0; y < dst.rows; y++) {\n\t\tconst srcRow = y * src.pitch;\n\t\tconst dstRow = y * dst.pitch;\n\n\t\tfor (let x = 0; x < dst.width; x++) {\n\t\t\t// Sample 5 subpixels centered on each RGB component\n\t\t\tconst subX = x * 3;\n\n\t\t\t// Red/Blue (first subpixel)\n\t\t\tconst r0 = subX - 2 >= 0 ? src.buffer[srcRow + subX - 2] : 0;\n\t\t\tconst r1 = subX - 1 >= 0 ? src.buffer[srcRow + subX - 1] : 0;\n\t\t\tconst r2 = src.buffer[srcRow + subX];\n\t\t\tconst r3 = subX + 1 < src.width ? src.buffer[srcRow + subX + 1] : 0;\n\t\t\tconst r4 = subX + 2 < src.width ? src.buffer[srcRow + subX + 2] : 0;\n\t\t\tconst rv = Math.min(\n\t\t\t\t255,\n\t\t\t\tMath.round(\n\t\t\t\t\t(r0 * w0 + r1 * w1 + r2 * w2 + r3 * w3 + r4 * w4) / weightSum,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Green (middle subpixel)\n\t\t\tconst g0 = subX - 1 >= 0 ? src.buffer[srcRow + subX - 1] : 0;\n\t\t\tconst g1 = src.buffer[srcRow + subX];\n\t\t\tconst g2 = subX + 1 < src.width ? src.buffer[srcRow + subX + 1] : 0;\n\t\t\tconst g3 = subX + 2 < src.width ? src.buffer[srcRow + subX + 2] : 0;\n\t\t\tconst g4 = subX + 3 < src.width ? src.buffer[srcRow + subX + 3] : 0;\n\t\t\tconst gv = Math.min(\n\t\t\t\t255,\n\t\t\t\tMath.round(\n\t\t\t\t\t(g0 * w0 + g1 * w1 + g2 * w2 + g3 * w3 + g4 * w4) / weightSum,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Blue/Red (last subpixel)\n\t\t\tconst b0 = src.buffer[srcRow + subX];\n\t\t\tconst b1 = subX + 1 < src.width ? src.buffer[srcRow + subX + 1] : 0;\n\t\t\tconst b2 = subX + 2 < src.width ? src.buffer[srcRow + subX + 2] : 0;\n\t\t\tconst b3 = subX + 3 < src.width ? src.buffer[srcRow + subX + 3] : 0;\n\t\t\tconst b4 = subX + 4 < src.width ? src.buffer[srcRow + subX + 4] : 0;\n\t\t\tconst bv = Math.min(\n\t\t\t\t255,\n\t\t\t\tMath.round(\n\t\t\t\t\t(b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3 + b4 * w4) / weightSum,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Pack RGB\n\t\t\tconst dstIdx = dstRow + x * 3;\n\t\t\tif (isBgr) {\n\t\t\t\tdst.buffer[dstIdx] = bv;\n\t\t\t\tdst.buffer[dstIdx + 1] = gv;\n\t\t\t\tdst.buffer[dstIdx + 2] = rv;\n\t\t\t} else {\n\t\t\t\tdst.buffer[dstIdx] = rv;\n\t\t\t\tdst.buffer[dstIdx + 1] = gv;\n\t\t\t\tdst.buffer[dstIdx + 2] = bv;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Apply 5-tap FIR filter vertically and pack to RGB\n */\nfunction applyLcdFilterVertical(\n\tsrc: Bitmap,\n\tdst: Bitmap,\n\tweights: number[],\n\tisBgr: boolean,\n): void {\n\tconst [w0, w1, w2, w3, w4] = weights;\n\tconst weightSum = w0 + w1 + w2 + w3 + w4;\n\n\tfor (let y = 0; y < dst.rows; y++) {\n\t\tconst subY = y * 3;\n\t\tconst dstRow = y * dst.pitch;\n\n\t\tfor (let x = 0; x < dst.width; x++) {\n\t\t\t// Red/Blue (first subpixel row)\n\t\t\tconst r0 = subY - 2 >= 0 ? src.buffer[(subY - 2) * src.pitch + x] : 0;\n\t\t\tconst r1 = subY - 1 >= 0 ? src.buffer[(subY - 1) * src.pitch + x] : 0;\n\t\t\tconst r2 = src.buffer[subY * src.pitch + x];\n\t\t\tconst r3 =\n\t\t\t\tsubY + 1 < src.rows ? src.buffer[(subY + 1) * src.pitch + x] : 0;\n\t\t\tconst r4 =\n\t\t\t\tsubY + 2 < src.rows ? src.buffer[(subY + 2) * src.pitch + x] : 0;\n\t\t\tconst rv = Math.min(\n\t\t\t\t255,\n\t\t\t\tMath.round(\n\t\t\t\t\t(r0 * w0 + r1 * w1 + r2 * w2 + r3 * w3 + r4 * w4) / weightSum,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Green (middle subpixel row)\n\t\t\tconst g0 = subY - 1 >= 0 ? src.buffer[(subY - 1) * src.pitch + x] : 0;\n\t\t\tconst g1 = src.buffer[subY * src.pitch + x];\n\t\t\tconst g2 =\n\t\t\t\tsubY + 1 < src.rows ? src.buffer[(subY + 1) * src.pitch + x] : 0;\n\t\t\tconst g3 =\n\t\t\t\tsubY + 2 < src.rows ? src.buffer[(subY + 2) * src.pitch + x] : 0;\n\t\t\tconst g4 =\n\t\t\t\tsubY + 3 < src.rows ? src.buffer[(subY + 3) * src.pitch + x] : 0;\n\t\t\tconst gv = Math.min(\n\t\t\t\t255,\n\t\t\t\tMath.round(\n\t\t\t\t\t(g0 * w0 + g1 * w1 + g2 * w2 + g3 * w3 + g4 * w4) / weightSum,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Blue/Red (last subpixel row)\n\t\t\tconst b0 = src.buffer[subY * src.pitch + x];\n\t\t\tconst b1 =\n\t\t\t\tsubY + 1 < src.rows ? src.buffer[(subY + 1) * src.pitch + x] : 0;\n\t\t\tconst b2 =\n\t\t\t\tsubY + 2 < src.rows ? src.buffer[(subY + 2) * src.pitch + x] : 0;\n\t\t\tconst b3 =\n\t\t\t\tsubY + 3 < src.rows ? src.buffer[(subY + 3) * src.pitch + x] : 0;\n\t\t\tconst b4 =\n\t\t\t\tsubY + 4 < src.rows ? src.buffer[(subY + 4) * src.pitch + x] : 0;\n\t\t\tconst bv = Math.min(\n\t\t\t\t255,\n\t\t\t\tMath.round(\n\t\t\t\t\t(b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3 + b4 * w4) / weightSum,\n\t\t\t\t),\n\t\t\t);\n\n\t\t\t// Pack RGB\n\t\t\tconst dstIdx = dstRow + x * 3;\n\t\t\tif (isBgr) {\n\t\t\t\tdst.buffer[dstIdx] = bv;\n\t\t\t\tdst.buffer[dstIdx + 1] = gv;\n\t\t\t\tdst.buffer[dstIdx + 2] = rv;\n\t\t\t} else {\n\t\t\t\tdst.buffer[dstIdx] = rv;\n\t\t\t\tdst.buffer[dstIdx + 1] = gv;\n\t\t\t\tdst.buffer[dstIdx + 2] = bv;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Convert LCD bitmap to RGBA for display\n * Uses gamma-corrected blending against a background color\n *\n * @param lcd LCD bitmap to convert\n * @param bgColor Background color as RGB (0-255 each)\n * @param fgColor Foreground color as RGB (0-255 each)\n * @returns RGBA pixel array (4 bytes per pixel)\n */\nexport function lcdToRGBA(\n\tlcd: Bitmap,\n\tbgColor: [number, number, number] = [255, 255, 255],\n\tfgColor: [number, number, number] = [0, 0, 0],\n): Uint8Array {\n\tconst rgba = new Uint8Array(lcd.width * lcd.rows * 4);\n\tconst [bgR, bgG, bgB] = bgColor;\n\tconst [fgR, fgG, fgB] = fgColor;\n\n\tfor (let y = 0; y < lcd.rows; y++) {\n\t\tconst srcRow = y * lcd.pitch;\n\t\tconst dstRow = y * lcd.width * 4;\n\n\t\tfor (let x = 0; x < lcd.width; x++) {\n\t\t\tconst srcIdx = srcRow + x * 3;\n\t\t\tconst dstIdx = dstRow + x * 4;\n\n\t\t\tconst r = lcd.buffer[srcIdx];\n\t\t\tconst g = lcd.buffer[srcIdx + 1];\n\t\t\tconst b = lcd.buffer[srcIdx + 2];\n\n\t\t\t// Blend with foreground/background\n\t\t\trgba[dstIdx] = blendChannel(bgR, fgR, r);\n\t\t\trgba[dstIdx + 1] = blendChannel(bgG, fgG, g);\n\t\t\trgba[dstIdx + 2] = blendChannel(bgB, fgB, b);\n\t\t\trgba[dstIdx + 3] = 255; // Fully opaque\n\t\t}\n\t}\n\n\treturn rgba;\n}\n\nfunction blendChannel(bg: number, fg: number, alpha: number): number {\n\treturn Math.round(bg + ((fg - bg) * alpha) / 255);\n}\n",
    "// Core types\n\n// AAT state machine\nexport {\n\tprocessContextual,\n\tprocessInsertion,\n\tprocessLigature,\n\tprocessRearrangement,\n} from \"./aat/state-machine.ts\";\n// TrueType hinting\nexport {\n\t// Interpreter\n\texecute,\n\trunCVTProgram,\n\trunFontProgram,\n\trunGlyphProgram,\n\trunProgram,\n\tsetCodeRange,\n\t// Programs\n\tcreateHintingEngine,\n\texecuteFontProgram,\n\ttype GlyphOutline,\n\ttype HintedGlyph,\n\ttype HintingEngine,\n\thintedToPixels,\n\thintGlyph,\n\tloadCVTProgram,\n\tloadFontProgram,\n\tsetSize,\n\t// Rounding\n\tcompensate,\n\tparseSuperRound,\n\tround,\n\troundDownToGrid,\n\troundOff,\n\troundSuper,\n\troundSuper45,\n\troundToDoubleGrid,\n\troundToGrid,\n\troundToHalfGrid,\n\troundUpToGrid,\n\t// Types\n\ttype CallRecord,\n\tCodeRange,\n\tcreateDefaultGraphicsState,\n\tcreateExecContext,\n\tcreateGlyphZone,\n\ttype ExecContext,\n\ttype F2Dot14,\n\ttype F26Dot6,\n\ttype FunctionDef,\n\ttype GlyphZone,\n\ttype GraphicsState,\n\ttype InstructionDef,\n\tOpcode,\n\ttype Point as HintingPoint,\n\tRoundMode,\n\tTouchFlag,\n\ttype UnitVector,\n} from \"./hinting/index.ts\";\nexport { GlyphBuffer } from \"./buffer/glyph-buffer.ts\";\n// Buffers\nexport { UnicodeBuffer } from \"./buffer/unicode-buffer.ts\";\n// Fluent API - Builder classes\n// Fluent API - Entry points\n// Fluent API - Pipe function\n// Fluent API - Pipe operators (prefixed with $ to avoid conflicts with existing exports)\nexport {\n\tadaptiveBlur as $adaptiveBlur,\n\tBitmapBuilder,\n\tbitmap,\n\t// Bitmap effects\n\tblur as $blur,\n\tboxBlur as $boxBlur,\n\tcascadeBlur as $cascadeBlur,\n\tchar,\n\tclone as $clone,\n\tcombine,\n\tcombinePaths as $combinePaths,\n\tcondensePath as $condensePath,\n\tconvert as $convert,\n\tcopy as $copy,\n\tembolden as $embolden,\n\temboldenGlyph as $emboldenGlyph,\n\t// Path effects\n\temboldenPath as $emboldenPath,\n\tfastBlur as $fastBlur,\n\tfromGlyph as $fromGlyph,\n\tglyph,\n\tglyphVar,\n\titalic as $italic,\n\tmatrix as $matrix,\n\tobliquePath as $obliquePath,\n\tPathBuilder,\n\tpad as $pad,\n\tpath,\n\tperspective as $perspective,\n\tpipe,\n\t// Rasterization\n\trasterize as $rasterize,\n\trasterizeAuto as $rasterizeAuto,\n\trasterizeWithGradient as $rasterizeWithGradient,\n\trenderMsdf as $renderMsdf,\n\t// SDF/MSDF rendering\n\trenderSdf as $renderSdf,\n\tresize as $resize,\n\tresizeBilinear as $resizeBilinear,\n\trotate as $rotate,\n\trotateDeg as $rotateDeg,\n\t// Path transforms\n\tscale as $scale,\n\tshear as $shear,\n\tshearBitmapX as $shearBitmapX,\n\tshearBitmapY as $shearBitmapY,\n\tshearGlyphX as $shearGlyphX,\n\tshearGlyphY as $shearGlyphY,\n\tshift as $shift,\n\tstrokeAsymmetric as $strokeAsymmetric,\n\tstrokeAsymmetricCombined as $strokeAsymmetricCombined,\n\tstrokePath as $strokePath,\n\ttoGray as $toGray,\n\t// Output\n\ttoRGBA as $toRGBA,\n\ttoSVG as $toSVG,\n\ttransformBitmap2D as $transformBitmap2D,\n\ttransformBitmap3D as $transformBitmap3D,\n\ttransformGlyph2D as $transformGlyph2D,\n\ttransformGlyph3D as $transformGlyph3D,\n\ttranslate as $translate,\n} from \"./fluent/index.ts\";\n// Fluent API - Types\nexport type {\n\tAutoRasterOptions,\n\tCanvasOptions,\n\tRasterOptions,\n\tSVGElementOptions,\n\tSVGOptions,\n\tTransformState,\n} from \"./fluent/types.ts\";\nexport { Reader } from \"./font/binary/reader.ts\";\nexport { createFace, Face } from \"./font/face.ts\";\n// Font parsing\nexport {\n\tFont,\n\tFontCollection,\n\ttype CollectionFaceName,\n\ttype FontLoadOptions,\n} from \"./font/font.ts\";\nexport type { AvarTable, AxisSegmentMap } from \"./font/tables/avar.ts\";\nexport { applyAvar, applyAvarMapping } from \"./font/tables/avar.ts\";\n// BASE table (baseline alignment)\nexport type {\n\tAxisTable as BaseAxisTable,\n\tBaselineValue,\n\tBaseScriptRecord,\n\tBaseTable,\n\tBaseValues,\n\tFeatMinMaxRecord,\n\tMinMax,\n\tMinMaxRecord,\n} from \"./font/tables/base.ts\";\nexport {\n\tBaselineTag,\n\tgetBaselineForScript,\n\tgetDefaultBaseline,\n\tgetMinMaxExtent,\n\tparseBase,\n} from \"./font/tables/base.ts\";\n// CBDT/CBLC (Google color bitmap) tables\nexport type {\n\tBitmapGlyph,\n\tBitmapSize,\n\tCbdtTable,\n\tCblcTable,\n\tGlyphBitmapMetrics,\n\tIndexSubTable,\n\tSbitLineMetrics,\n} from \"./font/tables/cbdt.ts\";\nexport {\n\tCbdtImageFormat,\n\tgetBitmapGlyph,\n\tgetColorBitmapSizes,\n\thasColorBitmap,\n} from \"./font/tables/cbdt.ts\";\n// CFF charstring execution\nexport {\n\texecuteCff2CharString,\n\texecuteCffCharString,\n\tgetCffGlyphWidth,\n} from \"./font/tables/cff-charstring.ts\";\n// CFF table\nexport type {\n\tCffTable,\n\tFDDict,\n\tFDSelect,\n\tPrivateDict,\n\tTopDict,\n} from \"./font/tables/cff.ts\";\nexport { getCffString, parseCff } from \"./font/tables/cff.ts\";\n// CFF2 table (variable fonts)\nexport type {\n\tCff2FDDict,\n\tCff2FDSelect,\n\tCff2PrivateDict,\n\tCff2Table,\n\tCff2TopDict,\n\tItemVariationData as Cff2ItemVariationData,\n\tItemVariationStore as Cff2ItemVariationStore,\n\tRegionAxisCoordinates as Cff2RegionAxisCoordinates,\n\tVariationRegion as Cff2VariationRegion,\n\tVariationRegionList,\n} from \"./font/tables/cff2.ts\";\nexport { calculateVariationDelta, parseCff2 } from \"./font/tables/cff2.ts\";\nexport type { CmapTable } from \"./font/tables/cmap.ts\";\n// COLR/CPAL color tables\nexport type {\n\tAffine2x3,\n\tBaseGlyphPaintRecord,\n\tBaseGlyphRecord,\n\tClipBox,\n\tClipRecord,\n\tColorLine,\n\tColorStop,\n\tColrTable,\n\tItemVariationData,\n\tItemVariationStore,\n\tLayerRecord,\n\tPaint,\n\tPaintColrGlyph,\n\tPaintColrLayers,\n\tPaintComposite,\n\tPaintGlyph,\n\tPaintLinearGradient,\n\tPaintRadialGradient,\n\tPaintRotate,\n\tPaintScale,\n\tPaintSkew,\n\tPaintSolid,\n\tPaintSweepGradient,\n\tPaintTransform,\n\tPaintTranslate,\n\tRegionAxisCoordinates,\n\tVarColorLine,\n\tVarColorStop,\n\tVariationRegion,\n} from \"./font/tables/colr.ts\";\nexport {\n\tCompositeMode,\n\tExtend,\n\tgetClipBox,\n\tgetColorLayers,\n\tgetColorPaint,\n\tgetColorVariationDelta,\n\tgetLayerPaint,\n\thasColorGlyph,\n\tisColrV1,\n\tPaintFormat,\n\tparseColr,\n} from \"./font/tables/colr.ts\";\nexport type { Color, ColorPalette, CpalTable } from \"./font/tables/cpal.ts\";\nexport {\n\tcolorToHex,\n\tcolorToRgba,\n\tgetColor,\n\tPaletteType,\n\tparseCpal,\n} from \"./font/tables/cpal.ts\";\n// AAT feat table\nexport type {\n\tFeatTable,\n\tFeatureRecord as AatFeatureRecord,\n\tFeatureSetting,\n} from \"./font/tables/feat.ts\";\nexport {\n\taatToOpenTypeTag,\n\tCaseSensitiveLayoutSetting,\n\tCharacterShapeSetting,\n\tContextualAlternativesSetting,\n\tDiacriticsSetting,\n\tFeatureFlags,\n\tFeatureType,\n\tFractionsSetting,\n\tgetAllFeatures,\n\tgetDefaultSetting,\n\tgetFeature as getAatFeature,\n\tgetSettingByValue,\n\thasSettingValue,\n\tisExclusiveFeature,\n\tLigatureSetting,\n\tLowerCaseSetting,\n\tNumberCaseSetting,\n\tNumberSpacingSetting,\n\topenTypeTagToAat,\n\tparseFeat,\n\tSmartSwashSetting,\n\tStylisticAlternativesSetting,\n\tUpperCaseSetting,\n\tVerticalPositionSetting,\n} from \"./font/tables/feat.ts\";\n// Variable font tables\nexport type {\n\tFvarTable,\n\tNamedInstance,\n\tVariationAxis,\n} from \"./font/tables/fvar.ts\";\nexport { normalizeAxisValue } from \"./font/tables/fvar.ts\";\n// gasp table\nexport type { GaspRange, GaspTable } from \"./font/tables/gasp.ts\";\nexport {\n\tGaspFlag,\n\tgetGaspBehavior,\n\tparseGasp,\n\tshouldDoGray,\n\tshouldGridFit,\n} from \"./font/tables/gasp.ts\";\n// OpenType layout tables\nexport type { GdefTable } from \"./font/tables/gdef.ts\";\n// Glyph outlines\nexport type {\n\tCompositeGlyph,\n\tContour,\n\tGlyph,\n\tGlyphPoint,\n\tSimpleGlyph,\n} from \"./font/tables/glyf.ts\";\nexport type { GposTable } from \"./font/tables/gpos.ts\";\nexport type { GsubTable } from \"./font/tables/gsub.ts\";\nexport type {\n\tGlyphVariationData,\n\tGvarTable,\n\tTupleVariationHeader,\n} from \"./font/tables/gvar.ts\";\nexport { calculateTupleScalar, getGlyphDelta } from \"./font/tables/gvar.ts\";\n// Hinting tables (fpgm, prep, cvt)\nexport type {\n\tCvtTable,\n\tFpgmTable,\n\tPrepTable,\n} from \"./font/tables/hinting.ts\";\nexport { parseCvt, parseFpgm, parsePrep } from \"./font/tables/hinting.ts\";\n// Required tables\nexport type { HeadTable } from \"./font/tables/head.ts\";\nexport type { HheaTable } from \"./font/tables/hhea.ts\";\nexport type { HmtxTable } from \"./font/tables/hmtx.ts\";\nexport type { HvarTable } from \"./font/tables/hvar.ts\";\nexport { getAdvanceWidthDelta } from \"./font/tables/hvar.ts\";\n// Legacy kern table\nexport type { KernSubtable, KernTable } from \"./font/tables/kern.ts\";\nexport { getKernValue } from \"./font/tables/kern.ts\";\nexport type { KerxSubtable, KerxTable } from \"./font/tables/kerx.ts\";\nexport { getKerxValue } from \"./font/tables/kerx.ts\";\nexport type { LocaTable } from \"./font/tables/loca.ts\";\nexport { getGlyphLocation, hasGlyphOutline } from \"./font/tables/loca.ts\";\nexport type { MaxpTable } from \"./font/tables/maxp.ts\";\n// MATH table (mathematical typesetting)\nexport type {\n\tExtendedShapeCoverage,\n\tGlyphAssembly,\n\tGlyphPartRecord,\n\tMathConstants,\n\tMathGlyphConstruction,\n\tMathGlyphInfo,\n\tMathItalicsCorrection,\n\tMathKernInfo,\n\tMathKernInfoTable,\n\tMathKernRecord,\n\tMathTable,\n\tMathTopAccentAttachment,\n\tMathValueRecord,\n\tMathVariants,\n} from \"./font/tables/math.ts\";\nexport {\n\tgetHorizontalAssembly,\n\tgetHorizontalVariants,\n\tgetItalicsCorrection,\n\tgetTopAccentAttachment,\n\tgetVerticalAssembly,\n\tgetVerticalVariants,\n\tisExtendedShape,\n\tparseMath,\n} from \"./font/tables/math.ts\";\n// AAT tables\nexport type { MorxChain, MorxSubtable, MorxTable } from \"./font/tables/morx.ts\";\nexport { applyNonContextual, MorxSubtableType } from \"./font/tables/morx.ts\";\nexport type { MvarTable, MvarValueRecord } from \"./font/tables/mvar.ts\";\nexport {\n\tgetCapHeightDelta,\n\tgetHAscenderDelta,\n\tgetHDescenderDelta,\n\tgetMetricDelta,\n\tgetXHeightDelta,\n\tMvarTags,\n} from \"./font/tables/mvar.ts\";\n// name table\nexport type { NameRecord, NameTable } from \"./font/tables/name.ts\";\nexport {\n\tgetFontFamily,\n\tgetFontSubfamily,\n\tgetFullName,\n\tgetNameById,\n\tgetPostScriptName,\n\tgetVersion,\n\tNameId,\n\tparseName,\n\tPlatformId,\n\tWindowsEncodingId,\n} from \"./font/tables/name.ts\";\n// OS/2 table\nexport type { Os2Table } from \"./font/tables/os2.ts\";\nexport {\n\tFsSelection,\n\tFsType,\n\tgetEmbeddingPermission,\n\tisBold,\n\tisItalic,\n\tparseOs2,\n\tuseTypoMetrics,\n\tWeightClass,\n\tWidthClass,\n} from \"./font/tables/os2.ts\";\n// post table\nexport type { PostTable } from \"./font/tables/post.ts\";\nexport { getGlyphName, isMonospaced, parsePost } from \"./font/tables/post.ts\";\n// SBIX (Apple bitmap) table\nexport type { SbixGlyph, SbixStrike, SbixTable } from \"./font/tables/sbix.ts\";\nexport {\n\tgetAvailablePpemSizes,\n\tgetGlyphBitmap as getSbixGlyphBitmap,\n\tgetStrikeForPpem,\n\thasGlyphBitmap,\n\tresolveDupeGlyph,\n\tSbixGraphicType,\n} from \"./font/tables/sbix.ts\";\n// STAT (Style Attributes) table\nexport type {\n\tAxisRecord,\n\tAxisValue,\n\tAxisValueFormat1,\n\tAxisValueFormat2,\n\tAxisValueFormat3,\n\tAxisValueFormat4,\n\tStatTable,\n} from \"./font/tables/stat.ts\";\nexport {\n\tAxisValueFlags,\n\tfindAxisValueByNameId,\n\tgetAxisIndex,\n\tgetAxisRecord,\n\tgetAxisValueNumber,\n\tgetAxisValuesForAxis,\n\tisElidableAxisValue,\n\tisOlderSiblingFont,\n\tmatchAxisValue,\n} from \"./font/tables/stat.ts\";\n// SVG table for color fonts\nexport type { SvgDocumentRecord, SvgTable } from \"./font/tables/svg.ts\";\nexport {\n\tgetSvgDocument,\n\tgetSvgGlyphIds,\n\thasSvgGlyph,\n} from \"./font/tables/svg.ts\";\n// JSTF table (justification)\nexport type {\n\tJstfLangSys,\n\tJstfMax,\n\tJstfModList,\n\tJstfPriorityRecord,\n\tJstfScriptRecord,\n\tJstfTable,\n} from \"./font/tables/jstf.ts\";\nexport {\n\tgetExtenderGlyphs,\n\tgetExtensionMods,\n\tgetJstfPriorities,\n\tgetShrinkageMods,\n\tJstfPriority,\n\tparseJstf,\n} from \"./font/tables/jstf.ts\";\n// SFNT font directory\nexport type { FontDirectory } from \"./font/tables/sfnt.ts\";\nexport {\n\tisCFF,\n\tisTrueType,\n\tparseFontDirectory,\n} from \"./font/tables/sfnt.ts\";\nexport type { TrackData, TrakTable } from \"./font/tables/trak.ts\";\nexport { applyTracking, getTrackingValue } from \"./font/tables/trak.ts\";\n// Vertical metrics tables\nexport type { VheaTable } from \"./font/tables/vhea.ts\";\nexport type { VerticalMetric, VmtxTable } from \"./font/tables/vmtx.ts\";\nexport { getVerticalMetrics } from \"./font/tables/vmtx.ts\";\nexport type { VertOriginYMetric, VorgTable } from \"./font/tables/vorg.ts\";\nexport { getVertOriginY, hasVertOriginY } from \"./font/tables/vorg.ts\";\nexport type { VvarTable } from \"./font/tables/vvar.ts\";\nexport {\n\tgetAdvanceHeightDelta,\n\tgetBsbDelta,\n\tgetTsbDelta,\n\tgetVorgDelta,\n} from \"./font/tables/vvar.ts\";\n// Justification\nexport type {\n\tJustifyAdjustment,\n\tJustifyOptions,\n\tJustifyResult,\n\tLineBreakResult,\n} from \"./layout/justify.ts\";\nexport {\n\tbreakIntoLines,\n\tcalculateLineWidth,\n\tJustifyMode,\n\tjustify,\n\tjustifyParagraph,\n} from \"./layout/justify.ts\";\nexport { ClassDef } from \"./layout/structures/class-def.ts\";\nexport {\n\tEMPTY_CLASS_DEF,\n\tparseClassDef,\n\tparseClassDefAt,\n} from \"./layout/structures/class-def.ts\";\n// Layout structures\nexport { Coverage } from \"./layout/structures/coverage.ts\";\nexport { parseCoverage, parseCoverageAt } from \"./layout/structures/coverage.ts\";\n// Device tables\nexport type {\n\tDeviceOrVariationIndex,\n\tDeviceTable,\n\tVariationIndexTable,\n} from \"./layout/structures/device.ts\";\nexport {\n\tapplyDeviceAdjustment,\n\tgetDeviceDelta,\n\tisVariationIndexTable,\n} from \"./layout/structures/device.ts\";\n// Feature variations\nexport type {\n\tCondition,\n\tConditionSet,\n\tFeatureVariationRecord,\n\tFeatureVariations,\n} from \"./layout/structures/feature-variations.ts\";\nexport {\n\tapplyFeatureVariations,\n\tevaluateConditionSet,\n\tfindMatchingFeatureVariation,\n\tgetSubstitutedLookups,\n} from \"./layout/structures/feature-variations.ts\";\n// Layout common structures\nexport type {\n\tFeature,\n\tFeatureList,\n\tFeatureRecord,\n\tLangSys,\n\tLangSysRecord,\n\tLookupHeader,\n\tScript as LayoutScript,\n\tScriptList,\n\tScriptRecord,\n} from \"./layout/structures/layout-common.ts\";\nexport {\n\tfindLangSys,\n\tfindScript,\n\tgetFeature,\n\tgetMarkAttachmentType,\n\tLookupFlag,\n\tparseFeatureList,\n\tparseLookupHeaders,\n\tparseScriptList,\n} from \"./layout/structures/layout-common.ts\";\n// Set digest for fast glyph coverage checking\nexport { createLookupDigest, SetDigest } from \"./layout/structures/set-digest.ts\";\n// Asymmetric stroke (independent x/y border widths)\nexport {\n\ttype AsymmetricStrokeOptions,\n\tstrokeAsymmetric,\n\tstrokeAsymmetricCombined,\n\tstrokeUniform,\n} from \"./raster/asymmetric-stroke.ts\";\n// Texture atlas for GPU rendering\nexport {\n\tatlasToAlpha,\n\tatlasToRGBA,\n\tbuildAsciiAtlas,\n\tbuildAtlas,\n\tbuildStringAtlas,\n\tgetGlyphUV,\n} from \"./raster/atlas.ts\";\n// Exact bounding box\nexport { getExactBounds } from \"./raster/bbox.ts\";\n// Fixed-point math utilities\nexport {\n\tabs,\n\tceilPixel,\n\tclamp,\n\tdivFix,\n\tdownscale,\n\tf26Dot6ToFloat,\n\tF16DOT16_ONE,\n\tF16DOT16_SHIFT,\n\tF26DOT6_ONE,\n\tF26DOT6_SHIFT,\n\tfloatToF26Dot6,\n\tfloatToPixel,\n\tfloorPixel,\n\tfracPixel,\n\thypot,\n\tmulDiv,\n\tmulFix,\n\tnormalizeVector,\n\tONE_PIXEL,\n\tPIXEL_BITS,\n\tPIXEL_MASK,\n\troundPixel,\n\tsign,\n\ttruncPixel,\n\tupscale,\n\tvectorLength,\n} from \"./raster/fixed-point.ts\";\n// Outline decomposition\nexport type { ValidationResult } from \"./raster/outline-decompose.ts\";\nexport {\n\tdecomposePath,\n\tgetFillRuleFromFlags,\n\tgetPathBounds,\n\tOutlineError,\n\tvalidateOutline,\n} from \"./raster/outline-decompose.ts\";\n// Bitmap utilities\nexport {\n\taddBitmaps,\n\tblendBitmap,\n\tcompositeBitmaps,\n\tconvertBitmap,\n\tcopyBitmap,\n\temboldenBitmap,\n\temboldenBitmapWithBearing,\n\texpandRasterMetrics,\n\texpandToFit,\n\tfixOutlineBitmap,\n\tfixOutline,\n\tmaxBitmaps,\n\tmulBitmaps,\n\tpadBitmap,\n\tresizeBitmap,\n\tresizeBitmapBilinear,\n\tshearBitmapX,\n\tshearBitmapY,\n\tshiftBitmap,\n\tsubtractBitmap,\n\tsubBitmaps,\n\ttransformBitmap2D,\n\ttransformBitmap3D,\n\tmeasureRasterGlyph,\n} from \"./raster/bitmap-utils.ts\";\n// Blur filters\nexport {\n\tblurBitmap,\n\tboxBlur,\n\tcreateGaussianKernel,\n\tgaussianBlur,\n} from \"./raster/blur.ts\";\n// Cascade blur (high-performance for large radii)\nexport {\n\tadaptiveBlur,\n\tcascadeBlur,\n\tfastGaussianBlur,\n} from \"./raster/cascade-blur.ts\";\n// Gradient fill\nexport {\n\ttype ColorStop as GradientColorStop,\n\tcreateGradientBitmap,\n\ttype Gradient,\n\tinterpolateGradient,\n\ttype LinearGradient,\n\ttype RadialGradient,\n\trasterizePathWithGradient,\n} from \"./raster/gradient.ts\";\n// LCD subpixel rendering\nexport {\n\tLCD_FILTER_DEFAULT,\n\tLCD_FILTER_LEGACY,\n\tLCD_FILTER_LIGHT,\n\tlcdToRGBA,\n\tLcdMode,\n\trasterizeLcd,\n} from \"./raster/lcd-filter.ts\";\n// MSDF (Multi-channel Signed Distance Field) rendering\nexport {\n\tassignEdgeColors,\n\tbuildMsdfAsciiAtlas,\n\tbuildMsdfAtlas,\n\tbuildMsdfStringAtlas,\n\ttype MsdfEdge,\n\ttype MsdfOptions,\n\tmedian,\n\tmsdfAtlasToRGB,\n\tmsdfAtlasToRGBA,\n\ttype Point as MsdfPoint,\n\trenderMsdf,\n\ttype SignedDistanceResult,\n\tsignedDistanceToCubic,\n\tsignedDistanceToLine,\n\tsignedDistanceToQuadratic,\n} from \"./raster/msdf.ts\";\nexport {\n\tbitmapToGray,\n\tbitmapToRGBA,\n\trasterizeGlyph,\n\trasterizeGlyphWithTransform,\n\trasterizePath,\n\trasterizeText,\n} from \"./raster/rasterize.ts\";\n// SDF rendering\nexport { renderSdf, type SdfOptions } from \"./raster/sdf.ts\";\n// Stroker\nexport {\n\ttype LineCap,\n\ttype LineJoin,\n\ttype StrokerOptions,\n\tstrokePath,\n} from \"./raster/stroker.ts\";\n// Synthetic effects\nexport { condensePath, emboldenPath, obliquePath } from \"./raster/synth.ts\";\n// Rasterization\nexport type {\n\tBitmap,\n\tFontSizeMode,\n\tGlyphAtlas,\n\tGlyphMetrics,\n\tGlyphRasterizeOptions,\n\tMsdfAtlasOptions,\n\tRasterizedGlyph,\n\tRasterizeOptions,\n\tSpan,\n\tTextRasterizeOptions,\n} from \"./raster/types.ts\";\nexport type {\n\tBitmapTransformOptions,\n\tRasterEffectOptions,\n\tRasterMetrics,\n} from \"./raster/bitmap-utils.ts\";\nexport {\n\tclearBitmap,\n\tcreateBitmap,\n\tFillRule,\n\tPixelMode,\n} from \"./raster/types.ts\";\n// Outline transforms\nexport {\n\ttype BoundingBox,\n\ttype ControlBox,\n\tclonePath,\n\tcombinePaths,\n\tcomputeControlBox,\n\tcomputeTightBounds,\n\tidentity2D,\n\tidentity3x3,\n\titalicizeOutline,\n\ttype Matrix2D,\n\ttype Matrix3x3,\n\tmultiply2D,\n\tmultiply3x3,\n\tperspectiveMatrix,\n\trotate2D,\n\trotateOutline,\n\trotateOutline90,\n\tscale2D,\n\tscaleOutline,\n\tscaleOutlinePow2,\n\tshear2D,\n\ttransformOutline2D,\n\ttransformOutline3D,\n\ttransformPoint2D,\n\ttransformPoint3x3,\n\ttranslate2D,\n\ttranslateOutline,\n\tupdateMinTransformedX,\n} from \"./render/outline-transform.ts\";\n// Rendering utilities\nexport type { GlyphPath, PathCommand, ShapedGlyph } from \"./render/path.ts\";\nexport {\n\tapplyMatrixToContext,\n\tcontourToPath,\n\tcreatePath2D,\n\tgetGlyphPath,\n\tgetGlyphPathWithVariation,\n\tgetTextWidth,\n\tglyphBufferToShapedGlyphs,\n\tglyphToSVG,\n\tmatrixToSVGTransform,\n\tpathToCanvas,\n\tpathToCanvasWithMatrix,\n\tpathToCanvasWithMatrix3D,\n\tpathToSVG,\n\tpathToSVGWithMatrix,\n\tpathToSVGWithMatrix3D,\n\trenderShapedText,\n\trenderShapedTextWithVariation,\n\tshapedTextToSVG,\n\tshapedTextToSVGWithVariation,\n} from \"./render/path.ts\";\n// Fallback positioning\nexport {\n\tapplyFallbackKerning,\n\tapplyFallbackMarkPositioning,\n} from \"./shaper/fallback.ts\";\n// Feature helpers\nexport {\n\tallSmallCaps,\n\tcapitalSpacing,\n\tcapsToSmallCaps,\n\tcaseSensitiveForms,\n\tcharacterVariant,\n\tcharacterVariants,\n\tcombineFeatures,\n\tcontextualAlternates,\n\tdiscretionaryLigatures,\n\tfeature,\n\tfeatures,\n\tfractions,\n\tfullWidthForms,\n\thalfWidthForms,\n\thistoricalLigatures,\n\tjis78Forms,\n\tjis83Forms,\n\tjis90Forms,\n\tjis2004Forms,\n\tkerning,\n\tliningFigures,\n\toldstyleFigures,\n\tordinals,\n\tpetiteCaps,\n\tproportionalFigures,\n\tproportionalWidthForms,\n\tquarterWidthForms,\n\truby,\n\tscientificInferiors,\n\tsimplifiedForms,\n\tslashedZero,\n\tsmallCaps,\n\tstandardLigatures,\n\tstylisticAlternates,\n\tstylisticSet,\n\tstylisticSets,\n\tsubscript,\n\tsuperscript,\n\tswash,\n\ttabularFigures,\n\tthirdWidthForms,\n\ttraditionalForms,\n\tverticalAlternatesRotation,\n\tverticalForms,\n\tverticalKanaAlternates,\n\tverticalLayoutFeatures,\n} from \"./shaper/features.ts\";\nexport {\n\tcreateShapePlan,\n\tgetOrCreateShapePlan,\n\ttype ShapeFeature,\n\ttype ShapePlan,\n} from \"./shaper/shape-plan.ts\";\n// Shaper\nexport {\n\ttype FontLike,\n\ttype ShapeOptions,\n\tshape,\n\tshapeInto,\n} from \"./shaper/shaper.ts\";\nexport * from \"./types.ts\";\n// BiDi processing (UAX #9)\nexport {\n\tapplyMirroring,\n\ttype BidiParagraph,\n\ttype BidiResult,\n\tBidiType,\n\tdetectDirection,\n\tgetCharType,\n\tgetEmbeddings,\n\tgetMirror,\n\tgetVisualOrder,\n\tisLTR,\n\tisRTL,\n\tprocessBidi,\n\treorderGlyphs,\n} from \"./unicode/bidi.ts\";\n// Line breaking (UAX #14)\nexport type { LineBreakAnalysis } from \"./unicode/line-break.ts\";\nexport {\n\tanalyzeLineBreaks,\n\tanalyzeLineBreaksForGlyphs,\n\tanalyzeLineBreaksFromCodepoints,\n\tBreakAction,\n\tBreakOpportunity,\n\tcanBreakAt,\n\tfindNextBreak,\n\tgetAllBreakOpportunities,\n\tgetLineBreakClass,\n\tLineBreakClass,\n\tmustBreakAt,\n} from \"./unicode/line-break.ts\";\n// Unicode utilities\nexport {\n\tdecompose,\n\tgetCombiningClass,\n\tNormalizationMode,\n\tnormalize,\n\treorderMarks,\n} from \"./unicode/normalize.ts\";\n// Script detection\nexport type { ScriptRun } from \"./unicode/script.ts\";\nexport {\n\tdetectScript,\n\tgetScript,\n\tgetScriptDirection,\n\tgetScriptRuns,\n\tgetScripts,\n\tgetScriptTag,\n\tisComplexScript,\n\tisScript,\n\tScript,\n} from \"./unicode/script.ts\";\n// Text segmentation (UAX #29)\nexport type {\n\tGraphemeBoundaries,\n\tWordBoundaries,\n} from \"./unicode/segmentation.ts\";\nexport {\n\tcountGraphemes,\n\tfindGraphemeBoundaries,\n\tfindWordBoundaries,\n\tGraphemeBreakProperty,\n\tgetGraphemeBreakProperty,\n\tgetWordBreakProperty,\n\tsplitGraphemes,\n\tsplitWords,\n\tWordBreakProperty,\n} from \"./unicode/segmentation.ts\";\n",
    "import type { GlyphInfo } from \"../types.ts\";\n\n/**\n * Normalization mode for shaping\n */\nexport enum NormalizationMode {\n\t/** No normalization */\n\tNone = 0,\n\t/** Decompose (NFD-like) */\n\tDecompose = 1,\n\t/** Compose (NFC-like) */\n\tCompose = 2,\n\t/** Auto-detect based on script */\n\tAuto = 3,\n}\n\n/**\n * Canonical Combining Class (ccc) for combining marks\n * Based on Unicode 15.0\n *\n * Optimized with early-exit for common non-combining ranges:\n * - Basic Latin (0000-007F)\n * - Latin-1 Supplement (0080-00FF)\n * - Latin Extended-A/B (0100-024F)\n * - IPA Extensions (0250-02AF)\n * - Spacing Modifier Letters (02B0-02FF) - most are spacing\n * - Greek and Coptic (0370-03FF) - base chars only\n * - Cyrillic (0400-04FF)\n * - Cyrillic Supplement (0500-052F)\n * - CJK ranges (3000+)\n * - Hangul (AC00-D7AF)\n * @param cp Unicode codepoint to check\n * @returns Canonical combining class (0 for non-combining characters, 1-255 for combining marks)\n */\nexport function getCombiningClass(cp: number): number {\n\t// FAST PATH: Most common scripts have no combining marks\n\t// Check ranges that are guaranteed CCC 0 first\n\n\t// Basic Latin, Latin-1, Latin Extended (0000-024F) - no combining marks\n\tif (cp < 0x0300) return 0;\n\n\t// Greek base characters (0370-03FF) and Cyrillic (0400-052F)\n\t// Skip the combining diacritical marks range (0300-036F)\n\tif (cp >= 0x0370 && cp < 0x0530) return 0;\n\n\t// CJK and East Asian scripts (3000+) - no combining marks in base ranges\n\tif (cp >= 0x3000) {\n\t\t// Hangul syllables (AC00-D7AF) - precomposed, no combining\n\t\tif (cp >= 0xac00 && cp <= 0xd7af) return 0;\n\t\t// CJK Unified Ideographs and related (4E00-9FFF, 3400-4DBF, etc.)\n\t\tif (cp >= 0x4e00 && cp <= 0x9fff) return 0;\n\t\tif (cp >= 0x3400 && cp <= 0x4dbf) return 0;\n\t\t// Hiragana/Katakana (3040-30FF) - base chars\n\t\tif (cp >= 0x3040 && cp < 0x3099) return 0;\n\t\tif (cp >= 0x309b && cp <= 0x30ff) return 0;\n\t\t// Bopomofo, CJK symbols\n\t\tif (cp >= 0x3100 && cp <= 0x312f) return 0;\n\t\tif (cp >= 0x3200 && cp <= 0x32ff) return 0;\n\t}\n\n\t// General combining marks (0300-036F) - check this range\n\tif (cp >= 0x0300 && cp <= 0x036f) return getLatinCcc(cp);\n\n\t// Hebrew combining marks (0591-05BD, 05BF, 05C1-05C2, 05C4-05C5, 05C7)\n\tif (cp >= 0x0591 && cp <= 0x05bd) return getHebrewCcc(cp);\n\tif (cp === 0x05bf) return 23;\n\tif (cp === 0x05c1) return 24;\n\tif (cp === 0x05c2) return 25;\n\tif (cp === 0x05c4) return 230;\n\tif (cp === 0x05c5) return 220;\n\tif (cp === 0x05c7) return 18;\n\n\t// Arabic combining marks (064B-065F, 0670)\n\tif (cp >= 0x064b && cp <= 0x065f) return getArabicCcc(cp);\n\tif (cp === 0x0670) return 35;\n\t// Extended Arabic marks\n\tif (cp >= 0x0610 && cp <= 0x061a) return 230;\n\tif (cp >= 0x06d6 && cp <= 0x06dc) return 230;\n\tif (cp >= 0x06df && cp <= 0x06e4) return 230;\n\tif (cp >= 0x06e7 && cp <= 0x06e8) return 230;\n\tif (cp >= 0x06ea && cp <= 0x06ed) return 220;\n\tif (cp === 0x08d4) return 230;\n\tif (cp >= 0x08e3 && cp <= 0x08ff) return 220;\n\n\t// Devanagari nukta and signs\n\tif (cp === 0x093c) return 7; // Nukta\n\tif (cp === 0x094d) return 9; // Virama\n\tif (cp >= 0x0951 && cp <= 0x0954) return 230; // Accent marks\n\tif (cp === 0x0955) return 0;\n\tif (cp >= 0x0956 && cp <= 0x0957) return 0;\n\n\t// Bengali nukta and virama\n\tif (cp === 0x09bc) return 7;\n\tif (cp === 0x09cd) return 9;\n\tif (cp === 0x09fe) return 230;\n\n\t// Gurmukhi\n\tif (cp === 0x0a3c) return 7; // Nukta\n\tif (cp === 0x0a4d) return 9; // Virama\n\n\t// Gujarati\n\tif (cp === 0x0abc) return 7; // Nukta\n\tif (cp === 0x0acd) return 9; // Virama\n\n\t// Oriya\n\tif (cp === 0x0b3c) return 7; // Nukta\n\tif (cp === 0x0b4d) return 9; // Virama\n\n\t// Tamil\n\tif (cp === 0x0bcd) return 9; // Virama\n\n\t// Telugu\n\tif (cp === 0x0c4d) return 9; // Virama\n\tif (cp === 0x0c55) return 84;\n\tif (cp === 0x0c56) return 91;\n\n\t// Kannada\n\tif (cp === 0x0cbc) return 7; // Nukta\n\tif (cp === 0x0ccd) return 9; // Virama\n\n\t// Malayalam\n\tif (cp === 0x0d4d) return 9; // Virama\n\n\t// Sinhala\n\tif (cp === 0x0dca) return 9; // Virama\n\n\t// Thai/Lao vowels and tone marks\n\tif (cp >= 0x0e31 && cp <= 0x0e3a) return 0; // Positioned, not reordered\n\tif (cp >= 0x0e47 && cp <= 0x0e4e) return getThaiCcc(cp);\n\tif (cp >= 0x0eb1 && cp <= 0x0ebc) return 0;\n\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return getThaiCcc(cp);\n\n\t// Tibetan\n\tif (cp >= 0x0f18 && cp <= 0x0f19) return 220;\n\tif (cp === 0x0f35) return 220;\n\tif (cp === 0x0f37) return 220;\n\tif (cp === 0x0f39) return 216;\n\tif (cp >= 0x0f71 && cp <= 0x0f7e) return getTibetanCcc(cp);\n\tif (cp >= 0x0f80 && cp <= 0x0f84) return getTibetanCcc(cp);\n\tif (cp >= 0x0f86 && cp <= 0x0f87) return 230;\n\n\t// Myanmar\n\tif (cp === 0x1037) return 7; // Nukta\n\tif (cp === 0x1039) return 9; // Virama\n\tif (cp === 0x103a) return 9;\n\n\t// Hangul Jamo (combining)\n\tif (cp >= 0x302a && cp <= 0x302f) return getHangulCcc(cp);\n\tif (cp >= 0x3099 && cp <= 0x309a) return 8; // Kana voicing\n\n\t// Note: General combining marks (0300-036F) already handled in fast path above\n\n\t// Combining Diacritical Marks Extended (1AB0-1AFF)\n\tif (cp >= 0x1ab0 && cp <= 0x1aff) return getCdmeClass(cp);\n\n\t// Combining Diacritical Marks Supplement (1DC0-1DFF)\n\tif (cp >= 0x1dc0 && cp <= 0x1dff) return getCdmsClass(cp);\n\n\t// Combining Half Marks (FE20-FE2F)\n\tif (cp >= 0xfe20 && cp <= 0xfe2f) return 230;\n\n\treturn 0;\n}\n\nfunction getThaiCcc(cp: number): number {\n\t// Thai tone marks and vowel signs above\n\tif (cp >= 0x0e48 && cp <= 0x0e4b) return 107; // Tone marks\n\tif (cp === 0x0e4c) return 0; // Thanthakhat\n\tif (cp === 0x0e4d) return 0; // Nikhahit\n\tif (cp === 0x0e4e) return 0; // Yamakkan\n\t// Lao tone marks\n\tif (cp >= 0x0ec8 && cp <= 0x0ecb) return 122;\n\treturn 0;\n}\n\nfunction getTibetanCcc(cp: number): number {\n\t// Called only for ranges 0x0f71-0x0f7e and 0x0f80-0x0f84\n\tif (cp === 0x0f71) return 129;\n\tif (cp === 0x0f72) return 130;\n\tif (cp === 0x0f73) return 0; // Composed\n\tif (cp === 0x0f74) return 132;\n\tif (cp === 0x0f75) return 0; // Composed\n\tif (cp === 0x0f76) return 0; // Composed\n\tif (cp === 0x0f77) return 0; // Composed\n\tif (cp === 0x0f78) return 0; // Composed\n\tif (cp === 0x0f79) return 0; // Composed\n\tif (cp === 0x0f7a) return 130;\n\tif (cp === 0x0f7b) return 130;\n\tif (cp === 0x0f7c) return 130;\n\tif (cp === 0x0f7d) return 130;\n\tif (cp === 0x0f7e) return 0;\n\tif (cp === 0x0f80) return 130;\n\tif (cp === 0x0f81) return 0; // Composed\n\tif (cp === 0x0f82) return 230;\n\tif (cp === 0x0f83) return 230;\n\t// cp === 0x0f84\n\treturn 9;\n}\n\nfunction getHangulCcc(cp: number): number {\n\t// Called only for range 0x302a-0x302f\n\tif (cp === 0x302a) return 218;\n\tif (cp === 0x302b) return 228;\n\tif (cp === 0x302c) return 232;\n\tif (cp === 0x302d) return 222;\n\tif (cp === 0x302e) return 224;\n\t// cp === 0x302f\n\treturn 224;\n}\n\nfunction getCdmeClass(cp: number): number {\n\t// Combining Diacritical Marks Extended\n\tif (cp >= 0x1ab0 && cp <= 0x1abe) return 230;\n\tif (cp === 0x1abf) return 220;\n\tif (cp === 0x1ac0) return 220;\n\treturn 230;\n}\n\nfunction getCdmsClass(cp: number): number {\n\t// Combining Diacritical Marks Supplement\n\tif (cp >= 0x1dc0 && cp <= 0x1dc1) return 230;\n\tif (cp === 0x1dc2) return 220;\n\tif (cp >= 0x1dc3 && cp <= 0x1dca) return 230;\n\tif (cp === 0x1dcb) return 230;\n\tif (cp === 0x1dcc) return 230;\n\tif (cp === 0x1dcd) return 234;\n\tif (cp === 0x1dce) return 214;\n\tif (cp === 0x1dcf) return 220;\n\tif (cp === 0x1dd0) return 202;\n\tif (cp >= 0x1dd1 && cp <= 0x1df5) return 230;\n\tif (cp >= 0x1df6 && cp <= 0x1df8) return 232;\n\tif (cp === 0x1df9) return 220;\n\tif (cp === 0x1dfa) return 218;\n\t// cp >= 0x1dfb && cp <= 0x1dff\n\treturn 230;\n}\n\nfunction getHebrewCcc(cp: number): number {\n\t// Called only for range 0x0591-0x05bd\n\t// Hebrew accents and marks have specific combining classes\n\tif (cp >= 0x0591 && cp <= 0x05a1) return 220; // Below marks\n\tif (cp >= 0x05a2 && cp <= 0x05af) return 230; // Above marks\n\tif (cp >= 0x05b0 && cp <= 0x05b9) {\n\t\t// Vowel points\n\t\tif (cp === 0x05b0) return 10; // Sheva\n\t\tif (cp === 0x05b1) return 11; // Hataf Segol\n\t\tif (cp === 0x05b2) return 12; // Hataf Patah\n\t\tif (cp === 0x05b3) return 13; // Hataf Qamats\n\t\tif (cp === 0x05b4) return 14; // Hiriq\n\t\tif (cp === 0x05b5) return 15; // Tsere\n\t\tif (cp === 0x05b6) return 16; // Segol\n\t\tif (cp === 0x05b7) return 17; // Patah\n\t\tif (cp === 0x05b8) return 18; // Qamats\n\t\t// cp === 0x05b9\n\t\treturn 19; // Holam\n\t}\n\tif (cp === 0x05ba) return 19; // Holam Haser\n\tif (cp === 0x05bb) return 20; // Qubuts\n\tif (cp === 0x05bc) return 21; // Dagesh\n\t// cp === 0x05bd\n\treturn 22; // Meteg\n}\n\nfunction getArabicCcc(cp: number): number {\n\tif (cp === 0x064b) return 27; // Fathatan\n\tif (cp === 0x064c) return 28; // Dammatan\n\tif (cp === 0x064d) return 29; // Kasratan\n\tif (cp === 0x064e) return 30; // Fatha\n\tif (cp === 0x064f) return 31; // Damma\n\tif (cp === 0x0650) return 32; // Kasra\n\tif (cp === 0x0651) return 33; // Shadda\n\tif (cp === 0x0652) return 34; // Sukun\n\tif (cp >= 0x0653 && cp <= 0x0655) return 230; // Maddah, Hamza above\n\tif (cp === 0x0656) return 220; // Subscript Alef\n\tif (cp === 0x0657) return 230; // Inverted Damma\n\tif (cp === 0x0658) return 230; // Mark Noon Ghunna\n\t// cp >= 0x0659 && cp <= 0x065f\n\treturn 230;\n}\n\nfunction getLatinCcc(cp: number): number {\n\t// Combining diacritical marks\n\tif (cp >= 0x0300 && cp <= 0x0314) return 230; // Above marks\n\tif (cp >= 0x0315 && cp <= 0x0315) return 232; // Above right\n\tif (cp >= 0x0316 && cp <= 0x0319) return 220; // Below marks\n\tif (cp >= 0x031a && cp <= 0x031a) return 232; // Above right\n\tif (cp >= 0x031b && cp <= 0x031b) return 216; // Attached above right\n\tif (cp >= 0x031c && cp <= 0x0320) return 220; // Below\n\tif (cp >= 0x0321 && cp <= 0x0322) return 202; // Attached below\n\tif (cp >= 0x0323 && cp <= 0x0326) return 220; // Below\n\tif (cp >= 0x0327 && cp <= 0x0328) return 202; // Attached below\n\tif (cp >= 0x0329 && cp <= 0x0333) return 220; // Below\n\tif (cp >= 0x0334 && cp <= 0x0338) return 1; // Overlay\n\tif (cp >= 0x0339 && cp <= 0x033c) return 220; // Below\n\tif (cp >= 0x033d && cp <= 0x0344) return 230; // Above\n\tif (cp === 0x0345) return 240; // Iota subscript\n\tif (cp >= 0x0346 && cp <= 0x034e) return 230; // Above\n\tif (cp === 0x034f) return 0; // CGJ\n\tif (cp >= 0x0350 && cp <= 0x0352) return 230; // Above\n\tif (cp >= 0x0353 && cp <= 0x0356) return 220; // Below\n\tif (cp >= 0x0357 && cp <= 0x0358) return 230; // Above\n\tif (cp >= 0x0359 && cp <= 0x035a) return 220; // Below\n\tif (cp >= 0x035b && cp <= 0x035b) return 230; // Above\n\tif (cp >= 0x035c && cp <= 0x035c) return 233; // Double below\n\tif (cp >= 0x035d && cp <= 0x035e) return 234; // Double above\n\tif (cp >= 0x035f && cp <= 0x035f) return 233; // Double below\n\tif (cp >= 0x0360 && cp <= 0x0361) return 234; // Double above\n\tif (cp >= 0x0362 && cp <= 0x0362) return 233; // Double below\n\tif (cp >= 0x0363 && cp <= 0x036f) return 230; // Above\n\treturn 0;\n}\n\n/**\n * Reorder combining marks according to canonical combining class\n * @param infos Array of glyph information objects (modified in place)\n */\nexport function reorderMarks(infos: GlyphInfo[]): void {\n\t// Simple bubble sort for stability (marks with same ccc keep order)\n\tconst n = infos.length;\n\tlet i = 1;\n\n\twhile (i < n) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccc = getCombiningClass(info.codepoint);\n\t\tif (ccc === 0) {\n\t\t\t// Non-combining, advance\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Look backward for marks to reorder with\n\t\tlet j = i;\n\t\twhile (j > 0) {\n\t\t\tconst prevInfo = infos[j - 1];\n\t\t\tif (!prevInfo) break;\n\n\t\t\tconst prevCcc = getCombiningClass(prevInfo.codepoint);\n\t\t\tif (prevCcc === 0) break; // Hit a base character\n\t\t\tif (prevCcc <= ccc) break; // Already in order\n\n\t\t\t// Swap\n\t\t\tinfos[j] = prevInfo;\n\t\t\tinfos[j - 1] = info;\n\t\t\tj--;\n\t\t}\n\n\t\ti++;\n\t}\n}\n\n/**\n * Common decomposition mappings (subset of Unicode decomposition)\n */\nconst DECOMPOSITIONS: Map<number, number[]> = new Map([\n\t// Latin precomposed characters (Latin-1 Supplement)\n\t[0x00c0, [0x0041, 0x0300]], //  = A + grave\n\t[0x00c1, [0x0041, 0x0301]], //  = A + acute\n\t[0x00c2, [0x0041, 0x0302]], //  = A + circumflex\n\t[0x00c3, [0x0041, 0x0303]], //  = A + tilde\n\t[0x00c4, [0x0041, 0x0308]], //  = A + diaeresis\n\t[0x00c5, [0x0041, 0x030a]], //  = A + ring\n\t[0x00c7, [0x0043, 0x0327]], //  = C + cedilla\n\t[0x00c8, [0x0045, 0x0300]], //  = E + grave\n\t[0x00c9, [0x0045, 0x0301]], //  = E + acute\n\t[0x00ca, [0x0045, 0x0302]], //  = E + circumflex\n\t[0x00cb, [0x0045, 0x0308]], //  = E + diaeresis\n\t[0x00cc, [0x0049, 0x0300]], //  = I + grave\n\t[0x00cd, [0x0049, 0x0301]], //  = I + acute\n\t[0x00ce, [0x0049, 0x0302]], //  = I + circumflex\n\t[0x00cf, [0x0049, 0x0308]], //  = I + diaeresis\n\t[0x00d1, [0x004e, 0x0303]], //  = N + tilde\n\t[0x00d2, [0x004f, 0x0300]], //  = O + grave\n\t[0x00d3, [0x004f, 0x0301]], //  = O + acute\n\t[0x00d4, [0x004f, 0x0302]], //  = O + circumflex\n\t[0x00d5, [0x004f, 0x0303]], //  = O + tilde\n\t[0x00d6, [0x004f, 0x0308]], //  = O + diaeresis\n\t[0x00d9, [0x0055, 0x0300]], //  = U + grave\n\t[0x00da, [0x0055, 0x0301]], //  = U + acute\n\t[0x00db, [0x0055, 0x0302]], //  = U + circumflex\n\t[0x00dc, [0x0055, 0x0308]], //  = U + diaeresis\n\t[0x00dd, [0x0059, 0x0301]], //  = Y + acute\n\t// Lowercase Latin-1\n\t[0x00e0, [0x0061, 0x0300]], //  = a + grave\n\t[0x00e1, [0x0061, 0x0301]], //  = a + acute\n\t[0x00e2, [0x0061, 0x0302]], //  = a + circumflex\n\t[0x00e3, [0x0061, 0x0303]], //  = a + tilde\n\t[0x00e4, [0x0061, 0x0308]], //  = a + diaeresis\n\t[0x00e5, [0x0061, 0x030a]], //  = a + ring\n\t[0x00e7, [0x0063, 0x0327]], //  = c + cedilla\n\t[0x00e8, [0x0065, 0x0300]], //  = e + grave\n\t[0x00e9, [0x0065, 0x0301]], //  = e + acute\n\t[0x00ea, [0x0065, 0x0302]], //  = e + circumflex\n\t[0x00eb, [0x0065, 0x0308]], //  = e + diaeresis\n\t[0x00ec, [0x0069, 0x0300]], //  = i + grave\n\t[0x00ed, [0x0069, 0x0301]], //  = i + acute\n\t[0x00ee, [0x0069, 0x0302]], //  = i + circumflex\n\t[0x00ef, [0x0069, 0x0308]], //  = i + diaeresis\n\t[0x00f1, [0x006e, 0x0303]], //  = n + tilde\n\t[0x00f2, [0x006f, 0x0300]], //  = o + grave\n\t[0x00f3, [0x006f, 0x0301]], //  = o + acute\n\t[0x00f4, [0x006f, 0x0302]], //  = o + circumflex\n\t[0x00f5, [0x006f, 0x0303]], //  = o + tilde\n\t[0x00f6, [0x006f, 0x0308]], //  = o + diaeresis\n\t[0x00f9, [0x0075, 0x0300]], //  = u + grave\n\t[0x00fa, [0x0075, 0x0301]], //  = u + acute\n\t[0x00fb, [0x0075, 0x0302]], //  = u + circumflex\n\t[0x00fc, [0x0075, 0x0308]], //  = u + diaeresis\n\t[0x00fd, [0x0079, 0x0301]], //  = y + acute\n\t[0x00ff, [0x0079, 0x0308]], //  = y + diaeresis\n\t// Latin Extended-A\n\t[0x0100, [0x0041, 0x0304]], //  = A + macron\n\t[0x0101, [0x0061, 0x0304]], //  = a + macron\n\t[0x0102, [0x0041, 0x0306]], //  = A + breve\n\t[0x0103, [0x0061, 0x0306]], //  = a + breve\n\t[0x0104, [0x0041, 0x0328]], //  = A + ogonek\n\t[0x0105, [0x0061, 0x0328]], //  = a + ogonek\n\t[0x0106, [0x0043, 0x0301]], //  = C + acute\n\t[0x0107, [0x0063, 0x0301]], //  = c + acute\n\t[0x0108, [0x0043, 0x0302]], //  = C + circumflex\n\t[0x0109, [0x0063, 0x0302]], //  = c + circumflex\n\t[0x010a, [0x0043, 0x0307]], //  = C + dot above\n\t[0x010b, [0x0063, 0x0307]], //  = c + dot above\n\t[0x010c, [0x0043, 0x030c]], //  = C + caron\n\t[0x010d, [0x0063, 0x030c]], //  = c + caron\n\t[0x010e, [0x0044, 0x030c]], //  = D + caron\n\t[0x010f, [0x0064, 0x030c]], //  = d + caron\n\t[0x0112, [0x0045, 0x0304]], //  = E + macron\n\t[0x0113, [0x0065, 0x0304]], //  = e + macron\n\t[0x0114, [0x0045, 0x0306]], //  = E + breve\n\t[0x0115, [0x0065, 0x0306]], //  = e + breve\n\t[0x0116, [0x0045, 0x0307]], //  = E + dot above\n\t[0x0117, [0x0065, 0x0307]], //  = e + dot above\n\t[0x0118, [0x0045, 0x0328]], //  = E + ogonek\n\t[0x0119, [0x0065, 0x0328]], //  = e + ogonek\n\t[0x011a, [0x0045, 0x030c]], //  = E + caron\n\t[0x011b, [0x0065, 0x030c]], //  = e + caron\n\t[0x011c, [0x0047, 0x0302]], //  = G + circumflex\n\t[0x011d, [0x0067, 0x0302]], //  = g + circumflex\n\t[0x011e, [0x0047, 0x0306]], //  = G + breve\n\t[0x011f, [0x0067, 0x0306]], //  = g + breve\n\t[0x0120, [0x0047, 0x0307]], //  = G + dot above\n\t[0x0121, [0x0067, 0x0307]], //  = g + dot above\n\t[0x0122, [0x0047, 0x0327]], //  = G + cedilla\n\t[0x0123, [0x0067, 0x0327]], //  = g + cedilla\n\t[0x0124, [0x0048, 0x0302]], //  = H + circumflex\n\t[0x0125, [0x0068, 0x0302]], //  = h + circumflex\n\t[0x0128, [0x0049, 0x0303]], //  = I + tilde\n\t[0x0129, [0x0069, 0x0303]], //  = i + tilde\n\t[0x012a, [0x0049, 0x0304]], //  = I + macron\n\t[0x012b, [0x0069, 0x0304]], //  = i + macron\n\t[0x012c, [0x0049, 0x0306]], //  = I + breve\n\t[0x012d, [0x0069, 0x0306]], //  = i + breve\n\t[0x012e, [0x0049, 0x0328]], //  = I + ogonek\n\t[0x012f, [0x0069, 0x0328]], //  = i + ogonek\n\t[0x0130, [0x0049, 0x0307]], //  = I + dot above\n\t[0x0134, [0x004a, 0x0302]], //  = J + circumflex\n\t[0x0135, [0x006a, 0x0302]], //  = j + circumflex\n\t[0x0136, [0x004b, 0x0327]], //  = K + cedilla\n\t[0x0137, [0x006b, 0x0327]], //  = k + cedilla\n\t[0x0139, [0x004c, 0x0301]], //  = L + acute\n\t[0x013a, [0x006c, 0x0301]], //  = l + acute\n\t[0x013b, [0x004c, 0x0327]], //  = L + cedilla\n\t[0x013c, [0x006c, 0x0327]], //  = l + cedilla\n\t[0x013d, [0x004c, 0x030c]], //  = L + caron\n\t[0x013e, [0x006c, 0x030c]], //  = l + caron\n\t[0x0143, [0x004e, 0x0301]], //  = N + acute\n\t[0x0144, [0x006e, 0x0301]], //  = n + acute\n\t[0x0145, [0x004e, 0x0327]], //  = N + cedilla\n\t[0x0146, [0x006e, 0x0327]], //  = n + cedilla\n\t[0x0147, [0x004e, 0x030c]], //  = N + caron\n\t[0x0148, [0x006e, 0x030c]], //  = n + caron\n\t[0x014c, [0x004f, 0x0304]], //  = O + macron\n\t[0x014d, [0x006f, 0x0304]], //  = o + macron\n\t[0x014e, [0x004f, 0x0306]], //  = O + breve\n\t[0x014f, [0x006f, 0x0306]], //  = o + breve\n\t[0x0150, [0x004f, 0x030b]], //  = O + double acute\n\t[0x0151, [0x006f, 0x030b]], //  = o + double acute\n\t[0x0154, [0x0052, 0x0301]], //  = R + acute\n\t[0x0155, [0x0072, 0x0301]], //  = r + acute\n\t[0x0156, [0x0052, 0x0327]], //  = R + cedilla\n\t[0x0157, [0x0072, 0x0327]], //  = r + cedilla\n\t[0x0158, [0x0052, 0x030c]], //  = R + caron\n\t[0x0159, [0x0072, 0x030c]], //  = r + caron\n\t[0x015a, [0x0053, 0x0301]], //  = S + acute\n\t[0x015b, [0x0073, 0x0301]], //  = s + acute\n\t[0x015c, [0x0053, 0x0302]], //  = S + circumflex\n\t[0x015d, [0x0073, 0x0302]], //  = s + circumflex\n\t[0x015e, [0x0053, 0x0327]], //  = S + cedilla\n\t[0x015f, [0x0073, 0x0327]], //  = s + cedilla\n\t[0x0160, [0x0053, 0x030c]], //  = S + caron\n\t[0x0161, [0x0073, 0x030c]], //  = s + caron\n\t[0x0162, [0x0054, 0x0327]], //  = T + cedilla\n\t[0x0163, [0x0074, 0x0327]], //  = t + cedilla\n\t[0x0164, [0x0054, 0x030c]], //  = T + caron\n\t[0x0165, [0x0074, 0x030c]], //  = t + caron\n\t[0x0168, [0x0055, 0x0303]], //  = U + tilde\n\t[0x0169, [0x0075, 0x0303]], //  = u + tilde\n\t[0x016a, [0x0055, 0x0304]], //  = U + macron\n\t[0x016b, [0x0075, 0x0304]], //  = u + macron\n\t[0x016c, [0x0055, 0x0306]], //  = U + breve\n\t[0x016d, [0x0075, 0x0306]], //  = u + breve\n\t[0x016e, [0x0055, 0x030a]], //  = U + ring\n\t[0x016f, [0x0075, 0x030a]], //  = u + ring\n\t[0x0170, [0x0055, 0x030b]], //  = U + double acute\n\t[0x0171, [0x0075, 0x030b]], //  = u + double acute\n\t[0x0172, [0x0055, 0x0328]], //  = U + ogonek\n\t[0x0173, [0x0075, 0x0328]], //  = u + ogonek\n\t[0x0174, [0x0057, 0x0302]], //  = W + circumflex\n\t[0x0175, [0x0077, 0x0302]], //  = w + circumflex\n\t[0x0176, [0x0059, 0x0302]], //  = Y + circumflex\n\t[0x0177, [0x0079, 0x0302]], //  = y + circumflex\n\t[0x0178, [0x0059, 0x0308]], //  = Y + diaeresis\n\t[0x0179, [0x005a, 0x0301]], //  = Z + acute\n\t[0x017a, [0x007a, 0x0301]], //  = z + acute\n\t[0x017b, [0x005a, 0x0307]], //  = Z + dot above\n\t[0x017c, [0x007a, 0x0307]], //  = z + dot above\n\t[0x017d, [0x005a, 0x030c]], //  = Z + caron\n\t[0x017e, [0x007a, 0x030c]], //  = z + caron\n\t// Vietnamese characters (Latin Extended Additional)\n\t[0x1ea0, [0x0041, 0x0323]], //  = A + dot below\n\t[0x1ea1, [0x0061, 0x0323]], //  = a + dot below\n\t[0x1ea2, [0x0041, 0x0309]], //  = A + hook above\n\t[0x1ea3, [0x0061, 0x0309]], //  = a + hook above\n\t[0x1eb8, [0x0045, 0x0323]], //  = E + dot below\n\t[0x1eb9, [0x0065, 0x0323]], //  = e + dot below\n\t[0x1eba, [0x0045, 0x0309]], //  = E + hook above\n\t[0x1ebb, [0x0065, 0x0309]], //  = e + hook above\n\t[0x1ebc, [0x0045, 0x0303]], //  = E + tilde\n\t[0x1ebd, [0x0065, 0x0303]], //  = e + tilde\n\t[0x1ec8, [0x0049, 0x0309]], //  = I + hook above\n\t[0x1ec9, [0x0069, 0x0309]], //  = i + hook above\n\t[0x1eca, [0x0049, 0x0323]], //  = I + dot below\n\t[0x1ecb, [0x0069, 0x0323]], //  = i + dot below\n\t[0x1ecc, [0x004f, 0x0323]], //  = O + dot below\n\t[0x1ecd, [0x006f, 0x0323]], //  = o + dot below\n\t[0x1ece, [0x004f, 0x0309]], //  = O + hook above\n\t[0x1ecf, [0x006f, 0x0309]], //  = o + hook above\n\t[0x1ee4, [0x0055, 0x0323]], //  = U + dot below\n\t[0x1ee5, [0x0075, 0x0323]], //  = u + dot below\n\t[0x1ee6, [0x0055, 0x0309]], //  = U + hook above\n\t[0x1ee7, [0x0075, 0x0309]], //  = u + hook above\n\t[0x1ef2, [0x0059, 0x0300]], //  = Y + grave\n\t[0x1ef3, [0x0079, 0x0300]], //  = y + grave\n\t[0x1ef4, [0x0059, 0x0323]], //  = Y + dot below\n\t[0x1ef5, [0x0079, 0x0323]], //  = y + dot below\n\t[0x1ef6, [0x0059, 0x0309]], //  = Y + hook above\n\t[0x1ef7, [0x0079, 0x0309]], //  = y + hook above\n\t[0x1ef8, [0x0059, 0x0303]], //  = Y + tilde\n\t[0x1ef9, [0x0079, 0x0303]], //  = y + tilde\n\t// Greek Extended\n\t[0x1f00, [0x03b1, 0x0313]], //  =  + psili\n\t[0x1f01, [0x03b1, 0x0314]], //  =  + dasia\n\t[0x1f08, [0x0391, 0x0313]], //  =  + psili\n\t[0x1f09, [0x0391, 0x0314]], //  =  + dasia\n\t// Cyrillic (common)\n\t[0x0439, [0x0438, 0x0306]], //  =  + breve\n\t[0x0419, [0x0418, 0x0306]], //  =  + breve\n\t[0x0451, [0x0435, 0x0308]], //  =  + diaeresis\n\t[0x0401, [0x0415, 0x0308]], //  =  + diaeresis\n]);\n\n/**\n * Decompose a codepoint if it has a canonical decomposition\n * @param cp Unicode codepoint to decompose\n * @returns Array of decomposed codepoints, or null if character has no decomposition\n */\nexport function decompose(cp: number): number[] | null {\n\treturn DECOMPOSITIONS.get(cp) ?? null;\n}\n\n/**\n * Common composition mappings (subset of Unicode canonical composition)\n * Maps (base, combining) pairs to composed character\n */\nconst COMPOSITIONS: Map<number, Map<number, number>> = new Map([\n\t// Latin A compositions\n\t[\n\t\t0x0041,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00c0], // A + grave = \n\t\t\t[0x0301, 0x00c1], // A + acute = \n\t\t\t[0x0302, 0x00c2], // A + circumflex = \n\t\t\t[0x0303, 0x00c3], // A + tilde = \n\t\t\t[0x0308, 0x00c4], // A + diaeresis = \n\t\t\t[0x030a, 0x00c5], // A + ring = \n\t\t\t[0x0328, 0x0104], // A + ogonek = \n\t\t\t[0x030c, 0x01cd], // A + caron = \n\t\t\t[0x0304, 0x0100], // A + macron = \n\t\t\t[0x0306, 0x0102], // A + breve = \n\t\t]),\n\t],\n\t// Latin C compositions\n\t[\n\t\t0x0043,\n\t\tnew Map([\n\t\t\t[0x0327, 0x00c7], // C + cedilla = \n\t\t\t[0x0301, 0x0106], // C + acute = \n\t\t\t[0x0302, 0x0108], // C + circumflex = \n\t\t\t[0x030c, 0x010c], // C + caron = \n\t\t\t[0x0307, 0x010a], // C + dot above = \n\t\t]),\n\t],\n\t// Latin E compositions\n\t[\n\t\t0x0045,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00c8], // E + grave = \n\t\t\t[0x0301, 0x00c9], // E + acute = \n\t\t\t[0x0302, 0x00ca], // E + circumflex = \n\t\t\t[0x0308, 0x00cb], // E + diaeresis = \n\t\t\t[0x0328, 0x0118], // E + ogonek = \n\t\t\t[0x030c, 0x011a], // E + caron = \n\t\t\t[0x0304, 0x0112], // E + macron = \n\t\t\t[0x0306, 0x0114], // E + breve = \n\t\t\t[0x0307, 0x0116], // E + dot above = \n\t\t]),\n\t],\n\t// Latin I compositions\n\t[\n\t\t0x0049,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00cc], // I + grave = \n\t\t\t[0x0301, 0x00cd], // I + acute = \n\t\t\t[0x0302, 0x00ce], // I + circumflex = \n\t\t\t[0x0308, 0x00cf], // I + diaeresis = \n\t\t\t[0x0303, 0x0128], // I + tilde = \n\t\t\t[0x0304, 0x012a], // I + macron = \n\t\t\t[0x0306, 0x012c], // I + breve = \n\t\t\t[0x0328, 0x012e], // I + ogonek = \n\t\t\t[0x0307, 0x0130], // I + dot above = \n\t\t]),\n\t],\n\t// Latin N compositions\n\t[\n\t\t0x004e,\n\t\tnew Map([\n\t\t\t[0x0303, 0x00d1], // N + tilde = \n\t\t\t[0x0301, 0x0143], // N + acute = \n\t\t\t[0x0327, 0x0145], // N + cedilla = \n\t\t\t[0x030c, 0x0147], // N + caron = \n\t\t]),\n\t],\n\t// Latin O compositions\n\t[\n\t\t0x004f,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00d2], // O + grave = \n\t\t\t[0x0301, 0x00d3], // O + acute = \n\t\t\t[0x0302, 0x00d4], // O + circumflex = \n\t\t\t[0x0303, 0x00d5], // O + tilde = \n\t\t\t[0x0308, 0x00d6], // O + diaeresis = \n\t\t\t[0x0304, 0x014c], // O + macron = \n\t\t\t[0x0306, 0x014e], // O + breve = \n\t\t\t[0x030b, 0x0150], // O + double acute = \n\t\t\t[0x0328, 0x01ea], // O + ogonek = \n\t\t]),\n\t],\n\t// Latin U compositions\n\t[\n\t\t0x0055,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00d9], // U + grave = \n\t\t\t[0x0301, 0x00da], // U + acute = \n\t\t\t[0x0302, 0x00db], // U + circumflex = \n\t\t\t[0x0308, 0x00dc], // U + diaeresis = \n\t\t\t[0x0303, 0x0168], // U + tilde = \n\t\t\t[0x0304, 0x016a], // U + macron = \n\t\t\t[0x0306, 0x016c], // U + breve = \n\t\t\t[0x030a, 0x016e], // U + ring = \n\t\t\t[0x030b, 0x0170], // U + double acute = \n\t\t\t[0x0328, 0x0172], // U + ogonek = \n\t\t\t[0x030c, 0x01d3], // U + caron = \n\t\t]),\n\t],\n\t// Latin Y compositions\n\t[\n\t\t0x0059,\n\t\tnew Map([\n\t\t\t[0x0301, 0x00dd], // Y + acute = \n\t\t\t[0x0302, 0x0176], // Y + circumflex = \n\t\t\t[0x0308, 0x0178], // Y + diaeresis = \n\t\t]),\n\t],\n\t// Lowercase a compositions\n\t[\n\t\t0x0061,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00e0], // a + grave = \n\t\t\t[0x0301, 0x00e1], // a + acute = \n\t\t\t[0x0302, 0x00e2], // a + circumflex = \n\t\t\t[0x0303, 0x00e3], // a + tilde = \n\t\t\t[0x0308, 0x00e4], // a + diaeresis = \n\t\t\t[0x030a, 0x00e5], // a + ring = \n\t\t\t[0x0328, 0x0105], // a + ogonek = \n\t\t\t[0x030c, 0x01ce], // a + caron = \n\t\t\t[0x0304, 0x0101], // a + macron = \n\t\t\t[0x0306, 0x0103], // a + breve = \n\t\t]),\n\t],\n\t// Lowercase c compositions\n\t[\n\t\t0x0063,\n\t\tnew Map([\n\t\t\t[0x0327, 0x00e7], // c + cedilla = \n\t\t\t[0x0301, 0x0107], // c + acute = \n\t\t\t[0x0302, 0x0109], // c + circumflex = \n\t\t\t[0x030c, 0x010d], // c + caron = \n\t\t\t[0x0307, 0x010b], // c + dot above = \n\t\t]),\n\t],\n\t// Lowercase e compositions\n\t[\n\t\t0x0065,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00e8], // e + grave = \n\t\t\t[0x0301, 0x00e9], // e + acute = \n\t\t\t[0x0302, 0x00ea], // e + circumflex = \n\t\t\t[0x0308, 0x00eb], // e + diaeresis = \n\t\t\t[0x0328, 0x0119], // e + ogonek = \n\t\t\t[0x030c, 0x011b], // e + caron = \n\t\t\t[0x0304, 0x0113], // e + macron = \n\t\t\t[0x0306, 0x0115], // e + breve = \n\t\t\t[0x0307, 0x0117], // e + dot above = \n\t\t]),\n\t],\n\t// Lowercase i compositions\n\t[\n\t\t0x0069,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00ec], // i + grave = \n\t\t\t[0x0301, 0x00ed], // i + acute = \n\t\t\t[0x0302, 0x00ee], // i + circumflex = \n\t\t\t[0x0308, 0x00ef], // i + diaeresis = \n\t\t\t[0x0303, 0x0129], // i + tilde = \n\t\t\t[0x0304, 0x012b], // i + macron = \n\t\t\t[0x0306, 0x012d], // i + breve = \n\t\t\t[0x0328, 0x012f], // i + ogonek = \n\t\t]),\n\t],\n\t// Lowercase n compositions\n\t[\n\t\t0x006e,\n\t\tnew Map([\n\t\t\t[0x0303, 0x00f1], // n + tilde = \n\t\t\t[0x0301, 0x0144], // n + acute = \n\t\t\t[0x0327, 0x0146], // n + cedilla = \n\t\t\t[0x030c, 0x0148], // n + caron = \n\t\t]),\n\t],\n\t// Lowercase o compositions\n\t[\n\t\t0x006f,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00f2], // o + grave = \n\t\t\t[0x0301, 0x00f3], // o + acute = \n\t\t\t[0x0302, 0x00f4], // o + circumflex = \n\t\t\t[0x0303, 0x00f5], // o + tilde = \n\t\t\t[0x0308, 0x00f6], // o + diaeresis = \n\t\t\t[0x0304, 0x014d], // o + macron = \n\t\t\t[0x0306, 0x014f], // o + breve = \n\t\t\t[0x030b, 0x0151], // o + double acute = \n\t\t\t[0x0328, 0x01eb], // o + ogonek = \n\t\t]),\n\t],\n\t// Lowercase u compositions\n\t[\n\t\t0x0075,\n\t\tnew Map([\n\t\t\t[0x0300, 0x00f9], // u + grave = \n\t\t\t[0x0301, 0x00fa], // u + acute = \n\t\t\t[0x0302, 0x00fb], // u + circumflex = \n\t\t\t[0x0308, 0x00fc], // u + diaeresis = \n\t\t\t[0x0303, 0x0169], // u + tilde = \n\t\t\t[0x0304, 0x016b], // u + macron = \n\t\t\t[0x0306, 0x016d], // u + breve = \n\t\t\t[0x030a, 0x016f], // u + ring = \n\t\t\t[0x030b, 0x0171], // u + double acute = \n\t\t\t[0x0328, 0x0173], // u + ogonek = \n\t\t\t[0x030c, 0x01d4], // u + caron = \n\t\t]),\n\t],\n\t// Lowercase y compositions\n\t[\n\t\t0x0079,\n\t\tnew Map([\n\t\t\t[0x0301, 0x00fd], // y + acute = \n\t\t\t[0x0308, 0x00ff], // y + diaeresis = \n\t\t\t[0x0302, 0x0177], // y + circumflex = \n\t\t]),\n\t],\n\t// Other common compositions\n\t[\n\t\t0x0053,\n\t\tnew Map([\n\t\t\t// S\n\t\t\t[0x0301, 0x015a], // S + acute = \n\t\t\t[0x0302, 0x015c], // S + circumflex = \n\t\t\t[0x0327, 0x015e], // S + cedilla = \n\t\t\t[0x030c, 0x0160], // S + caron = \n\t\t]),\n\t],\n\t[\n\t\t0x0073,\n\t\tnew Map([\n\t\t\t// s\n\t\t\t[0x0301, 0x015b], // s + acute = \n\t\t\t[0x0302, 0x015d], // s + circumflex = \n\t\t\t[0x0327, 0x015f], // s + cedilla = \n\t\t\t[0x030c, 0x0161], // s + caron = \n\t\t]),\n\t],\n\t[\n\t\t0x005a,\n\t\tnew Map([\n\t\t\t// Z\n\t\t\t[0x0301, 0x0179], // Z + acute = \n\t\t\t[0x0307, 0x017b], // Z + dot above = \n\t\t\t[0x030c, 0x017d], // Z + caron = \n\t\t]),\n\t],\n\t[\n\t\t0x007a,\n\t\tnew Map([\n\t\t\t// z\n\t\t\t[0x0301, 0x017a], // z + acute = \n\t\t\t[0x0307, 0x017c], // z + dot above = \n\t\t\t[0x030c, 0x017e], // z + caron = \n\t\t]),\n\t],\n]);\n\n/**\n * Try to compose a base character with a combining mark\n * Returns the composed character or null if no composition exists\n * @param base Base character codepoint\n * @param combining Combining mark codepoint\n * @returns Composed character codepoint, or null if no composition exists\n */\nexport function tryCompose(base: number, combining: number): number | null {\n\tconst baseCompositions = COMPOSITIONS.get(base);\n\tif (!baseCompositions) return null;\n\treturn baseCompositions.get(combining) ?? null;\n}\n\n/**\n * Compose combining marks with their bases where possible (NFC-like)\n */\nfunction composeMarks(infos: GlyphInfo[]): GlyphInfo[] {\n\tif (infos.length === 0) return infos;\n\n\tconst result: GlyphInfo[] = [];\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst current = infos[i]!;\n\t\tconst currentCcc = getCombiningClass(current.codepoint);\n\n\t\t// If this is a base character (ccc = 0), try to compose with following marks\n\t\tif (currentCcc === 0) {\n\t\t\tlet composedCp = current.codepoint;\n\t\t\tlet lastCcc = 0;\n\t\t\tlet j = i + 1;\n\n\t\t\t// Look for combining marks that can be composed\n\t\t\twhile (j < infos.length) {\n\t\t\t\tconst mark = infos[j]!;\n\t\t\t\tconst markCcc = getCombiningClass(mark.codepoint);\n\n\t\t\t\t// Stop at next base character\n\t\t\t\tif (markCcc === 0) break;\n\n\t\t\t\t// Can only compose if:\n\t\t\t\t// 1. Mark has higher ccc than last composed mark (or last was base)\n\t\t\t\t// 2. Composition exists for the pair\n\t\t\t\tif (markCcc > lastCcc || lastCcc === 0) {\n\t\t\t\t\tconst composed = tryCompose(composedCp, mark.codepoint);\n\t\t\t\t\tif (composed !== null) {\n\t\t\t\t\t\tcomposedCp = composed;\n\t\t\t\t\t\t// Mark this position as consumed (will skip)\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Mark wasn't composed, stop looking for compositions\n\t\t\t\t// but continue with remaining marks\n\t\t\t\tlastCcc = markCcc;\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t// Output the (possibly composed) base\n\t\t\tresult.push({\n\t\t\t\tglyphId: current.glyphId,\n\t\t\t\tcluster: current.cluster,\n\t\t\t\tmask: current.mask,\n\t\t\t\tcodepoint: composedCp,\n\t\t\t});\n\n\t\t\t// Output any marks that weren't composed\n\t\t\tfor (let k = i + 1; k < j; k++) {\n\t\t\t\tconst mark = infos[k];\n\t\t\t\tif (!mark) continue;\n\n\t\t\t\tconst markCcc = getCombiningClass(mark.codepoint);\n\t\t\t\t// Only output marks that weren't composed (check if they're still combining marks)\n\t\t\t\t// We need to re-check if a composition exists to determine what to output\n\t\t\t\tconst compositionExists =\n\t\t\t\t\ttryCompose(composedCp, mark.codepoint) !== null;\n\t\t\t\tif (!compositionExists && markCcc !== 0) {\n\t\t\t\t\tresult.push(mark);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = j;\n\t\t} else {\n\t\t\t// Standalone combining mark (no base), just copy it\n\t\t\tresult.push(current);\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Apply normalization to glyph infos\n * @param infos Array of glyph information objects\n * @param mode Normalization mode (None, Decompose, Compose, or Auto)\n * @returns Normalized array of glyph information objects\n */\nexport function normalize(\n\tinfos: GlyphInfo[],\n\tmode: NormalizationMode,\n): GlyphInfo[] {\n\tif (mode === NormalizationMode.None) {\n\t\treturn infos;\n\t}\n\n\tif (mode === NormalizationMode.Decompose) {\n\t\t// Decompose precomposed characters (NFD-like)\n\t\tconst result: GlyphInfo[] = [];\n\n\t\tfor (let i = 0; i < infos.length; i++) {\n\t\t\tconst info = infos[i]!;\n\t\t\tconst decomposed = decompose(info.codepoint);\n\t\t\tif (decomposed) {\n\t\t\t\t// Replace with decomposed sequence\n\t\t\t\tfor (let j = 0; j < decomposed.length; j++) {\n\t\t\t\t\tconst cp = decomposed[j]!;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tglyphId: info.glyphId, // Will be remapped later\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: cp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(info);\n\t\t\t}\n\t\t}\n\n\t\t// Reorder combining marks\n\t\treorderMarks(result);\n\n\t\treturn result;\n\t}\n\n\tif (mode === NormalizationMode.Compose) {\n\t\t// First decompose, reorder, then compose (NFC-like)\n\t\t// Step 1: Decompose\n\t\tconst decomposed: GlyphInfo[] = [];\n\t\tfor (let i = 0; i < infos.length; i++) {\n\t\t\tconst info = infos[i]!;\n\t\t\tconst dec = decompose(info.codepoint);\n\t\t\tif (dec) {\n\t\t\t\tfor (let j = 0; j < dec.length; j++) {\n\t\t\t\t\tconst cp = dec[j]!;\n\t\t\t\t\tdecomposed.push({\n\t\t\t\t\t\tglyphId: info.glyphId,\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: cp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdecomposed.push(info);\n\t\t\t}\n\t\t}\n\n\t\t// Step 2: Reorder combining marks\n\t\treorderMarks(decomposed);\n\n\t\t// Step 3: Compose\n\t\treturn composeMarks(decomposed);\n\t}\n\n\tif (mode === NormalizationMode.Auto) {\n\t\t// Auto mode: use decomposition by default (better for shaping)\n\t\tconst result: GlyphInfo[] = [];\n\n\t\tfor (let i = 0; i < infos.length; i++) {\n\t\t\tconst info = infos[i]!;\n\t\t\tconst decomposed = decompose(info.codepoint);\n\t\t\tif (decomposed) {\n\t\t\t\tfor (let j = 0; j < decomposed.length; j++) {\n\t\t\t\t\tconst cp = decomposed[j]!;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tglyphId: info.glyphId,\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: cp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(info);\n\t\t\t}\n\t\t}\n\n\t\treorderMarks(result);\n\t\treturn result;\n\t}\n\n\treturn infos;\n}\n",
    "import type { Font } from \"../font/font.ts\";\nimport { getGlyphClass } from \"../font/tables/gdef.ts\";\nimport { getKernValue } from \"../font/tables/kern.ts\";\nimport type { GlyphId, GlyphInfo, GlyphPosition } from \"../types.ts\";\nimport { GlyphClass } from \"../types.ts\";\nimport { getCombiningClass } from \"../unicode/normalize.ts\";\n\n/**\n * Quick check if text has any potential marks based on codepoints.\n * Uses fast O(1) checks for common non-mark ranges.\n */\nfunction hasAnyMarks(infos: GlyphInfo[]): boolean {\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tconst cp = info.codepoint;\n\t\t// Fast check: most scripts have no combining marks\n\t\t// Only check getCombiningClass for potential mark ranges\n\t\tif (cp >= 0x0300 && cp < 0x0370) return true; // Latin combining\n\t\tif (cp >= 0x0591 && cp < 0x05c8) return true; // Hebrew\n\t\tif (cp >= 0x0610 && cp < 0x0900) return true; // Arabic and extended\n\t\tif (cp >= 0x093c && cp < 0x0970) return true; // Devanagari marks\n\t\tif (cp >= 0x09bc && cp < 0x09ff) return true; // Bengali marks\n\t\tif (cp >= 0x0a3c && cp < 0x0a75) return true; // Gurmukhi marks\n\t\tif (cp >= 0x0abc && cp < 0x0aff) return true; // Gujarati marks\n\t\tif (cp >= 0x0b3c && cp < 0x0b70) return true; // Oriya marks\n\t\tif (cp >= 0x0bcd && cp < 0x0bd8) return true; // Tamil marks\n\t\tif (cp >= 0x0c4d && cp < 0x0c70) return true; // Telugu marks\n\t\tif (cp >= 0x0cbc && cp < 0x0cff) return true; // Kannada marks\n\t\tif (cp >= 0x0d4d && cp < 0x0d70) return true; // Malayalam marks\n\t\tif (cp >= 0x0dca && cp < 0x0df5) return true; // Sinhala marks\n\t\tif (cp >= 0x0e31 && cp < 0x0e50) return true; // Thai marks\n\t\tif (cp >= 0x0eb1 && cp < 0x0ed0) return true; // Lao marks\n\t\tif (cp >= 0x0f18 && cp < 0x0f88) return true; // Tibetan marks\n\t\tif (cp >= 0x1037 && cp < 0x103b) return true; // Myanmar marks\n\t\tif (cp >= 0x1ab0 && cp < 0x1b00) return true; // Combining Extended\n\t\tif (cp >= 0x1dc0 && cp < 0x1e00) return true; // Combining Supplement\n\t\tif (cp >= 0x302a && cp < 0x3030) return true; // Hangul combining\n\t\tif (cp >= 0x3099 && cp < 0x309b) return true; // Kana voicing\n\t\tif (cp >= 0xfe20 && cp < 0xfe30) return true; // Combining Half Marks\n\t}\n\treturn false;\n}\n\n/**\n * Fallback mark positioning when GPOS is not available\n * Uses combining class information to position marks\n */\nexport function applyFallbackMarkPositioning(\n\tfont: Font,\n\tinfos: GlyphInfo[],\n\tpositions: GlyphPosition[],\n): void {\n\t// Fast path: skip entirely if no marks detected\n\tif (!hasAnyMarks(infos)) return;\n\n\t// Cache glyph classes to avoid repeated GDEF lookups\n\tconst glyphClassCache = new Map<GlyphId, number>();\n\tconst getClass = (glyphId: GlyphId): number => {\n\t\tlet cls = glyphClassCache.get(glyphId);\n\t\tif (cls === undefined) {\n\t\t\tcls = font.gdef ? getGlyphClass(font.gdef, glyphId) : 0;\n\t\t\tglyphClassCache.set(glyphId, cls);\n\t\t}\n\t\treturn cls;\n\t};\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst pos = positions[i]!;\n\n\t\tconst glyphClass = getClass(info.glyphId);\n\t\tconst ccc = getCombiningClass(info.codepoint);\n\n\t\t// Skip if not a mark\n\t\tif (glyphClass !== GlyphClass.Mark && ccc === 0) continue;\n\n\t\t// Find the base glyph\n\t\tlet baseIndex = -1;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst prevInfo = infos[j]!;\n\t\t\tconst prevClass = getClass(prevInfo.glyphId);\n\t\t\tconst prevCcc = getCombiningClass(prevInfo.codepoint);\n\n\t\t\tif (prevClass === GlyphClass.Base || (prevClass === 0 && prevCcc === 0)) {\n\t\t\t\tbaseIndex = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (baseIndex < 0) continue;\n\n\t\tconst baseInfo = infos[baseIndex]!;\n\t\tconst basePos = positions[baseIndex]!;\n\n\t\t// Get base glyph metrics\n\t\tconst baseAdvance = font.advanceWidth(baseInfo.glyphId);\n\n\t\t// Position mark relative to base based on combining class\n\t\t// This is a simplified heuristic - real mark positioning uses anchors\n\t\tpositionMarkFallback(font, info, pos, baseInfo, basePos, baseAdvance, ccc);\n\n\t\t// Mark has zero advance (already accounted for in base)\n\t\tpos.xAdvance = 0;\n\t\tpos.yAdvance = 0;\n\t}\n}\n\nfunction positionMarkFallback(\n\tfont: Font,\n\tmarkInfo: GlyphInfo,\n\tmarkPos: GlyphPosition,\n\t_baseInfo: GlyphInfo,\n\tbasePos: GlyphPosition,\n\tbaseAdvance: number,\n\tccc: number,\n): void {\n\tconst markAdvance = font.advanceWidth(markInfo.glyphId);\n\tconst unitsPerEm = font.unitsPerEm;\n\n\t// Default: center mark over base\n\tlet xOffset = (baseAdvance - markAdvance) / 2;\n\tlet yOffset = 0;\n\n\t// Position based on combining class\n\tif (ccc >= 200 && ccc <= 240) {\n\t\t// Above marks (ccc 230 is common for above)\n\t\tyOffset = unitsPerEm * 0.7; // 70% of em height\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t} else if (ccc >= 202 && ccc <= 220) {\n\t\t// Below marks (ccc 220 is common for below)\n\t\tyOffset = -unitsPerEm * 0.15;\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t} else if (ccc === 1) {\n\t\t// Overlay marks\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t\tyOffset = unitsPerEm * 0.3;\n\t} else if (ccc >= 7 && ccc <= 9) {\n\t\t// Nukta, virama (below consonant)\n\t\tyOffset = -unitsPerEm * 0.1;\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t} else if (ccc >= 10 && ccc <= 35) {\n\t\t// Hebrew/Arabic vowels - specific positioning\n\t\tif (ccc <= 22) {\n\t\t\t// Hebrew below vowels\n\t\t\tyOffset = -unitsPerEm * 0.2;\n\t\t} else {\n\t\t\t// Arabic marks\n\t\t\tyOffset = ccc < 30 ? -unitsPerEm * 0.15 : unitsPerEm * 0.6;\n\t\t}\n\t\txOffset = (baseAdvance - markAdvance) / 2;\n\t}\n\n\t// Apply offset relative to base position\n\tmarkPos.xOffset = basePos.xOffset + xOffset - baseAdvance;\n\tmarkPos.yOffset = basePos.yOffset + yOffset;\n}\n\n/**\n * Apply fallback kerning using kern table\n */\nexport function applyFallbackKerning(\n\tfont: Font,\n\tinfos: GlyphInfo[],\n\tpositions: GlyphPosition[],\n): void {\n\tconst kern = font.kern;\n\tif (!kern) return;\n\n\tfor (let i = 0; i < infos.length - 1; i++) {\n\t\tconst info1 = infos[i];\n\t\tconst info2 = infos[i + 1];\n\t\tif (!info1 || !info2) continue;\n\n\t\tconst pos1 = positions[i];\n\t\tif (!pos1) continue;\n\n\t\t// Skip marks\n\t\tconst class1 = font.gdef ? getGlyphClass(font.gdef, info1.glyphId) : 0;\n\t\tconst class2 = font.gdef ? getGlyphClass(font.gdef, info2.glyphId) : 0;\n\t\tif (class1 === GlyphClass.Mark || class2 === GlyphClass.Mark) continue;\n\n\t\t// Get kerning from kern table\n\t\tconst kernValue = getKernValueFromTable(font, info1.glyphId, info2.glyphId);\n\t\tif (kernValue !== 0) {\n\t\t\tpos1.xAdvance += kernValue;\n\t\t}\n\t}\n}\n\nfunction getKernValueFromTable(\n\tfont: Font,\n\tleft: GlyphId,\n\tright: GlyphId,\n): number {\n\tconst kern = font.kern;\n\tif (!kern) return 0;\n\n\treturn getKernValue(kern, left, right);\n}\n\n/**\n * Recategorize combining marks for proper processing\n * Some scripts need marks to be processed in specific order\n */\nexport function recategorizeCombiningMarks(\n\t_font: Font,\n\tinfos: GlyphInfo[],\n): void {\n\t// For Hebrew, Arabic, and other scripts, ensure marks are in canonical order\n\t// This is typically handled by normalization, but we do a final check here\n\n\tlet i = 0;\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ccc = getCombiningClass(info.codepoint);\n\t\tif (ccc === 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find extent of combining sequence\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) break;\n\t\t\tconst nextCcc = getCombiningClass(nextInfo.codepoint);\n\t\t\tif (nextCcc === 0) break;\n\t\t\tj++;\n\t\t}\n\n\t\t// Sort combining marks by CCC (stable sort)\n\t\tif (j - i > 1) {\n\t\t\tconst marks = infos.slice(i, j);\n\t\t\tmarks.sort((a, b) => {\n\t\t\t\tconst cccA = getCombiningClass(a.codepoint);\n\t\t\t\tconst cccB = getCombiningClass(b.codepoint);\n\t\t\t\treturn cccA - cccB;\n\t\t\t});\n\t\t\tfor (let k = 0; k < marks.length; k++) {\n\t\t\t\tconst mark = marks[k]!;\n\t\t\t\tinfos[i + k] = mark;\n\t\t\t}\n\t\t}\n\n\t\ti = j;\n\t}\n}\n",
    "import { tag } from \"../types.ts\";\nimport type { ShapeFeature } from \"./shape-plan.ts\";\n\n/**\n * Feature helper utilities\n * Provides convenient APIs for enabling OpenType features\n */\n\n/**\n * Create a ShapeFeature for a stylistic set (ss01-ss20)\n */\nexport function stylisticSet(\n\tsetNumber: number,\n\tenabled: boolean = true,\n): ShapeFeature {\n\tif (setNumber < 1 || setNumber > 20) {\n\t\tthrow new Error(`Stylistic set number must be 1-20, got ${setNumber}`);\n\t}\n\tconst tagStr = `ss${setNumber.toString().padStart(2, \"0\")}`;\n\treturn { tag: tag(tagStr), enabled };\n}\n\n/**\n * Create ShapeFeatures for multiple stylistic sets\n */\nexport function stylisticSets(\n\tsetNumbers: number[],\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn setNumbers.map((n) => stylisticSet(n, enabled));\n}\n\n/**\n * Create a ShapeFeature for a character variant (cv01-cv99)\n */\nexport function characterVariant(\n\tvariantNumber: number,\n\tenabled: boolean = true,\n): ShapeFeature {\n\tif (variantNumber < 1 || variantNumber > 99) {\n\t\tthrow new Error(\n\t\t\t`Character variant number must be 1-99, got ${variantNumber}`,\n\t\t);\n\t}\n\tconst tagStr = `cv${variantNumber.toString().padStart(2, \"0\")}`;\n\treturn { tag: tag(tagStr), enabled };\n}\n\n/**\n * Create ShapeFeatures for multiple character variants\n */\nexport function characterVariants(\n\tvariantNumbers: number[],\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn variantNumbers.map((n) => characterVariant(n, enabled));\n}\n\n/**\n * Standard ligatures (liga)\n */\nexport function standardLigatures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"liga\"), enabled };\n}\n\n/**\n * Discretionary ligatures (dlig)\n */\nexport function discretionaryLigatures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"dlig\"), enabled };\n}\n\n/**\n * Historical ligatures (hlig)\n */\nexport function historicalLigatures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"hlig\"), enabled };\n}\n\n/**\n * Contextual alternates (calt)\n */\nexport function contextualAlternates(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"calt\"), enabled };\n}\n\n/**\n * Stylistic alternates (salt)\n */\nexport function stylisticAlternates(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"salt\"), enabled };\n}\n\n/**\n * Swash (swsh)\n */\nexport function swash(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"swsh\"), enabled };\n}\n\n/**\n * Small capitals (smcp)\n */\nexport function smallCaps(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"smcp\"), enabled };\n}\n\n/**\n * Capitals to small capitals (c2sc)\n */\nexport function capsToSmallCaps(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"c2sc\"), enabled };\n}\n\n/**\n * Petite capitals (pcap)\n */\nexport function petiteCaps(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"pcap\"), enabled };\n}\n\n/**\n * All small capitals (both smcp and c2sc)\n */\nexport function allSmallCaps(enabled: boolean = true): ShapeFeature[] {\n\treturn [smallCaps(enabled), capsToSmallCaps(enabled)];\n}\n\n/**\n * Oldstyle figures (onum)\n */\nexport function oldstyleFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"onum\"), enabled };\n}\n\n/**\n * Lining figures (lnum)\n */\nexport function liningFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"lnum\"), enabled };\n}\n\n/**\n * Proportional figures (pnum)\n */\nexport function proportionalFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"pnum\"), enabled };\n}\n\n/**\n * Tabular figures (tnum)\n */\nexport function tabularFigures(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"tnum\"), enabled };\n}\n\n/**\n * Fractions (frac)\n */\nexport function fractions(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"frac\"), enabled };\n}\n\n/**\n * Ordinals (ordn)\n */\nexport function ordinals(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"ordn\"), enabled };\n}\n\n/**\n * Slashed zero (zero)\n */\nexport function slashedZero(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"zero\"), enabled };\n}\n\n/**\n * Superscript (sups)\n */\nexport function superscript(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"sups\"), enabled };\n}\n\n/**\n * Subscript (subs)\n */\nexport function subscript(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"subs\"), enabled };\n}\n\n/**\n * Scientific inferiors (sinf)\n */\nexport function scientificInferiors(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"sinf\"), enabled };\n}\n\n/**\n * Case-sensitive forms (case)\n */\nexport function caseSensitiveForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"case\"), enabled };\n}\n\n/**\n * Capital spacing (cpsp)\n */\nexport function capitalSpacing(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"cpsp\"), enabled };\n}\n\n/**\n * Kerning (kern)\n */\nexport function kerning(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"kern\"), enabled };\n}\n\n/**\n * Vertical forms (vert) - for vertical text layout\n */\nexport function verticalForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"vert\"), enabled };\n}\n\n/**\n * Vertical alternates and rotation (vrt2) - for vertical text layout\n */\nexport function verticalAlternatesRotation(\n\tenabled: boolean = true,\n): ShapeFeature {\n\treturn { tag: tag(\"vrt2\"), enabled };\n}\n\n/**\n * Vertical Kana alternates (vkna) - for Japanese vertical text\n */\nexport function verticalKanaAlternates(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"vkna\"), enabled };\n}\n\n/**\n * All vertical layout features\n */\nexport function verticalLayoutFeatures(\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn [\n\t\tverticalForms(enabled),\n\t\tverticalAlternatesRotation(enabled),\n\t\tverticalKanaAlternates(enabled),\n\t];\n}\n\n/**\n * Ruby notation forms (ruby)\n */\nexport function ruby(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"ruby\"), enabled };\n}\n\n/**\n * Half-width forms (hwid)\n */\nexport function halfWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"hwid\"), enabled };\n}\n\n/**\n * Full-width forms (fwid)\n */\nexport function fullWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"fwid\"), enabled };\n}\n\n/**\n * Proportional-width forms (pwid)\n */\nexport function proportionalWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"pwid\"), enabled };\n}\n\n/**\n * Quarter-width forms (qwid)\n */\nexport function quarterWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"qwid\"), enabled };\n}\n\n/**\n * Third-width forms (twid)\n */\nexport function thirdWidthForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"twid\"), enabled };\n}\n\n/**\n * JIS78 forms (jp78) - Japanese\n */\nexport function jis78Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp78\"), enabled };\n}\n\n/**\n * JIS83 forms (jp83) - Japanese\n */\nexport function jis83Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp83\"), enabled };\n}\n\n/**\n * JIS90 forms (jp90) - Japanese\n */\nexport function jis90Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp90\"), enabled };\n}\n\n/**\n * JIS2004 forms (jp04) - Japanese\n */\nexport function jis2004Forms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"jp04\"), enabled };\n}\n\n/**\n * Simplified forms (smpl) - Chinese\n */\nexport function simplifiedForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"smpl\"), enabled };\n}\n\n/**\n * Traditional forms (trad) - Chinese\n */\nexport function traditionalForms(enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(\"trad\"), enabled };\n}\n\n/**\n * Create a feature from a 4-character tag string\n */\nexport function feature(tagStr: string, enabled: boolean = true): ShapeFeature {\n\treturn { tag: tag(tagStr), enabled };\n}\n\n/**\n * Create multiple features from tag strings\n */\nexport function features(\n\ttagStrs: string[],\n\tenabled: boolean = true,\n): ShapeFeature[] {\n\treturn tagStrs.map((t) => feature(t, enabled));\n}\n\n/**\n * Combine multiple feature sets\n */\nexport function combineFeatures(\n\t...featureSets: (ShapeFeature | ShapeFeature[])[]\n): ShapeFeature[] {\n\tconst result: ShapeFeature[] = [];\n\tfor (let i = 0; i < featureSets.length; i++) {\n\t\tconst set = featureSets[i]!;\n\t\tif (Array.isArray(set)) {\n\t\t\tresult.push(...set);\n\t\t} else {\n\t\t\tresult.push(set);\n\t\t}\n\t}\n\treturn result;\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Arabic joining types from Unicode\n */\nexport enum ArabicJoiningType {\n\tNonJoining = \"U\", // Non_Joining\n\tRightJoining = \"R\", // Right_Joining (joins on the right)\n\tDualJoining = \"D\", // Dual_Joining (joins on both sides)\n\tJoinCausing = \"C\", // Join_Causing (like TATWEEL)\n\tLeftJoining = \"L\", // Left_Joining (rare)\n\tTransparent = \"T\", // Transparent (marks, etc.)\n}\n\n/**\n * Action to take for each glyph based on context\n */\nexport enum JoiningAction {\n\tNone = 0,\n\tIsol = 1, // Isolated form\n\tFina = 2, // Final form\n\tMedi = 3, // Medial form\n\tInit = 4, // Initial form\n}\n\n/**\n * Arabic joining group for specific shaping behavior\n */\nexport enum ArabicJoiningGroup {\n\tNone = 0,\n\tAlaph = 1,\n\tDalathRish = 2,\n\t// Add more as needed for Syriac, etc.\n}\n\n/**\n * Per-glyph info for Arabic shaping\n */\nexport interface ArabicGlyphData {\n\tjoiningType: ArabicJoiningType;\n\tjoiningGroup: ArabicJoiningGroup;\n\taction: JoiningAction;\n}\n\n// Unicode ranges for Arabic characters\nconst ARABIC_START = 0x0600;\nconst ARABIC_END = 0x06ff;\nconst ARABIC_SUPPLEMENT_START = 0x0750;\nconst ARABIC_SUPPLEMENT_END = 0x077f;\nconst ARABIC_EXTENDED_A_START = 0x08a0;\nconst ARABIC_EXTENDED_A_END = 0x08ff;\nconst ARABIC_PRESENTATION_A_START = 0xfb50;\nconst ARABIC_PRESENTATION_A_END = 0xfdff;\nconst ARABIC_PRESENTATION_B_START = 0xfe70;\nconst ARABIC_PRESENTATION_B_END = 0xfeff;\n\n// Pre-computed joining type lookup table for Arabic block (0x0600-0x06FF)\n// Values: 0=NonJoining, 1=RightJoining, 2=DualJoining, 3=JoinCausing, 4=LeftJoining, 5=Transparent\nconst JOINING_TYPE_ARABIC_BLOCK = new Uint8Array([\n\t// 0x0600-0x060F: Number signs and punctuation (NonJoining)\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t// 0x0610-0x061F\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t// 0x0620-0x062F\n\t0,\n\t0,\n\t1,\n\t1,\n\t1,\n\t1,\n\t2,\n\t1,\n\t2,\n\t1,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t1, // 0622-0627=R, 0626/0628=D, 0629=R, 062A-062E=D, 062F=R\n\t// 0x0630-0x063F\n\t1,\n\t1,\n\t1,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2, // 0630-0632=R, 0633-063F=D\n\t// 0x0640-0x064F\n\t3,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t1,\n\t2,\n\t2,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5, // 0640=C, 0641-0647=D, 0648=R, 0649-064A=D, 064B-064F=T\n\t// 0x0650-0x065F\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5, // 0650-065F=T\n\t// 0x0660-0x066F\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t2,\n\t2, // 066E-066F=D\n\t// 0x0670-0x067F\n\t5,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2, // 0670=T, 0671-0677=R, 0678-067F=D\n\t// 0x0680-0x068F\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1, // 0680-0687=D, 0688-068F=R\n\t// 0x0690-0x069F\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2, // 0690-0699=R, 069A-069F=D\n\t// 0x06A0-0x06AF\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2, // 06A0-06AF=D\n\t// 0x06B0-0x06BF\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2, // 06B0-06BF=D\n\t// 0x06C0-0x06CF\n\t1,\n\t2,\n\t2,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t1,\n\t2,\n\t1,\n\t2,\n\t2, // 06C0=R, 06C1-06C2=D, 06C3-06CB=R, 06CC=D, 06CD=R, 06CE-06CF=D\n\t// 0x06D0-0x06DF\n\t2,\n\t2,\n\t1,\n\t1,\n\t0,\n\t2,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5, // 06D0-06D1=D, 06D2-06D3=R, 06D4=N, 06D5=D, 06D6-06DF=T\n\t// 0x06E0-0x06EF\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t0,\n\t0, // 06E0-06ED=T, 06EE-06EF=N\n\t// 0x06F0-0x06FF\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t2,\n\t2,\n\t2,\n\t0,\n\t0,\n\t2, // 06FA-06FC=D, 06FF=D\n]);\n\n// Map from lookup table value to ArabicJoiningType\nconst JOINING_TYPE_MAP: ArabicJoiningType[] = [\n\tArabicJoiningType.NonJoining, // 0\n\tArabicJoiningType.RightJoining, // 1\n\tArabicJoiningType.DualJoining, // 2\n\tArabicJoiningType.JoinCausing, // 3\n\tArabicJoiningType.LeftJoining, // 4\n\tArabicJoiningType.Transparent, // 5\n];\n\n/**\n * Check if a codepoint is in Arabic script range\n */\nexport function isArabic(cp: number): boolean {\n\treturn (\n\t\t(cp >= ARABIC_START && cp <= ARABIC_END) ||\n\t\t(cp >= ARABIC_SUPPLEMENT_START && cp <= ARABIC_SUPPLEMENT_END) ||\n\t\t(cp >= ARABIC_EXTENDED_A_START && cp <= ARABIC_EXTENDED_A_END) ||\n\t\t(cp >= ARABIC_PRESENTATION_A_START && cp <= ARABIC_PRESENTATION_A_END) ||\n\t\t(cp >= ARABIC_PRESENTATION_B_START && cp <= ARABIC_PRESENTATION_B_END)\n\t);\n}\n\n/**\n * Get the joining type for a codepoint\n * Based on Unicode Arabic Shaping data\n */\nexport function getJoiningType(cp: number): ArabicJoiningType {\n\t// Fast path: Arabic block (0x0600-0x06FF) - use lookup table\n\tif (cp >= 0x0600 && cp <= 0x06ff) {\n\t\treturn JOINING_TYPE_MAP[JOINING_TYPE_ARABIC_BLOCK[cp - 0x0600]!]!;\n\t}\n\n\t// Non-joining: below Arabic range\n\tif (cp < ARABIC_START) return ArabicJoiningType.NonJoining;\n\n\t// Syriac block (0x0700-0x074F) - limited support for left-joining\n\t// SYRIAC LETTER ALAPH (0x0710) and similar are left-joining in Syriac\n\tif (cp >= 0x0710 && cp <= 0x0712) return ArabicJoiningType.LeftJoining;\n\n\t// Extended marks (0x08D3-0x08FF)\n\tif (cp >= 0x08d3 && cp <= 0x08ff) return ArabicJoiningType.Transparent;\n\n\t// Default: NonJoining\n\treturn ArabicJoiningType.NonJoining;\n}\n\n// Numeric constants for fast joining type comparison (avoid string comparison)\nconst JT_NON_JOINING = 0;\nconst JT_RIGHT_JOINING = 1;\nconst JT_DUAL_JOINING = 2;\nconst JT_JOIN_CAUSING = 3;\nconst JT_LEFT_JOINING = 4;\nconst JT_TRANSPARENT = 5;\n\n/**\n * Get the numeric joining type for a codepoint (faster than enum)\n */\nfunction getJoiningTypeNumeric(cp: number): number {\n\t// Fast path: Arabic block (0x0600-0x06FF) - use lookup table\n\tif (cp >= 0x0600 && cp <= 0x06ff) {\n\t\treturn JOINING_TYPE_ARABIC_BLOCK[cp - 0x0600]!;\n\t}\n\n\t// Non-joining: below Arabic range\n\tif (cp < 0x0600) return JT_NON_JOINING;\n\n\t// Syriac block (0x0700-0x074F) - limited support for left-joining\n\t// SYRIAC LETTER ALAPH (0x0710) and similar are left-joining in Syriac\n\tif (cp >= 0x0710 && cp <= 0x0712) return JT_LEFT_JOINING;\n\n\t// Extended marks (0x08D3-0x08FF)\n\tif (cp >= 0x08d3 && cp <= 0x08ff) return JT_TRANSPARENT;\n\n\t// Default: NonJoining\n\treturn JT_NON_JOINING;\n}\n\n/**\n * Analyze joining for a sequence of glyphs.\n * Returns the action to take for each glyph.\n */\nexport function analyzeJoining(infos: GlyphInfo[]): JoiningAction[] {\n\tconst n = infos.length;\n\tconst actions: JoiningAction[] = new Array(n).fill(JoiningAction.None);\n\n\t// Analyze each glyph based on neighbors (skipping transparent)\n\tfor (let i = 0; i < n; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst cp = info.codepoint ?? 0;\n\t\tconst type = getJoiningTypeNumeric(cp);\n\n\t\t// Skip non-Arabic characters\n\t\tif (type === JT_NON_JOINING || type === JT_TRANSPARENT) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find previous non-transparent glyph\n\t\tlet prevType = JT_NON_JOINING;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst prevInfo = infos[j]!;\n\t\t\tconst prevCp = prevInfo.codepoint ?? 0;\n\t\t\tconst jType = getJoiningTypeNumeric(prevCp);\n\t\t\tif (jType !== JT_TRANSPARENT) {\n\t\t\t\tprevType = jType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Find next non-transparent glyph\n\t\tlet nextType = JT_NON_JOINING;\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tconst nextInfo = infos[j]!;\n\t\t\tconst nextCp = nextInfo.codepoint ?? 0;\n\t\t\tconst jType = getJoiningTypeNumeric(nextCp);\n\t\t\tif (jType !== JT_TRANSPARENT) {\n\t\t\t\tnextType = jType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Determine if we join left/right\n\t\tconst joinsLeft =\n\t\t\tprevType === JT_DUAL_JOINING ||\n\t\t\tprevType === JT_LEFT_JOINING ||\n\t\t\tprevType === JT_JOIN_CAUSING;\n\n\t\tconst joinsRight =\n\t\t\tnextType === JT_DUAL_JOINING ||\n\t\t\tnextType === JT_RIGHT_JOINING ||\n\t\t\tnextType === JT_JOIN_CAUSING;\n\n\t\t// Determine action based on joining type and context\n\t\tif (type === JT_DUAL_JOINING) {\n\t\t\tif (joinsLeft && joinsRight) {\n\t\t\t\tactions[i] = JoiningAction.Medi;\n\t\t\t} else if (joinsLeft) {\n\t\t\t\tactions[i] = JoiningAction.Fina;\n\t\t\t} else if (joinsRight) {\n\t\t\t\tactions[i] = JoiningAction.Init;\n\t\t\t} else {\n\t\t\t\tactions[i] = JoiningAction.Isol;\n\t\t\t}\n\t\t} else if (type === JT_RIGHT_JOINING) {\n\t\t\t// Right-joining can only join on the right (to previous glyph in RTL)\n\t\t\tif (joinsLeft) {\n\t\t\t\tactions[i] = JoiningAction.Fina;\n\t\t\t} else {\n\t\t\t\tactions[i] = JoiningAction.Isol;\n\t\t\t}\n\t\t} else if (type === JT_LEFT_JOINING) {\n\t\t\t// Left-joining (rare)\n\t\t\tif (joinsRight) {\n\t\t\t\tactions[i] = JoiningAction.Init;\n\t\t\t} else {\n\t\t\t\tactions[i] = JoiningAction.Isol;\n\t\t\t}\n\t\t}\n\t\t// JoinCausing - no form change, leave as None\n\t}\n\n\treturn actions;\n}\n\n/**\n * Get the feature tag for a joining action\n */\nexport function getFeatureForAction(action: JoiningAction): string | null {\n\tswitch (action) {\n\t\tcase JoiningAction.Isol:\n\t\t\treturn \"isol\";\n\t\tcase JoiningAction.Fina:\n\t\t\treturn \"fina\";\n\t\tcase JoiningAction.Medi:\n\t\t\treturn \"medi\";\n\t\tcase JoiningAction.Init:\n\t\t\treturn \"init\";\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Get default Arabic features in order\n */\nexport function getArabicFeatures(): string[] {\n\treturn [\n\t\t\"ccmp\", // Character composition/decomposition\n\t\t\"locl\", // Localized forms\n\t\t\"isol\", // Isolated forms\n\t\t\"init\", // Initial forms\n\t\t\"medi\", // Medial forms\n\t\t\"fina\", // Final forms\n\t\t\"rlig\", // Required ligatures\n\t\t\"rclt\", // Required contextual alternates\n\t\t\"calt\", // Contextual alternates\n\t\t\"liga\", // Standard ligatures\n\t];\n}\n\n/**\n * Set the feature mask for each glyph based on joining analysis\n * Inlined for performance - avoids intermediate array allocation\n */\nexport function setupArabicMasks(infos: GlyphInfo[]): void {\n\tconst n = infos.length;\n\n\t// Feature tag bits:\n\t// - bit 0: isol (0x1)\n\t// - bit 1: fina (0x2)\n\t// - bit 2: medi (0x4)\n\t// - bit 3: init (0x8)\n\tfor (let i = 0; i < n; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst cp = info.codepoint ?? 0;\n\t\tconst type = getJoiningTypeNumeric(cp);\n\n\t\t// Skip non-Arabic characters\n\t\tif (type === JT_NON_JOINING || type === JT_TRANSPARENT) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find previous non-transparent glyph\n\t\tlet prevType = JT_NON_JOINING;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst prevInfo = infos[j]!;\n\t\t\tconst prevCp = prevInfo.codepoint ?? 0;\n\t\t\tconst jType = getJoiningTypeNumeric(prevCp);\n\t\t\tif (jType !== JT_TRANSPARENT) {\n\t\t\t\tprevType = jType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Find next non-transparent glyph\n\t\tlet nextType = JT_NON_JOINING;\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tconst nextInfo = infos[j]!;\n\t\t\tconst nextCp = nextInfo.codepoint ?? 0;\n\t\t\tconst jType = getJoiningTypeNumeric(nextCp);\n\t\t\tif (jType !== JT_TRANSPARENT) {\n\t\t\t\tnextType = jType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Determine if we join left/right\n\t\tconst joinsLeft =\n\t\t\tprevType === JT_DUAL_JOINING ||\n\t\t\tprevType === JT_LEFT_JOINING ||\n\t\t\tprevType === JT_JOIN_CAUSING;\n\n\t\tconst joinsRight =\n\t\t\tnextType === JT_DUAL_JOINING ||\n\t\t\tnextType === JT_RIGHT_JOINING ||\n\t\t\tnextType === JT_JOIN_CAUSING;\n\n\t\t// Determine action and set mask based on joining type and context\n\t\tlet mask = 0;\n\t\tif (type === JT_DUAL_JOINING) {\n\t\t\tif (joinsLeft && joinsRight) {\n\t\t\t\tmask = 0x4; // medi\n\t\t\t} else if (joinsLeft) {\n\t\t\t\tmask = 0x2; // fina\n\t\t\t} else if (joinsRight) {\n\t\t\t\tmask = 0x8; // init\n\t\t\t} else {\n\t\t\t\tmask = 0x1; // isol\n\t\t\t}\n\t\t} else if (type === JT_RIGHT_JOINING) {\n\t\t\tif (joinsLeft) {\n\t\t\t\tmask = 0x2; // fina\n\t\t\t} else {\n\t\t\t\tmask = 0x1; // isol\n\t\t\t}\n\t\t} else if (type === JT_LEFT_JOINING) {\n\t\t\tif (joinsRight) {\n\t\t\t\tmask = 0x8; // init\n\t\t\t} else {\n\t\t\t\tmask = 0x1; // isol\n\t\t\t}\n\t\t}\n\t\t// JoinCausing - no form change, mask stays 0\n\n\t\tif (mask !== 0) {\n\t\t\tinfo.mask = (info.mask & 0xfffffff0) | mask;\n\t\t}\n\t}\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Ethiopic shaper\n * Handles Ethiopic/Ge'ez script\n *\n * Ethiopic is an abugida (alphasyllabary) where:\n * - Base consonants have inherent vowel 'a'\n * - Vowels modify the base consonant shape\n * - No joining behavior (unlike Arabic)\n * - Left-to-right direction\n *\n * Key features:\n * - Syllable-based writing (CV or CVC)\n * - Labialization marks (W modifier)\n * - Extended character sets for various languages\n */\n\n/**\n * Ethiopic character categories\n */\nexport enum EthiopicCategory {\n\tOther = 0,\n\tSyllable = 1, // Main syllabic characters (consonant + vowel)\n\tDigit = 2, // Ethiopic digits\n\tPunctuation = 3, // Ethiopic punctuation\n\tModifier = 4, // Combining marks\n\tToneMark = 5, // Tonal letters\n}\n\n/**\n * Get Ethiopic category for codepoint\n */\nexport function getEthiopicCategory(cp: number): EthiopicCategory {\n\t// Main Ethiopic block (1200-137F)\n\tif (cp >= 0x1200 && cp <= 0x137f) {\n\t\t// Syllables (1200-1248, 124A-124D, 1250-1256, etc.)\n\t\tif (cp >= 0x1200 && cp <= 0x1248) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x124a && cp <= 0x124d) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1250 && cp <= 0x1256) return EthiopicCategory.Syllable;\n\t\tif (cp === 0x1258) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x125a && cp <= 0x125d) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1260 && cp <= 0x1288) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x128a && cp <= 0x128d) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1290 && cp <= 0x12b0) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x12b2 && cp <= 0x12b5) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x12b8 && cp <= 0x12be) return EthiopicCategory.Syllable;\n\t\tif (cp === 0x12c0) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x12c2 && cp <= 0x12c5) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x12c8 && cp <= 0x12d6) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x12d8 && cp <= 0x1310) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1312 && cp <= 0x1315) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1318 && cp <= 0x135a) return EthiopicCategory.Syllable;\n\n\t\t// Combining marks (135D-135F)\n\t\tif (cp >= 0x135d && cp <= 0x135f) return EthiopicCategory.Modifier;\n\n\t\t// Punctuation (1360-1368)\n\t\tif (cp >= 0x1360 && cp <= 0x1368) return EthiopicCategory.Punctuation;\n\n\t\t// Digits (1369-137C)\n\t\tif (cp >= 0x1369 && cp <= 0x137c) return EthiopicCategory.Digit;\n\n\t\treturn EthiopicCategory.Other;\n\t}\n\n\t// Ethiopic Supplement (1380-139F)\n\tif (cp >= 0x1380 && cp <= 0x139f) {\n\t\tif (cp >= 0x1380 && cp <= 0x1399) return EthiopicCategory.Syllable;\n\t\treturn EthiopicCategory.Other;\n\t}\n\n\t// Ethiopic Extended (2D80-2DDF)\n\tif (cp >= 0x2d80 && cp <= 0x2ddf) {\n\t\tif (cp >= 0x2d80 && cp <= 0x2d96) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2da0 && cp <= 0x2da6) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2da8 && cp <= 0x2dae) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2db0 && cp <= 0x2db6) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2db8 && cp <= 0x2dbe) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2dc0 && cp <= 0x2dc6) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2dc8 && cp <= 0x2dce) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2dd0 && cp <= 0x2dd6) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x2dd8 && cp <= 0x2dde) return EthiopicCategory.Syllable;\n\t\treturn EthiopicCategory.Other;\n\t}\n\n\t// Ethiopic Extended-A (AB00-AB2F)\n\tif (cp >= 0xab00 && cp <= 0xab2f) {\n\t\tif (cp >= 0xab00 && cp <= 0xab06) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0xab09 && cp <= 0xab0e) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0xab11 && cp <= 0xab16) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0xab20 && cp <= 0xab26) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0xab28 && cp <= 0xab2e) return EthiopicCategory.Syllable;\n\t\treturn EthiopicCategory.Other;\n\t}\n\n\t// Ethiopic Extended-B (1E7E0-1E7FF)\n\tif (cp >= 0x1e7e0 && cp <= 0x1e7ff) {\n\t\tif (cp >= 0x1e7e0 && cp <= 0x1e7e6) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1e7e8 && cp <= 0x1e7eb) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1e7ed && cp <= 0x1e7ee) return EthiopicCategory.Syllable;\n\t\tif (cp >= 0x1e7f0 && cp <= 0x1e7fe) return EthiopicCategory.Syllable;\n\t\treturn EthiopicCategory.Other;\n\t}\n\n\treturn EthiopicCategory.Other;\n}\n\n/**\n * Check if codepoint is an Ethiopic syllable\n */\nexport function isEthiopicSyllable(cp: number): boolean {\n\treturn getEthiopicCategory(cp) === EthiopicCategory.Syllable;\n}\n\n/**\n * Get the vowel form of an Ethiopic syllable (0-7)\n * 0 = First form (inherent  or a)\n * 1 = Second form (u)\n * 2 = Third form (i)\n * 3 = Fourth form (a)\n * 4 = Fifth form (e)\n * 5 = Sixth form ( or no vowel)\n * 6 = Seventh form (o)\n * 7 = Eighth form (wa) - labialized\n */\nexport function getEthiopicVowelForm(cp: number): number {\n\tif (!isEthiopicSyllable(cp)) return -1;\n\n\t// Most Ethiopic syllables follow a pattern where the vowel\n\t// is determined by (cp - base) % 8 or similar\n\t// This is a simplified version\n\n\tif (cp >= 0x1200 && cp <= 0x1357) {\n\t\t// The ordering is irregular but generally follows:\n\t\t// base + 0 = first form ()\n\t\t// base + 1 = second form (u)\n\t\t// base + 2 = third form (i)\n\t\t// base + 3 = fourth form (a)\n\t\t// base + 4 = fifth form (e)\n\t\t// base + 5 = sixth form ()\n\t\t// base + 6 = seventh form (o)\n\t\t// base + 7 = eighth form (wa) when applicable\n\n\t\t// Find the base consonant (start of the row)\n\t\t// This is simplified; actual mapping is more complex\n\t\tconst _row = Math.floor((cp - 0x1200) / 8);\n\t\tconst form = (cp - 0x1200) % 8;\n\n\t\t// Some rows have fewer than 8 forms\n\t\treturn Math.min(form, 7);\n\t}\n\n\treturn 0;\n}\n\n/**\n * Ethiopic feature masks\n */\nexport const EthiopicFeatureMask = {\n\tccmp: 0x0001, // Composition/decomposition\n\tlocl: 0x0002, // Localized forms\n\tcalt: 0x0004, // Contextual alternates\n\tliga: 0x0008, // Standard ligatures\n\tss01: 0x0010, // Stylistic set 1\n\tss02: 0x0020, // Stylistic set 2\n} as const;\n\n/**\n * Set up masks for Ethiopic shaping\n */\nexport function setupEthiopicMasks(infos: GlyphInfo[]): void {\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getEthiopicCategory(info.codepoint);\n\n\t\t// All characters get basic features\n\t\tinfo.mask |= EthiopicFeatureMask.ccmp | EthiopicFeatureMask.locl;\n\n\t\tif (cat === EthiopicCategory.Syllable) {\n\t\t\t// Syllables participate in all features\n\t\t\tinfo.mask |=\n\t\t\t\tEthiopicFeatureMask.calt |\n\t\t\t\tEthiopicFeatureMask.liga |\n\t\t\t\tEthiopicFeatureMask.ss01 |\n\t\t\t\tEthiopicFeatureMask.ss02;\n\t\t} else if (cat === EthiopicCategory.Modifier) {\n\t\t\t// Modifiers need contextual features\n\t\t\tinfo.mask |= EthiopicFeatureMask.calt;\n\t\t}\n\t}\n}\n\n/**\n * Get default Ethiopic features in order\n */\nexport function getEthiopicFeatures(): string[] {\n\treturn [\n\t\t\"ccmp\", // Character composition/decomposition\n\t\t\"locl\", // Localized forms\n\t\t\"calt\", // Contextual alternates\n\t\t\"liga\", // Standard ligatures\n\t];\n}\n\n/**\n * Check if script uses Ethiopic shaper\n */\nexport function usesEthiopic(script: string): boolean {\n\treturn script === \"ethi\" || script === \"Ethi\";\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Georgian shaper\n * Handles Georgian script (Mkhedruli, Asomtavruli, Nuskhuri)\n *\n * Georgian is relatively simple compared to other complex scripts:\n * - No complex reordering\n * - No joining behavior\n * - Case transformations (Mkhedruli lowercase, Mtavruli uppercase)\n * - Historical scripts (Asomtavruli, Nuskhuri)\n *\n * Main complexity:\n * - Mtavruli (uppercase) added in Unicode 11.0\n * - Stylistic variants between scripts\n * - Small caps via 'smcp' feature\n */\n\n/**\n * Georgian character categories\n */\nexport enum GeorgianCategory {\n\tOther = 0,\n\tMkhedruli = 1, // Modern lowercase (10D0-10FA, 10FC, 10FD-10FF)\n\tMtavruli = 2, // Modern uppercase (1C90-1CBA, 1CBD-1CBF)\n\tAsomtavruli = 3, // Old Church uppercase (10A0-10C5, 10C7, 10CD)\n\tNuskhuri = 4, // Old Church lowercase (2D00-2D25, 2D27, 2D2D)\n\tModifier = 5, // Modifiers (10FB)\n\tPunctuation = 6, // Punctuation (10FB)\n\tDigit = 7, // Digits (using Latin digits with Georgian)\n\tLetter = 8, // Generic letter (for extensions)\n}\n\n/**\n * Get Georgian category for codepoint\n */\nexport function getGeorgianCategory(cp: number): GeorgianCategory {\n\t// Mkhedruli (modern lowercase)\n\tif (cp >= 0x10d0 && cp <= 0x10fa) return GeorgianCategory.Mkhedruli;\n\tif (cp === 0x10fc) return GeorgianCategory.Mkhedruli; // Modifier letter\n\tif (cp >= 0x10fd && cp <= 0x10ff) return GeorgianCategory.Mkhedruli;\n\n\t// Mtavruli (modern uppercase, added Unicode 11.0)\n\tif (cp >= 0x1c90 && cp <= 0x1cba) return GeorgianCategory.Mtavruli;\n\tif (cp >= 0x1cbd && cp <= 0x1cbf) return GeorgianCategory.Mtavruli;\n\n\t// Asomtavruli (old ecclesiastical uppercase)\n\tif (cp >= 0x10a0 && cp <= 0x10c5) return GeorgianCategory.Asomtavruli;\n\tif (cp === 0x10c7) return GeorgianCategory.Asomtavruli;\n\tif (cp === 0x10cd) return GeorgianCategory.Asomtavruli;\n\n\t// Nuskhuri (old ecclesiastical lowercase)\n\tif (cp >= 0x2d00 && cp <= 0x2d25) return GeorgianCategory.Nuskhuri;\n\tif (cp === 0x2d27) return GeorgianCategory.Nuskhuri;\n\tif (cp === 0x2d2d) return GeorgianCategory.Nuskhuri;\n\n\t// Paragraph separator (also used in Georgian)\n\tif (cp === 0x10fb) return GeorgianCategory.Punctuation;\n\n\treturn GeorgianCategory.Other;\n}\n\n/**\n * Check if character is a Georgian letter\n */\nexport function isGeorgianLetter(cp: number): boolean {\n\tconst cat = getGeorgianCategory(cp);\n\treturn (\n\t\tcat === GeorgianCategory.Mkhedruli ||\n\t\tcat === GeorgianCategory.Mtavruli ||\n\t\tcat === GeorgianCategory.Asomtavruli ||\n\t\tcat === GeorgianCategory.Nuskhuri\n\t);\n}\n\n/**\n * Georgian case mapping (Mkhedruli <-> Mtavruli)\n * Returns the corresponding uppercase/lowercase codepoint, or 0 if none\n */\nexport function georgianToUpper(cp: number): number {\n\t// Mkhedruli to Mtavruli\n\tif (cp >= 0x10d0 && cp <= 0x10fa) {\n\t\treturn cp - 0x10d0 + 0x1c90;\n\t}\n\tif (cp >= 0x10fd && cp <= 0x10ff) {\n\t\treturn cp - 0x10fd + 0x1cbd;\n\t}\n\treturn 0;\n}\n\nexport function georgianToLower(cp: number): number {\n\t// Mtavruli to Mkhedruli\n\tif (cp >= 0x1c90 && cp <= 0x1cba) {\n\t\treturn cp - 0x1c90 + 0x10d0;\n\t}\n\tif (cp >= 0x1cbd && cp <= 0x1cbf) {\n\t\treturn cp - 0x1cbd + 0x10fd;\n\t}\n\treturn 0;\n}\n\n/**\n * Georgian feature masks\n */\nexport const GeorgianFeatureMask = {\n\tccmp: 0x0001, // Composition/decomposition\n\tlocl: 0x0002, // Localized forms\n\tcalt: 0x0004, // Contextual alternates\n\tliga: 0x0008, // Standard ligatures\n\tsmcp: 0x0010, // Small capitals\n\tc2sc: 0x0020, // Capitals to small capitals\n\tcase_: 0x0040, // Case-sensitive forms\n\tcpsp: 0x0080, // Capital spacing\n} as const;\n\n/**\n * Set up masks for Georgian shaping\n */\nexport function setupGeorgianMasks(infos: GlyphInfo[]): void {\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getGeorgianCategory(info.codepoint);\n\n\t\t// All characters get basic features\n\t\tinfo.mask |= GeorgianFeatureMask.ccmp | GeorgianFeatureMask.locl;\n\n\t\tif (isGeorgianLetter(info.codepoint)) {\n\t\t\t// Letters participate in contextual features\n\t\t\tinfo.mask |= GeorgianFeatureMask.calt | GeorgianFeatureMask.liga;\n\n\t\t\t// Uppercase letters get case-related features\n\t\t\tif (\n\t\t\t\tcat === GeorgianCategory.Mtavruli ||\n\t\t\t\tcat === GeorgianCategory.Asomtavruli\n\t\t\t) {\n\t\t\t\tinfo.mask |= GeorgianFeatureMask.case_ | GeorgianFeatureMask.cpsp;\n\t\t\t}\n\n\t\t\t// Lowercase letters can get small caps\n\t\t\tif (\n\t\t\t\tcat === GeorgianCategory.Mkhedruli ||\n\t\t\t\tcat === GeorgianCategory.Nuskhuri\n\t\t\t) {\n\t\t\t\tinfo.mask |= GeorgianFeatureMask.smcp;\n\t\t\t}\n\n\t\t\t// Uppercase can be converted to small caps\n\t\t\tif (\n\t\t\t\tcat === GeorgianCategory.Mtavruli ||\n\t\t\t\tcat === GeorgianCategory.Asomtavruli\n\t\t\t) {\n\t\t\t\tinfo.mask |= GeorgianFeatureMask.c2sc;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Get default Georgian features in order\n */\nexport function getGeorgianFeatures(): string[] {\n\treturn [\n\t\t\"ccmp\", // Character composition/decomposition\n\t\t\"locl\", // Localized forms\n\t\t\"calt\", // Contextual alternates\n\t\t\"liga\", // Standard ligatures\n\t];\n}\n\n/**\n * Check if script uses Georgian shaper\n */\nexport function usesGeorgian(script: string): boolean {\n\treturn (\n\t\tscript === \"geor\" ||\n\t\tscript === \"Geor\" ||\n\t\tscript === \"geok\" ||\n\t\tscript === \"Geok\"\n\t);\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Mongolian shaper\n * Handles Traditional Mongolian, Manchu, and Sibe scripts\n *\n * Mongolian is written vertically (top to bottom, left to right columns).\n * Like Arabic, it has context-sensitive letter forms:\n * - Initial, Medial, Final, and Isolated forms\n *\n * Key characteristics:\n * - Vertical writing\n * - Positional forms (like Arabic joining)\n * - Free variation selectors (FVS1-FVS4)\n * - Vowel separators (MVS, NNBSP)\n */\n\n/**\n * Mongolian character categories\n */\nexport enum MongolianCategory {\n\tOther = 0,\n\tLetter = 1, // Regular letters\n\tVowel = 2, // Vowels\n\tDigit = 3, // Digits\n\tPunctuation = 4, // Punctuation\n\tFVS = 5, // Free Variation Selector\n\tMVS = 6, // Mongolian Vowel Separator (180E)\n\tNNBSP = 7, // Narrow No-Break Space (202F)\n\tZWJ = 8, // Zero Width Joiner\n\tZWNJ = 9, // Zero Width Non-Joiner\n}\n\n/**\n * Mongolian joining types (like Arabic)\n */\nexport enum MongolianJoining {\n\tNonJoining = 0,\n\tRightJoining = 1, // Joins to right (previous in text order)\n\tDualJoining = 2, // Joins both sides\n\tLeftJoining = 3, // Joins to left (next in text order) - rare\n\tTransparent = 4, // Invisible control characters\n\tCausing = 5, // Causes join but doesn't join itself\n}\n\n/**\n * Get Mongolian category\n */\nexport function getMongolianCategory(cp: number): MongolianCategory {\n\t// Control characters\n\tif (cp === 0x200c) return MongolianCategory.ZWNJ;\n\tif (cp === 0x200d) return MongolianCategory.ZWJ;\n\n\t// Mongolian Vowel Separator\n\tif (cp === 0x180e) return MongolianCategory.MVS;\n\n\t// Narrow No-Break Space (used as vowel separator)\n\tif (cp === 0x202f) return MongolianCategory.NNBSP;\n\n\t// Not Mongolian\n\tif (cp < 0x1800 || cp > 0x18af) {\n\t\t// Check Todo script (additional Mongolian range)\n\t\tif (cp >= 0x11660 && cp <= 0x1167f) return MongolianCategory.Letter;\n\t\treturn MongolianCategory.Other;\n\t}\n\n\t// Free Variation Selectors (180B-180D, 180F)\n\tif (cp >= 0x180b && cp <= 0x180d) return MongolianCategory.FVS;\n\tif (cp === 0x180f) return MongolianCategory.FVS;\n\n\t// Punctuation (1800-1805, 1807-180A)\n\tif (cp >= 0x1800 && cp <= 0x1805) return MongolianCategory.Punctuation;\n\tif (cp >= 0x1807 && cp <= 0x180a) return MongolianCategory.Punctuation;\n\n\t// Digits (1810-1819)\n\tif (cp >= 0x1810 && cp <= 0x1819) return MongolianCategory.Digit;\n\n\t// Vowels (specific letters that are vowels)\n\t// A, E, I, O, U, OE, UE\n\tif (\n\t\tcp === 0x1820 || // A\n\t\tcp === 0x1821 || // E\n\t\tcp === 0x1822 || // I\n\t\tcp === 0x1823 || // O\n\t\tcp === 0x1824 || // U\n\t\tcp === 0x1825 || // OE\n\t\tcp === 0x1826 // UE\n\t) {\n\t\treturn MongolianCategory.Vowel;\n\t}\n\n\t// Letters (1820-1878, 1880-18AA)\n\tif (cp >= 0x1820 && cp <= 0x1878) return MongolianCategory.Letter;\n\tif (cp >= 0x1880 && cp <= 0x18aa) return MongolianCategory.Letter;\n\n\treturn MongolianCategory.Other;\n}\n\n/**\n * Get Mongolian joining type for a codepoint\n */\nexport function getMongolianJoining(cp: number): MongolianJoining {\n\tconst cat = getMongolianCategory(cp);\n\n\t// Transparent characters\n\tif (cat === MongolianCategory.FVS) return MongolianJoining.Transparent;\n\tif (cat === MongolianCategory.ZWJ) return MongolianJoining.Causing;\n\tif (cat === MongolianCategory.ZWNJ) return MongolianJoining.NonJoining;\n\n\t// Vowel separator acts as non-joining\n\tif (cat === MongolianCategory.MVS || cat === MongolianCategory.NNBSP) {\n\t\treturn MongolianJoining.NonJoining;\n\t}\n\n\t// Non-joining characters\n\tif (\n\t\tcat === MongolianCategory.Digit ||\n\t\tcat === MongolianCategory.Punctuation\n\t) {\n\t\treturn MongolianJoining.NonJoining;\n\t}\n\n\t// Most Mongolian letters are dual-joining\n\tif (cat === MongolianCategory.Letter || cat === MongolianCategory.Vowel) {\n\t\t// A few letters are right-joining only\n\t\tif (\n\t\t\tcp === 0x1820 || // A (initial form only joins right)\n\t\t\tcp === 0x1821 // E\n\t\t) {\n\t\t\treturn MongolianJoining.DualJoining; // Actually dual but with special initial forms\n\t\t}\n\t\treturn MongolianJoining.DualJoining;\n\t}\n\n\treturn MongolianJoining.NonJoining;\n}\n\n/**\n * Mongolian positional forms\n */\nexport enum MongolianForm {\n\tIsolated = 0,\n\tInitial = 1,\n\tMedial = 2,\n\tFinal = 3,\n}\n\n/**\n * Determine positional form for a Mongolian character\n */\nexport function getMongolianForm(\n\tprev: MongolianJoining,\n\tcurrent: MongolianJoining,\n\tnext: MongolianJoining,\n): MongolianForm {\n\t// Transparent chars don't affect form (pass through previous join state)\n\tif (current === MongolianJoining.Transparent) {\n\t\treturn MongolianForm.Isolated;\n\t}\n\n\t// Non-joining always isolated\n\tif (current === MongolianJoining.NonJoining) {\n\t\treturn MongolianForm.Isolated;\n\t}\n\n\tconst joinsLeft =\n\t\tcurrent === MongolianJoining.DualJoining ||\n\t\tcurrent === MongolianJoining.LeftJoining;\n\tconst joinsRight =\n\t\tcurrent === MongolianJoining.DualJoining ||\n\t\tcurrent === MongolianJoining.RightJoining;\n\n\tconst canJoinPrev =\n\t\tprev === MongolianJoining.DualJoining ||\n\t\tprev === MongolianJoining.LeftJoining ||\n\t\tprev === MongolianJoining.Causing;\n\n\tconst canJoinNext =\n\t\tnext === MongolianJoining.DualJoining ||\n\t\tnext === MongolianJoining.RightJoining ||\n\t\tnext === MongolianJoining.Causing;\n\n\tconst joinedToPrev = joinsRight && canJoinPrev;\n\tconst joinedToNext = joinsLeft && canJoinNext;\n\n\tif (joinedToPrev && joinedToNext) return MongolianForm.Medial;\n\tif (joinedToPrev) return MongolianForm.Final;\n\tif (joinedToNext) return MongolianForm.Initial;\n\treturn MongolianForm.Isolated;\n}\n\n/**\n * Mongolian feature masks\n */\nexport const MongolianFeatureMask = {\n\tccmp: 0x0001, // Composition/decomposition\n\tlocl: 0x0002, // Localized forms\n\tisol: 0x0004, // Isolated forms\n\tinit: 0x0008, // Initial forms\n\tmedi: 0x0010, // Medial forms\n\tfina: 0x0020, // Final forms\n\trlig: 0x0040, // Required ligatures\n\tcalt: 0x0080, // Contextual alternates\n\tliga: 0x0100, // Standard ligatures\n\tvert: 0x0200, // Vertical writing forms\n} as const;\n\n/**\n * Set up masks for Mongolian shaping\n */\nexport function setupMongolianMasks(infos: GlyphInfo[]): void {\n\tconst n = infos.length;\n\n\t// First pass: determine joining types\n\tconst joiningTypes: MongolianJoining[] = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tjoiningTypes.push(getMongolianJoining(infos[i]?.codepoint ?? 0));\n\t}\n\n\t// Second pass: resolve effective joining considering transparent chars\n\tconst effectiveJoining: MongolianJoining[] = [];\n\tfor (let i = 0; i < joiningTypes.length; i++) {\n\t\tconst joining = joiningTypes[i]!;\n\t\t// For transparent characters, we still need their effective joining for masking\n\t\tif (joining === MongolianJoining.Transparent) {\n\t\t\teffectiveJoining.push(joining);\n\t\t} else {\n\t\t\teffectiveJoining.push(joining);\n\t\t}\n\t}\n\n\t// Third pass: assign forms and masks\n\tfor (let i = 0; i < n; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getMongolianCategory(info.codepoint);\n\n\t\t// All characters get ccmp and locl\n\t\tinfo.mask |= MongolianFeatureMask.ccmp | MongolianFeatureMask.locl;\n\n\t\t// Skip non-letters for form assignment\n\t\tif (cat !== MongolianCategory.Letter && cat !== MongolianCategory.Vowel) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get neighbors (skip transparent characters)\n\t\tlet prevJoin = MongolianJoining.NonJoining;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst jt = joiningTypes[j];\n\t\t\tif (jt !== MongolianJoining.Transparent) {\n\t\t\t\tif (jt !== undefined) prevJoin = jt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet nextJoin = MongolianJoining.NonJoining;\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tconst jt = joiningTypes[j];\n\t\t\tif (jt !== MongolianJoining.Transparent) {\n\t\t\t\tif (jt !== undefined) nextJoin = jt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst effJoin = effectiveJoining[i] ?? MongolianJoining.NonJoining;\n\t\tconst form = getMongolianForm(prevJoin, effJoin, nextJoin);\n\n\t\t// Apply form-specific mask\n\t\tswitch (form) {\n\t\t\tcase MongolianForm.Isolated:\n\t\t\t\tinfo.mask |= MongolianFeatureMask.isol;\n\t\t\t\tbreak;\n\t\t\tcase MongolianForm.Initial:\n\t\t\t\tinfo.mask |= MongolianFeatureMask.init;\n\t\t\t\tbreak;\n\t\t\tcase MongolianForm.Medial:\n\t\t\t\tinfo.mask |= MongolianFeatureMask.medi;\n\t\t\t\tbreak;\n\t\t\tcase MongolianForm.Final:\n\t\t\t\tinfo.mask |= MongolianFeatureMask.fina;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// All forms can participate in these\n\t\tinfo.mask |=\n\t\t\tMongolianFeatureMask.rlig |\n\t\t\tMongolianFeatureMask.calt |\n\t\t\tMongolianFeatureMask.liga |\n\t\t\tMongolianFeatureMask.vert;\n\t}\n}\n\n/**\n * Get default Mongolian features in order\n */\nexport function getMongolianFeatures(): string[] {\n\treturn [\n\t\t\"ccmp\", // Character composition/decomposition\n\t\t\"locl\", // Localized forms\n\t\t\"isol\", // Isolated forms\n\t\t\"init\", // Initial forms\n\t\t\"medi\", // Medial forms\n\t\t\"fina\", // Final forms\n\t\t\"rlig\", // Required ligatures\n\t\t\"calt\", // Contextual alternates\n\t\t\"liga\", // Standard ligatures\n\t\t\"vert\", // Vertical forms (for vertical text)\n\t];\n}\n\n/**\n * Check if script uses Mongolian shaper\n */\nexport function usesMongolian(script: string): boolean {\n\tconst mongolianScripts = [\n\t\t\"mong\", // Mongolian\n\t\t\"Mong\", // Mongolian (title case)\n\t\t\"phag\", // Phags-pa\n\t\t\"Phag\", // Phags-pa (title case)\n\t];\n\treturn mongolianScripts.includes(script);\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Syriac shaper\n * Handles Syriac script (Estrangela, Serto, Eastern)\n *\n * Syriac is a right-to-left script with:\n * - Joining behavior (like Arabic)\n * - Vowel marks (diacritics above/below)\n * - Multiple script styles (Estrangela, Serto, East Syriac)\n * - Dalath/Rish distinction marks\n */\n\n/**\n * Syriac joining types\n */\nexport enum SyriacJoining {\n\tNonJoining = 0,\n\tRightJoining = 1,\n\tDualJoining = 2,\n\tLeftJoining = 3,\n\tTransparent = 4,\n\tCausing = 5,\n}\n\n/**\n * Syriac character categories\n */\nexport enum SyriacCategory {\n\tOther = 0,\n\tLetter = 1,\n\tDiacritic = 2,\n\tPunctuation = 3,\n\tDigit = 4,\n}\n\n/**\n * Get Syriac joining type for codepoint\n */\nexport function getSyriacJoining(cp: number): SyriacJoining {\n\t// Control characters\n\tif (cp === 0x200c) return SyriacJoining.NonJoining; // ZWNJ\n\tif (cp === 0x200d) return SyriacJoining.Causing; // ZWJ\n\n\t// Not Syriac\n\tif (cp < 0x0700 || cp > 0x074f) {\n\t\t// Syriac supplement (0860-086A)\n\t\tif (cp >= 0x0860 && cp <= 0x086a) {\n\t\t\t// Most supplement letters are dual-joining\n\t\t\treturn SyriacJoining.DualJoining;\n\t\t}\n\t\treturn SyriacJoining.NonJoining;\n\t}\n\n\t// Punctuation (0700-070D)\n\tif (cp >= 0x0700 && cp <= 0x070d) return SyriacJoining.NonJoining;\n\n\t// Letters (0710-072F)\n\tif (cp >= 0x0710 && cp <= 0x072f) {\n\t\t// Alaph (0710) - dual joining\n\t\tif (cp === 0x0710) return SyriacJoining.DualJoining;\n\n\t\t// Waw (0718) - right joining\n\t\tif (cp === 0x0718) return SyriacJoining.RightJoining;\n\n\t\t// Yudh (071D) - right joining\n\t\tif (cp === 0x071d) return SyriacJoining.RightJoining;\n\n\t\t// Most letters are dual-joining\n\t\treturn SyriacJoining.DualJoining;\n\t}\n\n\t// Vowel marks (0730-074A) - transparent\n\tif (cp >= 0x0730 && cp <= 0x074a) return SyriacJoining.Transparent;\n\n\treturn SyriacJoining.NonJoining;\n}\n\n/**\n * Get Syriac category\n */\nexport function getSyriacCategory(cp: number): SyriacCategory {\n\t// Syriac block (0700-074F)\n\tif (cp >= 0x0700 && cp <= 0x074f) {\n\t\tif (cp >= 0x0700 && cp <= 0x070d) return SyriacCategory.Punctuation;\n\t\tif (cp >= 0x0710 && cp <= 0x072f) return SyriacCategory.Letter;\n\t\tif (cp >= 0x0730 && cp <= 0x074a) return SyriacCategory.Diacritic;\n\t\treturn SyriacCategory.Other;\n\t}\n\n\t// Syriac supplement (0860-086A)\n\tif (cp >= 0x0860 && cp <= 0x086a) return SyriacCategory.Letter;\n\n\treturn SyriacCategory.Other;\n}\n\n/**\n * Syriac positional forms\n */\nexport enum SyriacForm {\n\tIsolated = 0,\n\tInitial = 1,\n\tMedial = 2,\n\tFinal = 3,\n}\n\n/**\n * Determine Syriac positional form\n */\nexport function getSyriacForm(\n\tprev: SyriacJoining,\n\tcurrent: SyriacJoining,\n\tnext: SyriacJoining,\n): SyriacForm {\n\tif (current === SyriacJoining.Transparent) return SyriacForm.Isolated;\n\tif (current === SyriacJoining.NonJoining) return SyriacForm.Isolated;\n\n\tconst joinsLeft =\n\t\tcurrent === SyriacJoining.DualJoining ||\n\t\tcurrent === SyriacJoining.LeftJoining;\n\tconst joinsRight =\n\t\tcurrent === SyriacJoining.DualJoining ||\n\t\tcurrent === SyriacJoining.RightJoining;\n\n\tconst canJoinPrev =\n\t\tprev === SyriacJoining.DualJoining ||\n\t\tprev === SyriacJoining.LeftJoining ||\n\t\tprev === SyriacJoining.Causing;\n\n\tconst canJoinNext =\n\t\tnext === SyriacJoining.DualJoining ||\n\t\tnext === SyriacJoining.RightJoining ||\n\t\tnext === SyriacJoining.Causing;\n\n\t// Note: Syriac is RTL, so visual left = textual next, visual right = textual prev\n\tconst joinedToPrev = joinsRight && canJoinPrev;\n\tconst joinedToNext = joinsLeft && canJoinNext;\n\n\tif (joinedToPrev && joinedToNext) return SyriacForm.Medial;\n\tif (joinedToPrev) return SyriacForm.Final;\n\tif (joinedToNext) return SyriacForm.Initial;\n\treturn SyriacForm.Isolated;\n}\n\n/**\n * Syriac feature masks\n */\nexport const SyriacFeatureMask = {\n\tccmp: 0x0001,\n\tlocl: 0x0002,\n\tisol: 0x0004,\n\tinit: 0x0008,\n\tmedi: 0x0010,\n\tfina: 0x0020,\n\trlig: 0x0040,\n\tcalt: 0x0080,\n\tliga: 0x0100,\n\tstch: 0x0200, // Stretching glyph decomposition\n} as const;\n\n/**\n * Set up masks for Syriac shaping\n */\nexport function setupSyriacMasks(infos: GlyphInfo[]): void {\n\tconst n = infos.length;\n\n\t// Get joining types\n\tconst joiningTypes: SyriacJoining[] = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tjoiningTypes.push(getSyriacJoining(infos[i]?.codepoint ?? 0));\n\t}\n\n\t// Assign forms and masks\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst cat = getSyriacCategory(info.codepoint);\n\t\tconst joining = joiningTypes[i] ?? SyriacJoining.NonJoining;\n\n\t\t// Basic features for all\n\t\tinfo.mask |= SyriacFeatureMask.ccmp | SyriacFeatureMask.locl;\n\n\t\t// Skip non-letters for form assignment\n\t\tif (cat !== SyriacCategory.Letter) {\n\t\t\t// Diacritics still get some features\n\t\t\tif (cat === SyriacCategory.Diacritic) {\n\t\t\t\tinfo.mask |= SyriacFeatureMask.calt;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get effective neighbors\n\t\tlet prevJoin = SyriacJoining.NonJoining;\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst jt = joiningTypes[j];\n\t\t\tif (jt !== SyriacJoining.Transparent) {\n\t\t\t\tif (jt !== undefined) prevJoin = jt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet nextJoin = SyriacJoining.NonJoining;\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tconst jt = joiningTypes[j];\n\t\t\tif (jt !== SyriacJoining.Transparent) {\n\t\t\t\tif (jt !== undefined) nextJoin = jt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst form = getSyriacForm(prevJoin, joining, nextJoin);\n\n\t\tswitch (form) {\n\t\t\tcase SyriacForm.Isolated:\n\t\t\t\tinfo.mask |= SyriacFeatureMask.isol;\n\t\t\t\tbreak;\n\t\t\tcase SyriacForm.Initial:\n\t\t\t\tinfo.mask |= SyriacFeatureMask.init;\n\t\t\t\tbreak;\n\t\t\tcase SyriacForm.Medial:\n\t\t\t\tinfo.mask |= SyriacFeatureMask.medi;\n\t\t\t\tbreak;\n\t\t\tcase SyriacForm.Final:\n\t\t\t\tinfo.mask |= SyriacFeatureMask.fina;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tinfo.mask |=\n\t\t\tSyriacFeatureMask.rlig |\n\t\t\tSyriacFeatureMask.calt |\n\t\t\tSyriacFeatureMask.liga |\n\t\t\tSyriacFeatureMask.stch;\n\t}\n}\n\n/**\n * Get default Syriac features in order\n */\nexport function getSyriacFeatures(): string[] {\n\treturn [\n\t\t\"ccmp\", // Composition/decomposition\n\t\t\"locl\", // Localized forms\n\t\t\"stch\", // Stretching glyph decomposition\n\t\t\"isol\", // Isolated forms\n\t\t\"init\", // Initial forms\n\t\t\"medi\", // Medial forms\n\t\t\"fina\", // Final forms\n\t\t\"rlig\", // Required ligatures\n\t\t\"calt\", // Contextual alternates\n\t\t\"liga\", // Standard ligatures\n\t];\n}\n\n/**\n * Check if script uses Syriac shaper\n */\nexport function usesSyriac(script: string): boolean {\n\treturn script === \"syrc\" || script === \"Syrc\";\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Tibetan shaper\n * Handles Tibetan script complex text layout\n *\n * Tibetan is an Indic-derived script with:\n * - Base consonants (Ka, Kha, Ga, etc.)\n * - Subjoined consonants (below base)\n * - Vowel signs (above/below)\n * - Head letters (pre-composed stacks)\n * - Various combining marks\n */\n\n/**\n * Tibetan character categories\n */\nexport enum TibetanCategory {\n\tOther = 0,\n\tBase = 1, // Base consonants (Ka-A)\n\tSubjoined = 2, // Subjoined consonants (0F90-0FBC)\n\tVowelAbove = 3, // Vowel signs above (0F71-0F7D, 0F80-0F83)\n\tVowelBelow = 4, // Vowel signs below (0F71, 0F7A-0F7D)\n\tASubjoin = 5, // Subjoined A (0FB0)\n\tHeadMark = 6, // Head marks (0F39)\n\tAnusvara = 7, // Anusvara/Candrabindu (0F7E, 0F7F, 0F82, 0F83)\n\tHalanta = 8, // Halanta (0F84)\n\tDigit = 9, // Digits (0F20-0F33)\n\tSymbol = 10, // Symbols and punctuation\n\tZWNJ = 11, // Zero Width Non-Joiner\n\tZWJ = 12, // Zero Width Joiner\n}\n\n/**\n * Classify Tibetan codepoint\n */\nexport function getTibetanCategory(cp: number): TibetanCategory {\n\t// Control characters\n\tif (cp === 0x200c) return TibetanCategory.ZWNJ;\n\tif (cp === 0x200d) return TibetanCategory.ZWJ;\n\n\t// Not Tibetan\n\tif (cp < 0x0f00 || cp > 0x0fff) return TibetanCategory.Other;\n\n\t// Digits\n\tif (cp >= 0x0f20 && cp <= 0x0f33) return TibetanCategory.Digit;\n\n\t// Base consonants (0F40-0F6C)\n\tif (cp >= 0x0f40 && cp <= 0x0f6c) return TibetanCategory.Base;\n\n\t// Subjoined consonants (0F90-0FBC)\n\tif (cp >= 0x0f90 && cp <= 0x0fbc) {\n\t\tif (cp === 0x0fb0) return TibetanCategory.ASubjoin; // Subjoined A\n\t\treturn TibetanCategory.Subjoined;\n\t}\n\n\t// Vowel signs\n\tif (cp === 0x0f71) return TibetanCategory.VowelBelow; // AA\n\tif (cp >= 0x0f72 && cp <= 0x0f7d) {\n\t\t// I, II, U, UU, Vocalic R, Vocalic RR, E, EE, O, OO, reversed I\n\t\tif (cp >= 0x0f7a && cp <= 0x0f7d) return TibetanCategory.VowelBelow;\n\t\treturn TibetanCategory.VowelAbove;\n\t}\n\tif (cp >= 0x0f80 && cp <= 0x0f83) {\n\t\tif (cp === 0x0f82 || cp === 0x0f83) return TibetanCategory.Anusvara;\n\t\treturn TibetanCategory.VowelAbove;\n\t}\n\n\t// Anusvara and Visarga\n\tif (cp === 0x0f7e || cp === 0x0f7f) return TibetanCategory.Anusvara;\n\n\t// Halanta (Srog med)\n\tif (cp === 0x0f84) return TibetanCategory.Halanta;\n\n\t// Head mark (Tsa phru)\n\tif (cp === 0x0f39) return TibetanCategory.HeadMark;\n\n\t// Symbols and punctuation (0F00-0F1F, 0F34-0F3F)\n\tif (cp >= 0x0f00 && cp <= 0x0f1f) return TibetanCategory.Symbol;\n\tif (cp >= 0x0f34 && cp <= 0x0f3f) return TibetanCategory.Symbol;\n\n\treturn TibetanCategory.Other;\n}\n\n/**\n * Tibetan syllable structure\n */\ninterface TibetanSyllable {\n\tstart: number;\n\tend: number;\n\tbase: number;\n}\n\n/**\n * Find Tibetan syllable boundaries\n */\nfunction findTibetanSyllables(infos: GlyphInfo[]): TibetanSyllable[] {\n\tconst syllables: TibetanSyllable[] = [];\n\tconst n = infos.length;\n\tif (n === 0) return syllables;\n\n\tlet i = 0;\n\n\twhile (i < n) {\n\t\tconst start = i;\n\t\tlet base = -1;\n\n\t\t// Find base consonant\n\t\tconst cat = getTibetanCategory(infos[i]?.codepoint ?? 0);\n\t\tif (cat === TibetanCategory.Base) {\n\t\t\tbase = i;\n\t\t\ti++;\n\t\t} else if (\n\t\t\tcat === TibetanCategory.Digit ||\n\t\t\tcat === TibetanCategory.Symbol\n\t\t) {\n\t\t\t// Non-base characters form their own syllable\n\t\t\ti++;\n\t\t\tsyllables.push({ start, end: i, base: start });\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// Skip other characters\n\t\t\ti++;\n\t\t\tsyllables.push({ start, end: i, base: start });\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Consume subjoined consonants (stacked below)\n\t\twhile (i < n) {\n\t\t\tconst subCat = getTibetanCategory(infos[i]?.codepoint ?? 0);\n\t\t\tif (\n\t\t\t\tsubCat === TibetanCategory.Subjoined ||\n\t\t\t\tsubCat === TibetanCategory.ASubjoin ||\n\t\t\t\tsubCat === TibetanCategory.Halanta ||\n\t\t\t\tsubCat === TibetanCategory.ZWJ ||\n\t\t\t\tsubCat === TibetanCategory.ZWNJ\n\t\t\t) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Consume vowel signs (above and below)\n\t\twhile (i < n) {\n\t\t\tconst vowelCat = getTibetanCategory(infos[i]?.codepoint ?? 0);\n\t\t\tif (\n\t\t\t\tvowelCat === TibetanCategory.VowelAbove ||\n\t\t\t\tvowelCat === TibetanCategory.VowelBelow\n\t\t\t) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Consume anusvara/visarga\n\t\twhile (i < n) {\n\t\t\tconst markCat = getTibetanCategory(infos[i]?.codepoint ?? 0);\n\t\t\tif (markCat === TibetanCategory.Anusvara) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Consume head marks\n\t\twhile (i < n) {\n\t\t\tconst headCat = getTibetanCategory(infos[i]?.codepoint ?? 0);\n\t\t\tif (headCat === TibetanCategory.HeadMark) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsyllables.push({ start, end: i, base });\n\t}\n\n\treturn syllables;\n}\n\n/**\n * Tibetan feature masks\n */\nexport const TibetanFeatureMask = {\n\tccmp: 0x0001, // Glyph composition/decomposition\n\tlocl: 0x0002, // Localized forms\n\tabvs: 0x0004, // Above-base substitutions\n\tblws: 0x0008, // Below-base substitutions\n\tcalt: 0x0010, // Contextual alternates\n\tliga: 0x0020, // Standard ligatures\n} as const;\n\n/**\n * Set up masks for Tibetan shaping\n */\nexport function setupTibetanMasks(infos: GlyphInfo[]): void {\n\tconst syllables = findTibetanSyllables(infos);\n\n\tfor (let s = 0; s < syllables.length; s++) {\n\t\tconst syllable = syllables[s]!;\n\t\tfor (let i = syllable.start; i < syllable.end; i++) {\n\t\t\tconst info = infos[i];\n\t\t\tif (!info) continue;\n\n\t\t\t// Store syllable index\n\t\t\tinfo.mask = (info.mask & 0x0000ffff) | ((s & 0xffff) << 16);\n\n\t\t\tconst cat = getTibetanCategory(info.codepoint);\n\n\t\t\t// All glyphs get ccmp and locl\n\t\t\tinfo.mask |= TibetanFeatureMask.ccmp | TibetanFeatureMask.locl;\n\n\t\t\t// Subjoined consonants get blws\n\t\t\tif (\n\t\t\t\tcat === TibetanCategory.Subjoined ||\n\t\t\t\tcat === TibetanCategory.ASubjoin\n\t\t\t) {\n\t\t\t\tinfo.mask |= TibetanFeatureMask.blws;\n\t\t\t}\n\n\t\t\t// Vowels above get abvs\n\t\t\tif (\n\t\t\t\tcat === TibetanCategory.VowelAbove ||\n\t\t\t\tcat === TibetanCategory.Anusvara\n\t\t\t) {\n\t\t\t\tinfo.mask |= TibetanFeatureMask.abvs;\n\t\t\t}\n\n\t\t\t// Vowels below get blws\n\t\t\tif (cat === TibetanCategory.VowelBelow) {\n\t\t\t\tinfo.mask |= TibetanFeatureMask.blws;\n\t\t\t}\n\n\t\t\t// All characters can participate in calt and liga\n\t\t\tinfo.mask |= TibetanFeatureMask.calt | TibetanFeatureMask.liga;\n\t\t}\n\t}\n}\n\n/**\n * Get default Tibetan features in order\n */\nexport function getTibetanFeatures(): string[] {\n\treturn [\n\t\t\"ccmp\", // Character composition/decomposition\n\t\t\"locl\", // Localized forms\n\t\t\"abvs\", // Above-base substitutions\n\t\t\"blws\", // Below-base substitutions\n\t\t\"calt\", // Contextual alternates\n\t\t\"liga\", // Standard ligatures\n\t];\n}\n\n/**\n * Check if script uses Tibetan shaper\n */\nexport function usesTibetan(script: string): boolean {\n\treturn script === \"tibt\" || script === \"Tibt\";\n}\n",
    "import type { Font } from \"../font/font.ts\";\nimport type { AnyGposLookup, GposTable } from \"../font/tables/gpos.ts\";\nimport type { AnyGsubLookup, GsubTable } from \"../font/tables/gsub.ts\";\nimport {\n\ttype FeatureVariations,\n\tfindMatchingFeatureVariation,\n} from \"../layout/structures/feature-variations.ts\";\nimport {\n\tfindLangSys,\n\tfindScript,\n\tgetFeature,\n} from \"../layout/structures/layout-common.ts\";\nimport { getArabicFeatures } from \"./complex/arabic.ts\";\nimport { getEthiopicFeatures, usesEthiopic } from \"./complex/ethiopic.ts\";\nimport { getGeorgianFeatures, usesGeorgian } from \"./complex/georgian.ts\";\nimport { getMongolianFeatures, usesMongolian } from \"./complex/mongolian.ts\";\nimport { getSyriacFeatures, usesSyriac } from \"./complex/syriac.ts\";\nimport { getTibetanFeatures, usesTibetan } from \"./complex/tibetan.ts\";\nimport type { Tag, uint16 } from \"../types.ts\";\nimport { tag, tagToString } from \"../types.ts\";\n\n/** Shape plan cache for reusing computed plans */\nconst shapePlanCache = new WeakMap<Font, Map<string, ShapePlan>>();\n\n/** Maximum cache size per font */\nconst MAX_CACHE_SIZE = 64;\n\n/** Feature with optional value */\nexport interface ShapeFeature {\n\ttag: Tag;\n\tenabled: boolean;\n}\n\n/** Lookup entry with index */\nexport interface LookupEntry<T> {\n\tindex: number;\n\tlookup: T;\n}\n\n/** Collected lookups for shaping */\nexport interface ShapePlan {\n\tscript: Tag;\n\tlanguage: Tag | null;\n\tdirection: \"ltr\" | \"rtl\";\n\n\t/** GSUB lookups to apply, in order */\n\tgsubLookups: LookupEntry<AnyGsubLookup>[];\n\n\t/** GPOS lookups to apply, in order */\n\tgposLookups: LookupEntry<AnyGposLookup>[];\n\n\t/** Fast O(1) lookup by index for nested GSUB lookups */\n\tgsubLookupMap: Map<number, LookupEntry<AnyGsubLookup>>;\n\n\t/** Fast O(1) lookup by index for nested GPOS lookups */\n\tgposLookupMap: Map<number, LookupEntry<AnyGposLookup>>;\n}\n\n/** Baseline GSUB features (always enabled) */\nconst DEFAULT_GSUB_FEATURES = [\n\t\"ccmp\", // Glyph composition/decomposition\n\t\"locl\", // Localized forms\n\t\"rlig\", // Required ligatures\n\t\"rclt\", // Required contextual alternates\n\t\"calt\", // Contextual alternates\n\t\"liga\", // Standard ligatures\n];\n\n/** Default GPOS features (always enabled) */\nconst DEFAULT_GPOS_FEATURES = [\n\t\"kern\", // Kerning\n\t\"mark\", // Mark positioning\n\t\"mkmk\", // Mark-to-mark positioning\n];\n\n/** Script-specific default GSUB features */\nfunction getDefaultGsubFeatures(script: string): string[] {\n\tconst features = new Set<string>(DEFAULT_GSUB_FEATURES);\n\tconst scriptTag = script.padEnd(4, \" \");\n\tconst scriptLower = scriptTag.toLowerCase();\n\n\tif (usesSyriac(scriptTag)) {\n\t\tfor (const feature of getSyriacFeatures()) {\n\t\t\tfeatures.add(feature);\n\t\t}\n\t} else if (\n\t\tscriptLower === \"arab\" ||\n\t\tscriptLower === \"mand\" ||\n\t\tscriptLower === \"nko \" ||\n\t\tscriptLower === \"nkoo\"\n\t) {\n\t\tfor (const feature of getArabicFeatures()) {\n\t\t\tfeatures.add(feature);\n\t\t}\n\t} else if (usesMongolian(scriptTag)) {\n\t\tfor (const feature of getMongolianFeatures()) {\n\t\t\tfeatures.add(feature);\n\t\t}\n\t} else if (usesTibetan(scriptTag)) {\n\t\tfor (const feature of getTibetanFeatures()) {\n\t\t\tfeatures.add(feature);\n\t\t}\n\t} else if (usesEthiopic(scriptTag)) {\n\t\tfor (const feature of getEthiopicFeatures()) {\n\t\t\tfeatures.add(feature);\n\t\t}\n\t} else if (usesGeorgian(scriptTag)) {\n\t\tfor (const feature of getGeorgianFeatures()) {\n\t\t\tfeatures.add(feature);\n\t\t}\n\t}\n\n\treturn [...features];\n}\n\n/** Generate cache key for shape plan */\nfunction getCacheKey(\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[],\n\taxisCoords: number[] | null,\n): string {\n\t// Fast path for common case: no user features, no axis coords\n\tif (userFeatures.length === 0 && axisCoords === null) {\n\t\treturn language === null\n\t\t\t? `${script}||${direction}||`\n\t\t\t: `${script}|${language}|${direction}||`;\n\t}\n\n\tconst featuresKey = userFeatures\n\t\t.map((f) => `${tagToString(f.tag)}:${f.enabled ? \"1\" : \"0\"}`)\n\t\t.sort()\n\t\t.join(\",\");\n\tconst coordsKey = axisCoords\n\t\t? axisCoords.map((c) => c.toFixed(4)).join(\",\")\n\t\t: \"\";\n\treturn `${script}|${language || \"\"}|${direction}|${featuresKey}|${coordsKey}`;\n}\n\n/** Get or create a cached shape plan */\nexport function getOrCreateShapePlan(\n\tfont: Font,\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[] = [],\n\taxisCoords: number[] | null = null,\n): ShapePlan {\n\tconst cacheKey = getCacheKey(\n\t\tscript,\n\t\tlanguage,\n\t\tdirection,\n\t\tuserFeatures,\n\t\taxisCoords,\n\t);\n\n\t// Get or create font's cache map\n\tlet fontCache = shapePlanCache.get(font);\n\tif (!fontCache) {\n\t\tfontCache = new Map();\n\t\tshapePlanCache.set(font, fontCache);\n\t}\n\n\t// Check cache\n\tconst cached = fontCache.get(cacheKey);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\t// Create new plan\n\tconst plan = createShapePlanInternal(\n\t\tfont,\n\t\tscript,\n\t\tlanguage,\n\t\tdirection,\n\t\tuserFeatures,\n\t\taxisCoords,\n\t);\n\n\t// Evict if cache is too large\n\tif (fontCache.size >= MAX_CACHE_SIZE) {\n\t\tconst firstKey = fontCache.keys().next().value;\n\t\tif (firstKey !== undefined) {\n\t\t\tfontCache.delete(firstKey);\n\t\t}\n\t}\n\n\tfontCache.set(cacheKey, plan);\n\treturn plan;\n}\n\n/** Create a shape plan for the given font and settings */\nexport function createShapePlan(\n\tfont: Font,\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[] = [],\n\taxisCoords: number[] | null = null,\n): ShapePlan {\n\t// Use caching by default\n\treturn getOrCreateShapePlan(\n\t\tfont,\n\t\tscript,\n\t\tlanguage,\n\t\tdirection,\n\t\tuserFeatures,\n\t\taxisCoords,\n\t);\n}\n\n/** Create a shape plan without caching */\nfunction createShapePlanInternal(\n\tfont: Font,\n\tscript: string,\n\tlanguage: string | null,\n\tdirection: \"ltr\" | \"rtl\",\n\tuserFeatures: ShapeFeature[] = [],\n\taxisCoords: number[] | null = null,\n): ShapePlan {\n\tconst scriptTag = tag(script.padEnd(4, \" \"));\n\tconst languageTag = language ? tag(language.padEnd(4, \" \")) : null;\n\n\t// Collect enabled features\n\tconst enabledFeatures = new Set<Tag>();\n\n\t// Add default features\n\tconst gsubDefaults = getDefaultGsubFeatures(script);\n\tfor (let i = 0; i < gsubDefaults.length; i++) {\n\t\tenabledFeatures.add(tag(gsubDefaults[i]!));\n\t}\n\tfor (let i = 0; i < DEFAULT_GPOS_FEATURES.length; i++) {\n\t\tenabledFeatures.add(tag(DEFAULT_GPOS_FEATURES[i]!));\n\t}\n\n\t// Apply user features\n\tfor (let i = 0; i < userFeatures.length; i++) {\n\t\tconst feat = userFeatures[i]!;\n\t\tif (feat.enabled) {\n\t\t\tenabledFeatures.add(feat.tag);\n\t\t} else {\n\t\t\tenabledFeatures.delete(feat.tag);\n\t\t}\n\t}\n\n\t// Collect GSUB lookups (with feature variations support)\n\tconst gsubLookups = collectLookups(\n\t\tfont.gsub,\n\t\tscriptTag,\n\t\tlanguageTag,\n\t\tenabledFeatures,\n\t\taxisCoords,\n\t) as LookupEntry<AnyGsubLookup>[];\n\n\t// Collect GPOS lookups (with feature variations support)\n\tconst gposLookups = collectLookups(\n\t\tfont.gpos,\n\t\tscriptTag,\n\t\tlanguageTag,\n\t\tenabledFeatures,\n\t\taxisCoords,\n\t) as LookupEntry<AnyGposLookup>[];\n\n\t// Build lookup index maps for O(1) nested lookup access\n\tconst gsubLookupMap = new Map<number, LookupEntry<AnyGsubLookup>>();\n\tfor (let i = 0; i < gsubLookups.length; i++) {\n\t\tconst entry = gsubLookups[i]!;\n\t\tgsubLookupMap.set(entry.index, entry);\n\t}\n\n\tconst gposLookupMap = new Map<number, LookupEntry<AnyGposLookup>>();\n\tfor (let i = 0; i < gposLookups.length; i++) {\n\t\tconst entry = gposLookups[i]!;\n\t\tgposLookupMap.set(entry.index, entry);\n\t}\n\n\treturn {\n\t\tscript: scriptTag,\n\t\tlanguage: languageTag,\n\t\tdirection,\n\t\tgsubLookups,\n\t\tgposLookups,\n\t\tgsubLookupMap,\n\t\tgposLookupMap,\n\t};\n}\n\nfunction collectLookups<T extends { lookups: unknown[] }>(\n\ttable: T | null,\n\tscriptTag: Tag,\n\tlanguageTag: Tag | null,\n\tenabledFeatures: Set<Tag>,\n\taxisCoords: number[] | null,\n): Array<{ index: number; lookup: unknown }> {\n\tif (!table) return [];\n\n\tconst gsub = table as unknown as GsubTable | GposTable;\n\tconst lookupIndices = new Set<number>();\n\n\t// Find script\n\tlet script = findScript(gsub.scriptList, scriptTag);\n\tif (!script) {\n\t\t// Try DFLT script\n\t\tscript = findScript(gsub.scriptList, tag(\"DFLT\"));\n\t}\n\tif (!script) {\n\t\t// Try latn as fallback\n\t\tscript = findScript(gsub.scriptList, tag(\"latn\"));\n\t}\n\tif (!script) return [];\n\n\t// Find language system\n\tconst langSys = findLangSys(script, languageTag);\n\tif (!langSys) return [];\n\n\t// Get feature variations substitutions if applicable\n\tconst featureVariations = (gsub as { featureVariations?: FeatureVariations })\n\t\t.featureVariations;\n\tconst matchingVariation =\n\t\tfeatureVariations && axisCoords\n\t\t\t? findMatchingFeatureVariation(featureVariations, axisCoords)\n\t\t\t: null;\n\n\t// Build a map of feature indices to their substituted lookup lists\n\tconst featureSubstitutions = new Map<uint16, uint16[]>();\n\tif (matchingVariation) {\n\t\tconst subs = matchingVariation.featureTableSubstitution.substitutions;\n\t\tfor (let i = 0; i < subs.length; i++) {\n\t\t\tconst subst = subs[i]!;\n\t\t\tfeatureSubstitutions.set(\n\t\t\t\tsubst.featureIndex,\n\t\t\t\tsubst.alternateFeature.lookupListIndices,\n\t\t\t);\n\t\t}\n\t}\n\n\t// Add required feature\n\tif (langSys.requiredFeatureIndex !== 0xffff) {\n\t\tconst feature = getFeature(gsub.featureList, langSys.requiredFeatureIndex);\n\t\tif (feature) {\n\t\t\t// Check if this feature has a substitution\n\t\t\tconst substitutedLookups = featureSubstitutions.get(\n\t\t\t\tlangSys.requiredFeatureIndex,\n\t\t\t);\n\t\t\tconst lookups = substitutedLookups ?? feature.feature.lookupListIndices;\n\t\t\tfor (let i = 0; i < lookups.length; i++) {\n\t\t\t\tlookupIndices.add(lookups[i]!);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add enabled features\n\tconst featureIndices = langSys.featureIndices;\n\tfor (let f = 0; f < featureIndices.length; f++) {\n\t\tconst featureIndex = featureIndices[f]!;\n\t\tconst featureRecord = getFeature(gsub.featureList, featureIndex);\n\t\tif (!featureRecord) continue;\n\n\t\tif (enabledFeatures.has(featureRecord.featureTag)) {\n\t\t\t// Check if this feature has a substitution\n\t\t\tconst substitutedLookups = featureSubstitutions.get(featureIndex);\n\t\t\tconst lookups =\n\t\t\t\tsubstitutedLookups ?? featureRecord.feature.lookupListIndices;\n\t\t\tfor (let i = 0; i < lookups.length; i++) {\n\t\t\t\tlookupIndices.add(lookups[i]!);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to sorted array with lookup objects\n\tconst result: Array<{ index: number; lookup: unknown }> = [];\n\tconst sortedIndices = [...lookupIndices].sort((a, b) => a - b);\n\n\tfor (let i = 0; i < sortedIndices.length; i++) {\n\t\tconst index = sortedIndices[i]!;\n\t\tconst lookup = gsub.lookups[index];\n\t\tif (lookup) {\n\t\t\tresult.push({ index, lookup });\n\t\t}\n\t}\n\n\treturn result;\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Hangul shaper for Korean text\n * Handles Jamo composition and syllable block formation\n */\n\n// Hangul Unicode ranges\nconst HANGUL_BASE = 0xac00; // First precomposed syllable ()\nconst HANGUL_END = 0xd7a3; // Last precomposed syllable ()\n\nconst JAMO_L_BASE = 0x1100; // Leading consonant (choseong) base\nconst JAMO_V_BASE = 0x1161; // Vowel (jungseong) base\nconst JAMO_T_BASE = 0x11a7; // Trailing consonant (jongseong) base - 0x11a8 is first real one\n\nconst JAMO_L_COUNT = 19; // Number of leading consonants\nconst JAMO_V_COUNT = 21; // Number of vowels\nconst JAMO_T_COUNT = 28; // Number of trailing consonants (including none)\n\nconst JAMO_VT_COUNT = JAMO_V_COUNT * JAMO_T_COUNT; // 588\nconst _JAMO_LVT_COUNT = JAMO_L_COUNT * JAMO_VT_COUNT; // 11172\n\n// Compatibility Jamo (for conversion)\nconst COMPAT_JAMO_START = 0x3131;\nconst COMPAT_JAMO_END = 0x318e;\n\n// Hangul Jamo Extended-A (old Korean)\nconst JAMO_EXT_A_START = 0xa960;\nconst JAMO_EXT_A_END = 0xa97c;\n\n// Hangul Jamo Extended-B (old Korean)\nconst JAMO_EXT_B_START = 0xd7b0;\nconst JAMO_EXT_B_END = 0xd7fb;\n\n/**\n * Check if codepoint is a Hangul syllable\n */\nexport function isHangulSyllable(cp: number): boolean {\n\treturn cp >= HANGUL_BASE && cp <= HANGUL_END;\n}\n\n/**\n * Check if codepoint is a Hangul Jamo (conjoining)\n */\nexport function isHangulJamo(cp: number): boolean {\n\treturn (\n\t\t(cp >= JAMO_L_BASE && cp <= 0x11ff) ||\n\t\t(cp >= JAMO_EXT_A_START && cp <= JAMO_EXT_A_END) ||\n\t\t(cp >= JAMO_EXT_B_START && cp <= JAMO_EXT_B_END)\n\t);\n}\n\n/**\n * Check if codepoint is a leading consonant (L)\n */\nexport function isJamoL(cp: number): boolean {\n\treturn (\n\t\t(cp >= JAMO_L_BASE && cp < JAMO_L_BASE + JAMO_L_COUNT) ||\n\t\t(cp >= JAMO_EXT_A_START && cp <= JAMO_EXT_A_END)\n\t);\n}\n\n/**\n * Check if codepoint is a vowel (V)\n */\nexport function isJamoV(cp: number): boolean {\n\treturn (\n\t\t(cp >= JAMO_V_BASE && cp < JAMO_V_BASE + JAMO_V_COUNT) ||\n\t\t(cp >= 0xd7b0 && cp <= 0xd7c6)\n\t);\n}\n\n/**\n * Check if codepoint is a trailing consonant (T)\n */\nexport function isJamoT(cp: number): boolean {\n\treturn (\n\t\t(cp > JAMO_T_BASE && cp <= JAMO_T_BASE + JAMO_T_COUNT - 1) ||\n\t\t(cp >= 0xd7cb && cp <= 0xd7fb)\n\t);\n}\n\n/**\n * Decompose a precomposed Hangul syllable into Jamo\n */\nexport function decomposeHangul(cp: number): number[] {\n\tif (!isHangulSyllable(cp)) return [cp];\n\n\tconst syllableIndex = cp - HANGUL_BASE;\n\tconst l = Math.floor(syllableIndex / JAMO_VT_COUNT);\n\tconst v = Math.floor((syllableIndex % JAMO_VT_COUNT) / JAMO_T_COUNT);\n\tconst t = syllableIndex % JAMO_T_COUNT;\n\n\tconst result = [JAMO_L_BASE + l, JAMO_V_BASE + v];\n\tif (t > 0) {\n\t\tresult.push(JAMO_T_BASE + t);\n\t}\n\treturn result;\n}\n\n/**\n * Compose Jamo into a precomposed Hangul syllable\n */\nexport function composeHangul(\n\tl: number,\n\tv: number,\n\tt: number = 0,\n): number | null {\n\t// Normalize indices\n\tconst lIndex = l - JAMO_L_BASE;\n\tconst vIndex = v - JAMO_V_BASE;\n\tconst tIndex = t === 0 ? 0 : t - JAMO_T_BASE;\n\n\tif (lIndex < 0 || lIndex >= JAMO_L_COUNT) return null;\n\tif (vIndex < 0 || vIndex >= JAMO_V_COUNT) return null;\n\tif (tIndex < 0 || tIndex >= JAMO_T_COUNT) return null;\n\n\treturn HANGUL_BASE + lIndex * JAMO_VT_COUNT + vIndex * JAMO_T_COUNT + tIndex;\n}\n\n/**\n * Hangul syllable types\n */\nexport enum HangulSyllableType {\n\tNotApplicable = 0,\n\tLeadingJamo = 1, // L\n\tVowelJamo = 2, // V\n\tTrailingJamo = 3, // T\n\tLVSyllable = 4, // LV (no trailing)\n\tLVTSyllable = 5, // LVT (with trailing)\n}\n\n/**\n * Get the syllable type of a codepoint\n */\nexport function getHangulSyllableType(cp: number): HangulSyllableType {\n\tif (isJamoL(cp)) return HangulSyllableType.LeadingJamo;\n\tif (isJamoV(cp)) return HangulSyllableType.VowelJamo;\n\tif (isJamoT(cp)) return HangulSyllableType.TrailingJamo;\n\n\tif (isHangulSyllable(cp)) {\n\t\tconst syllableIndex = cp - HANGUL_BASE;\n\t\tconst t = syllableIndex % JAMO_T_COUNT;\n\t\treturn t === 0\n\t\t\t? HangulSyllableType.LVSyllable\n\t\t\t: HangulSyllableType.LVTSyllable;\n\t}\n\n\treturn HangulSyllableType.NotApplicable;\n}\n\n/**\n * Feature masks for Hangul\n */\nexport const HangulFeatureMask = {\n\tljmo: 0x0001, // Leading jamo forms\n\tvjmo: 0x0002, // Vowel jamo forms\n\ttjmo: 0x0004, // Trailing jamo forms\n} as const;\n\n/**\n * Setup Hangul masks for feature application\n */\nexport function setupHangulMasks(infos: GlyphInfo[]): void {\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst type = getHangulSyllableType(info.codepoint);\n\n\t\tswitch (type) {\n\t\t\tcase HangulSyllableType.LeadingJamo:\n\t\t\t\tinfo.mask |= HangulFeatureMask.ljmo;\n\t\t\t\tbreak;\n\t\t\tcase HangulSyllableType.VowelJamo:\n\t\t\t\tinfo.mask |= HangulFeatureMask.vjmo;\n\t\t\t\tbreak;\n\t\t\tcase HangulSyllableType.TrailingJamo:\n\t\t\t\tinfo.mask |= HangulFeatureMask.tjmo;\n\t\t\t\tbreak;\n\t\t\tcase HangulSyllableType.LVSyllable:\n\t\t\tcase HangulSyllableType.LVTSyllable:\n\t\t\t\t// Precomposed syllables don't need special features\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Normalize Hangul - compose Jamo sequences into syllables where possible\n */\nexport function normalizeHangul(infos: GlyphInfo[]): GlyphInfo[] {\n\tconst result: GlyphInfo[] = [];\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst type = getHangulSyllableType(info.codepoint);\n\n\t\t// Try to compose L + V [+ T]\n\t\tif (type === HangulSyllableType.LeadingJamo && i + 1 < infos.length) {\n\t\t\tconst nextInfo = infos[i + 1];\n\t\t\tif (!nextInfo) {\n\t\t\t\tresult.push(info);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextType = getHangulSyllableType(nextInfo.codepoint);\n\n\t\t\tif (nextType === HangulSyllableType.VowelJamo) {\n\t\t\t\t// Check for trailing jamo\n\t\t\t\tlet t = 0;\n\t\t\t\tlet consumed = 2;\n\n\t\t\t\tif (i + 2 < infos.length) {\n\t\t\t\t\tconst thirdInfo = infos[i + 2];\n\t\t\t\t\tif (thirdInfo) {\n\t\t\t\t\t\tconst thirdType = getHangulSyllableType(thirdInfo.codepoint);\n\n\t\t\t\t\t\tif (thirdType === HangulSyllableType.TrailingJamo) {\n\t\t\t\t\t\t\tt = thirdInfo.codepoint;\n\t\t\t\t\t\t\tconsumed = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst composed = composeHangul(info.codepoint, nextInfo.codepoint, t);\n\t\t\t\tif (composed !== null) {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tglyphId: info.glyphId, // Will be remapped\n\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\tcodepoint: composed,\n\t\t\t\t\t});\n\t\t\t\t\ti += consumed;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try to compose LV + T\n\t\tif (type === HangulSyllableType.LVSyllable && i + 1 < infos.length) {\n\t\t\tconst nextInfo = infos[i + 1];\n\t\t\tif (!nextInfo) {\n\t\t\t\tresult.push(info);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextType = getHangulSyllableType(nextInfo.codepoint);\n\n\t\t\tif (nextType === HangulSyllableType.TrailingJamo) {\n\t\t\t\t// Decompose LV, add T, recompose\n\t\t\t\tconst decomposed = decomposeHangul(info.codepoint);\n\t\t\t\tconst [firstJamo, secondJamo] = decomposed;\n\t\t\t\tif (\n\t\t\t\t\tdecomposed.length === 2 &&\n\t\t\t\t\tfirstJamo !== undefined &&\n\t\t\t\t\tsecondJamo !== undefined\n\t\t\t\t) {\n\t\t\t\t\tconst composed = composeHangul(\n\t\t\t\t\t\tfirstJamo,\n\t\t\t\t\t\tsecondJamo,\n\t\t\t\t\t\tnextInfo.codepoint,\n\t\t\t\t\t);\n\t\t\t\t\tif (composed !== null) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tglyphId: info.glyphId,\n\t\t\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\t\t\tmask: info.mask,\n\t\t\t\t\t\t\tcodepoint: composed,\n\t\t\t\t\t\t});\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No composition, keep as-is\n\t\tresult.push(info);\n\t\ti++;\n\t}\n\n\treturn result;\n}\n\n/**\n * Check if codepoint is Korean (Hangul or Jamo)\n */\nexport function isKorean(cp: number): boolean {\n\treturn (\n\t\tisHangulSyllable(cp) ||\n\t\tisHangulJamo(cp) ||\n\t\t(cp >= COMPAT_JAMO_START && cp <= COMPAT_JAMO_END)\n\t);\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Hebrew character categories\n */\nexport enum HebrewCategory {\n\tOther = 0,\n\tLetter = 1, // Regular letter\n\tPoint = 2, // Niqqud (vowel point)\n\tDagesh = 3, // Dagesh/Mapiq\n\tShin = 4, // Shin/Sin dot\n\tRafe = 5, // Rafe mark\n\tAccent = 6, // Cantillation marks\n\tMaqaf = 7, // Hebrew hyphen\n\tPunctuation = 8, // Punctuation\n}\n\n/**\n * Hebrew Unicode range\n */\nconst HEBREW_START = 0x0590;\nconst HEBREW_END = 0x05ff;\nconst HEBREW_EXTENDED_START = 0xfb1d;\nconst HEBREW_EXTENDED_END = 0xfb4f;\n\n/**\n * Check if codepoint is Hebrew\n */\nexport function isHebrew(cp: number): boolean {\n\treturn (\n\t\t(cp >= HEBREW_START && cp <= HEBREW_END) ||\n\t\t(cp >= HEBREW_EXTENDED_START && cp <= HEBREW_EXTENDED_END)\n\t);\n}\n\n/**\n * Get Hebrew category for a codepoint\n */\nexport function getHebrewCategory(cp: number): HebrewCategory {\n\t// Cantillation marks (0591-05AF)\n\tif (cp >= 0x0591 && cp <= 0x05af) return HebrewCategory.Accent;\n\n\t// Points (05B0-05BD)\n\tif (cp >= 0x05b0 && cp <= 0x05bd) return HebrewCategory.Point;\n\n\t// Maqaf\n\tif (cp === 0x05be) return HebrewCategory.Maqaf;\n\n\t// Rafe\n\tif (cp === 0x05bf) return HebrewCategory.Rafe;\n\n\t// Paseq, Sof Pasuq\n\tif (cp === 0x05c0 || cp === 0x05c3) return HebrewCategory.Punctuation;\n\n\t// Shin/Sin dot\n\tif (cp === 0x05c1 || cp === 0x05c2) return HebrewCategory.Shin;\n\n\t// Dagesh/Mapiq\n\tif (cp === 0x05bc) return HebrewCategory.Dagesh;\n\n\t// Meteg\n\tif (cp === 0x05bd) return HebrewCategory.Point;\n\n\t// Letters (05D0-05EA)\n\tif (cp >= 0x05d0 && cp <= 0x05ea) return HebrewCategory.Letter;\n\n\t// Final letters are handled the same\n\tif (cp >= 0x05f0 && cp <= 0x05f4) return HebrewCategory.Letter;\n\n\t// Extended forms (FB1D-FB4F)\n\tif (cp >= 0xfb1d && cp <= 0xfb4f) return HebrewCategory.Letter;\n\n\tif (isHebrew(cp)) return HebrewCategory.Other;\n\treturn HebrewCategory.Other;\n}\n\n/**\n * Set up masks for Hebrew shaping\n * Hebrew is relatively simple - mainly RTL with marks\n */\nexport function setupHebrewMasks(infos: GlyphInfo[]): void {\n\t// Hebrew shaping primarily relies on:\n\t// 1. Mark positioning (handled by GPOS)\n\t// 2. RTL reordering (handled by main shaper)\n\n\t// Group characters with their base letters\n\tlet baseIndex = 0;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getHebrewCategory(info.codepoint);\n\n\t\t// Letters start new clusters\n\t\tif (cat === HebrewCategory.Letter) {\n\t\t\tbaseIndex = i;\n\t\t}\n\n\t\t// Store base index for mark attachment\n\t\tinfo.mask = (info.mask & 0xffff0000) | (baseIndex & 0xffff);\n\t}\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Indic syllable categories based on Unicode and OpenType spec\n */\nexport enum IndicCategory {\n\tX = 0, // Other/Unknown\n\tC = 1, // Consonant\n\tV = 2, // Independent vowel\n\tN = 3, // Nukta\n\tH = 4, // Halant/Virama\n\tZWNJ = 5, // Zero Width Non-Joiner\n\tZWJ = 6, // Zero Width Joiner\n\tM = 7, // Matra (dependent vowel)\n\tSM = 8, // Syllable modifier (anusvara, visarga)\n\tA = 9, // Accent mark\n\tVD = 10, // Vedic mark\n\tPlaceholder = 11, // Placeholder (dotted circle)\n\tDotted_Circle = 12, // Explicit dotted circle\n\tRS = 13, // Repha form\n\tCoeng = 14, // Coeng (Khmer virama)\n\tRa = 15, // Ra consonant (for repha)\n\tCM = 16, // Consonant modifier\n\tSymbol = 17, // Symbol\n\tCS = 18, // Consonant with stacker\n}\n\n/**\n * Indic syllabic position\n */\nexport enum IndicPosition {\n\tStart = 0,\n\tRaToBecomeReph = 1,\n\tPreM = 2,\n\tPreC = 3,\n\tBaseC = 4,\n\tAfterMain = 5,\n\tAboveC = 6,\n\tBeforeSub = 7,\n\tBelowC = 8,\n\tAfterSub = 9,\n\tBeforePost = 10,\n\tPostC = 11,\n\tAfterPost = 12,\n\tFinalC = 13,\n\tSMVD = 14,\n\tEnd = 15,\n}\n\n/**\n * Per-glyph Indic shaping data\n */\nexport interface IndicGlyphData {\n\tcategory: IndicCategory;\n\tposition: IndicPosition;\n\tsyllableIndex: number;\n}\n\n/**\n * Determine if codepoint is in Devanagari range\n */\nfunction isDevanagari(cp: number): boolean {\n\treturn cp >= 0x0900 && cp <= 0x097f;\n}\n\n/**\n * Determine if codepoint is in Bengali range\n */\nfunction isBengali(cp: number): boolean {\n\treturn cp >= 0x0980 && cp <= 0x09ff;\n}\n\n/**\n * Determine if codepoint is in Gurmukhi range\n */\nfunction isGurmukhi(cp: number): boolean {\n\treturn cp >= 0x0a00 && cp <= 0x0a7f;\n}\n\n/**\n * Determine if codepoint is in Gujarati range\n */\nfunction isGujarati(cp: number): boolean {\n\treturn cp >= 0x0a80 && cp <= 0x0aff;\n}\n\n/**\n * Determine if codepoint is in Oriya range\n */\nfunction isOriya(cp: number): boolean {\n\treturn cp >= 0x0b00 && cp <= 0x0b7f;\n}\n\n/**\n * Determine if codepoint is in Tamil range\n */\nfunction isTamil(cp: number): boolean {\n\treturn cp >= 0x0b80 && cp <= 0x0bff;\n}\n\n/**\n * Determine if codepoint is in Telugu range\n */\nfunction isTelugu(cp: number): boolean {\n\treturn cp >= 0x0c00 && cp <= 0x0c7f;\n}\n\n/**\n * Determine if codepoint is in Kannada range\n */\nfunction isKannada(cp: number): boolean {\n\treturn cp >= 0x0c80 && cp <= 0x0cff;\n}\n\n/**\n * Determine if codepoint is in Malayalam range\n */\nfunction isMalayalam(cp: number): boolean {\n\treturn cp >= 0x0d00 && cp <= 0x0d7f;\n}\n\n/**\n * Check if a codepoint is an Indic script\n */\nexport function isIndic(cp: number): boolean {\n\treturn (\n\t\tisDevanagari(cp) ||\n\t\tisBengali(cp) ||\n\t\tisGurmukhi(cp) ||\n\t\tisGujarati(cp) ||\n\t\tisOriya(cp) ||\n\t\tisTamil(cp) ||\n\t\tisTelugu(cp) ||\n\t\tisKannada(cp) ||\n\t\tisMalayalam(cp)\n\t);\n}\n\n/**\n * Get the Indic category for a codepoint\n */\nexport function getIndicCategory(cp: number): IndicCategory {\n\t// Zero-width characters\n\tif (cp === 0x200c) return IndicCategory.ZWNJ;\n\tif (cp === 0x200d) return IndicCategory.ZWJ;\n\tif (cp === 0x25cc) return IndicCategory.Dotted_Circle;\n\n\t// Devanagari (0900-097F)\n\tif (isDevanagari(cp)) {\n\t\t// Vowel signs (matras)\n\t\tif (\n\t\t\t(cp >= 0x093a && cp <= 0x093b) ||\n\t\t\t(cp >= 0x093e && cp <= 0x094c) ||\n\t\t\t(cp >= 0x094e && cp <= 0x094f) ||\n\t\t\t(cp >= 0x0955 && cp <= 0x0957)\n\t\t) {\n\t\t\treturn IndicCategory.M;\n\t\t}\n\t\t// Virama\n\t\tif (cp === 0x094d) return IndicCategory.H;\n\t\t// Nukta\n\t\tif (cp === 0x093c) return IndicCategory.N;\n\t\t// Anusvara, Visarga, Chandrabindu\n\t\tif (cp >= 0x0901 && cp <= 0x0903) return IndicCategory.SM;\n\t\t// Vedic marks\n\t\tif (cp >= 0x0951 && cp <= 0x0954) return IndicCategory.A;\n\t\t// Independent vowels\n\t\tif (\n\t\t\t(cp >= 0x0904 && cp <= 0x0914) ||\n\t\t\tcp === 0x0960 ||\n\t\t\tcp === 0x0961 ||\n\t\t\tcp === 0x0972 ||\n\t\t\t(cp >= 0x0976 && cp <= 0x0977)\n\t\t) {\n\t\t\treturn IndicCategory.V;\n\t\t}\n\t\t// Consonants\n\t\tif (\n\t\t\t(cp >= 0x0915 && cp <= 0x0939) ||\n\t\t\t(cp >= 0x0958 && cp <= 0x095f) ||\n\t\t\tcp === 0x0978 ||\n\t\t\tcp === 0x0979 ||\n\t\t\tcp === 0x097a ||\n\t\t\t(cp >= 0x097b && cp <= 0x097c) ||\n\t\t\t(cp >= 0x097e && cp <= 0x097f)\n\t\t) {\n\t\t\t// Ra for repha\n\t\t\tif (cp === 0x0930) return IndicCategory.Ra;\n\t\t\treturn IndicCategory.C;\n\t\t}\n\t\t// Digits and symbols\n\t\tif (cp >= 0x0966 && cp <= 0x096f) return IndicCategory.Symbol;\n\t\treturn IndicCategory.X;\n\t}\n\n\t// Bengali (0980-09FF)\n\tif (isBengali(cp)) {\n\t\tif (\n\t\t\t(cp >= 0x09be && cp <= 0x09c4) ||\n\t\t\t(cp >= 0x09c7 && cp <= 0x09c8) ||\n\t\t\t(cp >= 0x09cb && cp <= 0x09cc) ||\n\t\t\tcp === 0x09d7\n\t\t) {\n\t\t\treturn IndicCategory.M;\n\t\t}\n\t\tif (cp === 0x09cd) return IndicCategory.H;\n\t\tif (cp === 0x09bc) return IndicCategory.N;\n\t\tif (cp >= 0x0981 && cp <= 0x0983) return IndicCategory.SM;\n\t\tif (\n\t\t\t(cp >= 0x0985 && cp <= 0x098c) ||\n\t\t\t(cp >= 0x098f && cp <= 0x0990) ||\n\t\t\t(cp >= 0x0993 && cp <= 0x0994) ||\n\t\t\tcp === 0x09e0 ||\n\t\t\tcp === 0x09e1\n\t\t) {\n\t\t\treturn IndicCategory.V;\n\t\t}\n\t\tif (\n\t\t\t(cp >= 0x0995 && cp <= 0x09a8) ||\n\t\t\t(cp >= 0x09aa && cp <= 0x09b0) ||\n\t\t\tcp === 0x09b2 ||\n\t\t\t(cp >= 0x09b6 && cp <= 0x09b9) ||\n\t\t\t(cp >= 0x09dc && cp <= 0x09dd) ||\n\t\t\t(cp >= 0x09df && cp <= 0x09e1)\n\t\t) {\n\t\t\tif (cp === 0x09b0) return IndicCategory.Ra;\n\t\t\treturn IndicCategory.C;\n\t\t}\n\t\treturn IndicCategory.X;\n\t}\n\n\t// Other Indic scripts - simplified handling\n\t// Tamil, Telugu, Kannada, Malayalam, Gurmukhi, Gujarati, Oriya\n\tif (\n\t\tisGurmukhi(cp) ||\n\t\tisGujarati(cp) ||\n\t\tisOriya(cp) ||\n\t\tisTamil(cp) ||\n\t\tisTelugu(cp) ||\n\t\tisKannada(cp) ||\n\t\tisMalayalam(cp)\n\t) {\n\t\tconst offset = cp & 0x7f; // Position within the block\n\t\t// Common patterns for Indic scripts\n\t\tif (offset >= 0x01 && offset <= 0x03) return IndicCategory.SM; // Anusvara etc\n\t\tif (offset >= 0x05 && offset <= 0x14) return IndicCategory.V; // Vowels\n\t\tif (offset >= 0x15 && offset <= 0x39) return IndicCategory.C; // Consonants\n\t\tif (offset === 0x3c) return IndicCategory.N; // Nukta\n\t\tif (offset >= 0x3e && offset <= 0x4c) return IndicCategory.M; // Matras\n\t\tif (offset === 0x4d) return IndicCategory.H; // Virama\n\t\treturn IndicCategory.X;\n\t}\n\n\treturn IndicCategory.X;\n}\n\n/**\n * Syllable structure for Indic scripts\n */\ninterface Syllable {\n\tstart: number;\n\tend: number;\n\thasReph: boolean;\n\tbaseConsonant: number;\n}\n\n/**\n * Find syllable boundaries in the glyph buffer\n */\nexport function findSyllables(infos: GlyphInfo[]): Syllable[] {\n\tconst syllables: Syllable[] = [];\n\tconst n = infos.length;\n\tif (n === 0) return syllables;\n\n\tlet start = 0;\n\n\twhile (start < n) {\n\t\tconst syllable = parseSyllable(infos, start);\n\t\tsyllables.push(syllable);\n\t\tstart = syllable.end;\n\t}\n\n\treturn syllables;\n}\n\n/**\n * Parse a single syllable starting at the given position\n */\nfunction parseSyllable(infos: GlyphInfo[], start: number): Syllable {\n\tconst n = infos.length;\n\tlet pos = start;\n\n\t// Check for initial consonant cluster with halant\n\tlet baseConsonant = -1;\n\tlet hasReph = false;\n\n\t// Look for Ra + H at the start (potential Reph)\n\tif (pos + 1 < n) {\n\t\tconst info1 = infos[pos];\n\t\tconst info2 = infos[pos + 1];\n\t\tif (info1 && info2) {\n\t\t\tconst cat1 = getIndicCategory(info1.codepoint ?? 0);\n\t\t\tconst cat2 = getIndicCategory(info2.codepoint ?? 0);\n\t\t\tif (cat1 === IndicCategory.Ra && cat2 === IndicCategory.H) {\n\t\t\t\thasReph = true;\n\t\t\t\tpos += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find base consonant (last consonant before matras/end)\n\tlet lastConsonant = -1;\n\twhile (pos < n) {\n\t\tconst info = infos[pos];\n\t\tif (!info) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cp = info.codepoint ?? 0;\n\t\tconst cat = getIndicCategory(cp);\n\n\t\tif (cat === IndicCategory.C || cat === IndicCategory.Ra) {\n\t\t\tlastConsonant = pos;\n\t\t\tpos++;\n\t\t\t// Check for nukta\n\t\t\tif (pos < n) {\n\t\t\t\tconst nextInfo = infos[pos];\n\t\t\t\tif (\n\t\t\t\t\tnextInfo &&\n\t\t\t\t\tgetIndicCategory(nextInfo.codepoint ?? 0) === IndicCategory.N\n\t\t\t\t) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check for halant (may continue consonant cluster)\n\t\t\tif (pos < n) {\n\t\t\t\tconst hInfo = infos[pos];\n\t\t\t\tif (\n\t\t\t\t\thInfo &&\n\t\t\t\t\tgetIndicCategory(hInfo.codepoint ?? 0) === IndicCategory.H\n\t\t\t\t) {\n\t\t\t\t\tpos++;\n\t\t\t\t\t// After halant, might have ZWJ/ZWNJ or another consonant\n\t\t\t\t\tif (pos < n) {\n\t\t\t\t\t\tconst afterH = infos[pos];\n\t\t\t\t\t\tif (afterH) {\n\t\t\t\t\t\t\tconst nextCat = getIndicCategory(afterH.codepoint ?? 0);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tnextCat === IndicCategory.ZWJ ||\n\t\t\t\t\t\t\t\tnextCat === IndicCategory.ZWNJ\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue; // Look for more consonants\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (cat === IndicCategory.V) {\n\t\t\t// Independent vowel as syllable base\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t} else if (cat === IndicCategory.N) {\n\t\t\t// Standalone nukta - skip\n\t\t\tpos++;\n\t\t} else {\n\t\t\t// Non-syllable character, end here\n\t\t\tif (lastConsonant === -1) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbaseConsonant = lastConsonant >= 0 ? lastConsonant : start;\n\n\t// Consume matras, anusvara, visarga\n\twhile (pos < n) {\n\t\tconst info = infos[pos];\n\t\tif (!info) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cp = info.codepoint ?? 0;\n\t\tconst cat = getIndicCategory(cp);\n\n\t\tif (\n\t\t\tcat === IndicCategory.M ||\n\t\t\tcat === IndicCategory.SM ||\n\t\t\tcat === IndicCategory.A ||\n\t\t\tcat === IndicCategory.N\n\t\t) {\n\t\t\tpos++;\n\t\t} else if (cat === IndicCategory.H) {\n\t\t\t// Halant at end (final form)\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Ensure we advance at least one position\n\tif (pos === start) {\n\t\tpos = start + 1;\n\t}\n\n\treturn {\n\t\tstart,\n\t\tend: pos,\n\t\thasReph,\n\t\tbaseConsonant,\n\t};\n}\n\n/**\n * Indic feature masks for OpenType features\n */\nexport const IndicFeatureMask = {\n\tnukt: 0x0001, // Nukta forms\n\takhn: 0x0002, // Akhand forms\n\trphf: 0x0004, // Reph forms\n\trkrf: 0x0008, // Rakaar forms\n\tpref: 0x0010, // Pre-base forms\n\tblwf: 0x0020, // Below-base forms\n\tabvf: 0x0040, // Above-base forms\n\thalf: 0x0080, // Half forms\n\tpstf: 0x0100, // Post-base forms\n\tvatu: 0x0200, // Vattu variants\n\tcjct: 0x0400, // Conjunct forms\n\tinit: 0x0800, // Initial forms\n\tpres: 0x1000, // Pre-base substitutions\n\tabvs: 0x2000, // Above-base substitutions\n\tblws: 0x4000, // Below-base substitutions\n\tpsts: 0x8000, // Post-base substitutions\n} as const;\n\n/**\n * Matra position in syllable\n */\nexport enum MatraPosition {\n\tPreBase = 0,\n\tAboveBase = 1,\n\tBelowBase = 2,\n\tPostBase = 3,\n}\n\n/**\n * Get matra position based on codepoint\n */\nexport function getMatraPosition(cp: number): MatraPosition {\n\t// Devanagari\n\tif (cp >= 0x0900 && cp <= 0x097f) {\n\t\t// Pre-base:  (093F)\n\t\tif (cp === 0x093f) return MatraPosition.PreBase;\n\t\t// Above-base:     (0945-0948)\n\t\tif (cp >= 0x0945 && cp <= 0x0948) return MatraPosition.AboveBase;\n\t\t// Below-base:     (0941-0944)\n\t\tif (cp >= 0x0941 && cp <= 0x0944) return MatraPosition.BelowBase;\n\t\t// Post-base: everything else\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Bengali\n\tif (cp >= 0x0980 && cp <= 0x09ff) {\n\t\t// Pre-base:  (09BF)\n\t\tif (cp === 0x09bf) return MatraPosition.PreBase;\n\t\t// Pre-base split vowels:   (09C7-09C8) - left part\n\t\tif (cp === 0x09c7 || cp === 0x09c8) return MatraPosition.PreBase;\n\t\t// Below-base:     (09C1-09C4)\n\t\tif (cp >= 0x09c1 && cp <= 0x09c4) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Tamil\n\tif (cp >= 0x0b80 && cp <= 0x0bff) {\n\t\t// Pre-base:    (0BC6-0BC8)\n\t\tif (cp >= 0x0bc6 && cp <= 0x0bc8) return MatraPosition.PreBase;\n\t\t// Above-base: none\n\t\t// Below-base:   (0BC1-0BC2)\n\t\tif (cp === 0x0bc1 || cp === 0x0bc2) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Telugu\n\tif (cp >= 0x0c00 && cp <= 0x0c7f) {\n\t\t// Above-base:      (0C3E-0C40, 0C46-0C48)\n\t\tif ((cp >= 0x0c3e && cp <= 0x0c40) || (cp >= 0x0c46 && cp <= 0x0c48)) {\n\t\t\treturn MatraPosition.AboveBase;\n\t\t}\n\t\t// Below-base:     (0C41-0C44)\n\t\tif (cp >= 0x0c41 && cp <= 0x0c44) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Kannada\n\tif (cp >= 0x0c80 && cp <= 0x0cff) {\n\t\t// Above-base: similar to Telugu\n\t\tif ((cp >= 0x0cbe && cp <= 0x0cc0) || (cp >= 0x0cc6 && cp <= 0x0cc8)) {\n\t\t\treturn MatraPosition.AboveBase;\n\t\t}\n\t\tif (cp >= 0x0cc1 && cp <= 0x0cc4) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Malayalam\n\tif (cp >= 0x0d00 && cp <= 0x0d7f) {\n\t\t// Pre-base:    (0D46-0D48)\n\t\tif (cp >= 0x0d46 && cp <= 0x0d48) return MatraPosition.PreBase;\n\t\t// Below-base:    (0D41-0D43)\n\t\tif (cp >= 0x0d41 && cp <= 0x0d43) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Gurmukhi\n\tif (cp >= 0x0a00 && cp <= 0x0a7f) {\n\t\t// Pre-base:  (0A3F)\n\t\tif (cp === 0x0a3f) return MatraPosition.PreBase;\n\t\t// Below-base:   (0A41-0A42)\n\t\tif (cp === 0x0a41 || cp === 0x0a42) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Gujarati\n\tif (cp >= 0x0a80 && cp <= 0x0aff) {\n\t\t// Pre-base:  (0ABF)\n\t\tif (cp === 0x0abf) return MatraPosition.PreBase;\n\t\t// Below-base:     (0AC1-0AC4)\n\t\tif (cp >= 0x0ac1 && cp <= 0x0ac4) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\t// Oriya\n\tif (cp >= 0x0b00 && cp <= 0x0b7f) {\n\t\t// Pre-base:  (0B3F)\n\t\tif (cp === 0x0b3f) return MatraPosition.PreBase;\n\t\t// Below-base:    (0B41-0B43)\n\t\tif (cp >= 0x0b41 && cp <= 0x0b43) return MatraPosition.BelowBase;\n\t\treturn MatraPosition.PostBase;\n\t}\n\n\treturn MatraPosition.PostBase;\n}\n\n/**\n * Set up masks and syllable indices for Indic shaping\n */\nexport function setupIndicMasks(infos: GlyphInfo[]): void {\n\tconst syllables = findSyllables(infos);\n\n\tfor (let i = 0; i < syllables.length; i++) {\n\t\tconst syllable = syllables[i]!;\n\t\t// Mark syllable boundaries in mask\n\t\tfor (let j = syllable.start; j < syllable.end; j++) {\n\t\t\tconst info = infos[j];\n\t\t\tif (info) {\n\t\t\t\t// Store syllable index in upper bits\n\t\t\t\tinfo.mask = (info.mask & 0x0000ffff) | ((i & 0xffff) << 16);\n\n\t\t\t\tconst cat = getIndicCategory(info.codepoint);\n\n\t\t\t\t// Nukta - always apply nukt feature\n\t\t\t\tif (cat === IndicCategory.N) {\n\t\t\t\t\tinfo.mask |= IndicFeatureMask.nukt;\n\t\t\t\t}\n\n\t\t\t\t// Halant handling\n\t\t\t\tif (cat === IndicCategory.H) {\n\t\t\t\t\t// Check position relative to base\n\t\t\t\t\tif (j < syllable.baseConsonant) {\n\t\t\t\t\t\t// Pre-base halant - half forms\n\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.half;\n\t\t\t\t\t} else if (j > syllable.baseConsonant) {\n\t\t\t\t\t\t// Post-base halant - below/post forms\n\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.blwf | IndicFeatureMask.pstf;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Consonant handling\n\t\t\t\tif (cat === IndicCategory.C || cat === IndicCategory.Ra) {\n\t\t\t\t\tif (j < syllable.baseConsonant) {\n\t\t\t\t\t\t// Pre-base consonant\n\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.half | IndicFeatureMask.cjct;\n\t\t\t\t\t} else if (j > syllable.baseConsonant) {\n\t\t\t\t\t\t// Post-base consonant\n\t\t\t\t\t\tinfo.mask |=\n\t\t\t\t\t\t\tIndicFeatureMask.blwf |\n\t\t\t\t\t\t\tIndicFeatureMask.pstf |\n\t\t\t\t\t\t\tIndicFeatureMask.vatu;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reph handling\n\t\t\t\tif (syllable.hasReph && j < syllable.start + 2) {\n\t\t\t\t\tinfo.mask |= IndicFeatureMask.rphf;\n\t\t\t\t}\n\n\t\t\t\t// Matra handling\n\t\t\t\tif (cat === IndicCategory.M) {\n\t\t\t\t\tconst matraPos = getMatraPosition(info.codepoint);\n\t\t\t\t\tswitch (matraPos) {\n\t\t\t\t\t\tcase MatraPosition.PreBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.pref | IndicFeatureMask.pres;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MatraPosition.AboveBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.abvf | IndicFeatureMask.abvs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MatraPosition.BelowBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.blwf | IndicFeatureMask.blws;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MatraPosition.PostBase:\n\t\t\t\t\t\t\tinfo.mask |= IndicFeatureMask.pstf | IndicFeatureMask.psts;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Syllable modifiers (anusvara, visarga)\n\t\t\t\tif (cat === IndicCategory.SM) {\n\t\t\t\t\tinfo.mask |= IndicFeatureMask.abvs | IndicFeatureMask.psts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Reorder glyphs within a syllable for correct visual display\n * This handles:\n * - Moving pre-base matras before the base consonant\n * - Moving reph to its final position\n */\nexport function reorderIndic(infos: GlyphInfo[]): void {\n\tconst syllables = findSyllables(infos);\n\n\tfor (let i = 0; i < syllables.length; i++) {\n\t\tconst syllable = syllables[i]!;\n\t\treorderSyllable(infos, syllable);\n\t}\n}\n\n/**\n * Reorder a single syllable\n */\nfunction reorderSyllable(infos: GlyphInfo[], syllable: Syllable): void {\n\tconst { start, end, baseConsonant, hasReph } = syllable;\n\n\t// Collect pre-base matras that need to move\n\tconst preBaseMatras: { index: number; info: GlyphInfo }[] = [];\n\n\tfor (let i = baseConsonant + 1; i < end; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getIndicCategory(info.codepoint);\n\t\tif (cat === IndicCategory.M) {\n\t\t\tconst matraPos = getMatraPosition(info.codepoint);\n\t\t\tif (matraPos === MatraPosition.PreBase) {\n\t\t\t\tpreBaseMatras.push({ index: i, info });\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move pre-base matras before the base (or before reph if present)\n\tif (preBaseMatras.length > 0) {\n\t\t// Sort by original index descending to process from right to left\n\t\tpreBaseMatras.sort((a, b) => b.index - a.index);\n\n\t\tfor (let i = 0; i < preBaseMatras.length; i++) {\n\t\t\tconst { index, info } = preBaseMatras[i]!;\n\t\t\t// Remove from current position\n\t\t\tinfos.splice(index, 1);\n\n\t\t\t// Insert before base (accounting for reph)\n\t\t\tconst insertPos = hasReph ? start + 2 : start;\n\t\t\tinfos.splice(insertPos, 0, info);\n\t\t}\n\t}\n\n\t// Handle reph movement (Ra + Halant at start moves to end of syllable)\n\t// Note: In many scripts, reph moves to after the matra\n\t// This is a simplified implementation - full implementation would check\n\t// script-specific rules\n\tif (hasReph && end > start + 2) {\n\t\t// Reph is at positions start and start+1 (Ra + Halant)\n\t\t// Move to end of syllable, before final consonant markers\n\t\tconst rephRa = infos[start];\n\t\tconst rephH = infos[start + 1];\n\n\t\tif (rephRa && rephH) {\n\t\t\t// Find insertion point: after matras, before syllable modifiers\n\t\t\tlet rephTarget = end - 1;\n\n\t\t\t// Adjust for any syllable modifiers at the end\n\t\t\twhile (rephTarget > baseConsonant) {\n\t\t\t\tconst targetInfo = infos[rephTarget];\n\t\t\t\tif (!targetInfo) break;\n\n\t\t\t\tconst cat = getIndicCategory(targetInfo.codepoint);\n\t\t\t\tif (cat === IndicCategory.SM || cat === IndicCategory.A) {\n\t\t\t\t\trephTarget--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Only move if target is different from current position\n\t\t\tif (rephTarget > start + 1) {\n\t\t\t\t// Remove Ra + Halant from start\n\t\t\t\tinfos.splice(start, 2);\n\n\t\t\t\t// Insert at new position (adjusted for removal)\n\t\t\t\tconst adjustedTarget = rephTarget - 2;\n\t\t\t\tinfos.splice(adjustedTarget + 1, 0, rephRa, rephH);\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Khmer shaper\n * Handles Khmer script syllable structure and reordering\n */\n\n// Khmer Unicode range\nconst KHMER_START = 0x1780;\nconst KHMER_END = 0x17ff;\nconst KHMER_SYMBOLS_START = 0x19e0;\nconst KHMER_SYMBOLS_END = 0x19ff;\n\n/**\n * Khmer character categories\n */\nexport enum KhmerCategory {\n\tOther = 0,\n\tConsonant = 1,\n\tIndependentVowel = 2,\n\tDependentVowel = 3,\n\tCoeng = 4, // Subscript sign ()\n\tRegister = 5, // Register shifters\n\tRobat = 6, // Consonant shifter ()\n\tSign = 7,\n\tAnusvara = 8, // Nikahit ()\n\tVisarga = 9, // Reahmuk ()\n}\n\n/**\n * Get Khmer character category\n */\nexport function getKhmerCategory(cp: number): KhmerCategory {\n\tif (cp < KHMER_START || cp > KHMER_END) return KhmerCategory.Other;\n\n\t// Consonants (-)\n\tif (cp >= 0x1780 && cp <= 0x17a2) return KhmerCategory.Consonant;\n\tif (cp === 0x17a3 || cp === 0x17a4) return KhmerCategory.IndependentVowel;\n\n\t// Independent vowels (-)\n\tif (cp >= 0x17a5 && cp <= 0x17b3) return KhmerCategory.IndependentVowel;\n\n\t// Dependent vowels (-)\n\tif (cp >= 0x17b6 && cp <= 0x17c5) return KhmerCategory.DependentVowel;\n\n\t// Signs\n\tif (cp === 0x17c6) return KhmerCategory.Anusvara; // Nikahit\n\tif (cp === 0x17c7) return KhmerCategory.Visarga; // Reahmuk\n\tif (cp === 0x17c8) return KhmerCategory.Sign; // Yuukaleapintu\n\n\t// Register shifters\n\tif (cp === 0x17c9 || cp === 0x17ca) return KhmerCategory.Register;\n\n\t// Coeng (subscript marker)\n\tif (cp === 0x17d2) return KhmerCategory.Coeng;\n\n\t// Robat\n\tif (cp === 0x17cc) return KhmerCategory.Robat;\n\n\t// Other signs\n\tif (cp >= 0x17cb && cp <= 0x17d1) return KhmerCategory.Sign;\n\tif (cp >= 0x17d3 && cp <= 0x17dd) return KhmerCategory.Sign;\n\n\treturn KhmerCategory.Other;\n}\n\n/**\n * Khmer feature masks\n */\nexport const KhmerFeatureMask = {\n\tpref: 0x0001, // Pre-base forms\n\tblwf: 0x0002, // Below-base forms\n\tabvf: 0x0004, // Above-base forms\n\tpstf: 0x0008, // Post-base forms\n\tcfar: 0x0010, // Conjunct form after Ra\n\tpres: 0x0020, // Pre-base substitutions\n\tabvs: 0x0040, // Above-base substitutions\n\tblws: 0x0080, // Below-base substitutions\n\tpsts: 0x0100, // Post-base substitutions\n\tclig: 0x0200, // Contextual ligatures\n} as const;\n\n/**\n * Check if codepoint is Khmer\n */\nexport function isKhmer(cp: number): boolean {\n\treturn (\n\t\t(cp >= KHMER_START && cp <= KHMER_END) ||\n\t\t(cp >= KHMER_SYMBOLS_START && cp <= KHMER_SYMBOLS_END)\n\t);\n}\n\n/**\n * Setup Khmer masks for feature application\n */\nexport function setupKhmerMasks(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getKhmerCategory(info.codepoint);\n\n\t\tif (cat === KhmerCategory.Other) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find syllable extent\n\t\tconst _syllableStart = i;\n\t\tlet _base = -1;\n\n\t\t// Find base consonant\n\t\tif (cat === KhmerCategory.Consonant) {\n\t\t\t_base = i;\n\t\t}\n\n\t\t// Process syllable\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextCat = getKhmerCategory(nextInfo.codepoint);\n\n\t\t\tif (nextCat === KhmerCategory.Other) break;\n\t\t\tif (nextCat === KhmerCategory.Consonant) {\n\t\t\t\t// Check if followed by coeng\n\t\t\t\tconst prevInfo = infos[j - 1];\n\t\t\t\tif (\n\t\t\t\t\tprevInfo &&\n\t\t\t\t\tgetKhmerCategory(prevInfo.codepoint) !== KhmerCategory.Coeng\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Coeng + consonant = subscript consonant\n\t\t\tif (nextCat === KhmerCategory.Coeng && j + 1 < infos.length) {\n\t\t\t\tconst afterCoeng = infos[j + 1];\n\t\t\t\tif (\n\t\t\t\t\tafterCoeng &&\n\t\t\t\t\tgetKhmerCategory(afterCoeng.codepoint) === KhmerCategory.Consonant\n\t\t\t\t) {\n\t\t\t\t\t// Mark for below-base forms\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.blwf;\n\t\t\t\t\tafterCoeng.mask |= KhmerFeatureMask.blwf;\n\t\t\t\t\tj += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Dependent vowels\n\t\t\tif (nextCat === KhmerCategory.DependentVowel) {\n\t\t\t\t// Pre-base vowels:   \n\t\t\t\tif (nextInfo.codepoint >= 0x17c1 && nextInfo.codepoint <= 0x17c3) {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t// Above-base vowels\n\t\t\t\telse if (nextInfo.codepoint >= 0x17b7 && nextInfo.codepoint <= 0x17ba) {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.abvf;\n\t\t\t\t}\n\t\t\t\t// Below-base vowels\n\t\t\t\telse if (\n\t\t\t\t\tnextInfo.codepoint === 0x17bb ||\n\t\t\t\t\tnextInfo.codepoint === 0x17bc ||\n\t\t\t\t\tnextInfo.codepoint === 0x17bd\n\t\t\t\t) {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.blwf;\n\t\t\t\t}\n\t\t\t\t// Post-base vowels\n\t\t\t\telse {\n\t\t\t\t\tnextInfo.mask |= KhmerFeatureMask.pstf;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register shifters (above)\n\t\t\tif (nextCat === KhmerCategory.Register) {\n\t\t\t\tnextInfo.mask |= KhmerFeatureMask.abvs;\n\t\t\t}\n\n\t\t\t// Robat (above)\n\t\t\tif (nextCat === KhmerCategory.Robat) {\n\t\t\t\tnextInfo.mask |= KhmerFeatureMask.abvs;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\ti = j;\n\t}\n}\n\n/**\n * Reorder Khmer pre-base vowels\n * Pre-base vowels (  ) should visually appear before the base\n */\nexport function reorderKhmer(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getKhmerCategory(info.codepoint);\n\n\t\tif (cat !== KhmerCategory.Consonant) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Found base consonant, look for pre-base vowels after it\n\t\tconst base = i;\n\t\tlet j = i + 1;\n\n\t\t// Skip coeng sequences\n\t\twhile (j < infos.length) {\n\t\t\tconst jInfo = infos[j];\n\t\t\tif (!jInfo) break;\n\t\t\tconst jCat = getKhmerCategory(jInfo.codepoint);\n\t\t\tif (jCat === KhmerCategory.Coeng && j + 1 < infos.length) {\n\t\t\t\tj += 2; // Skip coeng + consonant\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Check for pre-base vowel\n\t\tif (j < infos.length) {\n\t\t\tconst jInfo = infos[j];\n\t\t\tif (jInfo) {\n\t\t\t\tconst cp = jInfo.codepoint;\n\t\t\t\tif (cp >= 0x17c1 && cp <= 0x17c3) {\n\t\t\t\t\t// Move pre-base vowel before base\n\t\t\t\t\tconst vowel = jInfo;\n\t\t\t\t\tfor (let k = j; k > base; k--) {\n\t\t\t\t\t\tconst prevInfo = infos[k - 1];\n\t\t\t\t\t\tif (prevInfo) {\n\t\t\t\t\t\t\tinfos[k] = prevInfo;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinfos[base] = vowel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = j + 1;\n\t}\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Myanmar shaper\n * Handles Myanmar script syllable structure and reordering\n */\n\n// Myanmar Unicode ranges\nconst MYANMAR_START = 0x1000;\nconst MYANMAR_END = 0x109f;\nconst MYANMAR_EXT_A_START = 0xaa60;\nconst MYANMAR_EXT_A_END = 0xaa7f;\nconst MYANMAR_EXT_B_START = 0xa9e0;\nconst MYANMAR_EXT_B_END = 0xa9ff;\n\n/**\n * Myanmar character categories\n */\nexport enum MyanmarCategory {\n\tOther = 0,\n\tConsonant = 1,\n\tIndependentVowel = 2,\n\tDependentVowel = 3,\n\tMedial = 4,\n\tAsat = 5, // Killer ()\n\tAnusvara = 6, // Dot below\n\tVisarga = 7, // Visarga\n\tSign = 8,\n\tNumber = 9,\n\tPlaceholder = 10, // Placeholder for visible virama\n}\n\n/**\n * Get Myanmar character category\n */\nexport function getMyanmarCategory(cp: number): MyanmarCategory {\n\t// Main Myanmar block\n\tif (cp >= MYANMAR_START && cp <= MYANMAR_END) {\n\t\t// Consonants (-)\n\t\tif (cp >= 0x1000 && cp <= 0x1021) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1023 && cp <= 0x1027) return MyanmarCategory.IndependentVowel;\n\t\tif (cp >= 0x1029 && cp <= 0x102a) return MyanmarCategory.IndependentVowel;\n\n\t\t// Dependent vowels\n\t\tif (cp >= 0x102b && cp <= 0x1035) return MyanmarCategory.DependentVowel;\n\n\t\t// Anusvara\n\t\tif (cp === 0x1036) return MyanmarCategory.Anusvara;\n\n\t\t// Dot below (asat indicator)\n\t\tif (cp === 0x1037) return MyanmarCategory.Sign;\n\n\t\t// Visarga\n\t\tif (cp === 0x1038) return MyanmarCategory.Visarga;\n\n\t\t// Asat (killer/virama)\n\t\tif (cp === 0x1039) return MyanmarCategory.Asat;\n\t\tif (cp === 0x103a) return MyanmarCategory.Asat;\n\n\t\t// Medials (   )\n\t\tif (cp >= 0x103b && cp <= 0x103e) return MyanmarCategory.Medial;\n\n\t\t// More consonants (, etc.)\n\t\tif (cp >= 0x103f && cp <= 0x1049) {\n\t\t\tif (cp === 0x103f) return MyanmarCategory.Consonant;\n\t\t\treturn MyanmarCategory.Number;\n\t\t}\n\n\t\t// Signs and digits\n\t\tif (cp >= 0x104a && cp <= 0x104f) return MyanmarCategory.Sign;\n\t\tif (cp >= 0x1050 && cp <= 0x1059) return MyanmarCategory.Consonant;\n\n\t\t// Extended consonants\n\t\tif (cp >= 0x105a && cp <= 0x105d) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1060 && cp <= 0x1061) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1062 && cp <= 0x1064) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0x1065 && cp <= 0x1066) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1067 && cp <= 0x106d) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0x106e && cp <= 0x1070) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1071 && cp <= 0x1074) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0x1075 && cp <= 0x1081) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0x1082 && cp <= 0x1082) return MyanmarCategory.Medial;\n\t\tif (cp >= 0x1083 && cp <= 0x108c) return MyanmarCategory.DependentVowel;\n\t\tif (cp === 0x108d) return MyanmarCategory.Sign;\n\t\tif (cp === 0x108e) return MyanmarCategory.Consonant;\n\t\tif (cp === 0x108f) return MyanmarCategory.Sign;\n\t\tif (cp >= 0x1090 && cp <= 0x1099) return MyanmarCategory.Number;\n\t}\n\n\t// Myanmar Extended-A\n\tif (cp >= MYANMAR_EXT_A_START && cp <= MYANMAR_EXT_A_END) {\n\t\tif (cp >= 0xaa60 && cp <= 0xaa76) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0xaa77 && cp <= 0xaa79) return MyanmarCategory.Sign;\n\t\tif (cp === 0xaa7a) return MyanmarCategory.Consonant;\n\t\tif (cp === 0xaa7b) return MyanmarCategory.Sign;\n\t\tif (cp === 0xaa7c) return MyanmarCategory.Sign;\n\t\tif (cp === 0xaa7d) return MyanmarCategory.Sign;\n\t\tif (cp >= 0xaa7e && cp <= 0xaa7f) return MyanmarCategory.Consonant;\n\t}\n\n\t// Myanmar Extended-B\n\tif (cp >= MYANMAR_EXT_B_START && cp <= MYANMAR_EXT_B_END) {\n\t\tif (cp >= 0xa9e0 && cp <= 0xa9e4) return MyanmarCategory.Consonant;\n\t\tif (cp === 0xa9e5) return MyanmarCategory.DependentVowel;\n\t\tif (cp >= 0xa9e6 && cp <= 0xa9ef) return MyanmarCategory.Consonant;\n\t\tif (cp >= 0xa9f0 && cp <= 0xa9f9) return MyanmarCategory.Number;\n\t\tif (cp >= 0xa9fa && cp <= 0xa9fe) return MyanmarCategory.Consonant;\n\t}\n\n\treturn MyanmarCategory.Other;\n}\n\n/**\n * Myanmar feature masks\n */\nexport const MyanmarFeatureMask = {\n\trphf: 0x0001, // Reph forms\n\tpref: 0x0002, // Pre-base forms\n\tblwf: 0x0004, // Below-base forms\n\tpstf: 0x0008, // Post-base forms\n\tpres: 0x0010, // Pre-base substitutions\n\tabvs: 0x0020, // Above-base substitutions\n\tblws: 0x0040, // Below-base substitutions\n\tpsts: 0x0080, // Post-base substitutions\n} as const;\n\n/**\n * Check if codepoint is Myanmar\n */\nexport function isMyanmar(cp: number): boolean {\n\treturn (\n\t\t(cp >= MYANMAR_START && cp <= MYANMAR_END) ||\n\t\t(cp >= MYANMAR_EXT_A_START && cp <= MYANMAR_EXT_A_END) ||\n\t\t(cp >= MYANMAR_EXT_B_START && cp <= MYANMAR_EXT_B_END)\n\t);\n}\n\n/**\n * Setup Myanmar masks for feature application\n */\nexport function setupMyanmarMasks(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getMyanmarCategory(info.codepoint);\n\n\t\tif (cat === MyanmarCategory.Other) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find syllable extent\n\t\tlet _base = -1;\n\t\tlet hasAsat = false;\n\n\t\tif (cat === MyanmarCategory.Consonant) {\n\t\t\t_base = i;\n\t\t}\n\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextCat = getMyanmarCategory(nextInfo.codepoint);\n\n\t\t\tif (nextCat === MyanmarCategory.Other) break;\n\n\t\t\t// Asat (killer) marks a stacked consonant\n\t\t\tif (nextCat === MyanmarCategory.Asat) {\n\t\t\t\thasAsat = true;\n\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blwf;\n\n\t\t\t\t// Check for following consonant (stacking)\n\t\t\t\tif (j + 1 < infos.length) {\n\t\t\t\t\tconst afterAsat = infos[j + 1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tafterAsat &&\n\t\t\t\t\t\tgetMyanmarCategory(afterAsat.codepoint) ===\n\t\t\t\t\t\t\tMyanmarCategory.Consonant\n\t\t\t\t\t) {\n\t\t\t\t\t\tafterAsat.mask |= MyanmarFeatureMask.blwf;\n\t\t\t\t\t\tj += 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Medials\n\t\t\tif (nextCat === MyanmarCategory.Medial) {\n\t\t\t\tconst cp = nextInfo.codepoint;\n\t\t\t\t//  (ya) - pre-base\n\t\t\t\tif (cp === 0x103b) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t//  (ra) - pre-base\n\t\t\t\telse if (cp === 0x103c) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t//  (wa) - below-base\n\t\t\t\telse if (cp === 0x103d) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blwf;\n\t\t\t\t}\n\t\t\t\t//  (ha) - below-base\n\t\t\t\telse if (cp === 0x103e) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blwf;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Dependent vowels\n\t\t\tif (nextCat === MyanmarCategory.DependentVowel) {\n\t\t\t\tconst cp = nextInfo.codepoint;\n\t\t\t\t// Pre-base vowels: \n\t\t\t\tif (cp === 0x1031) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.pref;\n\t\t\t\t}\n\t\t\t\t// Above-base vowels\n\t\t\t\telse if (cp === 0x102d || cp === 0x102e || cp === 0x1032) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.abvs;\n\t\t\t\t}\n\t\t\t\t// Below-base vowels\n\t\t\t\telse if (cp === 0x102f || cp === 0x1030) {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.blws;\n\t\t\t\t}\n\t\t\t\t// Post-base vowels\n\t\t\t\telse {\n\t\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.psts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Signs above\n\t\t\tif (\n\t\t\t\tnextCat === MyanmarCategory.Anusvara ||\n\t\t\t\tnextCat === MyanmarCategory.Sign\n\t\t\t) {\n\t\t\t\tnextInfo.mask |= MyanmarFeatureMask.abvs;\n\t\t\t}\n\n\t\t\t// New syllable on consonant without asat\n\t\t\tif (nextCat === MyanmarCategory.Consonant && !hasAsat) {\n\t\t\t\t// Check if previous was asat\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tconst prevInfo = infos[j - 1];\n\t\t\t\t\tif (prevInfo) {\n\t\t\t\t\t\tconst prevCat = getMyanmarCategory(prevInfo.codepoint);\n\t\t\t\t\t\tif (prevCat !== MyanmarCategory.Asat) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thasAsat = false;\n\t\t\tj++;\n\t\t}\n\n\t\ti = j;\n\t}\n}\n\n/**\n * Reorder Myanmar pre-base vowels and medials\n *  and  should visually appear before the base consonant\n */\nexport function reorderMyanmar(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getMyanmarCategory(info.codepoint);\n\n\t\tif (cat !== MyanmarCategory.Consonant) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Found base consonant\n\t\tconst base = i;\n\t\tconst preBase: GlyphInfo[] = [];\n\n\t\t// Collect pre-base elements that follow base\n\t\tlet j = i + 1;\n\t\twhile (j < infos.length) {\n\t\t\tconst jInfo = infos[j];\n\t\t\tif (!jInfo) {\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst jCat = getMyanmarCategory(jInfo.codepoint);\n\n\t\t\t// Pre-base vowel ()\n\t\t\tif (jInfo.codepoint === 0x1031) {\n\t\t\t\tpreBase.push(jInfo);\n\t\t\t\tinfos.splice(j, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Pre-base medial ( ra)\n\t\t\tif (jInfo.codepoint === 0x103c) {\n\t\t\t\tpreBase.push(jInfo);\n\t\t\t\tinfos.splice(j, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Stop at next syllable\n\t\t\tif (\n\t\t\t\tjCat === MyanmarCategory.Consonant ||\n\t\t\t\tjCat === MyanmarCategory.Other\n\t\t\t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\t// Insert pre-base elements before base\n\t\tif (preBase.length > 0) {\n\t\t\tinfos.splice(base, 0, ...preBase);\n\t\t\ti += preBase.length;\n\t\t}\n\n\t\ti++;\n\t}\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Thai/Lao character categories\n */\nexport enum ThaiLaoCategory {\n\tOther = 0,\n\tConsonant = 1,\n\tLeadingVowel = 2, // Vowels that appear before consonant\n\tAboveVowel = 3, // Vowels above consonant\n\tBelowVowel = 4, // Vowels below consonant\n\tFollowingVowel = 5, // Vowels after consonant\n\tTone = 6, // Tone marks\n\tNikhahitMaiEk = 7, // Special combining marks\n\tSaraAm = 8, // Thai Sara Am (combines anusvara + aa)\n\tSymbol = 9,\n}\n\n/**\n * Check if codepoint is Thai\n */\nexport function isThai(cp: number): boolean {\n\treturn cp >= 0x0e00 && cp <= 0x0e7f;\n}\n\n/**\n * Check if codepoint is Lao\n */\nexport function isLao(cp: number): boolean {\n\treturn cp >= 0x0e80 && cp <= 0x0eff;\n}\n\n/**\n * Get Thai/Lao category for a codepoint\n */\nexport function getThaiLaoCategory(cp: number): ThaiLaoCategory {\n\t// Thai (0E00-0E7F)\n\tif (isThai(cp)) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e01 && cp <= 0x0e2e) return ThaiLaoCategory.Consonant;\n\t\t// Additional consonants\n\t\tif (cp === 0x0e2f) return ThaiLaoCategory.Consonant; // Paiyannoi\n\n\t\t// Leading vowels (displayed before consonant)\n\t\tif (cp >= 0x0e40 && cp <= 0x0e44) return ThaiLaoCategory.LeadingVowel;\n\n\t\t// Above vowels\n\t\tif (cp === 0x0e31) return ThaiLaoCategory.AboveVowel; // Mai Han-Akat\n\t\tif (cp >= 0x0e34 && cp <= 0x0e37) return ThaiLaoCategory.AboveVowel;\n\t\tif (cp === 0x0e47) return ThaiLaoCategory.AboveVowel; // Maitaikhu\n\n\t\t// Below vowels\n\t\tif (cp >= 0x0e38 && cp <= 0x0e3a) return ThaiLaoCategory.BelowVowel;\n\n\t\t// Following vowels\n\t\tif (cp === 0x0e30) return ThaiLaoCategory.FollowingVowel; // Sara A\n\t\tif (cp === 0x0e32 || cp === 0x0e33) return ThaiLaoCategory.FollowingVowel; // Sara Aa, Sara Am\n\t\tif (cp === 0x0e45) return ThaiLaoCategory.FollowingVowel; // Lakkhangyao\n\n\t\t// Sara Am (special - decomposes to nikhahit + sara aa)\n\t\tif (cp === 0x0e33) return ThaiLaoCategory.SaraAm;\n\n\t\t// Tone marks\n\t\tif (cp >= 0x0e48 && cp <= 0x0e4b) return ThaiLaoCategory.Tone;\n\n\t\t// Thanthakhat (cancellation mark)\n\t\tif (cp === 0x0e4c) return ThaiLaoCategory.Tone;\n\n\t\t// Nikhahit (anusvara)\n\t\tif (cp === 0x0e4d) return ThaiLaoCategory.NikhahitMaiEk;\n\n\t\t// Yamakkan\n\t\tif (cp === 0x0e4e) return ThaiLaoCategory.NikhahitMaiEk;\n\n\t\t// Digits and symbols\n\t\tif (cp >= 0x0e50 && cp <= 0x0e5b) return ThaiLaoCategory.Symbol;\n\n\t\treturn ThaiLaoCategory.Other;\n\t}\n\n\t// Lao (0E80-0EFF)\n\tif (isLao(cp)) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e81 && cp <= 0x0eae) return ThaiLaoCategory.Consonant;\n\n\t\t// Leading vowels\n\t\tif (cp >= 0x0ec0 && cp <= 0x0ec4) return ThaiLaoCategory.LeadingVowel;\n\n\t\t// Above vowels\n\t\tif (cp === 0x0eb1) return ThaiLaoCategory.AboveVowel;\n\t\tif (cp >= 0x0eb4 && cp <= 0x0eb7) return ThaiLaoCategory.AboveVowel;\n\t\tif (cp === 0x0ebb) return ThaiLaoCategory.AboveVowel;\n\n\t\t// Below vowels\n\t\tif (cp >= 0x0eb8 && cp <= 0x0eb9) return ThaiLaoCategory.BelowVowel;\n\t\tif (cp === 0x0ebc) return ThaiLaoCategory.BelowVowel;\n\n\t\t// Following vowels\n\t\tif (cp === 0x0eb0) return ThaiLaoCategory.FollowingVowel;\n\t\tif (cp === 0x0eb2 || cp === 0x0eb3) return ThaiLaoCategory.FollowingVowel;\n\n\t\t// Tone marks\n\t\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return ThaiLaoCategory.Tone;\n\n\t\t// Digits\n\t\tif (cp >= 0x0ed0 && cp <= 0x0ed9) return ThaiLaoCategory.Symbol;\n\n\t\treturn ThaiLaoCategory.Other;\n\t}\n\n\treturn ThaiLaoCategory.Other;\n}\n\n/**\n * Set up masks for Thai/Lao shaping\n *\n * Thai/Lao require:\n * 1. Reordering of pre-base vowels (they appear before consonant visually but after in Unicode)\n * 2. Proper stacking of above/below vowels and tone marks\n */\nexport function setupThaiLaoMasks(infos: GlyphInfo[]): void {\n\t// Group characters into syllable-like clusters\n\t// Each cluster starts with a consonant\n\n\tlet clusterIndex = 0;\n\tlet _consonantIndex = -1;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getThaiLaoCategory(info.codepoint);\n\n\t\t// Consonants start new clusters\n\t\tif (cat === ThaiLaoCategory.Consonant) {\n\t\t\tclusterIndex++;\n\t\t\t_consonantIndex = i;\n\t\t}\n\n\t\t// Store cluster info in mask\n\t\t// Upper bits: cluster index\n\t\t// Lower bits: category for reordering\n\t\tinfo.mask = (info.mask & 0xffffff00) | (cat & 0xff);\n\t\tinfo.mask = (info.mask & 0x0000ffff) | ((clusterIndex & 0xffff) << 16);\n\n\t\t// Mark leading vowels for reordering\n\t\tif (cat === ThaiLaoCategory.LeadingVowel) {\n\t\t\t// These need to be moved before the consonant during shaping\n\t\t\t// The GSUB pref feature handles this\n\t\t\tinfo.mask |= 0x100; // Mark for pre-base processing\n\t\t}\n\t}\n}\n\n/**\n * Reorder Thai/Lao clusters\n * Leading vowels (Sara E, Sara Ae, Sara O, Sara Ai Mai Muan, Sara Ai Mai Malai)\n * are stored after consonant in Unicode but displayed before\n */\nexport function reorderThaiLao(infos: GlyphInfo[]): void {\n\tlet i = 0;\n\twhile (i < infos.length) {\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst cat = getThaiLaoCategory(info.codepoint);\n\n\t\t// If we find a leading vowel, move it before its consonant\n\t\tif (cat === ThaiLaoCategory.LeadingVowel) {\n\t\t\t// Find the following consonant\n\t\t\tlet j = i + 1;\n\t\t\twhile (j < infos.length) {\n\t\t\t\tconst nextInfo = infos[j];\n\t\t\t\tif (!nextInfo) {\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst nextCat = getThaiLaoCategory(nextInfo.codepoint ?? 0);\n\t\t\t\tif (nextCat === ThaiLaoCategory.Consonant) {\n\t\t\t\t\t// Swap vowel and consonant\n\t\t\t\t\tconst temp = info;\n\t\t\t\t\tinfos[i] = nextInfo;\n\t\t\t\t\tinfos[j] = temp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nextCat !== ThaiLaoCategory.LeadingVowel) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n}\n",
    "import type { GlyphInfo } from \"../../types.ts\";\n\n/**\n * Universal Shaping Engine (USE) categories\n * Based on Unicode USE specification\n */\nexport enum UseCategory {\n\tO = 0, // Other\n\tB = 1, // Base\n\tCGJ = 2, // Combining Grapheme Joiner\n\tCM = 3, // Consonant modifier\n\tCS = 4, // Consonant with stacker\n\tF = 5, // Final\n\tFM = 6, // Final modifier\n\tGB = 7, // Generic base\n\tH = 8, // Halant/Virama\n\tHN = 9, // Halant or Nukta\n\tIND = 10, // Independent\n\tJ = 11, // Joiner\n\tN = 12, // Nukta\n\tR = 13, // Repha\n\tS = 14, // Symbol\n\tSB = 15, // Symbol modifier\n\tSE = 16, // Syllable ending\n\tSUB = 17, // Subjoined\n\tVS = 18, // Variation selector\n\tWJ = 19, // Word joiner\n\tZWJ = 20, // Zero Width Joiner\n\tZWNJ = 21, // Zero Width Non-Joiner\n\tV = 22, // Vowel (independent)\n\tVD = 23, // Vowel dependent\n\tVMAbv = 24, // Vowel modifier above\n\tVMBlw = 25, // Vowel modifier below\n\tVMPre = 26, // Vowel modifier pre\n\tVMPst = 27, // Vowel modifier post\n\tVAbv = 28, // Vowel above\n\tVBlw = 29, // Vowel below\n\tVPre = 30, // Vowel pre\n\tVPst = 31, // Vowel post\n\tSMAbv = 32, // Syllable modifier above\n\tSMBlw = 33, // Syllable modifier below\n\tFAbv = 34, // Final above\n\tFBlw = 35, // Final below\n\tFPst = 36, // Final post\n\tMAbv = 37, // Medial above\n\tMBlw = 38, // Medial below\n\tMPre = 39, // Medial pre\n\tMPst = 40, // Medial post\n}\n\n/**\n * Check if a script uses USE\n */\nexport function usesUSE(script: string): boolean {\n\t// Scripts that use Universal Shaping Engine\n\tconst useScripts = [\n\t\t\"bali\", // Balinese\n\t\t\"batk\", // Batak\n\t\t\"brah\", // Brahmi\n\t\t\"bugi\", // Buginese\n\t\t\"buhd\", // Buhid\n\t\t\"cakm\", // Chakma\n\t\t\"cham\", // Cham\n\t\t\"dupl\", // Duployan\n\t\t\"egyp\", // Egyptian Hieroglyphs\n\t\t\"gran\", // Grantha\n\t\t\"hano\", // Hanunoo\n\t\t\"java\", // Javanese\n\t\t\"kthi\", // Kaithi\n\t\t\"khar\", // Kharoshthi\n\t\t\"khmr\", // Khmer\n\t\t\"khoj\", // Khojki\n\t\t\"lana\", // Tai Tham\n\t\t\"lepc\", // Lepcha\n\t\t\"limb\", // Limbu\n\t\t\"mahj\", // Mahajani\n\t\t\"modi\", // Modi\n\t\t\"mtei\", // Meetei Mayek\n\t\t\"mymr\", // Myanmar\n\t\t\"newa\", // Newa\n\t\t\"phlp\", // Psalter Pahlavi\n\t\t\"rjng\", // Rejang\n\t\t\"saur\", // Saurashtra\n\t\t\"shrd\", // Sharada\n\t\t\"sidd\", // Siddham\n\t\t\"sind\", // Sindhi (Khudawadi)\n\t\t\"sinh\", // Sinhala\n\t\t\"sund\", // Sundanese\n\t\t\"sylo\", // Syloti Nagri\n\t\t\"tagb\", // Tagbanwa\n\t\t\"takr\", // Takri\n\t\t\"tale\", // Tai Le\n\t\t\"talu\", // New Tai Lue\n\t\t\"tavt\", // Tai Viet\n\t\t\"tibt\", // Tibetan\n\t\t\"tirh\", // Tirhuta\n\t];\n\treturn useScripts.includes(script);\n}\n\n/**\n * Get USE category for a codepoint\n */\nexport function getUseCategory(cp: number): UseCategory {\n\t// Zero-width characters\n\tif (cp === 0x200c) return UseCategory.ZWNJ;\n\tif (cp === 0x200d) return UseCategory.ZWJ;\n\tif (cp === 0x034f) return UseCategory.CGJ; // Combining Grapheme Joiner\n\tif (cp === 0x2060) return UseCategory.WJ; // Word Joiner\n\tif (cp >= 0xfe00 && cp <= 0xfe0f) return UseCategory.VS; // Variation Selectors\n\tif (cp >= 0xe0100 && cp <= 0xe01ef) return UseCategory.VS; // VS 17-256\n\n\t// Myanmar (1000-109F)\n\tif (cp >= 0x1000 && cp <= 0x109f) {\n\t\t// Consonants\n\t\tif (cp >= 0x1000 && cp <= 0x1020) return UseCategory.B;\n\t\t// Independent vowels\n\t\tif (cp >= 0x1021 && cp <= 0x102a) return UseCategory.IND;\n\t\t// Dependent vowels\n\t\tif (cp >= 0x102b && cp <= 0x1032) return UseCategory.VPst;\n\t\t// Anusvara etc\n\t\tif (cp >= 0x1036 && cp <= 0x1037) return UseCategory.SMAbv;\n\t\t// Virama\n\t\tif (cp === 0x1039) return UseCategory.H;\n\t\t// Asat (visible virama)\n\t\tif (cp === 0x103a) return UseCategory.H;\n\t\t// Medial consonants\n\t\tif (cp >= 0x103b && cp <= 0x103e) return UseCategory.MBlw;\n\t\t// Digits\n\t\tif (cp >= 0x1040 && cp <= 0x1049) return UseCategory.GB;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Khmer (1780-17FF)\n\tif (cp >= 0x1780 && cp <= 0x17ff) {\n\t\t// Consonants\n\t\tif (cp >= 0x1780 && cp <= 0x17a2) return UseCategory.B;\n\t\t// Independent vowels\n\t\tif (cp >= 0x17a3 && cp <= 0x17b3) return UseCategory.IND;\n\t\t// Dependent vowels\n\t\tif (cp >= 0x17b6 && cp <= 0x17c5) return UseCategory.VPst;\n\t\t// Coeng (stacking virama)\n\t\tif (cp === 0x17d2) return UseCategory.H;\n\t\t// Anusvara, Visarga\n\t\tif (cp >= 0x17c6 && cp <= 0x17c8) return UseCategory.SMAbv;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Tibetan (0F00-0FFF)\n\tif (cp >= 0x0f00 && cp <= 0x0fff) {\n\t\t// Syllable markers\n\t\tif (cp >= 0x0f00 && cp <= 0x0f17) return UseCategory.S;\n\t\t// Vowel signs\n\t\tif (cp >= 0x0f71 && cp <= 0x0f7d) return UseCategory.VAbv;\n\t\t// Subjoined consonants\n\t\tif (cp >= 0x0f90 && cp <= 0x0fbc) return UseCategory.SUB;\n\t\t// Base consonants\n\t\tif (cp >= 0x0f40 && cp <= 0x0f6c) return UseCategory.B;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Thai (0E00-0E7F)\n\tif (cp >= 0x0e00 && cp <= 0x0e7f) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e01 && cp <= 0x0e2e) return UseCategory.B;\n\t\t// Vowels\n\t\tif (cp >= 0x0e30 && cp <= 0x0e3a) return UseCategory.VPst;\n\t\tif (cp >= 0x0e40 && cp <= 0x0e44) return UseCategory.VPre;\n\t\t// Tone marks\n\t\tif (cp >= 0x0e48 && cp <= 0x0e4b) return UseCategory.SMAbv;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Lao (0E80-0EFF)\n\tif (cp >= 0x0e80 && cp <= 0x0eff) {\n\t\t// Consonants\n\t\tif (cp >= 0x0e81 && cp <= 0x0ea3) return UseCategory.B;\n\t\t// Vowels\n\t\tif (cp >= 0x0eb0 && cp <= 0x0ebc) return UseCategory.VPst;\n\t\tif (cp >= 0x0ec0 && cp <= 0x0ec4) return UseCategory.VPre;\n\t\t// Tone marks\n\t\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return UseCategory.SMAbv;\n\t\treturn UseCategory.O;\n\t}\n\n\t// Test mappings for categories not yet in real scripts\n\t// Using private use area for testing\n\tif (cp >= 0xe000 && cp <= 0xe0ff) {\n\t\tif (cp === 0xe000) return UseCategory.R; // Repha test\n\t\tif (cp === 0xe001) return UseCategory.VMAbv;\n\t\tif (cp === 0xe002) return UseCategory.VMBlw;\n\t\tif (cp === 0xe003) return UseCategory.VMPre;\n\t\tif (cp === 0xe004) return UseCategory.VMPst;\n\t\tif (cp === 0xe005) return UseCategory.CS;\n\t\tif (cp === 0xe006) return UseCategory.N;\n\t\tif (cp === 0xe007) return UseCategory.HN;\n\t\tif (cp === 0xe008) return UseCategory.VD;\n\t\tif (cp === 0xe009) return UseCategory.VBlw;\n\t\tif (cp === 0xe00a) return UseCategory.MAbv;\n\t\tif (cp === 0xe00b) return UseCategory.MPre;\n\t\tif (cp === 0xe00c) return UseCategory.MPst;\n\t\tif (cp === 0xe00d) return UseCategory.SMBlw;\n\t\tif (cp === 0xe00e) return UseCategory.FAbv;\n\t\tif (cp === 0xe00f) return UseCategory.FBlw;\n\t\tif (cp === 0xe010) return UseCategory.FPst;\n\t\tif (cp === 0xe011) return UseCategory.F;\n\t\tif (cp === 0xe012) return UseCategory.FM;\n\t}\n\n\treturn UseCategory.O;\n}\n\n/** USE feature masks */\nexport const UseFeatureMask = {\n\trphf: 0x0001, // Reph forms\n\tpref: 0x0002, // Pre-base forms\n\tblwf: 0x0004, // Below-base forms\n\tabvf: 0x0008, // Above-base forms\n\tpstf: 0x0010, // Post-base forms\n\thalf: 0x0020, // Half forms\n\tcjct: 0x0040, // Conjunct forms\n\tvatu: 0x0080, // Vattu variants\n\tpres: 0x0100, // Pre-base substitutions\n\tabvs: 0x0200, // Above-base substitutions\n\tblws: 0x0400, // Below-base substitutions\n\tpsts: 0x0800, // Post-base substitutions\n\thaln: 0x1000, // Halant forms\n} as const;\n\n/**\n * USE syllable structure\n */\ninterface UseSyllable {\n\tstart: number;\n\tend: number;\n\tbase: number;\n\thasReph: boolean;\n}\n\n/**\n * Find syllable boundaries in USE text\n */\nfunction findUseSyllables(infos: GlyphInfo[]): UseSyllable[] {\n\tconst syllables: UseSyllable[] = [];\n\tconst n = infos.length;\n\tif (n === 0) return syllables;\n\n\tlet start = 0;\n\n\twhile (start < n) {\n\t\tconst syllable = parseUseSyllable(infos, start);\n\t\tsyllables.push(syllable);\n\t\tstart = syllable.end;\n\t}\n\n\treturn syllables;\n}\n\n/**\n * Parse a single USE syllable\n */\nfunction parseUseSyllable(infos: GlyphInfo[], start: number): UseSyllable {\n\tconst n = infos.length;\n\tlet pos = start;\n\tlet base = -1;\n\tlet hasReph = false;\n\n\t// Check for Repha (R + H at start)\n\tif (pos + 1 < n) {\n\t\tconst info1 = infos[pos];\n\t\tconst info2 = infos[pos + 1];\n\t\tif (info1 && info2) {\n\t\t\tconst cat1 = getUseCategory(info1.codepoint ?? 0);\n\t\t\tconst cat2 = getUseCategory(info2.codepoint ?? 0);\n\t\t\tif (cat1 === UseCategory.R && cat2 === UseCategory.H) {\n\t\t\t\thasReph = true;\n\t\t\t\tpos += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find base character\n\twhile (pos < n) {\n\t\tconst info = infos[pos];\n\t\tif (!info) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getUseCategory(info.codepoint ?? 0);\n\n\t\t// Base characters\n\t\tif (\n\t\t\tcat === UseCategory.B ||\n\t\t\tcat === UseCategory.IND ||\n\t\t\tcat === UseCategory.GB ||\n\t\t\tcat === UseCategory.V\n\t\t) {\n\t\t\tbase = pos;\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Non-base starters - continue looking\n\t\tif (\n\t\t\tcat === UseCategory.VMPre ||\n\t\t\tcat === UseCategory.VPre ||\n\t\t\tcat === UseCategory.MPre\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// End of valid cluster start\n\t\tif (base === -1) {\n\t\t\tpos++;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (base === -1) base = start;\n\n\t// Consume consonant cluster\n\twhile (pos < n) {\n\t\tconst posInfo = infos[pos];\n\t\tif (!posInfo) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getUseCategory(posInfo.codepoint ?? 0);\n\n\t\t// Halant + Consonant continues cluster\n\t\tif (cat === UseCategory.H) {\n\t\t\tpos++;\n\t\t\tif (pos < n) {\n\t\t\t\tconst nextInfo = infos[pos];\n\t\t\t\tif (nextInfo) {\n\t\t\t\t\tconst nextCat = getUseCategory(nextInfo.codepoint ?? 0);\n\t\t\t\t\tif (\n\t\t\t\t\t\tnextCat === UseCategory.B ||\n\t\t\t\t\t\tnextCat === UseCategory.CS ||\n\t\t\t\t\t\tnextCat === UseCategory.SUB\n\t\t\t\t\t) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// ZWJ/ZWNJ after halant\n\t\t\t\t\tif (nextCat === UseCategory.ZWJ || nextCat === UseCategory.ZWNJ) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Subjoined consonants\n\t\tif (cat === UseCategory.SUB || cat === UseCategory.CS) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Nukta\n\t\tif (cat === UseCategory.N || cat === UseCategory.HN) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t// Consume matras and modifiers\n\twhile (pos < n) {\n\t\tconst posInfo = infos[pos];\n\t\tif (!posInfo) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst cat = getUseCategory(posInfo.codepoint ?? 0);\n\n\t\t// Vowel signs\n\t\tif (\n\t\t\tcat === UseCategory.VAbv ||\n\t\t\tcat === UseCategory.VBlw ||\n\t\t\tcat === UseCategory.VPre ||\n\t\t\tcat === UseCategory.VPst ||\n\t\t\tcat === UseCategory.VD\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Medials\n\t\tif (\n\t\t\tcat === UseCategory.MAbv ||\n\t\t\tcat === UseCategory.MBlw ||\n\t\t\tcat === UseCategory.MPre ||\n\t\t\tcat === UseCategory.MPst\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Vowel modifiers\n\t\tif (\n\t\t\tcat === UseCategory.VMAbv ||\n\t\t\tcat === UseCategory.VMBlw ||\n\t\t\tcat === UseCategory.VMPre ||\n\t\t\tcat === UseCategory.VMPst\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Syllable modifiers\n\t\tif (cat === UseCategory.SMAbv || cat === UseCategory.SMBlw) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Finals\n\t\tif (\n\t\t\tcat === UseCategory.FAbv ||\n\t\t\tcat === UseCategory.FBlw ||\n\t\t\tcat === UseCategory.FPst ||\n\t\t\tcat === UseCategory.F ||\n\t\t\tcat === UseCategory.FM\n\t\t) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// CGJ, VS\n\t\tif (cat === UseCategory.CGJ || cat === UseCategory.VS) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t// Ensure we advance at least one position\n\tif (pos === start) {\n\t\tpos = start + 1;\n\t}\n\n\treturn { start, end: pos, base, hasReph };\n}\n\n/**\n * Set up masks for USE shaping\n */\nexport function setupUseMasks(infos: GlyphInfo[]): void {\n\tconst syllables = findUseSyllables(infos);\n\n\tfor (let i = 0; i < syllables.length; i++) {\n\t\tconst syllable = syllables[i]!;\n\t\tfor (let j = syllable.start; j < syllable.end; j++) {\n\t\t\tconst info = infos[j];\n\t\t\tif (!info) continue;\n\n\t\t\t// Store syllable index in upper mask bits\n\t\t\tinfo.mask = (info.mask & 0x0000ffff) | ((i & 0xffff) << 16);\n\n\t\t\tconst cat = getUseCategory(info.codepoint);\n\n\t\t\t// Reph handling\n\t\t\tif (syllable.hasReph && j < syllable.start + 2) {\n\t\t\t\tinfo.mask |= UseFeatureMask.rphf;\n\t\t\t}\n\n\t\t\t// Pre-base handling\n\t\t\tif (j < syllable.base) {\n\t\t\t\tif (\n\t\t\t\t\tcat === UseCategory.B ||\n\t\t\t\t\tcat === UseCategory.CS ||\n\t\t\t\t\tcat === UseCategory.SUB\n\t\t\t\t) {\n\t\t\t\t\tinfo.mask |= UseFeatureMask.half | UseFeatureMask.cjct;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Post-base handling\n\t\t\tif (j > syllable.base) {\n\t\t\t\tif (\n\t\t\t\t\tcat === UseCategory.B ||\n\t\t\t\t\tcat === UseCategory.CS ||\n\t\t\t\t\tcat === UseCategory.SUB\n\t\t\t\t) {\n\t\t\t\t\tinfo.mask |=\n\t\t\t\t\t\tUseFeatureMask.blwf | UseFeatureMask.pstf | UseFeatureMask.vatu;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Halant\n\t\t\tif (cat === UseCategory.H || cat === UseCategory.HN) {\n\t\t\t\tif (j < syllable.base) {\n\t\t\t\t\tinfo.mask |= UseFeatureMask.half;\n\t\t\t\t} else {\n\t\t\t\t\tinfo.mask |= UseFeatureMask.haln;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Vowel signs\n\t\t\tif (cat === UseCategory.VPre) {\n\t\t\t\tinfo.mask |= UseFeatureMask.pref | UseFeatureMask.pres;\n\t\t\t} else if (cat === UseCategory.VAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvf | UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.VBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blwf | UseFeatureMask.blws;\n\t\t\t} else if (cat === UseCategory.VPst || cat === UseCategory.VD) {\n\t\t\t\tinfo.mask |= UseFeatureMask.pstf | UseFeatureMask.psts;\n\t\t\t}\n\n\t\t\t// Medials\n\t\t\tif (cat === UseCategory.MAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.MBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blws;\n\t\t\t} else if (cat === UseCategory.MPre) {\n\t\t\t\tinfo.mask |= UseFeatureMask.pres;\n\t\t\t} else if (cat === UseCategory.MPst) {\n\t\t\t\tinfo.mask |= UseFeatureMask.psts;\n\t\t\t}\n\n\t\t\t// Syllable modifiers\n\t\t\tif (cat === UseCategory.SMAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.SMBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blws;\n\t\t\t}\n\n\t\t\t// Finals\n\t\t\tif (cat === UseCategory.FAbv) {\n\t\t\t\tinfo.mask |= UseFeatureMask.abvs;\n\t\t\t} else if (cat === UseCategory.FBlw) {\n\t\t\t\tinfo.mask |= UseFeatureMask.blws;\n\t\t\t} else if (\n\t\t\t\tcat === UseCategory.FPst ||\n\t\t\t\tcat === UseCategory.F ||\n\t\t\t\tcat === UseCategory.FM\n\t\t\t) {\n\t\t\t\tinfo.mask |= UseFeatureMask.psts;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Reorder USE syllables (pre-base vowels, reph)\n */\nexport function reorderUSE(infos: GlyphInfo[]): void {\n\tconst syllables = findUseSyllables(infos);\n\n\tfor (let i = 0; i < syllables.length; i++) {\n\t\tconst syllable = syllables[i]!;\n\t\treorderUseSyllable(infos, syllable);\n\t}\n}\n\n/**\n * Reorder a single USE syllable\n */\nfunction reorderUseSyllable(infos: GlyphInfo[], syllable: UseSyllable): void {\n\tconst { start, end, base, hasReph } = syllable;\n\n\t// Collect pre-base vowels that need to move\n\tconst preBaseVowels: { index: number; info: GlyphInfo }[] = [];\n\n\tfor (let i = base + 1; i < end; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cat = getUseCategory(info.codepoint);\n\t\tif (cat === UseCategory.VPre || cat === UseCategory.MPre) {\n\t\t\tpreBaseVowels.push({ index: i, info });\n\t\t}\n\t}\n\n\t// Move pre-base vowels before the base\n\tif (preBaseVowels.length > 0) {\n\t\tpreBaseVowels.sort((a, b) => b.index - a.index);\n\n\t\tfor (let i = 0; i < preBaseVowels.length; i++) {\n\t\t\tconst { index, info } = preBaseVowels[i]!;\n\t\t\tinfos.splice(index, 1);\n\t\t\tconst insertPos = hasReph ? start + 2 : start;\n\t\t\tinfos.splice(insertPos, 0, info);\n\t\t}\n\t}\n\n\t// Move reph to end (if present)\n\tif (hasReph && end > start + 2) {\n\t\tconst rephStart = infos[start];\n\t\tconst rephH = infos[start + 1];\n\n\t\tif (rephStart && rephH) {\n\t\t\t// Find target position: after matras, before finals\n\t\t\tlet rephTarget = end - 1;\n\n\t\t\twhile (rephTarget > base) {\n\t\t\t\tconst targetInfo = infos[rephTarget];\n\t\t\t\tif (!targetInfo) break;\n\n\t\t\t\tconst cat = getUseCategory(targetInfo.codepoint);\n\t\t\t\tif (\n\t\t\t\t\tcat === UseCategory.SMAbv ||\n\t\t\t\t\tcat === UseCategory.SMBlw ||\n\t\t\t\t\tcat === UseCategory.FAbv ||\n\t\t\t\t\tcat === UseCategory.FBlw ||\n\t\t\t\t\tcat === UseCategory.FPst ||\n\t\t\t\t\tcat === UseCategory.F ||\n\t\t\t\t\tcat === UseCategory.FM\n\t\t\t\t) {\n\t\t\t\t\trephTarget--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rephTarget > start + 1) {\n\t\t\t\tinfos.splice(start, 2);\n\t\t\t\tconst adjustedTarget = rephTarget - 2;\n\t\t\t\tinfos.splice(adjustedTarget + 1, 0, rephStart, rephH);\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "import {\n\tprocessContextual,\n\tprocessInsertion,\n\tprocessLigature,\n\tprocessRearrangement,\n} from \"../aat/state-machine.ts\";\nimport { GlyphBuffer } from \"../buffer/glyph-buffer.ts\";\nimport type { UnicodeBuffer } from \"../buffer/unicode-buffer.ts\";\nimport { Face } from \"../font/face.ts\";\nimport type { Font } from \"../font/font.ts\";\nimport { getGlyphClass } from \"../font/tables/gdef.ts\";\nimport {\n\ttype AnyGposLookup,\n\tapplyKerningDirect,\n\ttype CursivePosLookup,\n\tGposLookupType,\n\ttype MarkBasePosLookup,\n\ttype MarkLigaturePosLookup,\n\ttype MarkMarkPosLookup,\n\ttype PairPosLookup,\n\ttype SinglePosLookup,\n} from \"../font/tables/gpos.ts\";\nimport type {\n\tChainingContextPosFormat1,\n\tChainingContextPosFormat2,\n\tChainingContextPosFormat3,\n\tChainingContextPosLookup,\n\tContextPosFormat1,\n\tContextPosFormat2,\n\tContextPosFormat3,\n\tContextPosLookup,\n\tPosLookupRecord,\n} from \"../font/tables/gpos-contextual.ts\";\nimport {\n\ttype AlternateSubstLookup,\n\ttype AnyGsubLookup,\n\tapplyLigatureSubstDirect,\n\tapplySingleSubst,\n\ttype ChainingContextSubstLookup,\n\ttype ContextSubstLookup,\n\tGsubLookupType,\n\ttype LigatureSubstLookup,\n\ttype MultipleSubstLookup,\n\ttype ReverseChainingSingleSubstLookup,\n\ttype SingleSubstLookup,\n} from \"../font/tables/gsub.ts\";\nimport type {\n\tChainingContextFormat1,\n\tChainingContextFormat2,\n\tChainingContextFormat3,\n\tContextSubstFormat1,\n\tContextSubstFormat2,\n\tContextSubstFormat3,\n\tSequenceLookupRecord,\n} from \"../font/tables/gsub-contextual.ts\";\nimport {\n\tapplyNonContextual,\n\ttype MorxContextualSubtable,\n\ttype MorxInsertionSubtable,\n\ttype MorxLigatureSubtable,\n\ttype MorxNonContextualSubtable,\n\ttype MorxRearrangementSubtable,\n\tMorxSubtableType,\n} from \"../font/tables/morx.ts\";\nimport type { ClassDef } from \"../layout/structures/class-def.ts\";\nimport {\n\tgetMarkAttachmentType,\n\tLookupFlag,\n} from \"../layout/structures/layout-common.ts\";\nimport { SetDigest } from \"../layout/structures/set-digest.ts\";\nimport type { GlyphId, GlyphInfo, GlyphPosition } from \"../types.ts\";\nimport { GlyphClass } from \"../types.ts\";\nimport { setupArabicMasks } from \"./complex/arabic.ts\";\nimport {\n\tisKorean,\n\tnormalizeHangul,\n\tsetupHangulMasks,\n} from \"./complex/hangul.ts\";\nimport { setupHebrewMasks } from \"./complex/hebrew.ts\";\nimport { isIndic, reorderIndic, setupIndicMasks } from \"./complex/indic.ts\";\nimport { isKhmer, reorderKhmer, setupKhmerMasks } from \"./complex/khmer.ts\";\nimport {\n\tisMyanmar,\n\treorderMyanmar,\n\tsetupMyanmarMasks,\n} from \"./complex/myanmar.ts\";\nimport {\n\tisLao,\n\tisThai,\n\treorderThaiLao,\n\tsetupThaiLaoMasks,\n} from \"./complex/thai-lao.ts\";\nimport { reorderUSE, setupUseMasks, usesUSE } from \"./complex/use.ts\";\nimport {\n\tapplyFallbackKerning,\n\tapplyFallbackMarkPositioning,\n} from \"./fallback.ts\";\nimport {\n\tgetOrCreateShapePlan,\n\ttype ShapeFeature,\n\ttype ShapePlan,\n} from \"./shape-plan.ts\";\nimport { tag } from \"../types.ts\";\n\n/**\n * Options for controlling text shaping behavior.\n */\nexport interface ShapeOptions {\n\t/** ISO 15924 script tag (e.g., \"arab\", \"deva\", \"latn\"). Defaults to buffer.script or \"latn\" */\n\tscript?: string;\n\t/** BCP 47 language tag (e.g., \"en\", \"ar-SA\", \"hi-IN\"). Defaults to buffer.language or null */\n\tlanguage?: string | null;\n\t/** Text direction: \"ltr\" (left-to-right) or \"rtl\" (right-to-left). Defaults to \"ltr\" */\n\tdirection?: \"ltr\" | \"rtl\";\n\t/** Array of OpenType features to apply (e.g., [{tag: \"liga\", value: 1}, {tag: \"kern\", value: 0}]) */\n\tfeatures?: ShapeFeature[];\n}\n\n/**\n * Pre-allocated arrays for ligature matching to avoid per-glyph allocations.\n * Max 16 components per ligature is a reasonable limit.\n */\nconst _ligMatchIndices = new Uint16Array(16);\nconst _ligMatchGlyphs = new Uint16Array(16);\n\n/**\n * Union type accepting either Font or Face instances.\n * Use Face for variable fonts to provide axis coordinates for feature variations.\n * Use Font for static fonts or when default axis values are acceptable.\n */\nexport type FontLike = Font | Face;\n\n/** Get the underlying Font from a FontLike */\nfunction getFont(fontLike: FontLike): Font {\n\treturn fontLike instanceof Face ? fontLike.font : fontLike;\n}\n\n/** Cached Face per Font for avoiding allocation overhead */\nconst _faceCache = new WeakMap<Font, Face>();\n\n/** Get Face (cached for non-variable fonts) */\nfunction getFace(fontLike: FontLike): Face {\n\tif (fontLike instanceof Face) return fontLike;\n\t// Cache Face per Font to avoid allocation per shape\n\tlet face = _faceCache.get(fontLike);\n\tif (!face) {\n\t\tface = new Face(fontLike);\n\t\t_faceCache.set(fontLike, face);\n\t}\n\treturn face;\n}\n\n/**\n * Pre-computed skip markers for efficient glyph skipping in contextual matching.\n * Bit is set to 1 if glyph at that position should be skipped for the given lookup flag.\n */\ntype SkipMarkers = Uint8Array;\n\n/**\n * Pre-compute skip markers for all glyphs in the buffer.\n * This avoids calling shouldSkipGlyph() repeatedly in tight loops.\n * O(n) one-time cost instead of O(n) repeated calls.\n */\nfunction precomputeSkipMarkers(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookupFlag: number,\n): SkipMarkers {\n\tconst markers = new Uint8Array(buffer.infos.length);\n\tconst gdef = font.gdef;\n\n\t// If no GDEF or no filtering flags, nothing to skip\n\tif (!gdef || lookupFlag === 0) {\n\t\treturn markers;\n\t}\n\n\tconst ignoreBase = lookupFlag & LookupFlag.IgnoreBaseGlyphs;\n\tconst ignoreLig = lookupFlag & LookupFlag.IgnoreLigatures;\n\tconst ignoreMark = lookupFlag & LookupFlag.IgnoreMarks;\n\tconst markAttachmentType = getMarkAttachmentType(lookupFlag);\n\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\n\t\tconst glyphClass = getGlyphClass(gdef, info.glyphId);\n\n\t\tif (ignoreBase && glyphClass === GlyphClass.Base) {\n\t\t\tmarkers[i] = 1;\n\t\t} else if (ignoreLig && glyphClass === GlyphClass.Ligature) {\n\t\t\tmarkers[i] = 1;\n\t\t} else if (ignoreMark && glyphClass === GlyphClass.Mark) {\n\t\t\tmarkers[i] = 1;\n\t\t} else if (markAttachmentType !== 0 && glyphClass === GlyphClass.Mark) {\n\t\t\tconst glyphMarkClass = gdef.markAttachClassDef.get(info.glyphId);\n\t\t\tif (glyphMarkClass !== markAttachmentType) {\n\t\t\t\tmarkers[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn markers;\n}\n\n/**\n * Pre-compute next non-skip index array for O(1) pair lookups.\n * nextNonSkip[i] = index of next non-skipped glyph after i, or -1 if none.\n * Built in reverse for O(n) construction.\n */\nfunction buildNextNonSkipArray(skip: SkipMarkers, length: number): Int16Array {\n\tconst next = new Int16Array(length);\n\tlet lastNonSkip = -1;\n\n\t// Build in reverse\n\tfor (let i = length - 1; i >= 0; i--) {\n\t\tnext[i] = lastNonSkip;\n\t\tif (!skip[i]) {\n\t\t\tlastNonSkip = i;\n\t\t}\n\t}\n\n\treturn next;\n}\n\n/**\n * Pre-computed base glyph index array for O(1) mark-to-base lookup.\n * baseIndex[i] = index of the base/ligature glyph for mark at position i, or -1.\n * Also returns whether any marks were found in the buffer.\n */\n/**\n * Quick check if buffer contains any mark glyphs.\n * This is O(n) but exits early on first mark found.\n */\nfunction hasAnyMarks(buffer: GlyphBuffer, font: Font): boolean {\n\tif (!font.gdef) return false;\n\tconst infos = buffer.infos;\n\tconst len = buffer.length;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tconst cls = getGlyphClass(font.gdef, info.glyphId);\n\t\tif (cls === GlyphClass.Mark) return true;\n\t}\n\treturn false;\n}\n\n/**\n * Build base index array for mark positioning.\n * Only called when hasMarks is true.\n */\nfunction buildBaseIndexArray(\n\tbuffer: GlyphBuffer,\n\tglyphClassCache: GlyphClassCache,\n\tfont: Font,\n): Int16Array {\n\tconst baseIndex = new Int16Array(buffer.infos.length);\n\tbaseIndex.fill(-1);\n\n\tlet lastBaseIndex = -1;\n\n\tfor (let i = 0; i < buffer.infos.length; i++) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) continue;\n\n\t\tconst cls = getCachedGlyphClass(font, info.glyphId, glyphClassCache);\n\n\t\tif (cls === GlyphClass.Base || cls === 0 || cls === GlyphClass.Ligature) {\n\t\t\t// This is a base or ligature, update the last base\n\t\t\tlastBaseIndex = i;\n\t\t} else if (cls === GlyphClass.Mark) {\n\t\t\t// This is a mark, point to the last base\n\t\t\tbaseIndex[i] = lastBaseIndex;\n\t\t}\n\t}\n\n\treturn baseIndex;\n}\n\n// Reusable GlyphBuffer pool for shapeInto\nconst _glyphBufferPool: GlyphBuffer[] = [];\nconst MAX_POOL_SIZE = 8;\n\n/**\n * Return a GlyphBuffer to the pool for reuse.\n * Call this when done with a buffer from shape() to reduce allocations.\n * The pool has a maximum size, so buffers beyond that limit will be discarded.\n *\n * @param buffer - The GlyphBuffer to return to the pool\n */\nexport function releaseBuffer(buffer: GlyphBuffer): void {\n\tif (_glyphBufferPool.length < MAX_POOL_SIZE) {\n\t\tbuffer.reset();\n\t\t_glyphBufferPool.push(buffer);\n\t}\n}\n\n/**\n * Shape text using OpenType features and complex script processing.\n *\n * Text shaping is the process of converting Unicode text into positioned glyphs for rendering.\n * This involves:\n * - Mapping characters to glyphs via the font's cmap table\n * - Applying OpenType GSUB substitutions (ligatures, contextual forms, etc.)\n * - Positioning glyphs via GPOS or fallback kerning/mark positioning\n * - Complex script analysis (Arabic joining, Indic reordering, etc.)\n * - Applying OpenType features (liga, kern, calt, etc.)\n *\n * The function returns a pooled GlyphBuffer for efficiency. Call releaseBuffer() when done\n * to return it to the pool for reuse.\n *\n * @param fontLike - Font or Face instance (Face for variable fonts with axis coordinates)\n * @param buffer - UnicodeBuffer containing the input text and metadata (script, language, direction)\n * @param options - Optional shaping parameters\n * @param options.script - ISO 15924 script tag (e.g., \"arab\", \"deva\"), defaults to buffer.script or \"latn\"\n * @param options.language - BCP 47 language tag (e.g., \"en\", \"ar-SA\"), defaults to buffer.language or null\n * @param options.direction - Text direction \"ltr\" or \"rtl\", defaults to \"ltr\"\n * @param options.features - Array of OpenType features to enable/disable (e.g., [{tag: \"liga\", value: 1}])\n * @returns GlyphBuffer containing shaped glyphs with positions and metadata\n */\nexport function shape(\n\tfontLike: FontLike,\n\tbuffer: UnicodeBuffer,\n\toptions: ShapeOptions = {},\n): GlyphBuffer {\n\t// Try to get a pooled buffer\n\tlet glyphBuffer = _glyphBufferPool.pop();\n\tif (!glyphBuffer) {\n\t\tglyphBuffer = GlyphBuffer.withCapacity(64);\n\t}\n\n\tshapeInto(fontLike, buffer, glyphBuffer, options);\n\treturn glyphBuffer;\n}\n\n/**\n * Shape text into an existing GlyphBuffer (zero-allocation hot path).\n *\n * This is a performance-optimized version of shape() that reuses an existing GlyphBuffer\n * instead of allocating a new one. Use this for maximum performance when shaping repeatedly,\n * such as in animation loops or batch text processing.\n *\n * The provided GlyphBuffer will be reset and filled with the shaped output. This avoids\n * allocations from the buffer pool and gives you full control over buffer lifecycle.\n *\n * @param fontLike - Font or Face instance (Face for variable fonts with axis coordinates)\n * @param buffer - UnicodeBuffer containing the input text and metadata (script, language, direction)\n * @param glyphBuffer - Existing GlyphBuffer to fill with shaped output (will be reset)\n * @param options - Optional shaping parameters\n * @param options.script - ISO 15924 script tag (e.g., \"arab\", \"deva\"), defaults to buffer.script or \"latn\"\n * @param options.language - BCP 47 language tag (e.g., \"en\", \"ar-SA\"), defaults to buffer.language or null\n * @param options.direction - Text direction \"ltr\" or \"rtl\", defaults to \"ltr\"\n * @param options.features - Array of OpenType features to enable/disable (e.g., [{tag: \"liga\", value: 1}])\n */\nexport function shapeInto(\n\tfontLike: FontLike,\n\tbuffer: UnicodeBuffer,\n\tglyphBuffer: GlyphBuffer,\n\toptions: ShapeOptions = {},\n): void {\n\tconst font = getFont(fontLike);\n\tconst face = getFace(fontLike);\n\n\tconst script = options.script ?? buffer.script ?? \"latn\";\n\tconst language = options.language ?? buffer.language ?? null;\n\tconst direction = options.direction ?? \"ltr\";\n\tconst features = options.features ?? [];\n\tlet kernEnabled = true;\n\tif (features.length) {\n\t\tconst kernTag = tag(\"kern\");\n\t\tfor (let i = 0; i < features.length; i++) {\n\t\t\tconst feat = features[i]!;\n\t\t\tif (feat.tag === kernTag) {\n\t\t\t\tkernEnabled = feat.enabled;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get axis coordinates from face for feature variations\n\tconst axisCoords =\n\t\tface.normalizedCoords.length > 0 ? face.normalizedCoords : null;\n\t// Use cached shape plan for repeated shaping with same parameters\n\tconst plan = getOrCreateShapePlan(\n\t\tfont,\n\t\tscript,\n\t\tlanguage,\n\t\tdirection,\n\t\tfeatures,\n\t\taxisCoords,\n\t);\n\n\t// Reset and reuse buffer\n\tglyphBuffer.reset();\n\tglyphBuffer.direction = buffer.direction;\n\tglyphBuffer.script = script;\n\tglyphBuffer.language = language;\n\n\t// Use pooled object initialization - inline glyphId lookup to avoid closure\n\tglyphBuffer.initFromCodepointsWithFont(\n\t\tbuffer.codepoints,\n\t\tbuffer.clusters,\n\t\tfont,\n\t);\n\n\t// Pre-shaping: Apply complex script analysis\n\tpreShape(glyphBuffer, script);\n\n\t// Apply GSUB\n\tapplyGsub(font, glyphBuffer, plan);\n\n\t// Initialize positions (using Face for variable font metrics)\n\tinitializePositions(face, glyphBuffer);\n\n\t// Apply GPOS or fallback positioning\n\tconst hasGpos = font.gpos !== null && plan.gposLookups.length > 0;\n\tif (hasGpos) {\n\t\tapplyGpos(font, glyphBuffer, plan);\n\t} else {\n\t\t// Fallback kerning using kern table\n\t\tif (kernEnabled) {\n\t\t\tapplyFallbackKerning(font, glyphBuffer.infos, glyphBuffer.positions);\n\t\t}\n\t\t// Fallback mark positioning using combining classes\n\t\tapplyFallbackMarkPositioning(\n\t\t\tfont,\n\t\t\tglyphBuffer.infos,\n\t\t\tglyphBuffer.positions,\n\t\t);\n\t}\n\n\t// Apply AAT morx substitutions if no GSUB\n\tif (!font.gsub && font.morx) {\n\t\tapplyMorx(font, glyphBuffer);\n\t}\n\n\t// Reverse for RTL\n\tif (direction === \"rtl\") {\n\t\tglyphBuffer.reverse();\n\t}\n}\n\n// Pre-shaping for complex scripts\n\nfunction preShape(buffer: GlyphBuffer, script: string): void {\n\t// Arabic joining analysis\n\tif (\n\t\tscript === \"arab\" ||\n\t\tscript === \"syrc\" ||\n\t\tscript === \"mand\" ||\n\t\tscript === \"nko \"\n\t) {\n\t\tsetupArabicMasks(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Hebrew (RTL with marks)\n\tif (script === \"hebr\") {\n\t\tsetupHebrewMasks(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Hangul (Korean)\n\tif (script === \"hang\" || script === \"kore\") {\n\t\t// Normalize Jamo sequences into precomposed syllables\n\t\tconst normalized = normalizeHangul(buffer.infos);\n\t\tif (normalized.length !== buffer.infos.length) {\n\t\t\tbuffer.initFromInfos(normalized);\n\t\t}\n\t\tsetupHangulMasks(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Indic scripts (syllable-based)\n\tif (\n\t\tscript === \"deva\" ||\n\t\tscript === \"beng\" ||\n\t\tscript === \"guru\" ||\n\t\tscript === \"gujr\" ||\n\t\tscript === \"orya\" ||\n\t\tscript === \"taml\" ||\n\t\tscript === \"telu\" ||\n\t\tscript === \"knda\" ||\n\t\tscript === \"mlym\"\n\t) {\n\t\tsetupIndicMasks(buffer.infos);\n\t\treorderIndic(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Thai and Lao (leading vowel reordering)\n\tif (script === \"thai\" || script === \"lao \") {\n\t\tsetupThaiLaoMasks(buffer.infos);\n\t\treorderThaiLao(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Khmer (subscript consonants, pre-base vowels)\n\tif (script === \"khmr\") {\n\t\tsetupKhmerMasks(buffer.infos);\n\t\treorderKhmer(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Myanmar (medials, pre-base vowels, stacking)\n\tif (script === \"mymr\") {\n\t\tsetupMyanmarMasks(buffer.infos);\n\t\treorderMyanmar(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Universal Shaping Engine (many other complex scripts)\n\tif (usesUSE(script)) {\n\t\tsetupUseMasks(buffer.infos);\n\t\treorderUSE(buffer.infos);\n\t\treturn;\n\t}\n\n\t// Auto-detect based on content if script is unknown\n\tif (script === \"Zyyy\" || script === \"Zinh\" || script === \"Zzzz\") {\n\t\tdetectAndApplyComplexShaping(buffer.infos);\n\t}\n}\n\n// Auto-detect complex script from content\nfunction detectAndApplyComplexShaping(infos: GlyphInfo[]): void {\n\tif (infos.length === 0) return;\n\n\t// Sample first few codepoints to detect script\n\tconst sampleLen = Math.min(10, infos.length);\n\n\tfor (let s = 0; s < sampleLen; s++) {\n\t\tconst info = infos[s]!;\n\t\tconst cp = info.codepoint;\n\n\t\t// Arabic range\n\t\tif (\n\t\t\t(cp >= 0x0600 && cp <= 0x06ff) ||\n\t\t\t(cp >= 0x0750 && cp <= 0x077f) ||\n\t\t\t(cp >= 0x08a0 && cp <= 0x08ff)\n\t\t) {\n\t\t\tsetupArabicMasks(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Hebrew range\n\t\tif (cp >= 0x0590 && cp <= 0x05ff) {\n\t\t\tsetupHebrewMasks(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Korean/Hangul\n\t\tif (isKorean(cp)) {\n\t\t\tconst normalized = normalizeHangul(infos);\n\t\t\tif (normalized.length !== infos.length) {\n\t\t\t\t// Replace infos in place\n\t\t\t\tinfos.length = 0;\n\t\t\t\tinfos.push(...normalized);\n\t\t\t}\n\t\t\tsetupHangulMasks(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Devanagari and other Indic\n\t\tif (isIndic(cp)) {\n\t\t\tsetupIndicMasks(infos);\n\t\t\treorderIndic(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Thai\n\t\tif (isThai(cp)) {\n\t\t\tsetupThaiLaoMasks(infos);\n\t\t\treorderThaiLao(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Lao\n\t\tif (isLao(cp)) {\n\t\t\tsetupThaiLaoMasks(infos);\n\t\t\treorderThaiLao(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Khmer\n\t\tif (isKhmer(cp)) {\n\t\t\tsetupKhmerMasks(infos);\n\t\t\treorderKhmer(infos);\n\t\t\treturn;\n\t\t}\n\n\t\t// Myanmar\n\t\tif (isMyanmar(cp)) {\n\t\t\tsetupMyanmarMasks(infos);\n\t\t\treorderMyanmar(infos);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n// GSUB application\n\nfunction applyGsub(font: Font, buffer: GlyphBuffer, plan: ShapePlan): void {\n\tconst lookups = plan.gsubLookups;\n\n\t// Build buffer digest for fast lookup skipping\n\t// Note: We rebuild after each lookup that modifies glyphs\n\tlet bufferDigest = new SetDigest();\n\tconst infos = buffer.infos;\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tbufferDigest.add(infos[i]!.glyphId);\n\t}\n\n\tfor (let i = 0; i < lookups.length; i++) {\n\t\tconst entry = lookups[i]!;\n\t\t// Skip entire lookup if no glyph in buffer could match\n\t\tif (!bufferDigest.mayIntersect(entry.lookup.digest)) continue;\n\n\t\tconst prevLength = buffer.length;\n\t\tapplyGsubLookup(font, buffer, entry.lookup, plan);\n\n\t\t// Rebuild digest if buffer was modified (length change indicates substitution)\n\t\tif (buffer.length !== prevLength) {\n\t\t\tbufferDigest = new SetDigest();\n\t\t\tfor (let j = 0; j < buffer.length; j++) {\n\t\t\t\tbufferDigest.add(infos[j]!.glyphId);\n\t\t\t}\n\t\t}\n\t}\n\t// Compact buffer after all GSUB lookups to remove marked-deleted glyphs\n\tbuffer.compact();\n}\n\nfunction applyGsubLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: AnyGsubLookup,\n\tplan: ShapePlan,\n): void {\n\tswitch (lookup.type) {\n\t\tcase GsubLookupType.Single:\n\t\t\tapplySingleSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Multiple:\n\t\t\tapplyMultipleSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Alternate:\n\t\t\t// Alternate requires user selection - use first alternate as default\n\t\t\tapplyAlternateSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Ligature:\n\t\t\tapplyLigatureSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t\tcase GsubLookupType.Context:\n\t\t\tapplyContextSubstLookup(font, buffer, lookup, plan);\n\t\t\tbreak;\n\t\tcase GsubLookupType.ChainingContext:\n\t\t\tapplyChainingContextSubstLookup(font, buffer, lookup, plan);\n\t\t\tbreak;\n\t\t// Note: Extension lookups (Type 7) are unwrapped during parsing\n\t\t// and converted to their actual lookup types, so no case needed here\n\t\tcase GsubLookupType.ReverseChainingSingle:\n\t\t\tapplyReverseChainingSingleSubstLookup(font, buffer, lookup);\n\t\t\tbreak;\n\t}\n}\n\nfunction applySingleSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: SingleSubstLookup,\n): void {\n\tconst infos = buffer.infos;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\n\t// FAST PATH: No skip checking needed\n\tif (lookup.flag === 0 || !font.gdef) {\n\t\t// Super-fast path for single subtable (very common)\n\t\tif (lookup.subtables.length === 1) {\n\t\t\tconst subtable = lookup.subtables[0]!;\n\t\t\tif (subtable.format === 1 && subtable.deltaGlyphId !== undefined) {\n\t\t\t\tconst delta = subtable.deltaGlyphId;\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\tconst info = infos[i]!;\n\t\t\t\t\t// Fast digest check before expensive Coverage lookup\n\t\t\t\t\tif (!digest.mayHave(info.glyphId)) continue;\n\t\t\t\t\tif (subtable.coverage.get(info.glyphId) !== null) {\n\t\t\t\t\t\tinfo.glyphId = (info.glyphId + delta) & 0xffff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2 && subtable.substituteGlyphIds) {\n\t\t\t\tconst subs = subtable.substituteGlyphIds;\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\tconst info = infos[i]!;\n\t\t\t\t\t// Fast digest check before expensive Coverage lookup\n\t\t\t\t\tif (!digest.mayHave(info.glyphId)) continue;\n\t\t\t\t\tconst idx = subtable.coverage.get(info.glyphId);\n\t\t\t\t\tif (idx !== null) {\n\t\t\t\t\t\tconst rep = subs[idx];\n\t\t\t\t\t\tif (rep !== undefined) info.glyphId = rep;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Multiple subtables - use function\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst info = infos[i]!;\n\t\t\t// Fast digest check before expensive Coverage lookup\n\t\t\tif (!digest.mayHave(info.glyphId)) continue;\n\t\t\tconst replacement = applySingleSubst(lookup, info.glyphId);\n\t\t\tif (replacement !== null) {\n\t\t\t\tinfo.glyphId = replacement;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// WITH SKIP: Need to check each glyph\n\tconst skip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\tfor (let i = 0; i < len; i++) {\n\t\tif (skip[i]) continue;\n\t\tconst info = infos[i]!;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\t\tconst replacement = applySingleSubst(lookup, info.glyphId);\n\t\tif (replacement !== null) {\n\t\t\tinfo.glyphId = replacement;\n\t\t}\n\t}\n}\n\nfunction applyMultipleSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MultipleSubstLookup,\n): void {\n\tconst digest = lookup.digest;\n\tlet i = 0;\n\twhile (i < buffer.infos.length) {\n\t\tconst info = buffer.infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet applied = false;\n\t\tconst subtables = lookup.subtables;\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\tconst sequence = subtable.sequences[coverageIndex];\n\t\t\tif (!sequence || sequence.length === 0) continue;\n\n\t\t\tconst firstGlyph = sequence[0];\n\t\t\tif (firstGlyph === undefined) continue;\n\n\t\t\t// Replace with first glyph\n\t\t\tinfo.glyphId = firstGlyph;\n\n\t\t\t// Insert remaining glyphs (avoid array destructuring allocation)\n\t\t\tfor (let j = 1; j < sequence.length; j++) {\n\t\t\t\tconst glyphId = sequence[j]!;\n\t\t\t\tconst newInfo: GlyphInfo = {\n\t\t\t\t\tglyphId,\n\t\t\t\t\tcluster: info.cluster,\n\t\t\t\t\tmask: info.mask,\n\t\t\t\t\tcodepoint: info.codepoint,\n\t\t\t\t};\n\t\t\t\tconst newPos: GlyphPosition = {\n\t\t\t\t\txAdvance: 0,\n\t\t\t\t\tyAdvance: 0,\n\t\t\t\t\txOffset: 0,\n\t\t\t\t\tyOffset: 0,\n\t\t\t\t};\n\t\t\t\tbuffer.insertGlyph(i + j, newInfo, newPos);\n\t\t\t}\n\n\t\t\ti += sequence.length;\n\t\t\tapplied = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!applied) i++;\n\t}\n}\n\nfunction applyAlternateSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: AlternateSubstLookup,\n): void {\n\t// Alternate substitution allows selecting from multiple alternates\n\t// By default, use the first alternate (index 0)\n\tconst infos = buffer.infos;\n\tconst subtables = lookup.subtables;\n\tconst digest = lookup.digest;\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i]!;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\tconst alternateSet = subtable.alternateSets[coverageIndex];\n\t\t\tif (!alternateSet || alternateSet.length === 0) continue;\n\n\t\t\tconst firstAlternate = alternateSet[0];\n\t\t\tif (firstAlternate === undefined) continue;\n\n\t\t\t// Use first alternate by default\n\t\t\tinfo.glyphId = firstAlternate;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyLigatureSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: LigatureSubstLookup,\n): void {\n\tconst infos = buffer.infos;\n\tconst len = infos.length;\n\tconst needsSkipCheck = lookup.flag !== 0 && font.gdef !== null;\n\tconst digest = lookup.digest;\n\n\t// Pre-compute skip markers only if needed\n\tlet skip: Uint8Array | null = null;\n\tif (needsSkipCheck) {\n\t\tskip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\t}\n\n\tlet i = 0;\n\twhile (i < len) {\n\t\t// Skip deleted glyphs\n\t\tif (buffer.isDeleted(i)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst info = infos[i];\n\t\tif (!info) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t// Use pre-computed skip markers\n\t\tif (skip?.[i]) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Collect matchable glyphs using pre-allocated arrays\n\t\tlet matchLen = 1;\n\t\t_ligMatchIndices[0] = i;\n\t\t_ligMatchGlyphs[0] = info.glyphId;\n\n\t\tfor (let j = i + 1; j < len && matchLen < 16; j++) {\n\t\t\t// Skip deleted glyphs\n\t\t\tif (buffer.isDeleted(j)) continue;\n\t\t\tconst nextInfo = infos[j];\n\t\t\tif (!nextInfo) continue;\n\t\t\t// Use pre-computed skip markers\n\t\t\tif (skip?.[j]) continue;\n\t\t\t_ligMatchIndices[matchLen] = j;\n\t\t\t_ligMatchGlyphs[matchLen] = nextInfo.glyphId;\n\t\t\tmatchLen++;\n\t\t}\n\n\t\t// Use direct Uint16Array version to avoid Array.from allocation\n\t\tconst result = applyLigatureSubstDirect(\n\t\t\tlookup,\n\t\t\t_ligMatchGlyphs,\n\t\t\tmatchLen,\n\t\t\t0,\n\t\t);\n\t\tif (result) {\n\t\t\t// Replace first glyph with ligature\n\t\t\tinfo.glyphId = result.ligatureGlyph;\n\n\t\t\t// Merge clusters and mark consumed glyphs for deletion\n\t\t\tfor (let k = 1; k < result.consumed; k++) {\n\t\t\t\tconst idx = _ligMatchIndices[k];\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst targetInfo = infos[idx];\n\t\t\t\t\tif (targetInfo) {\n\t\t\t\t\t\tinfo.cluster = Math.min(info.cluster, targetInfo.cluster);\n\t\t\t\t\t}\n\t\t\t\t\t// Mark for deferred deletion instead of immediate removal\n\t\t\t\t\tbuffer.markDeleted(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n}\n\nfunction applyContextSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ContextSubstLookup,\n\tplan: ShapePlan,\n): void {\n\tconst infos = buffer.infos;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\n\t// Pre-compute skip markers only if needed\n\tlet skip: Uint8Array | null = null;\n\tif (lookup.flag !== 0 && font.gdef !== null) {\n\t\tskip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\t}\n\n\t// Context substitution - matches input sequence and applies nested lookups\n\tconst subtables = lookup.subtables;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tif (skip?.[i]) continue;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: SequenceLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchContextFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchContextFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (matchContextFormat3(font, buffer, i, subtable, lookup.flag)) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedLookups(font, buffer, i, lookupRecords, plan);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction applyChainingContextSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ChainingContextSubstLookup,\n\tplan: ShapePlan,\n): void {\n\tconst infos = buffer.infos;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\n\t// Pre-compute skip markers only if needed\n\tlet skip: Uint8Array | null = null;\n\tif (lookup.flag !== 0 && font.gdef !== null) {\n\t\tskip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\t}\n\n\tconst subtables = lookup.subtables;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tif (skip?.[i]) continue;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: SequenceLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchChainingFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchChainingFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (matchChainingFormat3(font, buffer, i, subtable, lookup.flag)) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedLookups(font, buffer, i, lookupRecords, plan);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction applyReverseChainingSingleSubstLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ReverseChainingSingleSubstLookup,\n): void {\n\tconst infos = buffer.infos;\n\tconst subtables = lookup.subtables;\n\tconst digest = lookup.digest;\n\t// Process in reverse order\n\tfor (let i = infos.length - 1; i >= 0; i--) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tif (shouldSkipGlyph(font, info.glyphId, lookup.flag)) continue;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\t// Check backtrack (glyphs after current in reverse order)\n\t\t\tlet backtrackMatch = true;\n\t\t\tlet backtrackPos = i + 1;\n\t\t\tconst backtrackCoverages = subtable.backtrackCoverages;\n\t\t\tfor (let b = 0; b < backtrackCoverages.length; b++) {\n\t\t\t\tconst backCov = backtrackCoverages[b]!;\n\t\t\t\twhile (\n\t\t\t\t\tbacktrackPos < infos.length &&\n\t\t\t\t\tshouldSkipGlyph(font, infos[backtrackPos]?.glyphId, lookup.flag)\n\t\t\t\t) {\n\t\t\t\t\tbacktrackPos++;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tbacktrackPos >= infos.length ||\n\t\t\t\t\tbackCov.get(infos[backtrackPos]?.glyphId) === null\n\t\t\t\t) {\n\t\t\t\t\tbacktrackMatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbacktrackPos++;\n\t\t\t}\n\t\t\tif (!backtrackMatch) continue;\n\n\t\t\t// Check lookahead (glyphs before current)\n\t\t\tlet lookaheadMatch = true;\n\t\t\tlet lookaheadPos = i - 1;\n\t\t\tconst lookaheadCoverages = subtable.lookaheadCoverages;\n\t\t\tfor (let l = 0; l < lookaheadCoverages.length; l++) {\n\t\t\t\tconst lookCov = lookaheadCoverages[l]!;\n\t\t\t\twhile (\n\t\t\t\t\tlookaheadPos >= 0 &&\n\t\t\t\t\tshouldSkipGlyph(font, infos[lookaheadPos]?.glyphId, lookup.flag)\n\t\t\t\t) {\n\t\t\t\t\tlookaheadPos--;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tlookaheadPos < 0 ||\n\t\t\t\t\tlookCov.get(infos[lookaheadPos]?.glyphId) === null\n\t\t\t\t) {\n\t\t\t\t\tlookaheadMatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlookaheadPos--;\n\t\t\t}\n\t\t\tif (!lookaheadMatch) continue;\n\n\t\t\t// Apply substitution\n\t\t\tconst substitute = subtable.substituteGlyphIds[coverageIndex];\n\t\t\tif (substitute !== undefined) {\n\t\t\t\tinfo.glyphId = substitute;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Note: Extension lookups (Type 7) are unwrapped during parsing,\n// so no applyExtensionGsubLookup function is needed at runtime.\n\n/** Match Context Format 1 - glyph-based rules */\nfunction matchContextFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextSubstFormat1,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst ruleSet = subtable.ruleSets[coverageIndex];\n\tif (!ruleSet) return null;\n\n\tfor (let r = 0; r < ruleSet.length; r++) {\n\t\tconst rule = ruleSet[r]!;\n\t\tif (\n\t\t\tmatchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Format 2 - class-based rules */\nfunction matchContextFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextSubstFormat2,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.classDef.get(firstGlyph);\n\tconst classRuleSet = subtable.classRuleSets[firstClass];\n\tif (!classRuleSet) return null;\n\n\tfor (let r = 0; r < classRuleSet.length; r++) {\n\t\tconst rule = classRuleSet[r]!;\n\t\tif (\n\t\t\tmatchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.classDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Format 3 - coverage-based */\nfunction matchContextFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextSubstFormat3,\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\tconst coverages = subtable.coverages;\n\tlet pos = startIndex;\n\tfor (let c = 0; c < coverages.length; c++) {\n\t\tconst coverage = coverages[c]!;\n\t\twhile (\n\t\t\tpos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= infos.length) return false;\n\t\tif (coverage.get(infos[pos]?.glyphId) === null) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match Chaining Context Format 1 - glyph-based rules */\nfunction matchChainingFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextFormat1,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst chainRuleSet = subtable.chainRuleSets[coverageIndex];\n\tif (!chainRuleSet) return null;\n\n\tfor (let r = 0; r < chainRuleSet.length; r++) {\n\t\tconst rule = chainRuleSet[r]!;\n\t\t// Check backtrack (reversed order, before startIndex)\n\t\tif (\n\t\t\t!matchGlyphSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input (excluding first glyph which is in coverage)\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input sequence ends\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputSequence.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < buffer.infos.length &&\n\t\t\t\tshouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Format 2 - class-based rules */\nfunction matchChainingFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextFormat2,\n\tlookupFlag: number,\n): SequenceLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.inputClassDef.get(firstGlyph);\n\tconst chainClassRuleSet = subtable.chainClassRuleSets[firstClass];\n\tif (!chainClassRuleSet) return null;\n\n\tfor (let r = 0; r < chainClassRuleSet.length; r++) {\n\t\tconst rule = chainClassRuleSet[r]!;\n\t\t// Check backtrack classes (reversed order)\n\t\tif (\n\t\t\t!matchClassSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackClasses,\n\t\t\t\tsubtable.backtrackClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input classes (excluding first)\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.inputClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input ends\n\t\tconst infos = buffer.infos;\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputClasses.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < infos.length &&\n\t\t\t\tshouldSkipGlyph(font, infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead classes\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadClasses,\n\t\t\t\tsubtable.lookaheadClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Format 3 - coverage-based */\nfunction matchChainingFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextFormat3,\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\t// Check backtrack (in reverse order, before startIndex)\n\tlet backtrackPos = startIndex - 1;\n\tconst backtrackCoverages = subtable.backtrackCoverages;\n\tfor (let b = 0; b < backtrackCoverages.length; b++) {\n\t\tconst coverage = backtrackCoverages[b]!;\n\t\twhile (\n\t\t\tbacktrackPos >= 0 &&\n\t\t\tshouldSkipGlyph(font, infos[backtrackPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tbacktrackPos--;\n\t\t}\n\t\tif (backtrackPos < 0) return false;\n\t\tif (coverage.get(infos[backtrackPos]?.glyphId) === null) return false;\n\t\tbacktrackPos--;\n\t}\n\n\t// Check input sequence\n\tlet inputPos = startIndex;\n\tconst inputCoverages = subtable.inputCoverages;\n\tfor (let i = 0; i < inputCoverages.length; i++) {\n\t\tconst coverage = inputCoverages[i]!;\n\t\twhile (\n\t\t\tinputPos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[inputPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tinputPos++;\n\t\t}\n\t\tif (inputPos >= infos.length) return false;\n\t\tif (coverage.get(infos[inputPos]?.glyphId) === null) return false;\n\t\tinputPos++;\n\t}\n\n\t// Check lookahead\n\tlet lookaheadPos = inputPos;\n\tconst lookaheadCoverages = subtable.lookaheadCoverages;\n\tfor (let l = 0; l < lookaheadCoverages.length; l++) {\n\t\tconst coverage = lookaheadCoverages[l]!;\n\t\twhile (\n\t\t\tlookaheadPos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[lookaheadPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tlookaheadPos++;\n\t\t}\n\t\tif (lookaheadPos >= infos.length) return false;\n\t\tif (coverage.get(infos[lookaheadPos]?.glyphId) === null) return false;\n\t\tlookaheadPos++;\n\t}\n\n\treturn true;\n}\n\nfunction applyNestedLookups(\n\t_font: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tlookupRecords: Array<{ sequenceIndex: number; lookupListIndex: number }>,\n\tplan: ShapePlan,\n): void {\n\tconst len = lookupRecords.length;\n\tif (len === 0) return;\n\n\t// Fast path for single record (common case)\n\tif (len === 1) {\n\t\tconst record = lookupRecords[0]!;\n\t\tconst lookupEntry = plan.gsubLookupMap.get(record.lookupListIndex);\n\t\tif (!lookupEntry) return;\n\t\tconst pos = startIndex + record.sequenceIndex;\n\t\tif (pos >= buffer.infos.length) return;\n\t\tconst targetInfo = buffer.infos[pos];\n\t\tif (!targetInfo) return;\n\t\tif (lookupEntry.lookup.type === GsubLookupType.Single) {\n\t\t\tconst replacement = applySingleSubst(\n\t\t\t\tlookupEntry.lookup as SingleSubstLookup,\n\t\t\t\ttargetInfo.glyphId,\n\t\t\t);\n\t\t\tif (replacement !== null) {\n\t\t\t\ttargetInfo.glyphId = replacement;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// For multiple records, apply in descending sequence index order\n\t// Use selection approach for small arrays (typical case) to avoid alloc\n\tconst applied = new Uint8Array(len);\n\tfor (let round = 0; round < len; round++) {\n\t\t// Find max unapplied sequence index\n\t\tlet maxIdx = -1;\n\t\tlet maxSeq = -1;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (applied[i]) continue;\n\t\t\tconst seq = lookupRecords[i]?.sequenceIndex;\n\t\t\tif (seq > maxSeq) {\n\t\t\t\tmaxSeq = seq;\n\t\t\t\tmaxIdx = i;\n\t\t\t}\n\t\t}\n\t\tif (maxIdx < 0) break;\n\t\tapplied[maxIdx] = 1;\n\n\t\tconst record = lookupRecords[maxIdx]!;\n\t\tconst lookupEntry = plan.gsubLookupMap.get(record.lookupListIndex);\n\t\tif (!lookupEntry) continue;\n\t\tconst pos = startIndex + record.sequenceIndex;\n\t\tif (pos >= buffer.infos.length) continue;\n\t\tconst targetInfo = buffer.infos[pos];\n\t\tif (!targetInfo) continue;\n\n\t\tif (lookupEntry.lookup.type === GsubLookupType.Single) {\n\t\t\tconst replacement = applySingleSubst(\n\t\t\t\tlookupEntry.lookup as SingleSubstLookup,\n\t\t\t\ttargetInfo.glyphId,\n\t\t\t);\n\t\t\tif (replacement !== null) {\n\t\t\t\ttargetInfo.glyphId = replacement;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// GPOS application\n\nfunction initializePositions(face: Face, buffer: GlyphBuffer): void {\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst len = infos.length;\n\tconst hmtx = face.font.hmtx;\n\tconst hMetrics = hmtx.hMetrics;\n\tconst hMetricsLen = hMetrics.length;\n\tconst lastAdvance = hMetrics[hMetricsLen - 1]?.advanceWidth ?? 0;\n\tconst isVariable = face.normalizedCoords.length > 0;\n\n\t// Fast path for non-variable fonts - inline array access\n\tif (!isVariable) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst gid = infos[i]!.glyphId;\n\t\t\tpositions[i]!.xAdvance =\n\t\t\t\tgid < hMetricsLen ? (hMetrics[gid]?.advanceWidth ?? 0) : lastAdvance;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Variable font path - use Face for delta calculation\n\tfor (let i = 0; i < len; i++) {\n\t\tconst info = infos[i]!;\n\t\tpositions[i]!.xAdvance = face.advanceWidth(info.glyphId);\n\t}\n}\n\n/**\n * Glyph class cache for efficient repeated lookups during GPOS positioning.\n * Map from GlyphId to GlyphClass (avoids repeated GDEF lookups for same glyph).\n */\ntype GlyphClassCache = Map<GlyphId, number>;\n\n/**\n * Get glyph class with caching for O(1) repeated lookups.\n */\nfunction getCachedGlyphClass(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tcache: GlyphClassCache,\n): number {\n\tlet cls = cache.get(glyphId);\n\tif (cls === undefined) {\n\t\tcls = getGlyphClass(font.gdef, glyphId);\n\t\tcache.set(glyphId, cls);\n\t}\n\treturn cls;\n}\n\nfunction applyGpos(font: Font, buffer: GlyphBuffer, plan: ShapePlan): void {\n\t// Build buffer digest for fast lookup skipping\n\tconst bufferDigest = new SetDigest();\n\tconst infos = buffer.infos;\n\tconst len = buffer.length;\n\tfor (let i = 0; i < len; i++) {\n\t\tbufferDigest.add(infos[i]!.glyphId);\n\t}\n\n\t// Quick check for marks - avoid expensive base index build for simple Latin text\n\tconst hasMarks = hasAnyMarks(buffer, font);\n\n\t// Only build base index and glyph class cache if we have marks\n\t// This saves ~0.4s per call for simple Latin text\n\tlet baseIndexArray: Int16Array;\n\tlet glyphClassCache: GlyphClassCache;\n\tif (hasMarks) {\n\t\tglyphClassCache = new Map();\n\t\tbaseIndexArray = buildBaseIndexArray(buffer, glyphClassCache, font);\n\t} else {\n\t\t// Provide empty placeholders - these won't be used since hasMarks is false\n\t\tbaseIndexArray = _emptyBaseIndex;\n\t\tglyphClassCache = _emptyGlyphClassCache;\n\t}\n\n\tconst lookups = plan.gposLookups;\n\tfor (let i = 0; i < lookups.length; i++) {\n\t\tconst entry = lookups[i]!;\n\t\t// Skip entire lookup if no glyph in buffer could match\n\t\tif (!bufferDigest.mayIntersect(entry.lookup.digest)) continue;\n\n\t\tapplyGposLookup(\n\t\t\tfont,\n\t\t\tbuffer,\n\t\t\tentry.lookup,\n\t\t\tplan,\n\t\t\tglyphClassCache,\n\t\t\tbaseIndexArray,\n\t\t\thasMarks,\n\t\t);\n\t}\n}\n\n// Empty placeholders for non-mark text to avoid allocation\nconst _emptyBaseIndex = new Int16Array(0);\nconst _emptyGlyphClassCache: GlyphClassCache = new Map();\n\nfunction applyGposLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: AnyGposLookup,\n\tplan: ShapePlan,\n\tglyphClassCache: GlyphClassCache,\n\tbaseIndexArray: Int16Array,\n\thasMarks: boolean,\n): void {\n\tswitch (lookup.type) {\n\t\tcase GposLookupType.Single:\n\t\t\tapplySinglePosLookup(font, buffer, lookup, hasMarks);\n\t\t\tbreak;\n\t\tcase GposLookupType.Pair:\n\t\t\tapplyPairPosLookup(font, buffer, lookup, hasMarks);\n\t\t\tbreak;\n\t\tcase GposLookupType.Cursive:\n\t\t\tapplyCursivePosLookup(font, buffer, lookup, hasMarks);\n\t\t\tbreak;\n\t\tcase GposLookupType.MarkToBase:\n\t\t\t// Skip mark-to-base if no marks in buffer - O(1) check saves full buffer scan\n\t\t\tif (!hasMarks) break;\n\t\t\tapplyMarkBasePosLookup(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tlookup,\n\t\t\t\tglyphClassCache,\n\t\t\t\tbaseIndexArray,\n\t\t\t);\n\t\t\tbreak;\n\t\tcase GposLookupType.MarkToLigature:\n\t\t\t// Skip mark-to-ligature if no marks in buffer\n\t\t\tif (!hasMarks) break;\n\t\t\tapplyMarkLigaturePosLookup(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tlookup,\n\t\t\t\tglyphClassCache,\n\t\t\t\tbaseIndexArray,\n\t\t\t);\n\t\t\tbreak;\n\t\tcase GposLookupType.MarkToMark:\n\t\t\t// Skip mark-to-mark if no marks in buffer\n\t\t\tif (!hasMarks) break;\n\t\t\tapplyMarkMarkPosLookup(font, buffer, lookup, glyphClassCache);\n\t\t\tbreak;\n\t\tcase GposLookupType.Context:\n\t\t\tapplyContextPosLookup(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tlookup as ContextPosLookup,\n\t\t\t\tplan,\n\t\t\t\tglyphClassCache,\n\t\t\t\tbaseIndexArray,\n\t\t\t\thasMarks,\n\t\t\t);\n\t\t\tbreak;\n\t\tcase GposLookupType.ChainingContext:\n\t\t\tapplyChainingContextPosLookup(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tlookup as ChainingContextPosLookup,\n\t\t\t\tplan,\n\t\t\t\tglyphClassCache,\n\t\t\t\tbaseIndexArray,\n\t\t\t\thasMarks,\n\t\t\t);\n\t\t\tbreak;\n\t\t// Extension (type 9) is unwrapped during parsing - no runtime case needed\n\t}\n}\n\nfunction applySinglePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: SinglePosLookup,\n\thasMarks: boolean,\n): void {\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\tconst subtables = lookup.subtables;\n\n\t// FAST PATH: No skip checking needed (no flags, no GDEF, or no marks in buffer)\n\t// IgnoreMarks (0x10) is useless if there are no marks\n\tconst needsSkip = hasMarks && lookup.flag !== 0 && font.gdef !== null;\n\n\t// Optimized fast path: single subtable format 1 (common case)\n\tif (subtables.length === 1 && !needsSkip) {\n\t\tconst subtable = subtables[0]!;\n\t\tif (subtable.format === 1 && subtable.value) {\n\t\t\tconst value = subtable.value;\n\t\t\tconst hasX = value.xPlacement !== undefined && value.xPlacement !== 0;\n\t\t\tconst hasY = value.yPlacement !== undefined && value.yPlacement !== 0;\n\t\t\tconst hasXAdv = value.xAdvance !== undefined && value.xAdvance !== 0;\n\t\t\tconst hasYAdv = value.yAdvance !== undefined && value.yAdvance !== 0;\n\n\t\t\t// Skip entirely if all values are zero\n\t\t\tif (!hasX && !hasY && !hasXAdv && !hasYAdv) return;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst info = infos[i]!;\n\t\t\t\t// Fast digest check before expensive Coverage lookup\n\t\t\t\tif (!digest.mayHave(info.glyphId)) continue;\n\t\t\t\tif (subtable.coverage.get(info.glyphId) === null) continue;\n\t\t\t\tconst pos = positions[i]!;\n\t\t\t\tif (hasX) pos.xOffset += value.xPlacement!;\n\t\t\t\tif (hasY) pos.yOffset += value.yPlacement!;\n\t\t\t\tif (hasXAdv) pos.xAdvance += value.xAdvance!;\n\t\t\t\tif (hasYAdv) pos.yAdvance += value.yAdvance!;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Helper to apply single positioning at index i\n\tconst applySingle = (i: number) => {\n\t\tconst info = infos[i]!;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) return;\n\t\tconst pos = positions[i];\n\t\tif (!pos) return;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst coverageIndex = subtable.coverage.get(info.glyphId);\n\t\t\tif (coverageIndex === null) continue;\n\n\t\t\tconst value =\n\t\t\t\tsubtable.format === 1\n\t\t\t\t\t? subtable.value\n\t\t\t\t\t: subtable.values?.[coverageIndex];\n\t\t\tif (value) {\n\t\t\t\tif (value.xPlacement) pos.xOffset += value.xPlacement;\n\t\t\t\tif (value.yPlacement) pos.yOffset += value.yPlacement;\n\t\t\t\tif (value.xAdvance) pos.xAdvance += value.xAdvance;\n\t\t\t\tif (value.yAdvance) pos.yAdvance += value.yAdvance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tif (!needsSkip) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tapplySingle(i);\n\t\t}\n\t\treturn;\n\t}\n\n\t// WITH SKIP: Need to check each glyph\n\tconst skip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\tfor (let i = 0; i < len; i++) {\n\t\tif (skip[i]) continue;\n\t\tapplySingle(i);\n\t}\n}\n\nfunction applyPairPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: PairPosLookup,\n\thasMarks: boolean,\n): void {\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\tconst subtables = lookup.subtables;\n\tconst subtableCount = subtables.length;\n\n\t// FAST PATH: No skip checking needed (no flags, no GDEF, or no marks to skip)\n\t// This handles simple Latin text - O(n) with zero allocation\n\tconst needsSkip = hasMarks && lookup.flag !== 0 && font.gdef !== null;\n\tif (!needsSkip) {\n\t\t// SUPER-FAST PATH: Single subtable (very common for kerning)\n\t\t// Inline all logic to avoid function call overhead\n\t\tif (subtableCount === 1) {\n\t\t\tconst subtable = subtables[0]!;\n\t\t\tconst coverage = subtable.coverage;\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\t// Format 1: Per-glyph pair sets with binary search\n\t\t\t\tconst pairSets = subtable.pairSets;\n\t\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\t\tconst gid1 = infos[i]!.glyphId;\n\t\t\t\t\tif (!digest.mayHave(gid1)) continue;\n\t\t\t\t\tconst coverageIndex = coverage.get(gid1);\n\t\t\t\t\tif (coverageIndex === null) continue;\n\t\t\t\t\tconst pairSet = pairSets[coverageIndex];\n\t\t\t\t\tif (!pairSet) continue;\n\n\t\t\t\t\tconst gid2 = infos[i + 1]!.glyphId;\n\t\t\t\t\tconst records = pairSet.pairValueRecords;\n\t\t\t\t\t// Binary search for secondGlyph\n\t\t\t\t\tlet low = 0;\n\t\t\t\t\tlet high = records.length - 1;\n\t\t\t\t\twhile (low <= high) {\n\t\t\t\t\t\tconst mid = (low + high) >>> 1;\n\t\t\t\t\t\tconst record = records[mid]!;\n\t\t\t\t\t\tconst sg = record.secondGlyph;\n\t\t\t\t\t\tif (sg < gid2) {\n\t\t\t\t\t\t\tlow = mid + 1;\n\t\t\t\t\t\t} else if (sg > gid2) {\n\t\t\t\t\t\t\thigh = mid - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst xAdv1 = record.value1.xAdvance;\n\t\t\t\t\t\t\tif (xAdv1) positions[i]!.xAdvance += xAdv1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Format 2: Class-based kerning\n\t\t\t\tconst classDef1 = subtable.classDef1;\n\t\t\t\tconst classDef2 = subtable.classDef2;\n\t\t\t\tconst class1Records = subtable.class1Records;\n\t\t\t\tconst class1Count = class1Records.length;\n\n\t\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\t\tconst gid1 = infos[i]!.glyphId;\n\t\t\t\t\tif (!digest.mayHave(gid1)) continue;\n\t\t\t\t\tif (coverage.get(gid1) === null) continue;\n\n\t\t\t\t\tconst class1 = classDef1.get(gid1);\n\t\t\t\t\tif (class1 >= class1Count) continue;\n\t\t\t\t\tconst class1Record = class1Records[class1]!;\n\n\t\t\t\t\tconst gid2 = infos[i + 1]!.glyphId;\n\t\t\t\t\tconst class2 = classDef2.get(gid2);\n\t\t\t\t\tconst class2Records = class1Record.class2Records;\n\t\t\t\t\tif (class2 >= class2Records.length) continue;\n\n\t\t\t\t\tconst xAdv1 = class2Records[class2]!.value1.xAdvance;\n\t\t\t\t\tif (xAdv1) positions[i]!.xAdvance += xAdv1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// FAST PATH: Two subtables (Format 1 + Format 2) - common for kerning\n\t\t// Inline both lookups to avoid function call overhead\n\t\tif (subtableCount === 2) {\n\t\t\tconst st0 = subtables[0]!;\n\t\t\tconst st1 = subtables[1]!;\n\n\t\t\t// Common case: Format 1 (specific pairs) + Format 2 (class-based)\n\t\t\tif (st0.format === 1 && st1.format === 2) {\n\t\t\t\tconst cov0 = st0.coverage;\n\t\t\t\tconst pairSets = st0.pairSets;\n\t\t\t\tconst cov1 = st1.coverage;\n\t\t\t\tconst classDef1 = st1.classDef1;\n\t\t\t\tconst classDef2 = st1.classDef2;\n\t\t\t\tconst class1Records = st1.class1Records;\n\t\t\t\tconst class1Count = class1Records.length;\n\n\t\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\t\tconst gid1 = infos[i]!.glyphId;\n\t\t\t\t\tif (!digest.mayHave(gid1)) continue;\n\n\t\t\t\t\tconst gid2 = infos[i + 1]!.glyphId;\n\n\t\t\t\t\t// Try Format 1 first (specific pairs)\n\t\t\t\t\tconst covIdx0 = cov0.get(gid1);\n\t\t\t\t\tif (covIdx0 !== null) {\n\t\t\t\t\t\tconst pairSet = pairSets[covIdx0];\n\t\t\t\t\t\tif (pairSet) {\n\t\t\t\t\t\t\tconst records = pairSet.pairValueRecords;\n\t\t\t\t\t\t\tlet low = 0;\n\t\t\t\t\t\t\tlet high = records.length - 1;\n\t\t\t\t\t\t\tlet found = false;\n\t\t\t\t\t\t\twhile (low <= high) {\n\t\t\t\t\t\t\t\tconst mid = (low + high) >>> 1;\n\t\t\t\t\t\t\t\tconst record = records[mid]!;\n\t\t\t\t\t\t\t\tconst sg = record.secondGlyph;\n\t\t\t\t\t\t\t\tif (sg < gid2) {\n\t\t\t\t\t\t\t\t\tlow = mid + 1;\n\t\t\t\t\t\t\t\t} else if (sg > gid2) {\n\t\t\t\t\t\t\t\t\thigh = mid - 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst xAdv1 = record.value1.xAdvance;\n\t\t\t\t\t\t\t\t\tif (xAdv1) positions[i]!.xAdvance += xAdv1;\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back to Format 2 (class-based)\n\t\t\t\t\tif (cov1.get(gid1) !== null) {\n\t\t\t\t\t\tconst class1 = classDef1.get(gid1);\n\t\t\t\t\t\tif (class1 < class1Count) {\n\t\t\t\t\t\t\tconst class1Record = class1Records[class1]!;\n\t\t\t\t\t\t\tconst class2 = classDef2.get(gid2);\n\t\t\t\t\t\t\tconst class2Records = class1Record.class2Records;\n\t\t\t\t\t\t\tif (class2 < class2Records.length) {\n\t\t\t\t\t\t\t\tconst xAdv1 = class2Records[class2]!.value1.xAdvance;\n\t\t\t\t\t\t\t\tif (xAdv1) positions[i]!.xAdvance += xAdv1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Multiple subtables - use function call\n\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\tconst info1 = infos[i]!;\n\t\t\tif (!digest.mayHave(info1.glyphId)) continue;\n\t\t\tconst info2 = infos[i + 1]!;\n\t\t\tconst pos1 = positions[i]!;\n\t\t\tconst pos2 = positions[i + 1]!;\n\t\t\tapplyKerningDirect(lookup, info1.glyphId, info2.glyphId, pos1, pos2);\n\t\t}\n\t\treturn;\n\t}\n\n\t// OPTIMIZED PATH: With skip markers - O(n) with precomputed arrays\n\t// Used for complex text with marks that need to be skipped\n\tconst skip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\tconst nextNonSkip = buildNextNonSkipArray(skip, len);\n\n\tfor (let i = 0; i < len - 1; i++) {\n\t\tif (skip[i]) continue;\n\n\t\tconst j = nextNonSkip[i];\n\t\tif (j < 0) break;\n\n\t\tconst info1 = infos[i]!;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info1.glyphId)) continue;\n\t\tconst info2 = infos[j]!;\n\t\tconst pos1 = positions[i]!;\n\t\tconst pos2 = positions[j]!;\n\t\tapplyKerningDirect(lookup, info1.glyphId, info2.glyphId, pos1, pos2);\n\t}\n}\n\nfunction applyCursivePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: CursivePosLookup,\n\thasMarks: boolean,\n): void {\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\n\tconst subtables = lookup.subtables;\n\t// Helper to apply cursive positioning between glyphs at i and j\n\tconst applyCursive = (i: number, j: number) => {\n\t\tconst info1 = infos[i]!;\n\t\tconst info2 = infos[j]!;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info1.glyphId) && !digest.mayHave(info2.glyphId))\n\t\t\treturn;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst exitIndex = subtable.coverage.get(info1.glyphId);\n\t\t\tconst entryIndex = subtable.coverage.get(info2.glyphId);\n\n\t\t\tif (exitIndex === null || entryIndex === null) continue;\n\n\t\t\tconst exitRecord = subtable.entryExitRecords[exitIndex];\n\t\t\tconst entryRecord = subtable.entryExitRecords[entryIndex];\n\n\t\t\tif (!exitRecord?.exitAnchor || !entryRecord?.entryAnchor) continue;\n\n\t\t\tconst exitAnchor = exitRecord.exitAnchor;\n\t\t\tconst entryAnchor = entryRecord.entryAnchor;\n\n\t\t\tconst pos2 = positions[j];\n\t\t\tif (pos2) {\n\t\t\t\tpos2.yOffset = exitAnchor.yCoordinate - entryAnchor.yCoordinate;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t};\n\n\t// FAST PATH: No skip checking needed (no flags, no GDEF, or no marks)\n\tconst needsSkip = hasMarks && lookup.flag !== 0 && font.gdef !== null;\n\tif (!needsSkip) {\n\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\tapplyCursive(i, i + 1);\n\t\t}\n\t\treturn;\n\t}\n\n\t// OPTIMIZED PATH: With skip markers\n\tconst skip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\tconst nextNonSkip = buildNextNonSkipArray(skip, len);\n\n\tfor (let i = 0; i < len - 1; i++) {\n\t\tif (skip[i]) continue;\n\n\t\tconst j = nextNonSkip[i];\n\t\tif (j < 0) break;\n\n\t\tapplyCursive(i, j);\n\t}\n}\n\nfunction applyMarkBasePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MarkBasePosLookup,\n\tglyphClassCache: GlyphClassCache,\n\tbaseIndexArray: Int16Array,\n): void {\n\tconst digest = lookup.digest;\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst subtables = lookup.subtables;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst markInfo = infos[i];\n\t\tif (!markInfo) continue;\n\n\t\t// Fast digest check before expensive glyph class lookup\n\t\tif (!digest.mayHave(markInfo.glyphId)) continue;\n\n\t\t// Must be a mark glyph\n\t\tif (\n\t\t\tgetCachedGlyphClass(font, markInfo.glyphId, glyphClassCache) !==\n\t\t\tGlyphClass.Mark\n\t\t)\n\t\t\tcontinue;\n\n\t\t// Use pre-computed base index for O(1) lookup instead of O(n) backward scan\n\t\tconst baseIndex = baseIndexArray[i];\n\t\tif (baseIndex < 0) continue;\n\n\t\tconst baseInfo = infos[baseIndex];\n\t\tif (!baseInfo) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst markCoverageIndex = subtable.markCoverage.get(markInfo.glyphId);\n\t\t\tconst baseCoverageIndex = subtable.baseCoverage.get(baseInfo.glyphId);\n\n\t\t\tif (markCoverageIndex === null || baseCoverageIndex === null) continue;\n\n\t\t\tconst markRecord = subtable.markArray.markRecords[markCoverageIndex];\n\t\t\tconst baseRecord = subtable.baseArray[baseCoverageIndex];\n\n\t\t\tif (!markRecord || !baseRecord) continue;\n\n\t\t\tconst baseAnchor = baseRecord.baseAnchors[markRecord.markClass];\n\t\t\tif (!baseAnchor) continue;\n\n\t\t\tconst markAnchor = markRecord.markAnchor;\n\n\t\t\t// Position mark relative to base\n\t\t\tconst markPos = positions[i];\n\t\t\tconst basePos = positions[baseIndex];\n\t\t\tif (!markPos || !basePos) continue;\n\n\t\t\tmarkPos.xOffset =\n\t\t\t\tbaseAnchor.xCoordinate - markAnchor.xCoordinate + basePos.xOffset;\n\t\t\tmarkPos.yOffset =\n\t\t\t\tbaseAnchor.yCoordinate - markAnchor.yCoordinate + basePos.yOffset;\n\n\t\t\t// Mark doesn't advance cursor\n\t\t\tmarkPos.xAdvance = 0;\n\t\t\tmarkPos.yAdvance = 0;\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyMarkLigaturePosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MarkLigaturePosLookup,\n\tglyphClassCache: GlyphClassCache,\n\tbaseIndexArray: Int16Array,\n): void {\n\tconst digest = lookup.digest;\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst subtables = lookup.subtables;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst markInfo = infos[i];\n\t\tif (!markInfo) continue;\n\n\t\t// Fast digest check before expensive glyph class lookup\n\t\tif (!digest.mayHave(markInfo.glyphId)) continue;\n\n\t\tif (\n\t\t\tgetCachedGlyphClass(font, markInfo.glyphId, glyphClassCache) !==\n\t\t\tGlyphClass.Mark\n\t\t)\n\t\t\tcontinue;\n\n\t\t// Use pre-computed base index for O(1) lookup\n\t\tconst ligIndex = baseIndexArray[i];\n\t\tif (ligIndex < 0) continue;\n\n\t\tconst ligInfo = infos[ligIndex];\n\t\tif (!ligInfo) continue;\n\n\t\t// Must be a ligature\n\t\tif (\n\t\t\tgetCachedGlyphClass(font, ligInfo.glyphId, glyphClassCache) !==\n\t\t\tGlyphClass.Ligature\n\t\t)\n\t\t\tcontinue;\n\n\t\t// Count intervening marks to determine component index\n\t\tlet componentIndex = 0;\n\t\tfor (let j = ligIndex + 1; j < i; j++) {\n\t\t\tconst midInfo = infos[j];\n\t\t\tif (\n\t\t\t\tmidInfo &&\n\t\t\t\tgetCachedGlyphClass(font, midInfo.glyphId, glyphClassCache) ===\n\t\t\t\t\tGlyphClass.Mark\n\t\t\t) {\n\t\t\t\tcomponentIndex++;\n\t\t\t}\n\t\t}\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst markCoverageIndex = subtable.markCoverage.get(markInfo.glyphId);\n\t\t\tconst ligCoverageIndex = subtable.ligatureCoverage.get(ligInfo.glyphId);\n\n\t\t\tif (markCoverageIndex === null || ligCoverageIndex === null) continue;\n\n\t\t\tconst markRecord = subtable.markArray.markRecords[markCoverageIndex];\n\t\t\tconst ligAttach = subtable.ligatureArray[ligCoverageIndex];\n\n\t\t\tif (!markRecord || !ligAttach) continue;\n\n\t\t\t// Clamp component index\n\t\t\tconst compIdx = Math.min(\n\t\t\t\tcomponentIndex,\n\t\t\t\tligAttach.componentRecords.length - 1,\n\t\t\t);\n\t\t\tconst component = ligAttach.componentRecords[compIdx];\n\t\t\tif (!component) continue;\n\n\t\t\tconst ligAnchor = component.ligatureAnchors[markRecord.markClass];\n\t\t\tif (!ligAnchor) continue;\n\n\t\t\tconst markAnchor = markRecord.markAnchor;\n\t\t\tconst markPos = positions[i];\n\t\t\tconst ligPos = positions[ligIndex];\n\t\t\tif (!markPos || !ligPos) continue;\n\n\t\t\tmarkPos.xOffset =\n\t\t\t\tligAnchor.xCoordinate - markAnchor.xCoordinate + ligPos.xOffset;\n\t\t\tmarkPos.yOffset =\n\t\t\t\tligAnchor.yCoordinate - markAnchor.yCoordinate + ligPos.yOffset;\n\t\t\tmarkPos.xAdvance = 0;\n\t\t\tmarkPos.yAdvance = 0;\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction applyMarkMarkPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: MarkMarkPosLookup,\n\tglyphClassCache: GlyphClassCache,\n): void {\n\tconst digest = lookup.digest;\n\tconst infos = buffer.infos;\n\tconst positions = buffer.positions;\n\tconst subtables = lookup.subtables;\n\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst mark1Info = infos[i];\n\t\tif (!mark1Info) continue;\n\n\t\t// Fast digest check before expensive glyph class lookup\n\t\tif (!digest.mayHave(mark1Info.glyphId)) continue;\n\n\t\tif (\n\t\t\tgetCachedGlyphClass(font, mark1Info.glyphId, glyphClassCache) !==\n\t\t\tGlyphClass.Mark\n\t\t)\n\t\t\tcontinue;\n\n\t\t// Find preceding mark (mark2) - must be immediately preceding\n\t\tlet mark2Index = -1;\n\t\tif (i > 0) {\n\t\t\tconst prevInfo = infos[i - 1];\n\t\t\tif (prevInfo) {\n\t\t\t\tconst prevClass = getCachedGlyphClass(\n\t\t\t\t\tfont,\n\t\t\t\t\tprevInfo.glyphId,\n\t\t\t\t\tglyphClassCache,\n\t\t\t\t);\n\t\t\t\tif (prevClass === GlyphClass.Mark) {\n\t\t\t\t\tmark2Index = i - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mark2Index < 0) continue;\n\t\tconst mark2Info = infos[mark2Index];\n\t\tif (!mark2Info) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tconst mark1CoverageIndex = subtable.mark1Coverage.get(mark1Info.glyphId);\n\t\t\tconst mark2CoverageIndex = subtable.mark2Coverage.get(mark2Info.glyphId);\n\n\t\t\tif (mark1CoverageIndex === null || mark2CoverageIndex === null) continue;\n\n\t\t\tconst mark1Record = subtable.mark1Array.markRecords[mark1CoverageIndex];\n\t\t\tconst mark2Record = subtable.mark2Array[mark2CoverageIndex];\n\n\t\t\tif (!mark1Record || !mark2Record) continue;\n\n\t\t\tconst mark2Anchor = mark2Record.mark2Anchors[mark1Record.markClass];\n\t\t\tif (!mark2Anchor) continue;\n\n\t\t\tconst mark1Anchor = mark1Record.markAnchor;\n\t\t\tconst mark1Pos = positions[i];\n\t\t\tconst mark2Pos = positions[mark2Index];\n\t\t\tif (!mark1Pos || !mark2Pos) continue;\n\n\t\t\tmark1Pos.xOffset =\n\t\t\t\tmark2Anchor.xCoordinate - mark1Anchor.xCoordinate + mark2Pos.xOffset;\n\t\t\tmark1Pos.yOffset =\n\t\t\t\tmark2Anchor.yCoordinate - mark1Anchor.yCoordinate + mark2Pos.yOffset;\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// GPOS Context positioning\n\nfunction applyContextPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ContextPosLookup,\n\tplan: ShapePlan,\n\tglyphClassCache: GlyphClassCache,\n\tbaseIndexArray: Int16Array,\n\thasMarks: boolean,\n): void {\n\tconst infos = buffer.infos;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\tconst subtables = lookup.subtables;\n\n\t// Pre-compute skip markers only if needed\n\tlet skip: Uint8Array | null = null;\n\tif (lookup.flag !== 0 && font.gdef !== null) {\n\t\tskip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\t}\n\n\tfor (let i = 0; i < len; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tif (skip?.[i]) continue;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: PosLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchContextPosFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchContextPosFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (matchContextPosFormat3(font, buffer, i, subtable, lookup.flag)) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedPosLookups(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tlookupRecords,\n\t\t\t\t\tplan,\n\t\t\t\t\tglyphClassCache,\n\t\t\t\t\tbaseIndexArray,\n\t\t\t\t\thasMarks,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction applyChainingContextPosLookup(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tlookup: ChainingContextPosLookup,\n\tplan: ShapePlan,\n\tglyphClassCache: GlyphClassCache,\n\tbaseIndexArray: Int16Array,\n\thasMarks: boolean,\n): void {\n\tconst infos = buffer.infos;\n\tconst len = infos.length;\n\tconst digest = lookup.digest;\n\tconst subtables = lookup.subtables;\n\n\t// Pre-compute skip markers only if needed\n\tlet skip: Uint8Array | null = null;\n\tif (lookup.flag !== 0 && font.gdef !== null) {\n\t\tskip = precomputeSkipMarkers(font, buffer, lookup.flag);\n\t}\n\n\tfor (let i = 0; i < len; i++) {\n\t\tconst info = infos[i];\n\t\tif (!info) continue;\n\t\tif (skip?.[i]) continue;\n\t\t// Fast digest check before expensive Coverage lookup\n\t\tif (!digest.mayHave(info.glyphId)) continue;\n\n\t\tfor (let s = 0; s < subtables.length; s++) {\n\t\t\tconst subtable = subtables[s]!;\n\t\t\tlet matched = false;\n\t\t\tlet lookupRecords: PosLookupRecord[] = [];\n\n\t\t\tif (subtable.format === 1) {\n\t\t\t\tconst result = matchChainingContextPosFormat1(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 2) {\n\t\t\t\tconst result = matchChainingContextPosFormat2(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tsubtable,\n\t\t\t\t\tlookup.flag,\n\t\t\t\t);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = result;\n\t\t\t\t}\n\t\t\t} else if (subtable.format === 3) {\n\t\t\t\tif (\n\t\t\t\t\tmatchChainingContextPosFormat3(font, buffer, i, subtable, lookup.flag)\n\t\t\t\t) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tlookupRecords = subtable.lookupRecords;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (matched) {\n\t\t\t\tapplyNestedPosLookups(\n\t\t\t\t\tfont,\n\t\t\t\t\tbuffer,\n\t\t\t\t\ti,\n\t\t\t\t\tlookupRecords,\n\t\t\t\t\tplan,\n\t\t\t\t\tglyphClassCache,\n\t\t\t\t\tbaseIndexArray,\n\t\t\t\t\thasMarks,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Match Context Pos Format 1 - glyph-based rules */\nfunction matchContextPosFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextPosFormat1,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst ruleSet = subtable.ruleSets[coverageIndex];\n\tif (!ruleSet) return null;\n\n\tfor (let r = 0; r < ruleSet.length; r++) {\n\t\tconst rule = ruleSet[r]!;\n\t\tif (\n\t\t\tmatchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Pos Format 2 - class-based rules */\nfunction matchContextPosFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextPosFormat2,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.classDef.get(firstGlyph);\n\tconst classRuleSet = subtable.classRuleSets[firstClass];\n\tif (!classRuleSet) return null;\n\n\tfor (let r = 0; r < classRuleSet.length; r++) {\n\t\tconst rule = classRuleSet[r]!;\n\t\tif (\n\t\t\tmatchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.classDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\treturn rule.lookupRecords;\n\t\t}\n\t}\n\treturn null;\n}\n\n/** Match Context Pos Format 3 - coverage-based */\nfunction matchContextPosFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ContextPosFormat3,\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\tconst coverages = subtable.coverages;\n\tlet pos = startIndex;\n\tfor (let c = 0; c < coverages.length; c++) {\n\t\tconst coverage = coverages[c]!;\n\t\twhile (\n\t\t\tpos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= infos.length) return false;\n\t\tif (coverage.get(infos[pos]?.glyphId) === null) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match Chaining Context Pos Format 1 - glyph-based rules */\nfunction matchChainingContextPosFormat1(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextPosFormat1,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst chainRuleSet = subtable.chainRuleSets[coverageIndex];\n\tif (!chainRuleSet) return null;\n\n\tfor (let r = 0; r < chainRuleSet.length; r++) {\n\t\tconst rule = chainRuleSet[r]!;\n\t\t// Check backtrack (reversed order, before startIndex)\n\t\tif (\n\t\t\t!matchGlyphSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input (excluding first glyph which is in coverage)\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input sequence ends\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputSequence.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < buffer.infos.length &&\n\t\t\t\tshouldSkipGlyph(font, buffer.infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead\n\t\tif (\n\t\t\t!matchGlyphSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadSequence,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Pos Format 2 - class-based rules */\nfunction matchChainingContextPosFormat2(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextPosFormat2,\n\tlookupFlag: number,\n): PosLookupRecord[] | null {\n\tconst firstGlyph = buffer.infos[startIndex]?.glyphId;\n\tconst coverageIndex = subtable.coverage.get(firstGlyph);\n\tif (coverageIndex === null) return null;\n\n\tconst firstClass = subtable.inputClassDef.get(firstGlyph);\n\tconst chainClassRuleSet = subtable.chainClassRuleSets[firstClass];\n\tif (!chainClassRuleSet) return null;\n\n\tfor (let r = 0; r < chainClassRuleSet.length; r++) {\n\t\tconst rule = chainClassRuleSet[r]!;\n\t\t// Check backtrack classes (reversed order)\n\t\tif (\n\t\t\t!matchClassSequenceBackward(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex - 1,\n\t\t\t\trule.backtrackClasses,\n\t\t\t\tsubtable.backtrackClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check input classes (excluding first)\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tstartIndex + 1,\n\t\t\t\trule.inputClasses,\n\t\t\t\tsubtable.inputClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Find where input ends\n\t\tconst infos = buffer.infos;\n\t\tlet inputEnd = startIndex + 1;\n\t\tfor (let i = 0; i < rule.inputClasses.length; i++) {\n\t\t\twhile (\n\t\t\t\tinputEnd < infos.length &&\n\t\t\t\tshouldSkipGlyph(font, infos[inputEnd]?.glyphId, lookupFlag)\n\t\t\t) {\n\t\t\t\tinputEnd++;\n\t\t\t}\n\t\t\tinputEnd++;\n\t\t}\n\n\t\t// Check lookahead classes\n\t\tif (\n\t\t\t!matchClassSequence(\n\t\t\t\tfont,\n\t\t\t\tbuffer,\n\t\t\t\tinputEnd,\n\t\t\t\trule.lookaheadClasses,\n\t\t\t\tsubtable.lookaheadClassDef,\n\t\t\t\tlookupFlag,\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn rule.lookupRecords;\n\t}\n\treturn null;\n}\n\n/** Match Chaining Context Pos Format 3 - coverage-based */\nfunction matchChainingContextPosFormat3(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tsubtable: ChainingContextPosFormat3,\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\t// Check backtrack (in reverse order, before startIndex)\n\tlet backtrackPos = startIndex - 1;\n\tconst backtrackCoverages = subtable.backtrackCoverages;\n\tfor (let b = 0; b < backtrackCoverages.length; b++) {\n\t\tconst coverage = backtrackCoverages[b]!;\n\t\twhile (\n\t\t\tbacktrackPos >= 0 &&\n\t\t\tshouldSkipGlyph(font, infos[backtrackPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tbacktrackPos--;\n\t\t}\n\t\tif (backtrackPos < 0) return false;\n\t\tif (coverage.get(infos[backtrackPos]?.glyphId) === null) return false;\n\t\tbacktrackPos--;\n\t}\n\n\t// Check input sequence\n\tlet inputPos = startIndex;\n\tconst inputCoverages = subtable.inputCoverages;\n\tfor (let i = 0; i < inputCoverages.length; i++) {\n\t\tconst coverage = inputCoverages[i]!;\n\t\twhile (\n\t\t\tinputPos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[inputPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tinputPos++;\n\t\t}\n\t\tif (inputPos >= infos.length) return false;\n\t\tif (coverage.get(infos[inputPos]?.glyphId) === null) return false;\n\t\tinputPos++;\n\t}\n\n\t// Check lookahead\n\tlet lookaheadPos = inputPos;\n\tconst lookaheadCoverages = subtable.lookaheadCoverages;\n\tfor (let l = 0; l < lookaheadCoverages.length; l++) {\n\t\tconst coverage = lookaheadCoverages[l]!;\n\t\twhile (\n\t\t\tlookaheadPos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[lookaheadPos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tlookaheadPos++;\n\t\t}\n\t\tif (lookaheadPos >= infos.length) return false;\n\t\tif (coverage.get(infos[lookaheadPos]?.glyphId) === null) return false;\n\t\tlookaheadPos++;\n\t}\n\n\treturn true;\n}\n\n/** Apply nested positioning lookups at specific positions */\nfunction applyNestedPosLookups(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartIndex: number,\n\tlookupRecords: PosLookupRecord[],\n\tplan: ShapePlan,\n\tglyphClassCache: GlyphClassCache,\n\tbaseIndexArray: Int16Array,\n\thasMarks: boolean,\n): void {\n\tconst len = lookupRecords.length;\n\tif (len === 0) return;\n\n\t// Fast path for single record (common case)\n\tif (len === 1) {\n\t\tconst record = lookupRecords[0]!;\n\t\tconst lookupEntry = plan.gposLookupMap.get(record.lookupListIndex);\n\t\tif (!lookupEntry) return;\n\t\tconst pos = startIndex + record.sequenceIndex;\n\t\tif (pos >= buffer.infos.length) return;\n\t\tapplyGposLookup(\n\t\t\tfont,\n\t\t\tbuffer,\n\t\t\tlookupEntry.lookup,\n\t\t\tplan,\n\t\t\tglyphClassCache,\n\t\t\tbaseIndexArray,\n\t\t\thasMarks,\n\t\t);\n\t\treturn;\n\t}\n\n\t// For multiple records, apply in descending sequence index order\n\t// Use selection approach for small arrays (typical case) to avoid alloc\n\tconst applied = new Uint8Array(len);\n\tfor (let round = 0; round < len; round++) {\n\t\tlet maxIdx = -1;\n\t\tlet maxSeq = -1;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (applied[i]) continue;\n\t\t\tconst seq = lookupRecords[i]!.sequenceIndex;\n\t\t\tif (seq > maxSeq) {\n\t\t\t\tmaxSeq = seq;\n\t\t\t\tmaxIdx = i;\n\t\t\t}\n\t\t}\n\t\tif (maxIdx < 0) break;\n\t\tapplied[maxIdx] = 1;\n\n\t\tconst record = lookupRecords[maxIdx]!;\n\t\tconst lookupEntry = plan.gposLookupMap.get(record.lookupListIndex);\n\t\tif (!lookupEntry) continue;\n\t\tconst pos = startIndex + record.sequenceIndex;\n\t\tif (pos >= buffer.infos.length) continue;\n\t\tapplyGposLookup(\n\t\t\tfont,\n\t\t\tbuffer,\n\t\t\tlookupEntry.lookup,\n\t\t\tplan,\n\t\t\tglyphClassCache,\n\t\t\tbaseIndexArray,\n\t\t\thasMarks,\n\t\t);\n\t}\n}\n\n// Sequence matching helpers\n\n/** Match a sequence of specific glyphs forward */\nfunction matchGlyphSequence(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tglyphs: GlyphId[],\n\tlookupFlag: number,\n): boolean {\n\tlet pos = startPos;\n\tfor (let g = 0; g < glyphs.length; g++) {\n\t\tconst glyph = glyphs[g]!;\n\t\twhile (\n\t\t\tpos < buffer.infos.length &&\n\t\t\tshouldSkipGlyph(font, buffer.infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= buffer.infos.length) return false;\n\t\tif (buffer.infos[pos]?.glyphId !== glyph) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match a sequence of specific glyphs backward */\nfunction matchGlyphSequenceBackward(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tglyphs: GlyphId[],\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\tlet pos = startPos;\n\tfor (let g = 0; g < glyphs.length; g++) {\n\t\tconst glyph = glyphs[g]!;\n\t\twhile (pos >= 0 && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {\n\t\t\tpos--;\n\t\t}\n\t\tif (pos < 0) return false;\n\t\tif (infos[pos]?.glyphId !== glyph) return false;\n\t\tpos--;\n\t}\n\treturn true;\n}\n\n/** Match a sequence of classes forward */\nfunction matchClassSequence(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tclasses: number[],\n\tclassDef: ClassDef,\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\tlet pos = startPos;\n\tfor (let c = 0; c < classes.length; c++) {\n\t\tconst cls = classes[c]!;\n\t\twhile (\n\t\t\tpos < infos.length &&\n\t\t\tshouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)\n\t\t) {\n\t\t\tpos++;\n\t\t}\n\t\tif (pos >= infos.length) return false;\n\t\tif (classDef.get(infos[pos]?.glyphId) !== cls) return false;\n\t\tpos++;\n\t}\n\treturn true;\n}\n\n/** Match a sequence of classes backward */\nfunction matchClassSequenceBackward(\n\tfont: Font,\n\tbuffer: GlyphBuffer,\n\tstartPos: number,\n\tclasses: number[],\n\tclassDef: ClassDef,\n\tlookupFlag: number,\n): boolean {\n\tconst infos = buffer.infos;\n\tlet pos = startPos;\n\tfor (let c = 0; c < classes.length; c++) {\n\t\tconst cls = classes[c]!;\n\t\twhile (pos >= 0 && shouldSkipGlyph(font, infos[pos]?.glyphId, lookupFlag)) {\n\t\t\tpos--;\n\t\t}\n\t\tif (pos < 0) return false;\n\t\tif (classDef.get(infos[pos]?.glyphId) !== cls) return false;\n\t\tpos--;\n\t}\n\treturn true;\n}\n\n// Utility\n\nfunction shouldSkipGlyph(\n\tfont: Font,\n\tglyphId: GlyphId,\n\tlookupFlag: number,\n): boolean {\n\t// Fast path: if no ignore flags are set, nothing to skip\n\t// This avoids GDEF lookup for the common case of lookupFlag === 0\n\tif ((lookupFlag & 0x000e) === 0 && (lookupFlag & 0xff00) === 0) return false;\n\n\tconst gdef = font.gdef;\n\tif (!gdef) return false;\n\n\tconst glyphClass = getGlyphClass(gdef, glyphId);\n\n\tif (\n\t\tlookupFlag & LookupFlag.IgnoreBaseGlyphs &&\n\t\tglyphClass === GlyphClass.Base\n\t)\n\t\treturn true;\n\tif (\n\t\tlookupFlag & LookupFlag.IgnoreLigatures &&\n\t\tglyphClass === GlyphClass.Ligature\n\t)\n\t\treturn true;\n\tif (lookupFlag & LookupFlag.IgnoreMarks && glyphClass === GlyphClass.Mark)\n\t\treturn true;\n\n\tconst markAttachmentType = getMarkAttachmentType(lookupFlag);\n\tif (markAttachmentType !== 0 && glyphClass === GlyphClass.Mark) {\n\t\tconst glyphMarkClass = gdef.markAttachClassDef.get(glyphId);\n\t\tif (glyphMarkClass !== markAttachmentType) return true;\n\t}\n\n\treturn false;\n}\n\n// AAT morx substitution\n\nfunction applyMorx(font: Font, buffer: GlyphBuffer): void {\n\tconst morx = font.morx;\n\tif (!morx) return;\n\n\tconst chains = morx.chains;\n\tfor (let c = 0; c < chains.length; c++) {\n\t\tconst chain = chains[c]!;\n\t\tconst chainSubtables = chain.subtables;\n\t\tfor (let s = 0; s < chainSubtables.length; s++) {\n\t\t\tconst subtable = chainSubtables[s]!;\n\t\t\t// Apply if subFeatureFlags match (default: all enabled)\n\t\t\tif ((chain.defaultFlags & subtable.subFeatureFlags) === 0) continue;\n\n\t\t\tswitch (subtable.type) {\n\t\t\t\tcase MorxSubtableType.NonContextual: {\n\t\t\t\t\t// Simple substitution (Type 4)\n\t\t\t\t\tconst infos = buffer.infos;\n\t\t\t\t\tfor (let i = 0; i < infos.length; i++) {\n\t\t\t\t\t\tconst info = infos[i]!;\n\t\t\t\t\t\tconst replacement = applyNonContextual(\n\t\t\t\t\t\t\tsubtable as MorxNonContextualSubtable,\n\t\t\t\t\t\t\tinfo.glyphId,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (replacement !== null) {\n\t\t\t\t\t\t\tinfo.glyphId = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MorxSubtableType.Rearrangement:\n\t\t\t\t\t// Rearrangement (Type 0) - reorder glyphs\n\t\t\t\t\tprocessRearrangement(\n\t\t\t\t\t\tsubtable as MorxRearrangementSubtable,\n\t\t\t\t\t\tbuffer.infos,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MorxSubtableType.Contextual:\n\t\t\t\t\t// Contextual substitution (Type 1)\n\t\t\t\t\tprocessContextual(subtable as MorxContextualSubtable, buffer.infos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MorxSubtableType.Ligature: {\n\t\t\t\t\t// Ligature (Type 2)\n\t\t\t\t\tconst newInfos = processLigature(\n\t\t\t\t\t\tsubtable as MorxLigatureSubtable,\n\t\t\t\t\t\tbuffer.infos,\n\t\t\t\t\t);\n\t\t\t\t\t// Update buffer with new infos (may be shorter due to ligatures)\n\t\t\t\t\tif (newInfos.length !== buffer.infos.length) {\n\t\t\t\t\t\tbuffer.initFromInfos(newInfos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase MorxSubtableType.Insertion: {\n\t\t\t\t\t// Insertion (Type 5)\n\t\t\t\t\tconst newInfos = processInsertion(\n\t\t\t\t\t\tsubtable as MorxInsertionSubtable,\n\t\t\t\t\t\tbuffer.infos,\n\t\t\t\t\t);\n\t\t\t\t\t// Update buffer with new infos (may be longer due to insertions)\n\t\t\t\t\tif (newInfos.length !== buffer.infos.length) {\n\t\t\t\t\t\tbuffer.initFromInfos(newInfos);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Export internal functions for testing coverage\nexport const __testing = {\n\tapplyGsubLookup,\n\tapplyGposLookup,\n\tapplySingleSubstLookup,\n\tapplyMultipleSubstLookup,\n\tapplyAlternateSubstLookup,\n\tapplyLigatureSubstLookup,\n\tapplyContextSubstLookup,\n\tapplyChainingContextSubstLookup,\n\tapplyReverseChainingSingleSubstLookup,\n\tapplySinglePosLookup,\n\tapplyPairPosLookup,\n\tapplyCursivePosLookup,\n\tapplyMarkBasePosLookup,\n\tapplyMarkLigaturePosLookup,\n\tapplyMarkMarkPosLookup,\n\tapplyContextPosLookup,\n\tapplyChainingContextPosLookup,\n\tmatchContextFormat1,\n\tmatchContextFormat2,\n\tmatchContextFormat3,\n\tmatchChainingFormat1,\n\tmatchChainingFormat2,\n\tmatchChainingFormat3,\n\tmatchContextPosFormat1,\n\tmatchContextPosFormat2,\n\tmatchContextPosFormat3,\n\tmatchChainingContextPosFormat1,\n\tmatchChainingContextPosFormat2,\n\tmatchChainingContextPosFormat3,\n\tmatchGlyphSequence,\n\tmatchGlyphSequenceBackward,\n\tmatchClassSequence,\n\tmatchClassSequenceBackward,\n\tshouldSkipGlyph,\n\tprecomputeSkipMarkers,\n\tbuildNextNonSkipArray,\n\tapplyNestedLookups,\n\tapplyNestedPosLookups,\n\tapplyMorx,\n};\n",
    "// Bidi bracket pairs data, auto generated\nexport default {\n\tpairs:\n\t\t\"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n\tcanonical:\n\t\t\"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\",\n};\n",
    "/**\n * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n * mirroring characters. Returns an object holding the `map`, and optionally a `reverseMap`.\n */\nexport function parseCharacterMap(\n\tencodedString: string,\n\tincludeReverse: boolean,\n): { map: Map<string, string>; reverseMap: Map<string, string> | null } {\n\tconst radix = 36;\n\tlet lastCode = 0;\n\tconst map = new Map<string, string>();\n\tconst reverseMap = includeReverse ? new Map<string, string>() : null;\n\tlet prevPair = \"\";\n\n\tfunction visit(entry: string): void {\n\t\tif (entry.indexOf(\"+\") !== -1) {\n\t\t\tfor (let i = +entry; i--; ) {\n\t\t\t\tvisit(prevPair);\n\t\t\t}\n\t\t} else {\n\t\t\tprevPair = entry;\n\t\t\tconst parts = entry.split(\">\");\n\t\t\tconst aStr = parts[0] ?? \"\";\n\t\t\tconst bStr = parts[1] ?? \"\";\n\t\t\tlastCode += parseInt(aStr, radix);\n\t\t\tconst a = String.fromCodePoint(lastCode);\n\t\t\tlastCode += parseInt(bStr, radix);\n\t\t\tconst b = String.fromCodePoint(lastCode);\n\t\t\tmap.set(a, b);\n\t\t\tif (reverseMap) {\n\t\t\t\treverseMap.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tencodedString.split(\",\").forEach(visit);\n\treturn { map, reverseMap };\n}\n",
    "/**\n * Bidi bracket pair functions\n * Port of bidi-js brackets.js\n */\n\nimport data from \"./brackets.gen.ts\";\nimport { parseCharacterMap } from \"./parse-character-map.ts\";\n\nlet openToClose: Map<string, string> | null = null;\nlet closeToOpen: Map<string, string> | null = null;\nlet canonical: Map<string, string> | null = null;\n\nfunction parse(): void {\n\tif (!openToClose) {\n\t\tconst { map, reverseMap } = parseCharacterMap(data.pairs, true);\n\t\topenToClose = map;\n\t\tcloseToOpen = reverseMap;\n\t\tcanonical = parseCharacterMap(data.canonical, false).map;\n\t}\n}\n\n/**\n * Get the closing bracket character for an opening bracket\n * @param char Opening bracket character\n * @returns Corresponding closing bracket character, or null if not an opening bracket\n */\nexport function openingToClosingBracket(char: string): string | null {\n\tparse();\n\treturn openToClose?.get(char) || null;\n}\n\n/**\n * Get the opening bracket character for a closing bracket\n * @param char Closing bracket character\n * @returns Corresponding opening bracket character, or null if not a closing bracket\n */\nexport function closingToOpeningBracket(char: string): string | null {\n\tparse();\n\treturn closeToOpen?.get(char) || null;\n}\n\n/**\n * Get the canonical bracket character for a bracket\n * @param char Bracket character\n * @returns Canonical form of the bracket character, or null if not applicable\n */\nexport function getCanonicalBracket(char: string): string | null {\n\tparse();\n\treturn canonical?.get(char) || null;\n}\n",
    "// Bidi character types data, auto generated\nexport default {\n\tR: \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n\tEN: \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n\tES: \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n\tET: \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n\tAN: \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n\tCS: \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n\tB: \"a,3,f+2,2v,690\",\n\tS: \"9,2,k\",\n\tWS: \"c,k,4f4,1vk+a,u,1j,335\",\n\tON: \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n\tBN: \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n\tNSM: \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n\tAL: \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n\tLRO: \"6ct\",\n\tRLO: \"6cu\",\n\tLRE: \"6cq\",\n\tRLE: \"6cr\",\n\tPDF: \"6cs\",\n\tLRI: \"6ee\",\n\tRLI: \"6ef\",\n\tFSI: \"6eg\",\n\tPDI: \"6eh\",\n};\n",
    "/**\n * Bidi character type detection\n * Port of bidi-js charTypes.js\n */\n\nimport DATA from \"./char-types.gen.ts\";\n\nexport const TYPES: Record<string, number> = {};\nexport const TYPES_TO_NAMES: Record<number, string> = {};\nTYPES.L = 1; // L is the default\nTYPES_TO_NAMES[1] = \"L\";\n\nObject.keys(DATA).forEach((type, i) => {\n\tTYPES[type] = 1 << (i + 1);\n\tconst typeVal = TYPES[type];\n\tif (typeVal !== undefined) {\n\t\tTYPES_TO_NAMES[typeVal] = type;\n\t}\n});\n\nObject.freeze(TYPES);\n\n// Helper to get type value with fallback\nfunction getType(name: string): number {\n\treturn TYPES[name] ?? 0;\n}\n\nexport const ISOLATE_INIT_TYPES =\n\tgetType(\"LRI\") | getType(\"RLI\") | getType(\"FSI\");\nexport const STRONG_TYPES = getType(\"L\") | getType(\"R\") | getType(\"AL\");\nexport const NEUTRAL_ISOLATE_TYPES =\n\tgetType(\"B\") |\n\tgetType(\"S\") |\n\tgetType(\"WS\") |\n\tgetType(\"ON\") |\n\tgetType(\"FSI\") |\n\tgetType(\"LRI\") |\n\tgetType(\"RLI\") |\n\tgetType(\"PDI\");\nexport const BN_LIKE_TYPES =\n\tgetType(\"BN\") |\n\tgetType(\"RLE\") |\n\tgetType(\"LRE\") |\n\tgetType(\"RLO\") |\n\tgetType(\"LRO\") |\n\tgetType(\"PDF\");\nexport const TRAILING_TYPES =\n\tgetType(\"S\") |\n\tgetType(\"WS\") |\n\tgetType(\"B\") |\n\tISOLATE_INIT_TYPES |\n\tgetType(\"PDI\") |\n\tBN_LIKE_TYPES;\n\nlet map: Map<number, number> | null = null;\n\nfunction parseData(): void {\n\tif (!map) {\n\t\tmap = new Map();\n\t\tlet start = 0;\n\t\tfor (const type in DATA) {\n\t\t\tif (Object.hasOwn(DATA, type)) {\n\t\t\t\tconst segments = DATA[type as keyof typeof DATA];\n\t\t\t\tlet temp = \"\";\n\t\t\t\tlet end = 0;\n\t\t\t\tlet state = false;\n\t\t\t\tlet lastCode = 0; // Reset for each type - data is encoded relative to 0\n\t\t\t\tfor (let i = 0; i <= segments.length + 1; i += 1) {\n\t\t\t\t\tconst char = segments[i];\n\t\t\t\t\tif (char !== \",\" && i !== segments.length) {\n\t\t\t\t\t\tif (char === \"+\") {\n\t\t\t\t\t\t\tstate = true;\n\t\t\t\t\t\t\tlastCode = start = lastCode + parseInt(temp, 36);\n\t\t\t\t\t\t\ttemp = \"\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp += char;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!state) {\n\t\t\t\t\t\t\tlastCode = start = lastCode + parseInt(temp, 36);\n\t\t\t\t\t\t\tend = start;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend = start + parseInt(temp, 36);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate = false;\n\t\t\t\t\t\ttemp = \"\";\n\t\t\t\t\t\tlastCode = end;\n\t\t\t\t\t\tconst typeVal = getType(type);\n\t\t\t\t\t\tfor (let j = start; j < end + 1; j += 1) {\n\t\t\t\t\t\t\tmap.set(j, typeVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Get the bidi character type for a character\n * @param char Character to check\n * @returns Bidi character type as a bitmask\n */\nexport function getBidiCharType(char: string): number {\n\tparseData();\n\tconst codepoint = char.codePointAt(0);\n\tif (codepoint === undefined) return getType(\"L\");\n\treturn map?.get(codepoint) ?? getType(\"L\");\n}\n\n/**\n * Get the name of a bidi character type\n * @param char Character to check\n * @returns Bidi character type name (e.g., \"L\", \"R\", \"EN\", \"AN\", etc.)\n */\nexport function getBidiCharTypeName(char: string): string {\n\treturn TYPES_TO_NAMES[getBidiCharType(char)] ?? \"L\";\n}\n",
    "/**\n * Bidi embedding levels calculation (UAX #9)\n * Port of bidi-js embeddingLevels.js\n */\n\nimport {\n\tclosingToOpeningBracket,\n\tgetCanonicalBracket,\n\topeningToClosingBracket,\n} from \"./brackets.ts\";\nimport {\n\tBN_LIKE_TYPES,\n\tgetBidiCharType,\n\tISOLATE_INIT_TYPES,\n\tNEUTRAL_ISOLATE_TYPES,\n\tSTRONG_TYPES,\n\tTRAILING_TYPES,\n\tTYPES,\n} from \"./char-types.ts\";\n\n// Local type aliases\nconst TYPE_L = TYPES.L ?? 1;\nconst TYPE_R = TYPES.R ?? 2;\nconst TYPE_EN = TYPES.EN ?? 4;\nconst TYPE_ES = TYPES.ES ?? 8;\nconst TYPE_ET = TYPES.ET ?? 16;\nconst TYPE_AN = TYPES.AN ?? 32;\nconst TYPE_CS = TYPES.CS ?? 64;\nconst TYPE_B = TYPES.B ?? 128;\nconst TYPE_S = TYPES.S ?? 256;\nconst TYPE_ON = TYPES.ON ?? 512;\nconst TYPE_BN = TYPES.BN ?? 1024;\nconst TYPE_NSM = TYPES.NSM ?? 2048;\nconst TYPE_AL = TYPES.AL ?? 4096;\nconst TYPE_LRO = TYPES.LRO ?? 8192;\nconst TYPE_RLO = TYPES.RLO ?? 16384;\nconst TYPE_LRE = TYPES.LRE ?? 32768;\nconst TYPE_RLE = TYPES.RLE ?? 65536;\nconst TYPE_PDF = TYPES.PDF ?? 131072;\nconst TYPE_LRI = TYPES.LRI ?? 262144;\nconst TYPE_RLI = TYPES.RLI ?? 524288;\nconst TYPE_FSI = TYPES.FSI ?? 1048576;\nconst TYPE_PDI = TYPES.PDI ?? 2097152;\n\nexport interface EmbeddingLevelsResult {\n\tparagraphs: Array<{ start: number; end: number; level: number }>;\n\tlevels: Uint8Array;\n}\n\ninterface StatusStackEntry {\n\t_level: number;\n\t_override: number;\n\t_isolate: number;\n\t_isolInitIndex?: number;\n}\n\ninterface LevelRun {\n\t_start: number;\n\t_end: number;\n\t_level: number;\n\t_startsWithPDI: boolean;\n\t_endsWithIsolInit: boolean;\n}\n\ninterface IsolatingRunSeq {\n\t_seqIndices: number[];\n\t_sosType: number;\n\t_eosType: number;\n}\n\nfunction getCharType(charTypes: Uint32Array, i: number): number {\n\treturn charTypes[i] ?? 0;\n}\n\nfunction getSeqIndex(seqIndices: number[], i: number): number {\n\treturn seqIndices[i] ?? 0;\n}\n\nfunction getCharAt(s: string, i: number): string {\n\treturn s[i] ?? \"\";\n}\n\n/**\n * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n * base embedding level.\n * @param string Text string to process\n * @param baseDirection Base text direction: \"ltr\", \"rtl\", or \"auto\"\n * @returns Object containing embedding levels array and paragraph information\n */\nexport function getEmbeddingLevels(\n\tstring: string,\n\tbaseDirection?: \"ltr\" | \"rtl\" | \"auto\",\n): EmbeddingLevelsResult {\n\tconst MAX_DEPTH = 125;\n\n\t// Start by mapping all characters to their unicode type, as a bitmask integer\n\tconst charTypes = new Uint32Array(string.length);\n\tfor (let i = 0; i < string.length; i++) {\n\t\tcharTypes[i] = getBidiCharType(getCharAt(string, i));\n\t}\n\n\tconst charTypeCounts = new Map<number, number>();\n\n\tfunction changeCharType(i: number, type: number): void {\n\t\tconst oldType = getCharType(charTypes, i);\n\t\tcharTypes[i] = type;\n\t\tcharTypeCounts.set(oldType, (charTypeCounts.get(oldType) ?? 0) - 1);\n\t\tif (oldType & NEUTRAL_ISOLATE_TYPES) {\n\t\t\tcharTypeCounts.set(\n\t\t\t\tNEUTRAL_ISOLATE_TYPES,\n\t\t\t\t(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) - 1,\n\t\t\t);\n\t\t}\n\t\tcharTypeCounts.set(type, (charTypeCounts.get(type) ?? 0) + 1);\n\t\tif (type & NEUTRAL_ISOLATE_TYPES) {\n\t\t\tcharTypeCounts.set(\n\t\t\t\tNEUTRAL_ISOLATE_TYPES,\n\t\t\t\t(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) + 1,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst embedLevels = new Uint8Array(string.length);\n\tconst isolationPairs = new Map<number, number>();\n\n\tconst paragraphs: Array<{ start: number; end: number; level: number }> = [];\n\tlet paragraph: { start: number; end: number; level: number } | null = null;\n\n\tfunction determineAutoEmbedLevel(start: number, isFSI: boolean): number {\n\t\tfor (let i = start; i < string.length; i++) {\n\t\t\tconst charType = getCharType(charTypes, i);\n\t\t\tif (charType & (TYPE_R | TYPE_AL)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (charType & (TYPE_B | TYPE_L) || (isFSI && charType === TYPE_PDI)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (charType & ISOLATE_INIT_TYPES) {\n\t\t\t\tconst pdi = indexOfMatchingPDI(i);\n\t\t\t\ti = pdi === -1 ? string.length : pdi;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction indexOfMatchingPDI(isolateStart: number): number {\n\t\tlet isolationLevel = 1;\n\t\tfor (let i = isolateStart + 1; i < string.length; i++) {\n\t\t\tconst charType = getCharType(charTypes, i);\n\t\t\tif (charType & TYPE_B) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (charType & TYPE_PDI) {\n\t\t\t\tif (--isolationLevel === 0) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t} else if (charType & ISOLATE_INIT_TYPES) {\n\t\t\t\tisolationLevel++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (!paragraph) {\n\t\t\tparagraph = {\n\t\t\t\tstart: i,\n\t\t\t\tend: string.length - 1,\n\t\t\t\tlevel:\n\t\t\t\t\tbaseDirection === \"rtl\"\n\t\t\t\t\t\t? 1\n\t\t\t\t\t\t: baseDirection === \"ltr\"\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: determineAutoEmbedLevel(i, false),\n\t\t\t};\n\t\t\tparagraphs.push(paragraph);\n\t\t}\n\t\tif (getCharType(charTypes, i) & TYPE_B) {\n\t\t\tparagraph.end = i;\n\t\t\tparagraph = null;\n\t\t}\n\t}\n\n\tconst FORMATTING_TYPES =\n\t\tTYPE_RLE |\n\t\tTYPE_LRE |\n\t\tTYPE_RLO |\n\t\tTYPE_LRO |\n\t\tISOLATE_INIT_TYPES |\n\t\tTYPE_PDI |\n\t\tTYPE_PDF |\n\t\tTYPE_B;\n\tconst nextEven = (n: number): number => n + (n & 1 ? 1 : 2);\n\tconst nextOdd = (n: number): number => n + (n & 1 ? 2 : 1);\n\n\tfor (let paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n\t\tconst para = paragraphs[paraIdx];\n\t\tif (!para) continue;\n\t\tparagraph = para;\n\n\t\tconst statusStack: StatusStackEntry[] = [\n\t\t\t{\n\t\t\t\t_level: paragraph.level,\n\t\t\t\t_override: 0,\n\t\t\t\t_isolate: 0,\n\t\t\t},\n\t\t];\n\n\t\tlet overflowIsolateCount = 0;\n\t\tlet overflowEmbeddingCount = 0;\n\t\tlet validIsolateCount = 0;\n\t\tcharTypeCounts.clear();\n\n\t\tfor (let i = paragraph.start; i <= paragraph.end; i++) {\n\t\t\tlet charType = getCharType(charTypes, i);\n\t\t\tlet stackTop = statusStack[statusStack.length - 1];\n\t\t\tif (!stackTop) continue;\n\n\t\t\tcharTypeCounts.set(charType, (charTypeCounts.get(charType) ?? 0) + 1);\n\t\t\tif (charType & NEUTRAL_ISOLATE_TYPES) {\n\t\t\t\tcharTypeCounts.set(\n\t\t\t\t\tNEUTRAL_ISOLATE_TYPES,\n\t\t\t\t\t(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) ?? 0) + 1,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (charType & FORMATTING_TYPES) {\n\t\t\t\tif (charType & (TYPE_RLE | TYPE_LRE)) {\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tconst level = (charType === TYPE_RLE ? nextOdd : nextEven)(\n\t\t\t\t\t\tstackTop._level,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevel <= MAX_DEPTH &&\n\t\t\t\t\t\t!overflowIsolateCount &&\n\t\t\t\t\t\t!overflowEmbeddingCount\n\t\t\t\t\t) {\n\t\t\t\t\t\tstatusStack.push({\n\t\t\t\t\t\t\t_level: level,\n\t\t\t\t\t\t\t_override: 0,\n\t\t\t\t\t\t\t_isolate: 0,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!overflowIsolateCount) {\n\t\t\t\t\t\toverflowEmbeddingCount++;\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & (TYPE_RLO | TYPE_LRO)) {\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tconst level = (charType === TYPE_RLO ? nextOdd : nextEven)(\n\t\t\t\t\t\tstackTop._level,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevel <= MAX_DEPTH &&\n\t\t\t\t\t\t!overflowIsolateCount &&\n\t\t\t\t\t\t!overflowEmbeddingCount\n\t\t\t\t\t) {\n\t\t\t\t\t\tstatusStack.push({\n\t\t\t\t\t\t\t_level: level,\n\t\t\t\t\t\t\t_override: charType & TYPE_RLO ? TYPE_R : TYPE_L,\n\t\t\t\t\t\t\t_isolate: 0,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!overflowIsolateCount) {\n\t\t\t\t\t\toverflowEmbeddingCount++;\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & ISOLATE_INIT_TYPES) {\n\t\t\t\t\tif (charType & TYPE_FSI) {\n\t\t\t\t\t\tcharType =\n\t\t\t\t\t\t\tdetermineAutoEmbedLevel(i + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n\t\t\t\t\t}\n\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tif (stackTop._override) {\n\t\t\t\t\t\tchangeCharType(i, stackTop._override);\n\t\t\t\t\t}\n\t\t\t\t\tconst level = (charType === TYPE_RLI ? nextOdd : nextEven)(\n\t\t\t\t\t\tstackTop._level,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevel <= MAX_DEPTH &&\n\t\t\t\t\t\toverflowIsolateCount === 0 &&\n\t\t\t\t\t\toverflowEmbeddingCount === 0\n\t\t\t\t\t) {\n\t\t\t\t\t\tvalidIsolateCount++;\n\t\t\t\t\t\tstatusStack.push({\n\t\t\t\t\t\t\t_level: level,\n\t\t\t\t\t\t\t_override: 0,\n\t\t\t\t\t\t\t_isolate: 1,\n\t\t\t\t\t\t\t_isolInitIndex: i,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\toverflowIsolateCount++;\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & TYPE_PDI) {\n\t\t\t\t\tif (overflowIsolateCount > 0) {\n\t\t\t\t\t\toverflowIsolateCount--;\n\t\t\t\t\t} else if (validIsolateCount > 0) {\n\t\t\t\t\t\toverflowEmbeddingCount = 0;\n\t\t\t\t\t\twhile (statusStack.length > 0) {\n\t\t\t\t\t\t\tconst top = statusStack[statusStack.length - 1];\n\t\t\t\t\t\t\tif (top?._isolate) break;\n\t\t\t\t\t\t\tstatusStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst top = statusStack[statusStack.length - 1];\n\t\t\t\t\t\tconst isolInitIndex = top?._isolInitIndex;\n\t\t\t\t\t\tif (isolInitIndex != null) {\n\t\t\t\t\t\t\tisolationPairs.set(isolInitIndex, i);\n\t\t\t\t\t\t\tisolationPairs.set(i, isolInitIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatusStack.pop();\n\t\t\t\t\t\tvalidIsolateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tstackTop = statusStack[statusStack.length - 1];\n\t\t\t\t\tif (!stackTop) continue;\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t\tif (stackTop._override) {\n\t\t\t\t\t\tchangeCharType(i, stackTop._override);\n\t\t\t\t\t}\n\t\t\t\t} else if (charType & TYPE_PDF) {\n\t\t\t\t\tif (overflowIsolateCount === 0) {\n\t\t\t\t\t\tif (overflowEmbeddingCount > 0) {\n\t\t\t\t\t\t\toverflowEmbeddingCount--;\n\t\t\t\t\t\t} else if (!stackTop._isolate && statusStack.length > 1) {\n\t\t\t\t\t\t\tstatusStack.pop();\n\t\t\t\t\t\t\tstackTop = statusStack[statusStack.length - 1];\n\t\t\t\t\t\t\tif (!stackTop) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\t} else if (charType & TYPE_B) {\n\t\t\t\t\tembedLevels[i] = paragraph.level;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tembedLevels[i] = stackTop._level;\n\t\t\t\tif (stackTop._override && charType !== TYPE_BN) {\n\t\t\t\t\tchangeCharType(i, stackTop._override);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst levelRuns: LevelRun[] = [];\n\t\tlet currentRun: LevelRun | null = null;\n\t\tfor (let i = paragraph.start; i <= paragraph.end; i++) {\n\t\t\tconst charType = getCharType(charTypes, i);\n\t\t\tif (!(charType & BN_LIKE_TYPES)) {\n\t\t\t\tconst lvl = embedLevels[i] ?? 0;\n\t\t\t\tconst isIsolInit = !!(charType & ISOLATE_INIT_TYPES);\n\t\t\t\tconst isPDI = charType === TYPE_PDI;\n\t\t\t\tif (currentRun && lvl === currentRun._level) {\n\t\t\t\t\tcurrentRun._end = i;\n\t\t\t\t\tcurrentRun._endsWithIsolInit = isIsolInit;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentRun = {\n\t\t\t\t\t\t_start: i,\n\t\t\t\t\t\t_end: i,\n\t\t\t\t\t\t_level: lvl,\n\t\t\t\t\t\t_startsWithPDI: isPDI,\n\t\t\t\t\t\t_endsWithIsolInit: isIsolInit,\n\t\t\t\t\t};\n\t\t\t\t\tlevelRuns.push(currentRun);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst isolatingRunSeqs: IsolatingRunSeq[] = [];\n\n\t\tfor (let runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n\t\t\tconst run = levelRuns[runIdx];\n\t\t\tif (!run) continue;\n\t\t\tif (\n\t\t\t\t!run._startsWithPDI ||\n\t\t\t\t(run._startsWithPDI && !isolationPairs.has(run._start))\n\t\t\t) {\n\t\t\t\tcurrentRun = run;\n\t\t\t\tconst seqRuns: LevelRun[] = [run];\n\n\t\t\t\twhile (currentRun?._endsWithIsolInit) {\n\t\t\t\t\tconst pdiIndex = isolationPairs.get(currentRun._end);\n\t\t\t\t\tif (pdiIndex == null) break;\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor (let i = runIdx + 1; i < levelRuns.length; i++) {\n\t\t\t\t\t\tconst nextRun = levelRuns[i];\n\t\t\t\t\t\tif (nextRun?._start === pdiIndex) {\n\t\t\t\t\t\t\tcurrentRun = nextRun;\n\t\t\t\t\t\t\tseqRuns.push(nextRun);\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) break;\n\t\t\t\t}\n\n\t\t\t\tconst seqIndices: number[] = [];\n\t\t\t\tfor (let i = 0; i < seqRuns.length; i++) {\n\t\t\t\t\tconst seqRun = seqRuns[i]!;\n\t\t\t\t\tfor (let j = seqRun._start; j <= seqRun._end; j++) {\n\t\t\t\t\t\tseqIndices.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst firstIdx = seqIndices[0] ?? 0;\n\t\t\t\tconst firstLevel = embedLevels[firstIdx] ?? 0;\n\t\t\t\tlet prevLevel = paragraph.level;\n\t\t\t\tfor (let i = firstIdx - 1; i >= 0; i--) {\n\t\t\t\t\tif (!(getCharType(charTypes, i) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\tprevLevel = embedLevels[i] ?? 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst lastIndex = seqIndices[seqIndices.length - 1] ?? 0;\n\t\t\t\tconst lastLevel = embedLevels[lastIndex] ?? 0;\n\t\t\t\tlet nextLevel = paragraph.level;\n\t\t\t\tif (!(getCharType(charTypes, lastIndex) & ISOLATE_INIT_TYPES)) {\n\t\t\t\t\tfor (let i = lastIndex + 1; i <= paragraph.end; i++) {\n\t\t\t\t\t\tif (!(getCharType(charTypes, i) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\tnextLevel = embedLevels[i] ?? 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tisolatingRunSeqs.push({\n\t\t\t\t\t_seqIndices: seqIndices,\n\t\t\t\t\t_sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n\t\t\t\t\t_eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (let seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n\t\t\tconst seq = isolatingRunSeqs[seqIdx]!;\n\t\t\tconst {\n\t\t\t\t_seqIndices: seqIndices,\n\t\t\t\t_sosType: sosType,\n\t\t\t\t_eosType: eosType,\n\t\t\t} = seq;\n\t\t\tconst firstSeqIdx = seqIndices[0] ?? 0;\n\t\t\tconst embedDirection =\n\t\t\t\t(embedLevels[firstSeqIdx] ?? 0) & 1 ? TYPE_R : TYPE_L;\n\n\t\t\t// W1\n\t\t\tif (charTypeCounts.get(TYPE_NSM)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_NSM) {\n\t\t\t\t\t\tlet prevType = sosType;\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\t\tprevType = getCharType(charTypes, sjIdx);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchangeCharType(\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\tprevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W2\n\t\t\tif (charTypeCounts.get(TYPE_EN)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_EN) {\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= -1; sj--) {\n\t\t\t\t\t\t\tconst prevCharType =\n\t\t\t\t\t\t\t\tsj === -1\n\t\t\t\t\t\t\t\t\t? sosType\n\t\t\t\t\t\t\t\t\t: getCharType(charTypes, getSeqIndex(seqIndices, sj));\n\t\t\t\t\t\t\tif (prevCharType & STRONG_TYPES) {\n\t\t\t\t\t\t\t\tif (prevCharType === TYPE_AL) {\n\t\t\t\t\t\t\t\t\tchangeCharType(i, TYPE_AN);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W3\n\t\t\tif (charTypeCounts.get(TYPE_AL)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_AL) {\n\t\t\t\t\t\tchangeCharType(i, TYPE_R);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W4\n\t\t\tif (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n\t\t\t\tfor (let si = 1; si < seqIndices.length - 1; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & (TYPE_ES | TYPE_CS)) {\n\t\t\t\t\t\tlet prevType = 0;\n\t\t\t\t\t\tlet nextType = 0;\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tprevType = getCharType(charTypes, getSeqIndex(seqIndices, sj));\n\t\t\t\t\t\t\tif (!(prevType & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let sj = si + 1; sj < seqIndices.length; sj++) {\n\t\t\t\t\t\t\tnextType = getCharType(charTypes, getSeqIndex(seqIndices, sj));\n\t\t\t\t\t\t\tif (!(nextType & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tprevType === nextType &&\n\t\t\t\t\t\t\t(getCharType(charTypes, i) === TYPE_ES\n\t\t\t\t\t\t\t\t? prevType === TYPE_EN\n\t\t\t\t\t\t\t\t: prevType & (TYPE_EN | TYPE_AN))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchangeCharType(i, prevType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W5\n\t\t\tif (charTypeCounts.get(TYPE_EN)) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & TYPE_EN) {\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & (TYPE_ET | BN_LIKE_TYPES)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tchangeCharType(sjIdx, TYPE_EN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (si++; si < seqIndices.length; si++) {\n\t\t\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\tgetCharType(charTypes, siIdx) &\n\t\t\t\t\t\t\t\t\t(TYPE_ET | BN_LIKE_TYPES | TYPE_EN)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (getCharType(charTypes, siIdx) !== TYPE_EN) {\n\t\t\t\t\t\t\t\tchangeCharType(siIdx, TYPE_EN);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W6\n\t\t\tif (\n\t\t\t\tcharTypeCounts.get(TYPE_ET) ||\n\t\t\t\tcharTypeCounts.get(TYPE_ES) ||\n\t\t\t\tcharTypeCounts.get(TYPE_CS)\n\t\t\t) {\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, i) & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n\t\t\t\t\t\tchangeCharType(i, TYPE_ON);\n\t\t\t\t\t\tfor (let sj = si - 1; sj >= 0; sj--) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t\tchangeCharType(sjIdx, TYPE_ON);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let sj = si + 1; sj < seqIndices.length; sj++) {\n\t\t\t\t\t\t\tconst sjIdx = getSeqIndex(seqIndices, sj);\n\t\t\t\t\t\t\tif (!(getCharType(charTypes, sjIdx) & BN_LIKE_TYPES)) break;\n\t\t\t\t\t\t\tchangeCharType(sjIdx, TYPE_ON);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// W7\n\t\t\tif (charTypeCounts.get(TYPE_EN)) {\n\t\t\t\tlet prevStrongType = sosType;\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\tconst type = getCharType(charTypes, i);\n\t\t\t\t\tif (type & TYPE_EN) {\n\t\t\t\t\t\tif (prevStrongType === TYPE_L) {\n\t\t\t\t\t\t\tchangeCharType(i, TYPE_L);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (type & STRONG_TYPES) {\n\t\t\t\t\t\tprevStrongType = type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// N0-N2\n\t\t\tif (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n\t\t\t\tconst R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;\n\t\t\t\tconst STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n\t\t\t\tconst bracketPairs: Array<[number, number]> = [];\n\t\t\t\tconst openerStack: Array<{ char: string; seqIndex: number }> = [];\n\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, siIdx) & NEUTRAL_ISOLATE_TYPES) {\n\t\t\t\t\t\tconst char = getCharAt(string, siIdx);\n\t\t\t\t\t\tconst closingBracket = openingToClosingBracket(char);\n\t\t\t\t\t\tif (closingBracket !== null) {\n\t\t\t\t\t\t\tif (openerStack.length < 63) {\n\t\t\t\t\t\t\t\topenerStack.push({ char, seqIndex: si });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst oppositeBracket = closingToOpeningBracket(char);\n\t\t\t\t\t\t\tif (oppositeBracket !== null) {\n\t\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\t\tlet stackIdx = openerStack.length - 1;\n\t\t\t\t\t\t\t\t\tstackIdx >= 0;\n\t\t\t\t\t\t\t\t\tstackIdx--\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst opener = openerStack[stackIdx];\n\t\t\t\t\t\t\t\t\tif (!opener) continue;\n\t\t\t\t\t\t\t\t\tconst stackChar = opener.char;\n\t\t\t\t\t\t\t\t\tconst canonicalChar = getCanonicalBracket(char);\n\t\t\t\t\t\t\t\t\tconst canonicalStack = getCanonicalBracket(stackChar);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tstackChar === oppositeBracket ||\n\t\t\t\t\t\t\t\t\t\t(canonicalChar &&\n\t\t\t\t\t\t\t\t\t\t\tstackChar === closingToOpeningBracket(canonicalChar)) ||\n\t\t\t\t\t\t\t\t\t\t(canonicalStack &&\n\t\t\t\t\t\t\t\t\t\t\topeningToClosingBracket(canonicalStack) === char)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tbracketPairs.push([opener.seqIndex, si]);\n\t\t\t\t\t\t\t\t\t\topenerStack.length = stackIdx;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbracketPairs.sort((a, b) => a[0] - b[0]);\n\n\t\t\t\tfor (let pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n\t\t\t\t\tconst pair = bracketPairs[pairIdx]!;\n\t\t\t\t\tconst [openSeqIdx, closeSeqIdx] = pair;\n\t\t\t\t\tlet foundStrongType = false;\n\t\t\t\t\tlet useStrongType = 0;\n\n\t\t\t\t\tfor (let si = openSeqIdx + 1; si < closeSeqIdx; si++) {\n\t\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\tconst ct = getCharType(charTypes, i);\n\t\t\t\t\t\tif (ct & STRONG_TYPES_FOR_N_STEPS) {\n\t\t\t\t\t\t\tfoundStrongType = true;\n\t\t\t\t\t\t\tconst lr = ct & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\t\t\t\t\t\t\tif (lr === embedDirection) {\n\t\t\t\t\t\t\t\tuseStrongType = lr;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (foundStrongType && !useStrongType) {\n\t\t\t\t\t\tuseStrongType = sosType;\n\t\t\t\t\t\tfor (let si = openSeqIdx - 1; si >= 0; si--) {\n\t\t\t\t\t\t\tconst i = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\tconst ct = getCharType(charTypes, i);\n\t\t\t\t\t\t\tif (ct & STRONG_TYPES_FOR_N_STEPS) {\n\t\t\t\t\t\t\t\tconst lr = ct & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\t\t\t\t\t\t\t\tuseStrongType = lr !== embedDirection ? lr : embedDirection;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useStrongType) {\n\t\t\t\t\t\tcharTypes[getSeqIndex(seqIndices, openSeqIdx)] = useStrongType;\n\t\t\t\t\t\tcharTypes[getSeqIndex(seqIndices, closeSeqIdx)] = useStrongType;\n\n\t\t\t\t\t\tif (useStrongType !== embedDirection) {\n\t\t\t\t\t\t\tfor (let si = openSeqIdx + 1; si < seqIndices.length; si++) {\n\t\t\t\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\t\tif (!(getCharType(charTypes, siIdx) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\t\t\tif (getBidiCharType(getCharAt(string, siIdx)) & TYPE_NSM) {\n\t\t\t\t\t\t\t\t\t\tcharTypes[siIdx] = useStrongType;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let si = closeSeqIdx + 1; si < seqIndices.length; si++) {\n\t\t\t\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\t\t\t\tif (!(getCharType(charTypes, siIdx) & BN_LIKE_TYPES)) {\n\t\t\t\t\t\t\t\t\tif (getBidiCharType(getCharAt(string, siIdx)) & TYPE_NSM) {\n\t\t\t\t\t\t\t\t\t\tcharTypes[siIdx] = useStrongType;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// N1/N2\n\t\t\t\tfor (let si = 0; si < seqIndices.length; si++) {\n\t\t\t\t\tconst siIdx = getSeqIndex(seqIndices, si);\n\t\t\t\t\tif (getCharType(charTypes, siIdx) & NEUTRAL_ISOLATE_TYPES) {\n\t\t\t\t\t\tlet niRunStart = si;\n\t\t\t\t\t\tlet niRunEnd = si;\n\t\t\t\t\t\tlet prevType = sosType;\n\n\t\t\t\t\t\tfor (let si2 = si - 1; si2 >= 0; si2--) {\n\t\t\t\t\t\t\tconst si2Idx = getSeqIndex(seqIndices, si2);\n\t\t\t\t\t\t\tif (getCharType(charTypes, si2Idx) & BN_LIKE_TYPES) {\n\t\t\t\t\t\t\t\tniRunStart = si2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprevType =\n\t\t\t\t\t\t\t\t\tgetCharType(charTypes, si2Idx) & R_TYPES_FOR_N_STEPS\n\t\t\t\t\t\t\t\t\t\t? TYPE_R\n\t\t\t\t\t\t\t\t\t\t: TYPE_L;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet nextType = eosType;\n\t\t\t\t\t\tfor (let si2 = si + 1; si2 < seqIndices.length; si2++) {\n\t\t\t\t\t\t\tconst si2Idx = getSeqIndex(seqIndices, si2);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tgetCharType(charTypes, si2Idx) &\n\t\t\t\t\t\t\t\t(NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tniRunEnd = si2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnextType =\n\t\t\t\t\t\t\t\t\tgetCharType(charTypes, si2Idx) & R_TYPES_FOR_N_STEPS\n\t\t\t\t\t\t\t\t\t\t? TYPE_R\n\t\t\t\t\t\t\t\t\t\t: TYPE_L;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let sj = niRunStart; sj <= niRunEnd; sj++) {\n\t\t\t\t\t\t\tcharTypes[getSeqIndex(seqIndices, sj)] =\n\t\t\t\t\t\t\t\tprevType === nextType ? prevType : embedDirection;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsi = niRunEnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Resolving Implicit Levels\n\t\tfor (let i = paragraph.start; i <= paragraph.end; i++) {\n\t\t\tconst level = embedLevels[i] ?? 0;\n\t\t\tconst type = getCharType(charTypes, i);\n\n\t\t\tif (level & 1) {\n\t\t\t\tif (type & (TYPE_L | TYPE_EN | TYPE_AN)) {\n\t\t\t\t\tembedLevels[i]++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (type & TYPE_R) {\n\t\t\t\t\tembedLevels[i]++;\n\t\t\t\t} else if (type & (TYPE_AN | TYPE_EN)) {\n\t\t\t\t\tembedLevels[i] += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type & BN_LIKE_TYPES) {\n\t\t\t\tembedLevels[i] =\n\t\t\t\t\ti === 0 ? paragraph.level : (embedLevels[i - 1] ?? paragraph.level);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ti === paragraph.end ||\n\t\t\t\tgetBidiCharType(getCharAt(string, i)) & (TYPE_S | TYPE_B)\n\t\t\t) {\n\t\t\t\tfor (\n\t\t\t\t\tlet j = i;\n\t\t\t\t\tj >= 0 && getBidiCharType(getCharAt(string, j)) & TRAILING_TYPES;\n\t\t\t\t\tj--\n\t\t\t\t) {\n\t\t\t\t\tembedLevels[j] = paragraph.level;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tlevels: embedLevels,\n\t\tparagraphs,\n\t};\n}\n",
    "// Bidi mirrored chars data, auto generated\nexport default \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n",
    "/**\n * Bidi character mirroring\n * Port of bidi-js mirroring.js\n */\n\nimport data from \"./mirroring.gen.ts\";\nimport { parseCharacterMap } from \"./parse-character-map.ts\";\n\nlet mirrorMap: Map<string, string> | null = null;\n\nfunction parse(): void {\n\tif (!mirrorMap) {\n\t\tconst { map, reverseMap } = parseCharacterMap(data, true);\n\t\t// Combine both maps into one\n\t\tif (reverseMap) {\n\t\t\treverseMap.forEach((value, key) => {\n\t\t\t\tmap.set(key, value);\n\t\t\t});\n\t\t}\n\t\tmirrorMap = map;\n\t}\n}\n\n/**\n * Get the mirrored version of a character for BiDi display\n * @param char Character to mirror\n * @returns Mirrored character, or null if character has no mirror\n */\nexport function getMirroredCharacter(char: string): string | null {\n\tparse();\n\treturn mirrorMap?.get(char) || null;\n}\n\n/**\n * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n * for any characters in right-to-left segments that have defined mirrored characters.\n * @param string Text string to process\n * @param embeddingLevels Resolved embedding levels from getEmbeddingLevels\n * @param start Start index (defaults to 0)\n * @param end End index (defaults to string length - 1)\n * @returns Map of character indices to their mirrored replacements\n */\nexport function getMirroredCharactersMap(\n\tstring: string,\n\tembeddingLevels: Uint8Array,\n\tstart?: number,\n\tend?: number,\n): Map<number, string> {\n\tconst strLen = string.length;\n\tstart = Math.max(0, start == null ? 0 : +start);\n\tend = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n\tconst map = new Map<number, string>();\n\tfor (let i = start; i <= end; i++) {\n\t\tif (embeddingLevels[i] & 1) {\n\t\t\t// only odd (rtl) levels\n\t\t\tconst mirror = getMirroredCharacter(string[i]);\n\t\t\tif (mirror !== null) {\n\t\t\t\tmap.set(i, mirror);\n\t\t\t}\n\t\t}\n\t}\n\treturn map;\n}\n",
    "/**\n * Bidi reordering\n * Port of bidi-js reordering.js\n */\n\nimport { getBidiCharType, TRAILING_TYPES } from \"./char-types.ts\";\nimport type { EmbeddingLevelsResult } from \"./embedding-levels.ts\";\nimport { getMirroredCharacter } from \"./mirroring.ts\";\n\n/**\n * Given a start and end denoting a single line within a string, and a set of precalculated\n * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n * @param string Text string to process\n * @param embeddingLevelsResult Result from getEmbeddingLevels\n * @param start Start index (defaults to 0)\n * @param end End index (defaults to string length - 1)\n * @returns Array of segment ranges [start, end] to be reversed\n */\nexport function getReorderSegments(\n\tstring: string,\n\tembeddingLevelsResult: EmbeddingLevelsResult,\n\tstart?: number,\n\tend?: number,\n): Array<[number, number]> {\n\tconst strLen = string.length;\n\tconst startPos = Math.max(0, start == null ? 0 : +start);\n\tconst endPos = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n\tconst segments: Array<[number, number]> = [];\n\tfor (let i = 0; i < embeddingLevelsResult.paragraphs.length; i++) {\n\t\tconst paragraph = embeddingLevelsResult.paragraphs[i]!;\n\t\tconst lineStart = Math.max(startPos, paragraph.start);\n\t\tconst lineEnd = Math.min(endPos, paragraph.end);\n\t\tif (lineStart < lineEnd) {\n\t\t\t// Local slice for mutation\n\t\t\tconst lineLevels = embeddingLevelsResult.levels.slice(\n\t\t\t\tlineStart,\n\t\t\t\tlineEnd + 1,\n\t\t\t);\n\n\t\t\t// 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n\t\t\t// end of the line to the paragraph level.\n\t\t\tfor (let i = lineEnd; i >= lineStart; i--) {\n\t\t\t\tconst char = string[i];\n\t\t\t\tif (char === undefined) break;\n\t\t\t\tif (!(getBidiCharType(char) & TRAILING_TYPES)) break;\n\t\t\t\tlineLevels[i - lineStart] = paragraph.level;\n\t\t\t}\n\n\t\t\t// L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n\t\t\t// not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n\t\t\tlet maxLevel = paragraph.level;\n\t\t\tlet minOddLevel = Infinity;\n\t\t\tfor (let i = 0; i < lineLevels.length; i++) {\n\t\t\t\tconst level = lineLevels[i] ?? 0;\n\t\t\t\tif (level > maxLevel) maxLevel = level;\n\t\t\t\tif (level < minOddLevel) minOddLevel = level | 1;\n\t\t\t}\n\t\t\tfor (let lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n\t\t\t\tfor (let i = 0; i < lineLevels.length; i++) {\n\t\t\t\t\tconst level = lineLevels[i] ?? 0;\n\t\t\t\t\tif (level >= lvl) {\n\t\t\t\t\t\tconst segStart = i;\n\t\t\t\t\t\twhile (i + 1 < lineLevels.length) {\n\t\t\t\t\t\t\tconst nextLevel = lineLevels[i + 1] ?? 0;\n\t\t\t\t\t\t\tif (nextLevel < lvl) break;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i > segStart) {\n\t\t\t\t\t\t\tsegments.push([segStart + lineStart, i + lineStart]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn segments;\n}\n\n/**\n * Get the reordered string with bidi segments reversed\n * @param string Text string to reorder\n * @param embedLevelsResult Result from getEmbeddingLevels\n * @param start Start index (defaults to 0)\n * @param end End index (defaults to string length - 1)\n * @returns Reordered string with BiDi applied\n */\nexport function getReorderedString(\n\tstring: string,\n\tembedLevelsResult: EmbeddingLevelsResult,\n\tstart?: number,\n\tend?: number,\n): string {\n\tconst indices = getReorderedIndices(string, embedLevelsResult, start, end);\n\tconst chars = [...string];\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst charIndex = indices[i] ?? 0;\n\t\tconst level = embedLevelsResult.levels[charIndex] ?? 0;\n\t\tconst originalChar = string[charIndex] ?? \"\";\n\t\tif (level & 1) {\n\t\t\tconst mirrored = getMirroredCharacter(originalChar);\n\t\t\tchars[i] = mirrored ?? originalChar;\n\t\t} else {\n\t\t\tchars[i] = originalChar;\n\t\t}\n\t}\n\treturn chars.join(\"\");\n}\n\n/**\n * Get an array with character indices in their new bidi order\n * @param string Text string to process\n * @param embedLevelsResult Result from getEmbeddingLevels\n * @param start Start index (defaults to 0)\n * @param end End index (defaults to string length - 1)\n * @returns Array mapping new positions to original character indices\n */\nexport function getReorderedIndices(\n\tstring: string,\n\tembedLevelsResult: EmbeddingLevelsResult,\n\tstart?: number,\n\tend?: number,\n): number[] {\n\tconst segments = getReorderSegments(string, embedLevelsResult, start, end);\n\t// Fill an array with indices\n\tconst indices: number[] = [];\n\tfor (let i = 0; i < string.length; i++) {\n\t\tindices[i] = i;\n\t}\n\t// Reverse each segment in order\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tconst segment = segments[i]!;\n\t\tconst segStart = segment[0];\n\t\tconst segEnd = segment[1];\n\t\tconst slice = indices.slice(segStart, segEnd + 1);\n\t\tfor (let j = slice.length; j--; ) {\n\t\t\tconst val = slice[j];\n\t\t\tif (val !== undefined) {\n\t\t\t\tindices[segEnd - j] = val;\n\t\t\t}\n\t\t}\n\t}\n\treturn indices;\n}\n",
    "/**\n * Bidirectional text processing (UAX #9)\n */\n\nimport type { GlyphInfo } from \"../types.ts\";\nimport { Direction } from \"../types.ts\";\nimport {\n\tgetBidiCharType,\n\tgetEmbeddingLevels,\n\tgetMirroredCharacter,\n\tgetReorderedIndices,\n} from \"./bidi/index.ts\";\n\n/**\n * Result of BiDi processing\n */\nexport interface BidiResult {\n\t/** Embedding levels per character */\n\tlevels: Uint8Array;\n\t/** Paragraph information */\n\tparagraphs: BidiParagraph[];\n}\n\n/**\n * Paragraph info from BiDi algorithm\n */\nexport interface BidiParagraph {\n\tstart: number;\n\tend: number;\n\tlevel: number;\n}\n\n/**\n * Get embedding levels for a string\n */\nexport function getEmbeddings(\n\ttext: string,\n\tbaseDirection: Direction = Direction.LTR,\n): BidiResult {\n\tconst dir =\n\t\tbaseDirection === Direction.RTL\n\t\t\t? \"rtl\"\n\t\t\t: baseDirection === Direction.LTR\n\t\t\t\t? \"ltr\"\n\t\t\t\t: \"auto\";\n\n\tconst result = getEmbeddingLevels(text, dir);\n\n\treturn {\n\t\tlevels: result.levels,\n\t\tparagraphs: result.paragraphs,\n\t};\n}\n\n/**\n * Get reordered indices for visual display\n */\nexport function getVisualOrder(\n\ttext: string,\n\tresult: BidiResult,\n\tstart: number = 0,\n\tend: number = text.length,\n): number[] {\n\treturn [...getReorderedIndices(text, result, start, end)];\n}\n\n/**\n * Apply BiDi reordering to glyph infos\n */\nexport function reorderGlyphs(\n\tinfos: GlyphInfo[],\n\tresult: BidiResult,\n): GlyphInfo[] {\n\tif (infos.length === 0) return infos;\n\n\t// Get reordered indices\n\tconst dummyString = \"x\".repeat(infos.length);\n\tconst indices = getReorderedIndices(dummyString, result, 0, infos.length);\n\n\t// Reorder glyphs according to visual order\n\tconst reordered: GlyphInfo[] = [];\n\tfor (let i = 0; i < indices.length; i++) {\n\t\tconst idx = indices[i]!;\n\t\tif (idx < infos.length) {\n\t\t\tconst info = infos[idx];\n\t\t\tif (info) {\n\t\t\t\treordered.push(info);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn reordered;\n}\n\n/**\n * Get mirrored character for RTL contexts\n */\nexport function getMirror(codepoint: number): number {\n\tconst char = String.fromCodePoint(codepoint);\n\tconst mirrored = getMirroredCharacter(char);\n\treturn mirrored ? (mirrored.codePointAt(0) ?? codepoint) : codepoint;\n}\n\n/**\n * Apply character mirroring for RTL runs\n */\nexport function applyMirroring(infos: GlyphInfo[], levels: Uint8Array): void {\n\tfor (let i = 0; i < infos.length; i++) {\n\t\tconst info = infos[i]!;\n\t\tconst level = levels[i];\n\t\tif (level === undefined) continue;\n\n\t\t// Odd levels are RTL\n\t\tif (level & 1) {\n\t\t\tconst mirrored = getMirror(info.codepoint);\n\t\t\tif (mirrored !== info.codepoint) {\n\t\t\t\t// Store mirrored codepoint - glyph ID will be remapped later\n\t\t\t\tinfo.codepoint = mirrored;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * BiDi character type constants\n */\nexport const BidiType = {\n\tL: 0x0001, // Left-to-Right\n\tR: 0x0002, // Right-to-Left\n\tEN: 0x0004, // European Number\n\tES: 0x0008, // European Separator\n\tET: 0x0010, // European Terminator\n\tAN: 0x0020, // Arabic Number\n\tCS: 0x0040, // Common Separator\n\tB: 0x0080, // Paragraph Separator\n\tS: 0x0100, // Segment Separator\n\tWS: 0x0200, // Whitespace\n\tON: 0x0400, // Other Neutral\n\tBN: 0x0800, // Boundary Neutral\n\tNSM: 0x1000, // Non-Spacing Mark\n\tAL: 0x2000, // Arabic Letter\n\tLRO: 0x4000, // Left-to-Right Override\n\tRLO: 0x8000, // Right-to-Left Override\n\tLRE: 0x10000, // Left-to-Right Embedding\n\tRLE: 0x20000, // Right-to-Left Embedding\n\tPDF: 0x40000, // Pop Directional Format\n\tLRI: 0x80000, // Left-to-Right Isolate\n\tRLI: 0x100000, // Right-to-Left Isolate\n\tFSI: 0x200000, // First Strong Isolate\n\tPDI: 0x400000, // Pop Directional Isolate\n} as const;\n\n/**\n * Get BiDi character type for a character\n */\nexport function getCharType(char: string): number {\n\treturn getBidiCharType(char);\n}\n\n/**\n * Check if a character is strongly RTL\n */\nexport function isRTL(codepoint: number): boolean {\n\tconst char = String.fromCodePoint(codepoint);\n\tconst type = getBidiCharType(char);\n\treturn (type & (BidiType.R | BidiType.AL)) !== 0;\n}\n\n/**\n * Check if a character is strongly LTR\n */\nexport function isLTR(codepoint: number): boolean {\n\tconst char = String.fromCodePoint(codepoint);\n\tconst type = getBidiCharType(char);\n\treturn (type & BidiType.L) !== 0;\n}\n\n/**\n * Detect base direction from text content\n */\nexport function detectDirection(text: string): Direction {\n\tconst chars = [...text];\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tconst type = getBidiCharType(char);\n\t\tif (type & BidiType.L) return Direction.LTR;\n\t\tif (type & (BidiType.R | BidiType.AL)) return Direction.RTL;\n\t}\n\treturn Direction.LTR; // Default\n}\n\n/**\n * Full BiDi processing for shaping\n */\nexport function processBidi(\n\tinfos: GlyphInfo[],\n\tbaseDirection: Direction = Direction.LTR,\n): { infos: GlyphInfo[]; levels: Uint8Array } {\n\tif (infos.length === 0) {\n\t\treturn { infos, levels: new Uint8Array(0) };\n\t}\n\n\t// Build string from codepoints\n\tconst text = infos.map((i) => String.fromCodePoint(i.codepoint)).join(\"\");\n\n\t// Get embedding levels\n\tconst result = getEmbeddings(text, baseDirection);\n\n\t// Apply character mirroring\n\tapplyMirroring(infos, result.levels);\n\n\t// Reorder glyphs for visual order\n\tconst reordered = reorderGlyphs(infos, result);\n\n\treturn { infos: reordered, levels: result.levels };\n}\n",
    "/**\n * Unicode Line Breaking Algorithm (UAX #14)\n * Determines line break opportunities in text\n */\n\nimport type { GlyphInfo } from \"../types.ts\";\n\n/**\n * Line break class from UAX #14\n */\nexport enum LineBreakClass {\n\t// Non-tailorable Line Breaking Classes\n\tBK = 0, // Mandatory Break\n\tCR = 1, // Carriage Return\n\tLF = 2, // Line Feed\n\tCM = 3, // Combining Mark\n\tNL = 4, // Next Line\n\tSG = 5, // Surrogate (not used)\n\tWJ = 6, // Word Joiner\n\tZW = 7, // Zero Width Space\n\tGL = 8, // Non-breaking (\"Glue\")\n\tSP = 9, // Space\n\tZWJ = 10, // Zero Width Joiner\n\n\t// Break Opportunities\n\tB2 = 11, // Break Opportunity Before and After\n\tBA = 12, // Break After\n\tBB = 13, // Break Before\n\tHY = 14, // Hyphen\n\tCB = 15, // Contingent Break Opportunity\n\n\t// Characters Prohibiting Certain Breaks\n\tCL = 16, // Close Punctuation\n\tCP = 17, // Close Parenthesis\n\tEX = 18, // Exclamation/Interrogation\n\tIN = 19, // Inseparable\n\tNS = 20, // Nonstarter\n\tOP = 21, // Open Punctuation\n\tQU = 22, // Quotation\n\n\t// Numeric Context\n\tIS = 23, // Infix Numeric Separator\n\tNU = 24, // Numeric\n\tPO = 25, // Postfix Numeric\n\tPR = 26, // Prefix Numeric\n\tSY = 27, // Symbols Allowing Break After\n\n\t// Other Characters\n\tAI = 28, // Ambiguous (Alphabetic or Ideographic)\n\tAL = 29, // Alphabetic\n\tCJ = 30, // Conditional Japanese Starter\n\tEB = 31, // Emoji Base\n\tEM = 32, // Emoji Modifier\n\tH2 = 33, // Hangul LV Syllable\n\tH3 = 34, // Hangul LVT Syllable\n\tHL = 35, // Hebrew Letter\n\tID = 36, // Ideographic\n\tJL = 37, // Hangul L Jamo\n\tJV = 38, // Hangul V Jamo\n\tJT = 39, // Hangul T Jamo\n\tRI = 40, // Regional Indicator\n\tSA = 41, // Complex Context Dependent (South East Asian)\n\tXX = 42, // Unknown\n}\n\n/**\n * Break action\n */\nexport enum BreakAction {\n\tDirect = 0, // Direct break opportunity (after space)\n\tIndirect = 1, // Indirect break (only if spaces intervene)\n\tCombiningIndirect = 2, // Indirect break for combining marks\n\tCombiningProhibited = 3, // Prohibited break for combining marks\n\tProhibited = 4, // No break allowed\n\tExplicit = 5, // Explicit break (BK, CR, LF, NL)\n}\n\n/**\n * Line break opportunity\n */\nexport enum BreakOpportunity {\n\tNoBreak = 0,\n\tOptional = 1,\n\tMandatory = 2,\n}\n\n/**\n * Get line break class for a codepoint\n */\nexport function getLineBreakClass(cp: number): LineBreakClass {\n\t// Mandatory breaks\n\tif (cp === 0x000a) return LineBreakClass.LF;\n\tif (cp === 0x000d) return LineBreakClass.CR;\n\tif (cp === 0x0085) return LineBreakClass.NL;\n\tif (cp === 0x000b || cp === 0x000c) return LineBreakClass.BK;\n\tif (cp === 0x2028) return LineBreakClass.BK; // Line Separator\n\tif (cp === 0x2029) return LineBreakClass.BK; // Paragraph Separator\n\n\t// Zero-width characters\n\tif (cp === 0x200b) return LineBreakClass.ZW; // Zero Width Space\n\tif (cp === 0x200d) return LineBreakClass.ZWJ; // Zero Width Joiner\n\tif (cp === 0x2060) return LineBreakClass.WJ; // Word Joiner\n\tif (cp === 0xfeff) return LineBreakClass.WJ; // BOM / ZWNBSP\n\n\t// Spaces\n\tif (cp === 0x0020) return LineBreakClass.SP;\n\tif (cp === 0x00a0) return LineBreakClass.GL; // No-Break Space\n\tif (cp === 0x202f) return LineBreakClass.GL; // Narrow No-Break Space\n\tif (cp === 0x2007) return LineBreakClass.GL; // Figure Space\n\tif (cp === 0x2011) return LineBreakClass.GL; // Non-Breaking Hyphen\n\n\t// Tabs and other whitespace\n\tif (cp === 0x0009) return LineBreakClass.BA; // Tab\n\tif (cp >= 0x2000 && cp <= 0x200a) return LineBreakClass.BA; // Various spaces\n\n\t// Combining marks\n\tif (cp >= 0x0300 && cp <= 0x036f) return LineBreakClass.CM; // Combining Diacritical Marks\n\tif (cp >= 0x0483 && cp <= 0x0489) return LineBreakClass.CM; // Cyrillic combining\n\tif (cp >= 0x0591 && cp <= 0x05bd) return LineBreakClass.CM; // Hebrew points\n\tif (cp >= 0x05bf && cp <= 0x05c7) return LineBreakClass.CM;\n\tif (cp >= 0x0610 && cp <= 0x061a) return LineBreakClass.CM; // Arabic marks\n\tif (cp >= 0x064b && cp <= 0x065f) return LineBreakClass.CM;\n\tif (cp >= 0x0670 && cp <= 0x0670) return LineBreakClass.CM;\n\tif (cp >= 0x06d6 && cp <= 0x06ed) return LineBreakClass.CM;\n\tif (cp >= 0x0711 && cp <= 0x0711) return LineBreakClass.CM; // Syriac\n\tif (cp >= 0x0730 && cp <= 0x074a) return LineBreakClass.CM;\n\tif (cp >= 0x07a6 && cp <= 0x07b0) return LineBreakClass.CM; // Thaana\n\tif (cp >= 0x0816 && cp <= 0x0823) return LineBreakClass.CM; // Samaritan\n\tif (cp >= 0x0825 && cp <= 0x082d) return LineBreakClass.CM;\n\tif (cp >= 0x0859 && cp <= 0x085b) return LineBreakClass.CM; // Mandaic\n\tif (cp >= 0x08d3 && cp <= 0x08e1) return LineBreakClass.CM; // Arabic extended\n\tif (cp >= 0x08e3 && cp <= 0x0903) return LineBreakClass.CM;\n\tif (cp >= 0x093a && cp <= 0x093c) return LineBreakClass.CM; // Devanagari\n\tif (cp >= 0x093e && cp <= 0x094f) return LineBreakClass.CM;\n\tif (cp >= 0x0951 && cp <= 0x0957) return LineBreakClass.CM;\n\tif (cp >= 0x0962 && cp <= 0x0963) return LineBreakClass.CM;\n\tif (cp >= 0x0981 && cp <= 0x0983) return LineBreakClass.CM; // Bengali\n\tif (cp === 0x09bc) return LineBreakClass.CM;\n\tif (cp >= 0x09be && cp <= 0x09cd) return LineBreakClass.CM;\n\tif (cp >= 0x09d7 && cp <= 0x09d7) return LineBreakClass.CM;\n\tif (cp >= 0x09e2 && cp <= 0x09e3) return LineBreakClass.CM;\n\tif (cp >= 0x09fe && cp <= 0x09fe) return LineBreakClass.CM;\n\tif (cp >= 0x0a01 && cp <= 0x0a03) return LineBreakClass.CM; // Gurmukhi\n\tif (cp >= 0x0a3c && cp <= 0x0a51) return LineBreakClass.CM;\n\tif (cp >= 0x0a70 && cp <= 0x0a71) return LineBreakClass.CM;\n\tif (cp >= 0x0a75 && cp <= 0x0a75) return LineBreakClass.CM;\n\tif (cp >= 0x0a81 && cp <= 0x0a83) return LineBreakClass.CM; // Gujarati\n\tif (cp >= 0x0abc && cp <= 0x0acd) return LineBreakClass.CM;\n\tif (cp >= 0x0ae2 && cp <= 0x0ae3) return LineBreakClass.CM;\n\tif (cp >= 0x0afa && cp <= 0x0aff) return LineBreakClass.CM;\n\tif (cp >= 0x0b01 && cp <= 0x0b03) return LineBreakClass.CM; // Oriya\n\tif (cp >= 0x0b3c && cp <= 0x0b57) return LineBreakClass.CM;\n\tif (cp >= 0x0b62 && cp <= 0x0b63) return LineBreakClass.CM;\n\tif (cp >= 0x0b82 && cp <= 0x0b82) return LineBreakClass.CM; // Tamil\n\tif (cp >= 0x0bbe && cp <= 0x0bcd) return LineBreakClass.CM;\n\tif (cp >= 0x0bd7 && cp <= 0x0bd7) return LineBreakClass.CM;\n\tif (cp >= 0x0c00 && cp <= 0x0c04) return LineBreakClass.CM; // Telugu\n\tif (cp >= 0x0c3e && cp <= 0x0c56) return LineBreakClass.CM;\n\tif (cp >= 0x0c62 && cp <= 0x0c63) return LineBreakClass.CM;\n\tif (cp >= 0x0c81 && cp <= 0x0c83) return LineBreakClass.CM; // Kannada\n\tif (cp >= 0x0cbc && cp <= 0x0cd6) return LineBreakClass.CM;\n\tif (cp >= 0x0ce2 && cp <= 0x0ce3) return LineBreakClass.CM;\n\tif (cp >= 0x0d00 && cp <= 0x0d03) return LineBreakClass.CM; // Malayalam\n\tif (cp >= 0x0d3b && cp <= 0x0d4d) return LineBreakClass.CM;\n\tif (cp >= 0x0d57 && cp <= 0x0d57) return LineBreakClass.CM;\n\tif (cp >= 0x0d62 && cp <= 0x0d63) return LineBreakClass.CM;\n\tif (cp >= 0x0d81 && cp <= 0x0d83) return LineBreakClass.CM; // Sinhala\n\tif (cp >= 0x0dca && cp <= 0x0df3) return LineBreakClass.CM;\n\tif (cp >= 0x0f18 && cp <= 0x0f19) return LineBreakClass.CM; // Tibetan\n\tif (cp >= 0x0f35 && cp <= 0x0f39) return LineBreakClass.CM;\n\tif (cp >= 0x0f3e && cp <= 0x0f3f) return LineBreakClass.CM;\n\tif (cp >= 0x0f71 && cp <= 0x0f84) return LineBreakClass.CM;\n\tif (cp >= 0x0f86 && cp <= 0x0f87) return LineBreakClass.CM;\n\tif (cp >= 0x0f8d && cp <= 0x0fbc) return LineBreakClass.CM;\n\tif (cp === 0x0fc6) return LineBreakClass.CM;\n\tif (cp >= 0x1712 && cp <= 0x1714) return LineBreakClass.CM; // Tagalog\n\tif (cp >= 0x1732 && cp <= 0x1734) return LineBreakClass.CM; // Hanunoo\n\tif (cp >= 0x1752 && cp <= 0x1753) return LineBreakClass.CM; // Buhid\n\tif (cp >= 0x1772 && cp <= 0x1773) return LineBreakClass.CM; // Tagbanwa\n\tif (cp >= 0x17b4 && cp <= 0x17d3) return LineBreakClass.CM; // Khmer\n\tif (cp === 0x17dd) return LineBreakClass.CM;\n\tif (cp >= 0x180b && cp <= 0x180d) return LineBreakClass.CM; // Mongolian\n\tif (cp === 0x180f) return LineBreakClass.CM;\n\tif (cp >= 0x1885 && cp <= 0x1886) return LineBreakClass.CM;\n\tif (cp === 0x18a9) return LineBreakClass.CM;\n\tif (cp >= 0x1920 && cp <= 0x193b) return LineBreakClass.CM; // Limbu, Buginese\n\tif (cp >= 0x1a17 && cp <= 0x1a1b) return LineBreakClass.CM;\n\tif (cp >= 0x1a55 && cp <= 0x1a7f) return LineBreakClass.CM; // Tai Tham\n\tif (cp >= 0x1ab0 && cp <= 0x1ace) return LineBreakClass.CM; // Combining Diacritical Marks Extended\n\tif (cp >= 0x1b00 && cp <= 0x1b04) return LineBreakClass.CM; // Balinese\n\tif (cp >= 0x1b34 && cp <= 0x1b44) return LineBreakClass.CM;\n\tif (cp >= 0x1b6b && cp <= 0x1b73) return LineBreakClass.CM;\n\tif (cp >= 0x1b80 && cp <= 0x1b82) return LineBreakClass.CM; // Sundanese\n\tif (cp >= 0x1ba1 && cp <= 0x1bad) return LineBreakClass.CM;\n\tif (cp >= 0x1be6 && cp <= 0x1bf3) return LineBreakClass.CM; // Batak\n\tif (cp >= 0x1c24 && cp <= 0x1c37) return LineBreakClass.CM; // Lepcha\n\tif (cp >= 0x1cd0 && cp <= 0x1cf9) return LineBreakClass.CM; // Vedic Extensions\n\tif (cp >= 0x1dc0 && cp <= 0x1dff) return LineBreakClass.CM; // Combining Diacritical Marks Supplement\n\tif (cp >= 0x20d0 && cp <= 0x20f0) return LineBreakClass.CM; // Combining Diacritical Marks for Symbols\n\tif (cp >= 0x2cef && cp <= 0x2cf1) return LineBreakClass.CM; // Coptic\n\tif (cp === 0x2d7f) return LineBreakClass.CM; // Tifinagh\n\tif (cp >= 0x2de0 && cp <= 0x2dff) return LineBreakClass.CM; // Cyrillic Extended-A\n\tif (cp >= 0x302a && cp <= 0x302f) return LineBreakClass.CM; // Ideographic Description\n\tif (cp >= 0x3099 && cp <= 0x309a) return LineBreakClass.CM; // Hiragana/Katakana voicing\n\tif (cp >= 0xa66f && cp <= 0xa672) return LineBreakClass.CM; // Combining Cyrillic\n\tif (cp >= 0xa674 && cp <= 0xa67d) return LineBreakClass.CM;\n\tif (cp >= 0xa69e && cp <= 0xa69f) return LineBreakClass.CM;\n\tif (cp >= 0xa6f0 && cp <= 0xa6f1) return LineBreakClass.CM; // Bamum\n\tif (cp >= 0xa802 && cp <= 0xa827) return LineBreakClass.CM; // Syloti Nagri\n\tif (cp >= 0xa82c && cp <= 0xa82c) return LineBreakClass.CM;\n\tif (cp >= 0xa880 && cp <= 0xa881) return LineBreakClass.CM; // Saurashtra\n\tif (cp >= 0xa8b4 && cp <= 0xa8c5) return LineBreakClass.CM;\n\tif (cp >= 0xa8e0 && cp <= 0xa8f1) return LineBreakClass.CM; // Devanagari Extended\n\tif (cp === 0xa8ff) return LineBreakClass.CM;\n\tif (cp >= 0xa926 && cp <= 0xa92d) return LineBreakClass.CM; // Kayah Li\n\tif (cp >= 0xa947 && cp <= 0xa953) return LineBreakClass.CM; // Rejang\n\tif (cp >= 0xa980 && cp <= 0xa983) return LineBreakClass.CM; // Javanese\n\tif (cp >= 0xa9b3 && cp <= 0xa9cd) return LineBreakClass.CM;\n\tif (cp === 0xa9e5) return LineBreakClass.CM; // Myanmar Extended-B\n\tif (cp >= 0xaa29 && cp <= 0xaa36) return LineBreakClass.CM; // Cham\n\tif (cp >= 0xaa43 && cp <= 0xaa43) return LineBreakClass.CM;\n\tif (cp >= 0xaa4c && cp <= 0xaa4d) return LineBreakClass.CM;\n\tif (cp >= 0xaa7b && cp <= 0xaa7d) return LineBreakClass.CM; // Myanmar Extended-A\n\tif (cp >= 0xaab0 && cp <= 0xaac2) return LineBreakClass.CM; // Tai Viet\n\tif (cp >= 0xaaeb && cp <= 0xaaef) return LineBreakClass.CM; // Meetei Mayek Extensions\n\tif (cp >= 0xaaf5 && cp <= 0xaaf6) return LineBreakClass.CM;\n\tif (cp >= 0xabe3 && cp <= 0xabea) return LineBreakClass.CM; // Meetei Mayek\n\tif (cp >= 0xabec && cp <= 0xabed) return LineBreakClass.CM;\n\tif (cp === 0xfb1e) return LineBreakClass.CM; // Hebrew\n\tif (cp >= 0xfe00 && cp <= 0xfe0f) return LineBreakClass.CM; // Variation Selectors\n\tif (cp >= 0xfe20 && cp <= 0xfe2f) return LineBreakClass.CM; // Combining Half Marks\n\tif (cp >= 0x101fd && cp <= 0x101fd) return LineBreakClass.CM; // Phaistos\n\tif (cp >= 0x102e0 && cp <= 0x102e0) return LineBreakClass.CM; // Coptic Epact\n\tif (cp >= 0x10376 && cp <= 0x1037a) return LineBreakClass.CM; // Old Permic\n\tif (cp >= 0x10a01 && cp <= 0x10a0f) return LineBreakClass.CM; // Kharoshthi\n\tif (cp >= 0x10a38 && cp <= 0x10a3f) return LineBreakClass.CM;\n\tif (cp >= 0x10ae5 && cp <= 0x10ae6) return LineBreakClass.CM; // Manichaean\n\tif (cp >= 0x10d24 && cp <= 0x10d27) return LineBreakClass.CM; // Hanifi Rohingya\n\tif (cp >= 0x10eab && cp <= 0x10eac) return LineBreakClass.CM; // Yezidi\n\tif (cp >= 0x10f46 && cp <= 0x10f50) return LineBreakClass.CM; // Sogdian\n\tif (cp >= 0x10f82 && cp <= 0x10f85) return LineBreakClass.CM; // Old Uyghur\n\tif (cp >= 0x11000 && cp <= 0x11002) return LineBreakClass.CM; // Brahmi\n\tif (cp >= 0x11038 && cp <= 0x11046) return LineBreakClass.CM;\n\tif (cp >= 0x11070 && cp <= 0x11070) return LineBreakClass.CM;\n\tif (cp >= 0x11073 && cp <= 0x11074) return LineBreakClass.CM;\n\tif (cp >= 0x1107f && cp <= 0x11082) return LineBreakClass.CM;\n\tif (cp >= 0x110b0 && cp <= 0x110c2) return LineBreakClass.CM; // Kaithi\n\tif (cp >= 0x11100 && cp <= 0x11102) return LineBreakClass.CM; // Chakma\n\tif (cp >= 0x11127 && cp <= 0x11134) return LineBreakClass.CM;\n\tif (cp === 0x11145) return LineBreakClass.CM;\n\tif (cp === 0x11146) return LineBreakClass.CM;\n\tif (cp >= 0x11173 && cp <= 0x11173) return LineBreakClass.CM; // Mahajani\n\tif (cp >= 0x11180 && cp <= 0x11182) return LineBreakClass.CM; // Sharada\n\tif (cp >= 0x111b3 && cp <= 0x111c0) return LineBreakClass.CM;\n\tif (cp >= 0x111c9 && cp <= 0x111cc) return LineBreakClass.CM;\n\tif (cp === 0x111ce) return LineBreakClass.CM;\n\tif (cp === 0x111cf) return LineBreakClass.CM;\n\tif (cp >= 0x1122c && cp <= 0x11237) return LineBreakClass.CM; // Khojki\n\tif (cp === 0x1123e) return LineBreakClass.CM;\n\tif (cp >= 0x112df && cp <= 0x112ea) return LineBreakClass.CM; // Khudawadi\n\tif (cp >= 0x11300 && cp <= 0x11303) return LineBreakClass.CM; // Grantha\n\tif (cp >= 0x1133b && cp <= 0x1133c) return LineBreakClass.CM;\n\tif (cp >= 0x1133e && cp <= 0x1134d) return LineBreakClass.CM;\n\tif (cp >= 0x11357 && cp <= 0x11357) return LineBreakClass.CM;\n\tif (cp >= 0x11362 && cp <= 0x11374) return LineBreakClass.CM;\n\tif (cp >= 0x11435 && cp <= 0x11446) return LineBreakClass.CM; // Newa\n\tif (cp === 0x1145e) return LineBreakClass.CM;\n\tif (cp >= 0x114b0 && cp <= 0x114c3) return LineBreakClass.CM; // Tirhuta\n\tif (cp >= 0x115af && cp <= 0x115c0) return LineBreakClass.CM; // Siddham\n\tif (cp >= 0x115dc && cp <= 0x115dd) return LineBreakClass.CM;\n\tif (cp >= 0x11630 && cp <= 0x11640) return LineBreakClass.CM; // Modi\n\tif (cp >= 0x116ab && cp <= 0x116b7) return LineBreakClass.CM; // Takri\n\tif (cp >= 0x1171d && cp <= 0x1172b) return LineBreakClass.CM; // Ahom\n\tif (cp >= 0x1182c && cp <= 0x1183a) return LineBreakClass.CM; // Dogra\n\tif (cp >= 0x11930 && cp <= 0x11935) return LineBreakClass.CM; // Dives Akuru\n\tif (cp >= 0x11937 && cp <= 0x11938) return LineBreakClass.CM;\n\tif (cp >= 0x1193b && cp <= 0x1193e) return LineBreakClass.CM;\n\tif (cp === 0x11940) return LineBreakClass.CM;\n\tif (cp >= 0x11942 && cp <= 0x11943) return LineBreakClass.CM;\n\tif (cp >= 0x119d1 && cp <= 0x119d7) return LineBreakClass.CM; // Nandinagari\n\tif (cp >= 0x119da && cp <= 0x119e0) return LineBreakClass.CM;\n\tif (cp === 0x119e4) return LineBreakClass.CM;\n\tif (cp >= 0x11a01 && cp <= 0x11a0a) return LineBreakClass.CM; // Zanabazar Square\n\tif (cp >= 0x11a33 && cp <= 0x11a39) return LineBreakClass.CM;\n\tif (cp >= 0x11a3b && cp <= 0x11a3e) return LineBreakClass.CM;\n\tif (cp === 0x11a47) return LineBreakClass.CM;\n\tif (cp >= 0x11a51 && cp <= 0x11a5b) return LineBreakClass.CM; // Soyombo\n\tif (cp >= 0x11a8a && cp <= 0x11a99) return LineBreakClass.CM;\n\tif (cp >= 0x11c2f && cp <= 0x11c36) return LineBreakClass.CM; // Bhaiksuki\n\tif (cp >= 0x11c38 && cp <= 0x11c3f) return LineBreakClass.CM;\n\tif (cp >= 0x11c92 && cp <= 0x11ca7) return LineBreakClass.CM; // Marchen\n\tif (cp >= 0x11ca9 && cp <= 0x11cb6) return LineBreakClass.CM;\n\tif (cp >= 0x11d31 && cp <= 0x11d45) return LineBreakClass.CM; // Masaram Gondi\n\tif (cp === 0x11d47) return LineBreakClass.CM;\n\tif (cp >= 0x11d8a && cp <= 0x11d97) return LineBreakClass.CM; // Gunjala Gondi\n\tif (cp >= 0x11ef3 && cp <= 0x11ef6) return LineBreakClass.CM; // Makasar\n\tif (cp >= 0x16af0 && cp <= 0x16af4) return LineBreakClass.CM; // Bassa Vah\n\tif (cp >= 0x16b30 && cp <= 0x16b36) return LineBreakClass.CM; // Pahawh Hmong\n\tif (cp === 0x16f4f) return LineBreakClass.CM; // Miao\n\tif (cp >= 0x16f51 && cp <= 0x16f87) return LineBreakClass.CM;\n\tif (cp >= 0x16f8f && cp <= 0x16f92) return LineBreakClass.CM;\n\tif (cp >= 0x16fe4 && cp <= 0x16fe4) return LineBreakClass.CM; // Khitan Small Script\n\tif (cp >= 0x16ff0 && cp <= 0x16ff1) return LineBreakClass.CM;\n\tif (cp >= 0x1bc9d && cp <= 0x1bc9e) return LineBreakClass.CM; // Duployan\n\tif (cp >= 0x1cf00 && cp <= 0x1cf46) return LineBreakClass.CM; // Znamenny Musical Notation\n\tif (cp >= 0x1d165 && cp <= 0x1d169) return LineBreakClass.CM; // Musical Symbols\n\tif (cp >= 0x1d16d && cp <= 0x1d172) return LineBreakClass.CM;\n\tif (cp >= 0x1d17b && cp <= 0x1d182) return LineBreakClass.CM;\n\tif (cp >= 0x1d185 && cp <= 0x1d18b) return LineBreakClass.CM;\n\tif (cp >= 0x1d1aa && cp <= 0x1d1ad) return LineBreakClass.CM;\n\tif (cp >= 0x1d242 && cp <= 0x1d244) return LineBreakClass.CM;\n\tif (cp >= 0x1da00 && cp <= 0x1da36) return LineBreakClass.CM; // Sutton SignWriting\n\tif (cp >= 0x1da3b && cp <= 0x1da6c) return LineBreakClass.CM;\n\tif (cp === 0x1da75) return LineBreakClass.CM;\n\tif (cp === 0x1da84) return LineBreakClass.CM;\n\tif (cp >= 0x1da9b && cp <= 0x1daaf) return LineBreakClass.CM;\n\tif (cp >= 0x1e000 && cp <= 0x1e02a) return LineBreakClass.CM; // Glagolitic Supplement\n\tif (cp >= 0x1e130 && cp <= 0x1e136) return LineBreakClass.CM; // Nyiakeng Puachue Hmong\n\tif (cp >= 0x1e2ae && cp <= 0x1e2ae) return LineBreakClass.CM; // Toto\n\tif (cp >= 0x1e2ec && cp <= 0x1e2ef) return LineBreakClass.CM; // Wancho\n\tif (cp >= 0x1e8d0 && cp <= 0x1e8d6) return LineBreakClass.CM; // Mende Kikakui\n\tif (cp >= 0x1e944 && cp <= 0x1e94a) return LineBreakClass.CM; // Adlam\n\tif (cp >= 0xe0100 && cp <= 0xe01ef) return LineBreakClass.CM; // Variation Selectors Supplement\n\n\t// Punctuation\n\tif (cp === 0x0021) return LineBreakClass.EX; // !\n\tif (cp === 0x003f) return LineBreakClass.EX; // ?\n\tif (cp === 0x0022) return LineBreakClass.QU; // \"\n\tif (cp === 0x0027) return LineBreakClass.QU; // '\n\tif (cp === 0x0028) return LineBreakClass.OP; // (\n\tif (cp === 0x0029) return LineBreakClass.CP; // )\n\tif (cp === 0x005b) return LineBreakClass.OP; // [\n\tif (cp === 0x005d) return LineBreakClass.CP; // ]\n\tif (cp === 0x007b) return LineBreakClass.OP; // {\n\tif (cp === 0x007d) return LineBreakClass.CL; // }\n\tif (cp === 0x002c) return LineBreakClass.IS; // ,\n\tif (cp === 0x002e) return LineBreakClass.IS; // .\n\tif (cp === 0x003a) return LineBreakClass.IS; // :\n\tif (cp === 0x003b) return LineBreakClass.IS; // ;\n\tif (cp === 0x002d) return LineBreakClass.HY; // -\n\tif (cp === 0x2010) return LineBreakClass.BA; // Hyphen\n\tif (cp === 0x2013) return LineBreakClass.BA; // En Dash\n\tif (cp === 0x2014) return LineBreakClass.B2; // Em Dash\n\tif (cp === 0x2018 || cp === 0x2019) return LineBreakClass.QU; // Single quotes\n\tif (cp === 0x201c || cp === 0x201d) return LineBreakClass.QU; // Double quotes\n\tif (cp === 0x2026) return LineBreakClass.IN; // Ellipsis\n\n\t// CJK punctuation\n\tif (cp === 0x3001 || cp === 0x3002) return LineBreakClass.CL; // Ideographic comma, period\n\tif (cp === 0x3008) return LineBreakClass.OP;\n\tif (cp === 0x3009) return LineBreakClass.CL;\n\tif (cp === 0x300a) return LineBreakClass.OP;\n\tif (cp === 0x300b) return LineBreakClass.CL;\n\tif (cp === 0x300c) return LineBreakClass.OP;\n\tif (cp === 0x300d) return LineBreakClass.CL;\n\tif (cp === 0x300e) return LineBreakClass.OP;\n\tif (cp === 0x300f) return LineBreakClass.CL;\n\tif (cp === 0x3010) return LineBreakClass.OP;\n\tif (cp === 0x3011) return LineBreakClass.CL;\n\tif (cp === 0x3014) return LineBreakClass.OP;\n\tif (cp === 0x3015) return LineBreakClass.CL;\n\tif (cp === 0x3016) return LineBreakClass.OP;\n\tif (cp === 0x3017) return LineBreakClass.CL;\n\tif (cp >= 0x3018 && cp <= 0x301b)\n\t\treturn cp % 2 === 0 ? LineBreakClass.OP : LineBreakClass.CL;\n\tif (cp === 0xff08) return LineBreakClass.OP; // Fullwidth (\n\tif (cp === 0xff09) return LineBreakClass.CL; // Fullwidth )\n\tif (cp === 0xff0c) return LineBreakClass.CL; // Fullwidth ,\n\tif (cp === 0xff0e) return LineBreakClass.CL; // Fullwidth .\n\tif (cp === 0xff1a) return LineBreakClass.NS; // Fullwidth :\n\tif (cp === 0xff1b) return LineBreakClass.NS; // Fullwidth ;\n\tif (cp === 0xff1f) return LineBreakClass.EX; // Fullwidth ?\n\tif (cp === 0xff01) return LineBreakClass.EX; // Fullwidth !\n\n\t// Small Kana\n\tif (cp >= 0x3041 && cp <= 0x3096) {\n\t\t// Check for small kana\n\t\tif (\n\t\t\tcp === 0x3041 ||\n\t\t\tcp === 0x3043 ||\n\t\t\tcp === 0x3045 ||\n\t\t\tcp === 0x3047 ||\n\t\t\tcp === 0x3049 ||\n\t\t\tcp === 0x3063 ||\n\t\t\tcp === 0x3083 ||\n\t\t\tcp === 0x3085 ||\n\t\t\tcp === 0x3087 ||\n\t\t\tcp === 0x308e ||\n\t\t\tcp === 0x3095 ||\n\t\t\tcp === 0x3096\n\t\t)\n\t\t\treturn LineBreakClass.CJ;\n\t\treturn LineBreakClass.ID;\n\t}\n\tif (cp >= 0x30a1 && cp <= 0x30fa) {\n\t\t// Check for small katakana\n\t\tif (\n\t\t\tcp === 0x30a1 ||\n\t\t\tcp === 0x30a3 ||\n\t\t\tcp === 0x30a5 ||\n\t\t\tcp === 0x30a7 ||\n\t\t\tcp === 0x30a9 ||\n\t\t\tcp === 0x30c3 ||\n\t\t\tcp === 0x30e3 ||\n\t\t\tcp === 0x30e5 ||\n\t\t\tcp === 0x30e7 ||\n\t\t\tcp === 0x30ee ||\n\t\t\tcp === 0x30f5 ||\n\t\t\tcp === 0x30f6\n\t\t)\n\t\t\treturn LineBreakClass.CJ;\n\t\treturn LineBreakClass.ID;\n\t}\n\n\t// Hiragana/Katakana prolonged sound mark\n\tif (cp === 0x30fc) return LineBreakClass.CJ;\n\n\t// Hangul\n\tif (cp >= 0x1100 && cp <= 0x115f) return LineBreakClass.JL;\n\tif (cp >= 0xa960 && cp <= 0xa97c) return LineBreakClass.JL;\n\tif (cp >= 0x1160 && cp <= 0x11a7) return LineBreakClass.JV;\n\tif (cp >= 0xd7b0 && cp <= 0xd7c6) return LineBreakClass.JV;\n\tif (cp >= 0x11a8 && cp <= 0x11ff) return LineBreakClass.JT;\n\tif (cp >= 0xd7cb && cp <= 0xd7fb) return LineBreakClass.JT;\n\t// Hangul syllables\n\tif (cp >= 0xac00 && cp <= 0xd7a3) {\n\t\tconst sIndex = cp - 0xac00;\n\t\tif (sIndex % 28 === 0) return LineBreakClass.H2;\n\t\treturn LineBreakClass.H3;\n\t}\n\n\t// Numbers\n\tif (cp >= 0x0030 && cp <= 0x0039) return LineBreakClass.NU;\n\tif (cp >= 0x0660 && cp <= 0x0669) return LineBreakClass.NU; // Arabic-Indic\n\tif (cp >= 0x06f0 && cp <= 0x06f9) return LineBreakClass.NU; // Extended Arabic-Indic\n\tif (cp >= 0x0966 && cp <= 0x096f) return LineBreakClass.NU; // Devanagari\n\tif (cp >= 0xff10 && cp <= 0xff19) return LineBreakClass.NU; // Fullwidth\n\n\t// Currency symbols\n\tif (cp === 0x0024) return LineBreakClass.PR; // $\n\tif (cp === 0x00a3) return LineBreakClass.PR; // \n\tif (cp === 0x00a5) return LineBreakClass.PR; // \n\tif (cp === 0x20ac) return LineBreakClass.PR; // \n\tif (cp === 0x0025) return LineBreakClass.PO; // %\n\n\t// Hebrew\n\tif (cp >= 0x05d0 && cp <= 0x05ea) return LineBreakClass.HL;\n\tif (cp >= 0xfb1d && cp <= 0xfb4f) return LineBreakClass.HL;\n\n\t// CJK Ideographs\n\tif (cp >= 0x4e00 && cp <= 0x9fff) return LineBreakClass.ID;\n\tif (cp >= 0x3400 && cp <= 0x4dbf) return LineBreakClass.ID;\n\tif (cp >= 0x20000 && cp <= 0x2a6df) return LineBreakClass.ID;\n\tif (cp >= 0x2a700 && cp <= 0x2b73f) return LineBreakClass.ID;\n\tif (cp >= 0x2b740 && cp <= 0x2b81f) return LineBreakClass.ID;\n\tif (cp >= 0x2b820 && cp <= 0x2ceaf) return LineBreakClass.ID;\n\tif (cp >= 0x2ceb0 && cp <= 0x2ebef) return LineBreakClass.ID;\n\tif (cp >= 0x30000 && cp <= 0x3134f) return LineBreakClass.ID;\n\tif (cp >= 0xf900 && cp <= 0xfaff) return LineBreakClass.ID;\n\tif (cp >= 0x2f800 && cp <= 0x2fa1f) return LineBreakClass.ID;\n\n\t// Emoji\n\tif (cp >= 0x1f300 && cp <= 0x1f9ff) return LineBreakClass.ID;\n\tif (cp >= 0x1fa00 && cp <= 0x1faff) return LineBreakClass.ID;\n\tif (cp >= 0x2600 && cp <= 0x26ff) return LineBreakClass.ID;\n\tif (cp >= 0x2700 && cp <= 0x27bf) return LineBreakClass.ID;\n\n\t// Regional indicators\n\tif (cp >= 0x1f1e0 && cp <= 0x1f1ff) return LineBreakClass.RI;\n\n\t// Emoji modifiers\n\tif (cp >= 0x1f3fb && cp <= 0x1f3ff) return LineBreakClass.EM;\n\n\t// Thai\n\tif (cp >= 0x0e00 && cp <= 0x0e7f) return LineBreakClass.SA;\n\n\t// Lao\n\tif (cp >= 0x0e80 && cp <= 0x0eff) return LineBreakClass.SA;\n\n\t// Myanmar\n\tif (cp >= 0x1000 && cp <= 0x109f) return LineBreakClass.SA;\n\tif (cp >= 0xa9e0 && cp <= 0xa9ff) return LineBreakClass.SA;\n\tif (cp >= 0xaa60 && cp <= 0xaa7f) return LineBreakClass.SA;\n\n\t// Khmer\n\tif (cp >= 0x1780 && cp <= 0x17ff) return LineBreakClass.SA;\n\tif (cp >= 0x19e0 && cp <= 0x19ff) return LineBreakClass.SA;\n\n\t// Default: treat as alphabetic\n\tif (cp >= 0x0041 && cp <= 0x005a) return LineBreakClass.AL; // A-Z\n\tif (cp >= 0x0061 && cp <= 0x007a) return LineBreakClass.AL; // a-z\n\tif (cp >= 0x00c0 && cp <= 0x024f) return LineBreakClass.AL; // Latin Extended\n\n\t// Arabic\n\tif (cp >= 0x0600 && cp <= 0x06ff) return LineBreakClass.AL;\n\tif (cp >= 0x0750 && cp <= 0x077f) return LineBreakClass.AL;\n\tif (cp >= 0x08a0 && cp <= 0x08ff) return LineBreakClass.AL;\n\n\t// Devanagari and other Indic\n\tif (cp >= 0x0900 && cp <= 0x097f) return LineBreakClass.AL;\n\tif (cp >= 0x0980 && cp <= 0x09ff) return LineBreakClass.AL;\n\tif (cp >= 0x0a00 && cp <= 0x0a7f) return LineBreakClass.AL;\n\tif (cp >= 0x0a80 && cp <= 0x0aff) return LineBreakClass.AL;\n\tif (cp >= 0x0b00 && cp <= 0x0b7f) return LineBreakClass.AL;\n\tif (cp >= 0x0b80 && cp <= 0x0bff) return LineBreakClass.AL;\n\tif (cp >= 0x0c00 && cp <= 0x0c7f) return LineBreakClass.AL;\n\tif (cp >= 0x0c80 && cp <= 0x0cff) return LineBreakClass.AL;\n\tif (cp >= 0x0d00 && cp <= 0x0d7f) return LineBreakClass.AL;\n\n\t// Cyrillic\n\tif (cp >= 0x0400 && cp <= 0x04ff) return LineBreakClass.AL;\n\tif (cp >= 0x0500 && cp <= 0x052f) return LineBreakClass.AL;\n\n\t// Greek\n\tif (cp >= 0x0370 && cp <= 0x03ff) return LineBreakClass.AL;\n\n\treturn LineBreakClass.XX;\n}\n\n/**\n * Pair table for line break classes\n * Returns whether a break is allowed between two classes\n */\nfunction getPairAction(\n\tbefore: LineBreakClass,\n\tafter: LineBreakClass,\n): BreakAction {\n\t// LB1: Resolve AI, CB, CJ, SA, SG, XX -> AL (simplified)\n\tif (before === LineBreakClass.AI) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.SA) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.SG) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.XX) before = LineBreakClass.AL;\n\tif (before === LineBreakClass.CJ) before = LineBreakClass.NS;\n\n\tif (after === LineBreakClass.AI) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.SA) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.SG) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.XX) after = LineBreakClass.AL;\n\tif (after === LineBreakClass.CJ) after = LineBreakClass.NS;\n\n\t// LB4: Always break after hard line breaks\n\tif (before === LineBreakClass.BK) return BreakAction.Explicit;\n\n\t// LB5: Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks\n\tif (before === LineBreakClass.CR && after === LineBreakClass.LF)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.CR ||\n\t\tbefore === LineBreakClass.LF ||\n\t\tbefore === LineBreakClass.NL\n\t)\n\t\treturn BreakAction.Explicit;\n\n\t// LB6: Do not break before hard line breaks\n\tif (\n\t\tafter === LineBreakClass.BK ||\n\t\tafter === LineBreakClass.CR ||\n\t\tafter === LineBreakClass.LF ||\n\t\tafter === LineBreakClass.NL\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB7: Do not break before spaces or zero width space\n\tif (after === LineBreakClass.SP || after === LineBreakClass.ZW)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB8: Break before any character following a zero-width space\n\tif (before === LineBreakClass.ZW) return BreakAction.Direct;\n\n\t// LB8a: Do not break after a zero width joiner\n\tif (before === LineBreakClass.ZWJ) return BreakAction.Prohibited;\n\n\t// LB9: Do not break a combining character sequence\n\t// Note: BK, CR, LF, NL, ZW are already handled by early returns above\n\tif (after === LineBreakClass.CM || after === LineBreakClass.ZWJ) {\n\t\tif (before !== LineBreakClass.SP) return BreakAction.Prohibited;\n\t}\n\n\t// LB10: Treat any remaining combining mark or ZWJ as AL\n\t// Use type assertion since we know these could be CM/ZWJ from above\n\tlet beforeResolved: LineBreakClass = before;\n\tlet afterResolved: LineBreakClass = after;\n\tif (before === LineBreakClass.CM || (before as number) === LineBreakClass.ZWJ)\n\t\tbeforeResolved = LineBreakClass.AL;\n\tif (after === LineBreakClass.CM || after === LineBreakClass.ZWJ)\n\t\tafterResolved = LineBreakClass.AL;\n\tbefore = beforeResolved;\n\tafter = afterResolved;\n\n\t// LB11: Do not break before or after Word Joiner\n\tif (before === LineBreakClass.WJ || after === LineBreakClass.WJ)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB12: Do not break after NBSP and related characters\n\tif (before === LineBreakClass.GL) return BreakAction.Prohibited;\n\n\t// LB12a: Do not break before NBSP and related characters, except after spaces and hyphens\n\tif (after === LineBreakClass.GL) {\n\t\tif (\n\t\t\tbefore !== LineBreakClass.SP &&\n\t\t\tbefore !== LineBreakClass.BA &&\n\t\t\tbefore !== LineBreakClass.HY\n\t\t)\n\t\t\treturn BreakAction.Prohibited;\n\t}\n\n\t// LB13: Do not break before ']' or '!' or ';' or '/', even after spaces\n\tif (\n\t\tafter === LineBreakClass.CL ||\n\t\tafter === LineBreakClass.CP ||\n\t\tafter === LineBreakClass.EX ||\n\t\tafter === LineBreakClass.IS ||\n\t\tafter === LineBreakClass.SY\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB14: Do not break after '[', even after spaces\n\tif (before === LineBreakClass.OP) return BreakAction.Prohibited;\n\n\t// LB15: Do not break within '\"[', even with intervening spaces\n\tif (before === LineBreakClass.QU && after === LineBreakClass.OP)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB16: Do not break between closing punctuation and nonstarter\n\tif (\n\t\t(before === LineBreakClass.CL || before === LineBreakClass.CP) &&\n\t\tafter === LineBreakClass.NS\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB17: Do not break within '', even with intervening spaces\n\tif (before === LineBreakClass.B2 && after === LineBreakClass.B2)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB18: Break after spaces\n\tif (before === LineBreakClass.SP) return BreakAction.Direct;\n\n\t// LB19: Do not break before or after quotation marks\n\tif (before === LineBreakClass.QU || after === LineBreakClass.QU)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB20: Break before and after unresolved CB\n\tif (before === LineBreakClass.CB || after === LineBreakClass.CB)\n\t\treturn BreakAction.Direct;\n\n\t// LB21: Do not break before hyphen-minus, etc.\n\t// Note: LB21a (Hebrew + Hyphen) is subsumed by this rule\n\tif (\n\t\tafter === LineBreakClass.BA ||\n\t\tafter === LineBreakClass.HY ||\n\t\tafter === LineBreakClass.NS\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (before === LineBreakClass.BB) return BreakAction.Prohibited;\n\n\t// LB21b: Don't break between Solidus and Hebrew letters\n\tif (before === LineBreakClass.SY && after === LineBreakClass.HL)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB22: Do not break before ellipses\n\tif (after === LineBreakClass.IN) return BreakAction.Prohibited;\n\n\t// LB23: Do not break between digits and letters\n\tif (\n\t\t(before === LineBreakClass.AL || before === LineBreakClass.HL) &&\n\t\tafter === LineBreakClass.NU\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.NU &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB23a: Do not break between numeric prefixes/postfixes and ideographs\n\tif (before === LineBreakClass.PR && after === LineBreakClass.ID)\n\t\treturn BreakAction.Prohibited;\n\tif (before === LineBreakClass.ID && after === LineBreakClass.PO)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB24: Do not break between numeric prefix/postfix and letters\n\tif (\n\t\t(before === LineBreakClass.PR || before === LineBreakClass.PO) &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\t(before === LineBreakClass.AL || before === LineBreakClass.HL) &&\n\t\t(after === LineBreakClass.PR || after === LineBreakClass.PO)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB25: Do not break between numbers\n\tif (\n\t\t(before === LineBreakClass.CL || before === LineBreakClass.CP) &&\n\t\tafter === LineBreakClass.NU\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.NU &&\n\t\t(after === LineBreakClass.PO || after === LineBreakClass.PR)\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\t(before === LineBreakClass.PO ||\n\t\t\tbefore === LineBreakClass.PR ||\n\t\t\tbefore === LineBreakClass.HY ||\n\t\t\tbefore === LineBreakClass.IS ||\n\t\t\tbefore === LineBreakClass.NU ||\n\t\t\tbefore === LineBreakClass.SY) &&\n\t\tafter === LineBreakClass.NU\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB26: Do not break a Korean syllable\n\tif (before === LineBreakClass.JL) {\n\t\tif (\n\t\t\tafter === LineBreakClass.JL ||\n\t\t\tafter === LineBreakClass.JV ||\n\t\t\tafter === LineBreakClass.H2 ||\n\t\t\tafter === LineBreakClass.H3\n\t\t)\n\t\t\treturn BreakAction.Prohibited;\n\t}\n\tif (before === LineBreakClass.JV || before === LineBreakClass.H2) {\n\t\tif (after === LineBreakClass.JV || after === LineBreakClass.JT)\n\t\t\treturn BreakAction.Prohibited;\n\t}\n\tif (before === LineBreakClass.JT || before === LineBreakClass.H3) {\n\t\tif (after === LineBreakClass.JT) return BreakAction.Prohibited;\n\t}\n\n\t// LB27: Treat Korean syllables as ID\n\tif (\n\t\tbefore === LineBreakClass.JL ||\n\t\tbefore === LineBreakClass.JV ||\n\t\tbefore === LineBreakClass.JT ||\n\t\tbefore === LineBreakClass.H2 ||\n\t\tbefore === LineBreakClass.H3\n\t) {\n\t\tif (after === LineBreakClass.PO) return BreakAction.Prohibited;\n\t}\n\tif (\n\t\tafter === LineBreakClass.JL ||\n\t\tafter === LineBreakClass.JV ||\n\t\tafter === LineBreakClass.JT ||\n\t\tafter === LineBreakClass.H2 ||\n\t\tafter === LineBreakClass.H3\n\t) {\n\t\tif (before === LineBreakClass.PR) return BreakAction.Prohibited;\n\t}\n\n\t// LB28: Do not break between alphabetics\n\tif (\n\t\t(before === LineBreakClass.AL || before === LineBreakClass.HL) &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB29: Do not break between numeric punctuation and alphabetics\n\tif (\n\t\tbefore === LineBreakClass.IS &&\n\t\t(after === LineBreakClass.AL || after === LineBreakClass.HL)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB30: Do not break between letters/numbers and opening/closing\n\tif (\n\t\t(before === LineBreakClass.AL ||\n\t\t\tbefore === LineBreakClass.HL ||\n\t\t\tbefore === LineBreakClass.NU) &&\n\t\tafter === LineBreakClass.OP\n\t)\n\t\treturn BreakAction.Prohibited;\n\tif (\n\t\tbefore === LineBreakClass.CP &&\n\t\t(after === LineBreakClass.AL ||\n\t\t\tafter === LineBreakClass.HL ||\n\t\t\tafter === LineBreakClass.NU)\n\t)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB30a: Break between pairs of regional indicator symbols\n\tif (before === LineBreakClass.RI && after === LineBreakClass.RI)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB30b: Do not break between an emoji base and an emoji modifier\n\tif (before === LineBreakClass.EB && after === LineBreakClass.EM)\n\t\treturn BreakAction.Prohibited;\n\n\t// LB31: Break everywhere else\n\treturn BreakAction.Direct;\n}\n\n/**\n * Result of line break analysis\n */\nexport interface LineBreakAnalysis {\n\t/** Break opportunities (one per character boundary) */\n\tbreaks: BreakOpportunity[];\n\t/** Line break classes for each character */\n\tclasses: LineBreakClass[];\n}\n\n/**\n * Analyze line break opportunities in text\n */\nexport function analyzeLineBreaks(text: string): LineBreakAnalysis {\n\tconst codepoints: number[] = [];\n\tconst chars = [...text];\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t}\n\n\treturn analyzeLineBreaksFromCodepoints(codepoints);\n}\n\n/**\n * Analyze line break opportunities from codepoints\n */\nexport function analyzeLineBreaksFromCodepoints(\n\tcodepoints: number[],\n): LineBreakAnalysis {\n\tconst len = codepoints.length;\n\tconst classes: LineBreakClass[] = [];\n\tconst breaks: BreakOpportunity[] = [];\n\n\t// Get classes for all codepoints\n\tfor (let i = 0; i < codepoints.length; i++) {\n\t\tconst cp = codepoints[i]!;\n\t\tclasses.push(getLineBreakClass(cp));\n\t}\n\n\t// LB1: Assign a line breaking class - done in getLineBreakClass\n\n\t// LB2: Never break at the start of text\n\tbreaks.push(BreakOpportunity.NoBreak);\n\n\t// Process each boundary\n\tfor (let i = 1; i < len; i++) {\n\t\tconst before = classes[i - 1];\n\t\tconst after = classes[i];\n\n\t\tconst action = getPairAction(before, after);\n\n\t\tswitch (action) {\n\t\t\tcase BreakAction.Explicit:\n\t\t\t\tbreaks.push(BreakOpportunity.Mandatory);\n\t\t\t\tbreak;\n\t\t\tcase BreakAction.Direct:\n\t\t\t\tbreaks.push(BreakOpportunity.Optional);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreaks.push(BreakOpportunity.NoBreak);\n\t\t}\n\t}\n\n\t// LB3: Always break at the end of text\n\tbreaks.push(BreakOpportunity.Mandatory);\n\n\treturn { breaks, classes };\n}\n\n/**\n * Analyze line breaks for glyph infos\n */\nexport function analyzeLineBreaksForGlyphs(\n\tinfos: GlyphInfo[],\n): LineBreakAnalysis {\n\tconst codepoints = infos.map((info) => info.codepoint);\n\treturn analyzeLineBreaksFromCodepoints(codepoints);\n}\n\n/**\n * Find next line break opportunity\n */\nexport function findNextBreak(\n\tanalysis: LineBreakAnalysis,\n\tstartIndex: number,\n): number {\n\tfor (let i = startIndex + 1; i < analysis.breaks.length; i++) {\n\t\tif (analysis.breaks[i] !== BreakOpportunity.NoBreak) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn analysis.breaks.length - 1;\n}\n\n/**\n * Check if break is allowed at position\n */\nexport function canBreakAt(\n\tanalysis: LineBreakAnalysis,\n\tindex: number,\n): boolean {\n\tif (index < 0 || index >= analysis.breaks.length) return false;\n\treturn analysis.breaks[index] !== BreakOpportunity.NoBreak;\n}\n\n/**\n * Check if break is mandatory at position\n */\nexport function mustBreakAt(\n\tanalysis: LineBreakAnalysis,\n\tindex: number,\n): boolean {\n\tif (index < 0 || index >= analysis.breaks.length) return false;\n\treturn analysis.breaks[index] === BreakOpportunity.Mandatory;\n}\n\n/**\n * Get all break opportunities\n */\nexport function getAllBreakOpportunities(\n\tanalysis: LineBreakAnalysis,\n): number[] {\n\tconst opportunities: number[] = [];\n\tfor (let i = 0; i < analysis.breaks.length; i++) {\n\t\tif (analysis.breaks[i] !== BreakOpportunity.NoBreak) {\n\t\t\topportunities.push(i);\n\t\t}\n\t}\n\treturn opportunities;\n}\n",
    "/**\n * Unicode Script Detection\n * Detects the script of text based on codepoints\n */\n\n/**\n * Unicode script values (ISO 15924)\n */\nexport enum Script {\n\tCommon = \"Zyyy\",\n\tInherited = \"Zinh\",\n\tUnknown = \"Zzzz\",\n\n\t// Major scripts\n\tLatin = \"Latn\",\n\tGreek = \"Grek\",\n\tCyrillic = \"Cyrl\",\n\tArmenian = \"Armn\",\n\tHebrew = \"Hebr\",\n\tArabic = \"Arab\",\n\tSyriac = \"Syrc\",\n\tThaana = \"Thaa\",\n\tDevanagari = \"Deva\",\n\tBengali = \"Beng\",\n\tGurmukhi = \"Guru\",\n\tGujarati = \"Gujr\",\n\tOriya = \"Orya\",\n\tTamil = \"Taml\",\n\tTelugu = \"Telu\",\n\tKannada = \"Knda\",\n\tMalayalam = \"Mlym\",\n\tSinhala = \"Sinh\",\n\tThai = \"Thai\",\n\tLao = \"Laoo\",\n\tTibetan = \"Tibt\",\n\tMyanmar = \"Mymr\",\n\tGeorgian = \"Geor\",\n\tHangul = \"Hang\",\n\tEthiopic = \"Ethi\",\n\tCherokee = \"Cher\",\n\tCanadianAboriginal = \"Cans\",\n\tOgham = \"Ogam\",\n\tRunic = \"Runr\",\n\tKhmer = \"Khmr\",\n\tMongolian = \"Mong\",\n\tHiragana = \"Hira\",\n\tKatakana = \"Kana\",\n\tBopomofo = \"Bopo\",\n\tHan = \"Hani\",\n\tYi = \"Yiii\",\n\tOldItalic = \"Ital\",\n\tGothic = \"Goth\",\n\tDeseret = \"Dsrt\",\n\tTagalog = \"Tglg\",\n\tHanunoo = \"Hano\",\n\tBuhid = \"Buhd\",\n\tTagbanwa = \"Tagb\",\n\tLimbu = \"Limb\",\n\tTaiLe = \"Tale\",\n\tLinearB = \"Linb\",\n\tUgaritic = \"Ugar\",\n\tShavian = \"Shaw\",\n\tOsmanya = \"Osma\",\n\tCypriot = \"Cprt\",\n\tBraille = \"Brai\",\n\tBuginese = \"Bugi\",\n\tCoptic = \"Copt\",\n\tNewTaiLue = \"Talu\",\n\tGlagolitic = \"Glag\",\n\tTifinagh = \"Tfng\",\n\tSylotiNagri = \"Sylo\",\n\tOldPersian = \"Xpeo\",\n\tKharoshthi = \"Khar\",\n\tBalinese = \"Bali\",\n\tCuneiform = \"Xsux\",\n\tPhoenician = \"Phnx\",\n\tPhagsPa = \"Phag\",\n\tNko = \"Nkoo\",\n\tSundanese = \"Sund\",\n\tLepcha = \"Lepc\",\n\tOlChiki = \"Olck\",\n\tVai = \"Vaii\",\n\tSaurashtra = \"Saur\",\n\tKayahLi = \"Kali\",\n\tRejang = \"Rjng\",\n\tLycian = \"Lyci\",\n\tCarian = \"Cari\",\n\tLydian = \"Lydi\",\n\tCham = \"Cham\",\n\tTaiTham = \"Lana\",\n\tTaiViet = \"Tavt\",\n\tAvestan = \"Avst\",\n\tEgyptianHieroglyphs = \"Egyp\",\n\tSamaritan = \"Samr\",\n\tLisu = \"Lisu\",\n\tBamum = \"Bamu\",\n\tJavanese = \"Java\",\n\tMeeteiMayek = \"Mtei\",\n\tImperialAramaic = \"Armi\",\n\tOldSouthArabian = \"Sarb\",\n\tInscriptionalParthian = \"Prti\",\n\tInscriptionalPahlavi = \"Phli\",\n\tOldTurkic = \"Orkh\",\n\tKaithi = \"Kthi\",\n\tBatak = \"Batk\",\n\tBrahmi = \"Brah\",\n\tMandaic = \"Mand\",\n\tChakma = \"Cakm\",\n\tMeroiticCursive = \"Merc\",\n\tMeroiticHieroglyphs = \"Mero\",\n\tMiao = \"Plrd\",\n\tSharada = \"Shrd\",\n\tSoraSompeng = \"Sora\",\n\tTakri = \"Takr\",\n\tCaucasianAlbanian = \"Aghb\",\n\tBassaVah = \"Bass\",\n\tDuployan = \"Dupl\",\n\tElbasan = \"Elba\",\n\tGrantha = \"Gran\",\n\tPahawhHmong = \"Hmng\",\n\tKhojki = \"Khoj\",\n\tLinearA = \"Lina\",\n\tMahajani = \"Mahj\",\n\tManichaean = \"Mani\",\n\tMendeKikakui = \"Mend\",\n\tModi = \"Modi\",\n\tMro = \"Mroo\",\n\tOldNorthArabian = \"Narb\",\n\tNabataean = \"Nbat\",\n\tPalmyrene = \"Palm\",\n\tPauCinHau = \"Pauc\",\n\tOldPermic = \"Perm\",\n\tPsalterPahlavi = \"Phlp\",\n\tSiddham = \"Sidd\",\n\tKhudawadi = \"Sind\",\n\tTirhuta = \"Tirh\",\n\tWarangCiti = \"Wara\",\n\tAhom = \"Ahom\",\n\tAnatolianHieroglyphs = \"Hluw\",\n\tHatran = \"Hatr\",\n\tMultani = \"Mult\",\n\tOldHungarian = \"Hung\",\n\tSignWriting = \"Sgnw\",\n\tAdlam = \"Adlm\",\n\tBhaiksuki = \"Bhks\",\n\tMarchen = \"Marc\",\n\tNewa = \"Newa\",\n\tOsage = \"Osge\",\n\tTangut = \"Tang\",\n\tMasaramGondi = \"Gonm\",\n\tNushu = \"Nshu\",\n\tSoyombo = \"Soyo\",\n\tZanabazarSquare = \"Zanb\",\n\tDogra = \"Dogr\",\n\tGunjalaGondi = \"Gong\",\n\tMakasar = \"Maka\",\n\tMedefaidrin = \"Medf\",\n\tHanifiRohingya = \"Rohg\",\n\tSogdian = \"Sogd\",\n\tOldSogdian = \"Sogo\",\n\tElymaic = \"Elym\",\n\tNandinagari = \"Nand\",\n\tNyiakengPuachueHmong = \"Hmnp\",\n\tWancho = \"Wcho\",\n\tYezidi = \"Yezi\",\n\tChorasmian = \"Chrs\",\n\tDivesAkuru = \"Diak\",\n\tKhitanSmallScript = \"Kits\",\n\tVithkuqi = \"Vith\",\n\tOldUyghur = \"Ougr\",\n\tCypro_Minoan = \"Cpmn\",\n\tTangsa = \"Tnsa\",\n\tToto = \"Toto\",\n\tKawi = \"Kawi\",\n\tNagMundari = \"Nagm\",\n}\n\n/**\n * Script range entry\n */\ninterface ScriptRange {\n\tstart: number;\n\tend: number;\n\tscript: Script;\n}\n\n/**\n * Script ranges (sorted by start codepoint)\n */\nconst SCRIPT_RANGES: ScriptRange[] = [\n\t// Basic Latin\n\t{ start: 0x0000, end: 0x007f, script: Script.Common },\n\t// Latin-1 Supplement\n\t{ start: 0x0080, end: 0x00ff, script: Script.Latin },\n\t// Latin Extended-A\n\t{ start: 0x0100, end: 0x017f, script: Script.Latin },\n\t// Latin Extended-B\n\t{ start: 0x0180, end: 0x024f, script: Script.Latin },\n\t// IPA Extensions\n\t{ start: 0x0250, end: 0x02af, script: Script.Latin },\n\t// Spacing Modifier Letters\n\t{ start: 0x02b0, end: 0x02ff, script: Script.Common },\n\t// Combining Diacritical Marks\n\t{ start: 0x0300, end: 0x036f, script: Script.Inherited },\n\t// Greek and Coptic\n\t{ start: 0x0370, end: 0x03ff, script: Script.Greek },\n\t// Cyrillic\n\t{ start: 0x0400, end: 0x04ff, script: Script.Cyrillic },\n\t// Cyrillic Supplement\n\t{ start: 0x0500, end: 0x052f, script: Script.Cyrillic },\n\t// Armenian\n\t{ start: 0x0530, end: 0x058f, script: Script.Armenian },\n\t// Hebrew\n\t{ start: 0x0590, end: 0x05ff, script: Script.Hebrew },\n\t// Arabic\n\t{ start: 0x0600, end: 0x06ff, script: Script.Arabic },\n\t// Syriac\n\t{ start: 0x0700, end: 0x074f, script: Script.Syriac },\n\t// Arabic Supplement\n\t{ start: 0x0750, end: 0x077f, script: Script.Arabic },\n\t// Thaana\n\t{ start: 0x0780, end: 0x07bf, script: Script.Thaana },\n\t// NKo\n\t{ start: 0x07c0, end: 0x07ff, script: Script.Nko },\n\t// Samaritan\n\t{ start: 0x0800, end: 0x083f, script: Script.Samaritan },\n\t// Mandaic\n\t{ start: 0x0840, end: 0x085f, script: Script.Mandaic },\n\t// Syriac Supplement\n\t{ start: 0x0860, end: 0x086f, script: Script.Syriac },\n\t// Arabic Extended-B\n\t{ start: 0x0870, end: 0x089f, script: Script.Arabic },\n\t// Arabic Extended-A\n\t{ start: 0x08a0, end: 0x08ff, script: Script.Arabic },\n\t// Devanagari\n\t{ start: 0x0900, end: 0x097f, script: Script.Devanagari },\n\t// Bengali\n\t{ start: 0x0980, end: 0x09ff, script: Script.Bengali },\n\t// Gurmukhi\n\t{ start: 0x0a00, end: 0x0a7f, script: Script.Gurmukhi },\n\t// Gujarati\n\t{ start: 0x0a80, end: 0x0aff, script: Script.Gujarati },\n\t// Oriya\n\t{ start: 0x0b00, end: 0x0b7f, script: Script.Oriya },\n\t// Tamil\n\t{ start: 0x0b80, end: 0x0bff, script: Script.Tamil },\n\t// Telugu\n\t{ start: 0x0c00, end: 0x0c7f, script: Script.Telugu },\n\t// Kannada\n\t{ start: 0x0c80, end: 0x0cff, script: Script.Kannada },\n\t// Malayalam\n\t{ start: 0x0d00, end: 0x0d7f, script: Script.Malayalam },\n\t// Sinhala\n\t{ start: 0x0d80, end: 0x0dff, script: Script.Sinhala },\n\t// Thai\n\t{ start: 0x0e00, end: 0x0e7f, script: Script.Thai },\n\t// Lao\n\t{ start: 0x0e80, end: 0x0eff, script: Script.Lao },\n\t// Tibetan\n\t{ start: 0x0f00, end: 0x0fff, script: Script.Tibetan },\n\t// Myanmar\n\t{ start: 0x1000, end: 0x109f, script: Script.Myanmar },\n\t// Georgian\n\t{ start: 0x10a0, end: 0x10ff, script: Script.Georgian },\n\t// Hangul Jamo\n\t{ start: 0x1100, end: 0x11ff, script: Script.Hangul },\n\t// Ethiopic\n\t{ start: 0x1200, end: 0x137f, script: Script.Ethiopic },\n\t// Ethiopic Supplement\n\t{ start: 0x1380, end: 0x139f, script: Script.Ethiopic },\n\t// Cherokee\n\t{ start: 0x13a0, end: 0x13ff, script: Script.Cherokee },\n\t// Unified Canadian Aboriginal Syllabics\n\t{ start: 0x1400, end: 0x167f, script: Script.CanadianAboriginal },\n\t// Ogham\n\t{ start: 0x1680, end: 0x169f, script: Script.Ogham },\n\t// Runic\n\t{ start: 0x16a0, end: 0x16ff, script: Script.Runic },\n\t// Tagalog\n\t{ start: 0x1700, end: 0x171f, script: Script.Tagalog },\n\t// Hanunoo\n\t{ start: 0x1720, end: 0x173f, script: Script.Hanunoo },\n\t// Buhid\n\t{ start: 0x1740, end: 0x175f, script: Script.Buhid },\n\t// Tagbanwa\n\t{ start: 0x1760, end: 0x177f, script: Script.Tagbanwa },\n\t// Khmer\n\t{ start: 0x1780, end: 0x17ff, script: Script.Khmer },\n\t// Mongolian\n\t{ start: 0x1800, end: 0x18af, script: Script.Mongolian },\n\t// Unified Canadian Aboriginal Syllabics Extended\n\t{ start: 0x18b0, end: 0x18ff, script: Script.CanadianAboriginal },\n\t// Limbu\n\t{ start: 0x1900, end: 0x194f, script: Script.Limbu },\n\t// Tai Le\n\t{ start: 0x1950, end: 0x197f, script: Script.TaiLe },\n\t// New Tai Lue\n\t{ start: 0x1980, end: 0x19df, script: Script.NewTaiLue },\n\t// Khmer Symbols\n\t{ start: 0x19e0, end: 0x19ff, script: Script.Khmer },\n\t// Buginese\n\t{ start: 0x1a00, end: 0x1a1f, script: Script.Buginese },\n\t// Tai Tham\n\t{ start: 0x1a20, end: 0x1aaf, script: Script.TaiTham },\n\t// Combining Diacritical Marks Extended\n\t{ start: 0x1ab0, end: 0x1aff, script: Script.Inherited },\n\t// Balinese\n\t{ start: 0x1b00, end: 0x1b7f, script: Script.Balinese },\n\t// Sundanese\n\t{ start: 0x1b80, end: 0x1bbf, script: Script.Sundanese },\n\t// Batak\n\t{ start: 0x1bc0, end: 0x1bff, script: Script.Batak },\n\t// Lepcha\n\t{ start: 0x1c00, end: 0x1c4f, script: Script.Lepcha },\n\t// Ol Chiki\n\t{ start: 0x1c50, end: 0x1c7f, script: Script.OlChiki },\n\t// Cyrillic Extended-C\n\t{ start: 0x1c80, end: 0x1c8f, script: Script.Cyrillic },\n\t// Georgian Extended\n\t{ start: 0x1c90, end: 0x1cbf, script: Script.Georgian },\n\t// Sundanese Supplement\n\t{ start: 0x1cc0, end: 0x1ccf, script: Script.Sundanese },\n\t// Vedic Extensions\n\t{ start: 0x1cd0, end: 0x1cff, script: Script.Inherited },\n\t// Phonetic Extensions\n\t{ start: 0x1d00, end: 0x1d7f, script: Script.Latin },\n\t// Phonetic Extensions Supplement\n\t{ start: 0x1d80, end: 0x1dbf, script: Script.Latin },\n\t// Combining Diacritical Marks Supplement\n\t{ start: 0x1dc0, end: 0x1dff, script: Script.Inherited },\n\t// Latin Extended Additional\n\t{ start: 0x1e00, end: 0x1eff, script: Script.Latin },\n\t// Greek Extended\n\t{ start: 0x1f00, end: 0x1fff, script: Script.Greek },\n\t// General Punctuation\n\t{ start: 0x2000, end: 0x206f, script: Script.Common },\n\t// Superscripts and Subscripts\n\t{ start: 0x2070, end: 0x209f, script: Script.Common },\n\t// Currency Symbols\n\t{ start: 0x20a0, end: 0x20cf, script: Script.Common },\n\t// Combining Diacritical Marks for Symbols\n\t{ start: 0x20d0, end: 0x20ff, script: Script.Inherited },\n\t// Letterlike Symbols\n\t{ start: 0x2100, end: 0x214f, script: Script.Common },\n\t// Number Forms\n\t{ start: 0x2150, end: 0x218f, script: Script.Common },\n\t// Arrows\n\t{ start: 0x2190, end: 0x21ff, script: Script.Common },\n\t// Mathematical Operators\n\t{ start: 0x2200, end: 0x22ff, script: Script.Common },\n\t// Miscellaneous Technical\n\t{ start: 0x2300, end: 0x23ff, script: Script.Common },\n\t// Control Pictures\n\t{ start: 0x2400, end: 0x243f, script: Script.Common },\n\t// OCR\n\t{ start: 0x2440, end: 0x245f, script: Script.Common },\n\t// Enclosed Alphanumerics\n\t{ start: 0x2460, end: 0x24ff, script: Script.Common },\n\t// Box Drawing\n\t{ start: 0x2500, end: 0x257f, script: Script.Common },\n\t// Block Elements\n\t{ start: 0x2580, end: 0x259f, script: Script.Common },\n\t// Geometric Shapes\n\t{ start: 0x25a0, end: 0x25ff, script: Script.Common },\n\t// Miscellaneous Symbols\n\t{ start: 0x2600, end: 0x26ff, script: Script.Common },\n\t// Dingbats\n\t{ start: 0x2700, end: 0x27bf, script: Script.Common },\n\t// Miscellaneous Mathematical Symbols-A\n\t{ start: 0x27c0, end: 0x27ef, script: Script.Common },\n\t// Supplemental Arrows-A\n\t{ start: 0x27f0, end: 0x27ff, script: Script.Common },\n\t// Braille Patterns\n\t{ start: 0x2800, end: 0x28ff, script: Script.Braille },\n\t// Supplemental Arrows-B\n\t{ start: 0x2900, end: 0x297f, script: Script.Common },\n\t// Miscellaneous Mathematical Symbols-B\n\t{ start: 0x2980, end: 0x29ff, script: Script.Common },\n\t// Supplemental Mathematical Operators\n\t{ start: 0x2a00, end: 0x2aff, script: Script.Common },\n\t// Miscellaneous Symbols and Arrows\n\t{ start: 0x2b00, end: 0x2bff, script: Script.Common },\n\t// Glagolitic\n\t{ start: 0x2c00, end: 0x2c5f, script: Script.Glagolitic },\n\t// Latin Extended-C\n\t{ start: 0x2c60, end: 0x2c7f, script: Script.Latin },\n\t// Coptic\n\t{ start: 0x2c80, end: 0x2cff, script: Script.Coptic },\n\t// Georgian Supplement\n\t{ start: 0x2d00, end: 0x2d2f, script: Script.Georgian },\n\t// Tifinagh\n\t{ start: 0x2d30, end: 0x2d7f, script: Script.Tifinagh },\n\t// Ethiopic Extended\n\t{ start: 0x2d80, end: 0x2ddf, script: Script.Ethiopic },\n\t// Cyrillic Extended-A\n\t{ start: 0x2de0, end: 0x2dff, script: Script.Cyrillic },\n\t// Supplemental Punctuation\n\t{ start: 0x2e00, end: 0x2e7f, script: Script.Common },\n\t// CJK Radicals Supplement\n\t{ start: 0x2e80, end: 0x2eff, script: Script.Han },\n\t// Kangxi Radicals\n\t{ start: 0x2f00, end: 0x2fdf, script: Script.Han },\n\t// Ideographic Description Characters\n\t{ start: 0x2ff0, end: 0x2fff, script: Script.Common },\n\t// CJK Symbols and Punctuation\n\t{ start: 0x3000, end: 0x303f, script: Script.Common },\n\t// Hiragana\n\t{ start: 0x3040, end: 0x309f, script: Script.Hiragana },\n\t// Katakana\n\t{ start: 0x30a0, end: 0x30ff, script: Script.Katakana },\n\t// Bopomofo\n\t{ start: 0x3100, end: 0x312f, script: Script.Bopomofo },\n\t// Hangul Compatibility Jamo\n\t{ start: 0x3130, end: 0x318f, script: Script.Hangul },\n\t// Kanbun\n\t{ start: 0x3190, end: 0x319f, script: Script.Common },\n\t// Bopomofo Extended\n\t{ start: 0x31a0, end: 0x31bf, script: Script.Bopomofo },\n\t// CJK Strokes\n\t{ start: 0x31c0, end: 0x31ef, script: Script.Common },\n\t// Katakana Phonetic Extensions\n\t{ start: 0x31f0, end: 0x31ff, script: Script.Katakana },\n\t// Enclosed CJK Letters and Months\n\t{ start: 0x3200, end: 0x32ff, script: Script.Common },\n\t// CJK Compatibility\n\t{ start: 0x3300, end: 0x33ff, script: Script.Common },\n\t// CJK Unified Ideographs Extension A\n\t{ start: 0x3400, end: 0x4dbf, script: Script.Han },\n\t// Yijing Hexagram Symbols\n\t{ start: 0x4dc0, end: 0x4dff, script: Script.Common },\n\t// CJK Unified Ideographs\n\t{ start: 0x4e00, end: 0x9fff, script: Script.Han },\n\t// Yi Syllables\n\t{ start: 0xa000, end: 0xa48f, script: Script.Yi },\n\t// Yi Radicals\n\t{ start: 0xa490, end: 0xa4cf, script: Script.Yi },\n\t// Lisu\n\t{ start: 0xa4d0, end: 0xa4ff, script: Script.Lisu },\n\t// Vai\n\t{ start: 0xa500, end: 0xa63f, script: Script.Vai },\n\t// Cyrillic Extended-B\n\t{ start: 0xa640, end: 0xa69f, script: Script.Cyrillic },\n\t// Bamum\n\t{ start: 0xa6a0, end: 0xa6ff, script: Script.Bamum },\n\t// Modifier Tone Letters\n\t{ start: 0xa700, end: 0xa71f, script: Script.Common },\n\t// Latin Extended-D\n\t{ start: 0xa720, end: 0xa7ff, script: Script.Latin },\n\t// Syloti Nagri\n\t{ start: 0xa800, end: 0xa82f, script: Script.SylotiNagri },\n\t// Common Indic Number Forms\n\t{ start: 0xa830, end: 0xa83f, script: Script.Common },\n\t// Phags-pa\n\t{ start: 0xa840, end: 0xa87f, script: Script.PhagsPa },\n\t// Saurashtra\n\t{ start: 0xa880, end: 0xa8df, script: Script.Saurashtra },\n\t// Devanagari Extended\n\t{ start: 0xa8e0, end: 0xa8ff, script: Script.Devanagari },\n\t// Kayah Li\n\t{ start: 0xa900, end: 0xa92f, script: Script.KayahLi },\n\t// Rejang\n\t{ start: 0xa930, end: 0xa95f, script: Script.Rejang },\n\t// Hangul Jamo Extended-A\n\t{ start: 0xa960, end: 0xa97f, script: Script.Hangul },\n\t// Javanese\n\t{ start: 0xa980, end: 0xa9df, script: Script.Javanese },\n\t// Myanmar Extended-B\n\t{ start: 0xa9e0, end: 0xa9ff, script: Script.Myanmar },\n\t// Cham\n\t{ start: 0xaa00, end: 0xaa5f, script: Script.Cham },\n\t// Myanmar Extended-A\n\t{ start: 0xaa60, end: 0xaa7f, script: Script.Myanmar },\n\t// Tai Viet\n\t{ start: 0xaa80, end: 0xaadf, script: Script.TaiViet },\n\t// Meetei Mayek Extensions\n\t{ start: 0xaae0, end: 0xaaff, script: Script.MeeteiMayek },\n\t// Ethiopic Extended-A\n\t{ start: 0xab00, end: 0xab2f, script: Script.Ethiopic },\n\t// Latin Extended-E\n\t{ start: 0xab30, end: 0xab6f, script: Script.Latin },\n\t// Cherokee Supplement\n\t{ start: 0xab70, end: 0xabbf, script: Script.Cherokee },\n\t// Meetei Mayek\n\t{ start: 0xabc0, end: 0xabff, script: Script.MeeteiMayek },\n\t// Hangul Syllables\n\t{ start: 0xac00, end: 0xd7af, script: Script.Hangul },\n\t// Hangul Jamo Extended-B\n\t{ start: 0xd7b0, end: 0xd7ff, script: Script.Hangul },\n\t// High Surrogates, Low Surrogates\n\t{ start: 0xd800, end: 0xdfff, script: Script.Unknown },\n\t// Private Use Area\n\t{ start: 0xe000, end: 0xf8ff, script: Script.Unknown },\n\t// CJK Compatibility Ideographs\n\t{ start: 0xf900, end: 0xfaff, script: Script.Han },\n\t// Alphabetic Presentation Forms\n\t{ start: 0xfb00, end: 0xfb4f, script: Script.Latin },\n\t// Arabic Presentation Forms-A\n\t{ start: 0xfb50, end: 0xfdff, script: Script.Arabic },\n\t// Variation Selectors\n\t{ start: 0xfe00, end: 0xfe0f, script: Script.Inherited },\n\t// Vertical Forms\n\t{ start: 0xfe10, end: 0xfe1f, script: Script.Common },\n\t// Combining Half Marks\n\t{ start: 0xfe20, end: 0xfe2f, script: Script.Inherited },\n\t// CJK Compatibility Forms\n\t{ start: 0xfe30, end: 0xfe4f, script: Script.Common },\n\t// Small Form Variants\n\t{ start: 0xfe50, end: 0xfe6f, script: Script.Common },\n\t// Arabic Presentation Forms-B\n\t{ start: 0xfe70, end: 0xfeff, script: Script.Arabic },\n\t// Halfwidth and Fullwidth Forms\n\t{ start: 0xff00, end: 0xffef, script: Script.Common },\n\t// Specials\n\t{ start: 0xfff0, end: 0xffff, script: Script.Common },\n\t// Linear B Syllabary\n\t{ start: 0x10000, end: 0x1007f, script: Script.LinearB },\n\t// Linear B Ideograms\n\t{ start: 0x10080, end: 0x100ff, script: Script.LinearB },\n\t// Aegean Numbers\n\t{ start: 0x10100, end: 0x1013f, script: Script.Common },\n\t// Ancient Greek Numbers\n\t{ start: 0x10140, end: 0x1018f, script: Script.Greek },\n\t// Ancient Symbols\n\t{ start: 0x10190, end: 0x101cf, script: Script.Common },\n\t// Phaistos Disc\n\t{ start: 0x101d0, end: 0x101ff, script: Script.Common },\n\t// Lycian\n\t{ start: 0x10280, end: 0x1029f, script: Script.Lycian },\n\t// Carian\n\t{ start: 0x102a0, end: 0x102df, script: Script.Carian },\n\t// Coptic Epact Numbers\n\t{ start: 0x102e0, end: 0x102ff, script: Script.Inherited },\n\t// Old Italic\n\t{ start: 0x10300, end: 0x1032f, script: Script.OldItalic },\n\t// Gothic\n\t{ start: 0x10330, end: 0x1034f, script: Script.Gothic },\n\t// Old Permic\n\t{ start: 0x10350, end: 0x1037f, script: Script.OldPermic },\n\t// Ugaritic\n\t{ start: 0x10380, end: 0x1039f, script: Script.Ugaritic },\n\t// Old Persian\n\t{ start: 0x103a0, end: 0x103df, script: Script.OldPersian },\n\t// Deseret\n\t{ start: 0x10400, end: 0x1044f, script: Script.Deseret },\n\t// Shavian\n\t{ start: 0x10450, end: 0x1047f, script: Script.Shavian },\n\t// Osmanya\n\t{ start: 0x10480, end: 0x104af, script: Script.Osmanya },\n\t// Osage\n\t{ start: 0x104b0, end: 0x104ff, script: Script.Osage },\n\t// Elbasan\n\t{ start: 0x10500, end: 0x1052f, script: Script.Elbasan },\n\t// Caucasian Albanian\n\t{ start: 0x10530, end: 0x1056f, script: Script.CaucasianAlbanian },\n\t// Vithkuqi\n\t{ start: 0x10570, end: 0x105bf, script: Script.Vithkuqi },\n\t// Linear A\n\t{ start: 0x10600, end: 0x1077f, script: Script.LinearA },\n\t// Latin Extended-F\n\t{ start: 0x10780, end: 0x107bf, script: Script.Latin },\n\t// Cypriot Syllabary\n\t{ start: 0x10800, end: 0x1083f, script: Script.Cypriot },\n\t// Imperial Aramaic\n\t{ start: 0x10840, end: 0x1085f, script: Script.ImperialAramaic },\n\t// Palmyrene\n\t{ start: 0x10860, end: 0x1087f, script: Script.Palmyrene },\n\t// Nabataean\n\t{ start: 0x10880, end: 0x108af, script: Script.Nabataean },\n\t// Hatran\n\t{ start: 0x108e0, end: 0x108ff, script: Script.Hatran },\n\t// Phoenician\n\t{ start: 0x10900, end: 0x1091f, script: Script.Phoenician },\n\t// Lydian\n\t{ start: 0x10920, end: 0x1093f, script: Script.Lydian },\n\t// Meroitic Hieroglyphs\n\t{ start: 0x10980, end: 0x1099f, script: Script.MeroiticHieroglyphs },\n\t// Meroitic Cursive\n\t{ start: 0x109a0, end: 0x109ff, script: Script.MeroiticCursive },\n\t// Kharoshthi\n\t{ start: 0x10a00, end: 0x10a5f, script: Script.Kharoshthi },\n\t// Old South Arabian\n\t{ start: 0x10a60, end: 0x10a7f, script: Script.OldSouthArabian },\n\t// Old North Arabian\n\t{ start: 0x10a80, end: 0x10a9f, script: Script.OldNorthArabian },\n\t// Manichaean\n\t{ start: 0x10ac0, end: 0x10aff, script: Script.Manichaean },\n\t// Avestan\n\t{ start: 0x10b00, end: 0x10b3f, script: Script.Avestan },\n\t// Inscriptional Parthian\n\t{ start: 0x10b40, end: 0x10b5f, script: Script.InscriptionalParthian },\n\t// Inscriptional Pahlavi\n\t{ start: 0x10b60, end: 0x10b7f, script: Script.InscriptionalPahlavi },\n\t// Psalter Pahlavi\n\t{ start: 0x10b80, end: 0x10baf, script: Script.PsalterPahlavi },\n\t// Old Turkic\n\t{ start: 0x10c00, end: 0x10c4f, script: Script.OldTurkic },\n\t// Old Hungarian\n\t{ start: 0x10c80, end: 0x10cff, script: Script.OldHungarian },\n\t// Hanifi Rohingya\n\t{ start: 0x10d00, end: 0x10d3f, script: Script.HanifiRohingya },\n\t// Yezidi\n\t{ start: 0x10e80, end: 0x10ebf, script: Script.Yezidi },\n\t// Old Sogdian\n\t{ start: 0x10f00, end: 0x10f2f, script: Script.OldSogdian },\n\t// Sogdian\n\t{ start: 0x10f30, end: 0x10f6f, script: Script.Sogdian },\n\t// Old Uyghur\n\t{ start: 0x10f70, end: 0x10faf, script: Script.OldUyghur },\n\t// Chorasmian\n\t{ start: 0x10fb0, end: 0x10fdf, script: Script.Chorasmian },\n\t// Elymaic\n\t{ start: 0x10fe0, end: 0x10fff, script: Script.Elymaic },\n\t// Brahmi\n\t{ start: 0x11000, end: 0x1107f, script: Script.Brahmi },\n\t// Kaithi\n\t{ start: 0x11080, end: 0x110cf, script: Script.Kaithi },\n\t// Sora Sompeng\n\t{ start: 0x110d0, end: 0x110ff, script: Script.SoraSompeng },\n\t// Chakma\n\t{ start: 0x11100, end: 0x1114f, script: Script.Chakma },\n\t// Mahajani\n\t{ start: 0x11150, end: 0x1117f, script: Script.Mahajani },\n\t// Sharada\n\t{ start: 0x11180, end: 0x111df, script: Script.Sharada },\n\t// Sinhala Archaic Numbers\n\t{ start: 0x111e0, end: 0x111ff, script: Script.Sinhala },\n\t// Khojki\n\t{ start: 0x11200, end: 0x1124f, script: Script.Khojki },\n\t// Multani\n\t{ start: 0x11280, end: 0x112af, script: Script.Multani },\n\t// Khudawadi\n\t{ start: 0x112b0, end: 0x112ff, script: Script.Khudawadi },\n\t// Grantha\n\t{ start: 0x11300, end: 0x1137f, script: Script.Grantha },\n\t// Newa\n\t{ start: 0x11400, end: 0x1147f, script: Script.Newa },\n\t// Tirhuta\n\t{ start: 0x11480, end: 0x114df, script: Script.Tirhuta },\n\t// Siddham\n\t{ start: 0x11580, end: 0x115ff, script: Script.Siddham },\n\t// Modi\n\t{ start: 0x11600, end: 0x1165f, script: Script.Modi },\n\t// Mongolian Supplement\n\t{ start: 0x11660, end: 0x1167f, script: Script.Mongolian },\n\t// Takri\n\t{ start: 0x11680, end: 0x116cf, script: Script.Takri },\n\t// Ahom\n\t{ start: 0x11700, end: 0x1174f, script: Script.Ahom },\n\t// Dogra\n\t{ start: 0x11800, end: 0x1184f, script: Script.Dogra },\n\t// Warang Citi\n\t{ start: 0x118a0, end: 0x118ff, script: Script.WarangCiti },\n\t// Dives Akuru\n\t{ start: 0x11900, end: 0x1195f, script: Script.DivesAkuru },\n\t// Nandinagari\n\t{ start: 0x119a0, end: 0x119ff, script: Script.Nandinagari },\n\t// Zanabazar Square\n\t{ start: 0x11a00, end: 0x11a4f, script: Script.ZanabazarSquare },\n\t// Soyombo\n\t{ start: 0x11a50, end: 0x11aaf, script: Script.Soyombo },\n\t// UCAS Extended-A\n\t{ start: 0x11ab0, end: 0x11abf, script: Script.CanadianAboriginal },\n\t// Pau Cin Hau\n\t{ start: 0x11ac0, end: 0x11aff, script: Script.PauCinHau },\n\t// Bhaiksuki\n\t{ start: 0x11c00, end: 0x11c6f, script: Script.Bhaiksuki },\n\t// Marchen\n\t{ start: 0x11c70, end: 0x11cbf, script: Script.Marchen },\n\t// Masaram Gondi\n\t{ start: 0x11d00, end: 0x11d5f, script: Script.MasaramGondi },\n\t// Gunjala Gondi\n\t{ start: 0x11d60, end: 0x11daf, script: Script.GunjalaGondi },\n\t// Makasar\n\t{ start: 0x11ee0, end: 0x11eff, script: Script.Makasar },\n\t// Kawi\n\t{ start: 0x11f00, end: 0x11f5f, script: Script.Kawi },\n\t// Cuneiform\n\t{ start: 0x12000, end: 0x123ff, script: Script.Cuneiform },\n\t// Cuneiform Numbers and Punctuation\n\t{ start: 0x12400, end: 0x1247f, script: Script.Cuneiform },\n\t// Early Dynastic Cuneiform\n\t{ start: 0x12480, end: 0x1254f, script: Script.Cuneiform },\n\t// Cypro-Minoan\n\t{ start: 0x12f90, end: 0x12fff, script: Script.Cypro_Minoan },\n\t// Egyptian Hieroglyphs\n\t{ start: 0x13000, end: 0x1342f, script: Script.EgyptianHieroglyphs },\n\t// Egyptian Hieroglyph Format Controls\n\t{ start: 0x13430, end: 0x1345f, script: Script.EgyptianHieroglyphs },\n\t// Anatolian Hieroglyphs\n\t{ start: 0x14400, end: 0x1467f, script: Script.AnatolianHieroglyphs },\n\t// Bamum Supplement\n\t{ start: 0x16800, end: 0x16a3f, script: Script.Bamum },\n\t// Mro\n\t{ start: 0x16a40, end: 0x16a6f, script: Script.Mro },\n\t// Tangsa\n\t{ start: 0x16a70, end: 0x16acf, script: Script.Tangsa },\n\t// Bassa Vah\n\t{ start: 0x16ad0, end: 0x16aff, script: Script.BassaVah },\n\t// Pahawh Hmong\n\t{ start: 0x16b00, end: 0x16b8f, script: Script.PahawhHmong },\n\t// Medefaidrin\n\t{ start: 0x16e40, end: 0x16e9f, script: Script.Medefaidrin },\n\t// Miao\n\t{ start: 0x16f00, end: 0x16f9f, script: Script.Miao },\n\t// Ideographic Symbols and Punctuation\n\t{ start: 0x16fe0, end: 0x16fff, script: Script.Common },\n\t// Tangut\n\t{ start: 0x17000, end: 0x187ff, script: Script.Tangut },\n\t// Tangut Components\n\t{ start: 0x18800, end: 0x18aff, script: Script.Tangut },\n\t// Khitan Small Script\n\t{ start: 0x18b00, end: 0x18cff, script: Script.KhitanSmallScript },\n\t// Tangut Supplement\n\t{ start: 0x18d00, end: 0x18d7f, script: Script.Tangut },\n\t// Kana Extended-B\n\t{ start: 0x1aff0, end: 0x1afff, script: Script.Katakana },\n\t// Kana Supplement\n\t{ start: 0x1b000, end: 0x1b0ff, script: Script.Hiragana },\n\t// Kana Extended-A\n\t{ start: 0x1b100, end: 0x1b12f, script: Script.Hiragana },\n\t// Small Kana Extension\n\t{ start: 0x1b130, end: 0x1b16f, script: Script.Katakana },\n\t// Nushu\n\t{ start: 0x1b170, end: 0x1b2ff, script: Script.Nushu },\n\t// Duployan\n\t{ start: 0x1bc00, end: 0x1bc9f, script: Script.Duployan },\n\t// Shorthand Format Controls\n\t{ start: 0x1bca0, end: 0x1bcaf, script: Script.Common },\n\t// Znamenny Musical Notation\n\t{ start: 0x1cf00, end: 0x1cfcf, script: Script.Common },\n\t// Byzantine Musical Symbols\n\t{ start: 0x1d000, end: 0x1d0ff, script: Script.Common },\n\t// Musical Symbols\n\t{ start: 0x1d100, end: 0x1d1ff, script: Script.Common },\n\t// Ancient Greek Musical Notation\n\t{ start: 0x1d200, end: 0x1d24f, script: Script.Greek },\n\t// Kaktovik Numerals\n\t{ start: 0x1d2c0, end: 0x1d2df, script: Script.Common },\n\t// Mayan Numerals\n\t{ start: 0x1d2e0, end: 0x1d2ff, script: Script.Common },\n\t// Tai Xuan Jing Symbols\n\t{ start: 0x1d300, end: 0x1d35f, script: Script.Common },\n\t// Counting Rod Numerals\n\t{ start: 0x1d360, end: 0x1d37f, script: Script.Common },\n\t// Mathematical Alphanumeric Symbols\n\t{ start: 0x1d400, end: 0x1d7ff, script: Script.Common },\n\t// Sutton SignWriting\n\t{ start: 0x1d800, end: 0x1daaf, script: Script.SignWriting },\n\t// Latin Extended-G\n\t{ start: 0x1df00, end: 0x1dfff, script: Script.Latin },\n\t// Glagolitic Supplement\n\t{ start: 0x1e000, end: 0x1e02f, script: Script.Glagolitic },\n\t// Cyrillic Extended-D\n\t{ start: 0x1e030, end: 0x1e08f, script: Script.Cyrillic },\n\t// Nyiakeng Puachue Hmong\n\t{ start: 0x1e100, end: 0x1e14f, script: Script.NyiakengPuachueHmong },\n\t// Toto\n\t{ start: 0x1e290, end: 0x1e2bf, script: Script.Toto },\n\t// Wancho\n\t{ start: 0x1e2c0, end: 0x1e2ff, script: Script.Wancho },\n\t// Nag Mundari\n\t{ start: 0x1e4d0, end: 0x1e4ff, script: Script.NagMundari },\n\t// Ethiopic Extended-B\n\t{ start: 0x1e7e0, end: 0x1e7ff, script: Script.Ethiopic },\n\t// Mende Kikakui\n\t{ start: 0x1e800, end: 0x1e8df, script: Script.MendeKikakui },\n\t// Adlam\n\t{ start: 0x1e900, end: 0x1e95f, script: Script.Adlam },\n\t// Indic Siyaq Numbers\n\t{ start: 0x1ec70, end: 0x1ecbf, script: Script.Common },\n\t// Ottoman Siyaq Numbers\n\t{ start: 0x1ed00, end: 0x1ed4f, script: Script.Common },\n\t// Arabic Mathematical Alphabetic Symbols\n\t{ start: 0x1ee00, end: 0x1eeff, script: Script.Arabic },\n\t// Mahjong Tiles\n\t{ start: 0x1f000, end: 0x1f02f, script: Script.Common },\n\t// Domino Tiles\n\t{ start: 0x1f030, end: 0x1f09f, script: Script.Common },\n\t// Playing Cards\n\t{ start: 0x1f0a0, end: 0x1f0ff, script: Script.Common },\n\t// Enclosed Alphanumeric Supplement\n\t{ start: 0x1f100, end: 0x1f1ff, script: Script.Common },\n\t// Enclosed Ideographic Supplement\n\t{ start: 0x1f200, end: 0x1f2ff, script: Script.Common },\n\t// Miscellaneous Symbols and Pictographs\n\t{ start: 0x1f300, end: 0x1f5ff, script: Script.Common },\n\t// Emoticons\n\t{ start: 0x1f600, end: 0x1f64f, script: Script.Common },\n\t// Ornamental Dingbats\n\t{ start: 0x1f650, end: 0x1f67f, script: Script.Common },\n\t// Transport and Map Symbols\n\t{ start: 0x1f680, end: 0x1f6ff, script: Script.Common },\n\t// Alchemical Symbols\n\t{ start: 0x1f700, end: 0x1f77f, script: Script.Common },\n\t// Geometric Shapes Extended\n\t{ start: 0x1f780, end: 0x1f7ff, script: Script.Common },\n\t// Supplemental Arrows-C\n\t{ start: 0x1f800, end: 0x1f8ff, script: Script.Common },\n\t// Supplemental Symbols and Pictographs\n\t{ start: 0x1f900, end: 0x1f9ff, script: Script.Common },\n\t// Chess Symbols\n\t{ start: 0x1fa00, end: 0x1fa6f, script: Script.Common },\n\t// Symbols and Pictographs Extended-A\n\t{ start: 0x1fa70, end: 0x1faff, script: Script.Common },\n\t// Symbols for Legacy Computing\n\t{ start: 0x1fb00, end: 0x1fbff, script: Script.Common },\n\t// CJK Unified Ideographs Extension B\n\t{ start: 0x20000, end: 0x2a6df, script: Script.Han },\n\t// CJK Unified Ideographs Extension C\n\t{ start: 0x2a700, end: 0x2b73f, script: Script.Han },\n\t// CJK Unified Ideographs Extension D\n\t{ start: 0x2b740, end: 0x2b81f, script: Script.Han },\n\t// CJK Unified Ideographs Extension E\n\t{ start: 0x2b820, end: 0x2ceaf, script: Script.Han },\n\t// CJK Unified Ideographs Extension F\n\t{ start: 0x2ceb0, end: 0x2ebef, script: Script.Han },\n\t// CJK Compatibility Ideographs Supplement\n\t{ start: 0x2f800, end: 0x2fa1f, script: Script.Han },\n\t// CJK Unified Ideographs Extension G\n\t{ start: 0x30000, end: 0x3134f, script: Script.Han },\n\t// CJK Unified Ideographs Extension H\n\t{ start: 0x31350, end: 0x323af, script: Script.Han },\n\t// Tags\n\t{ start: 0xe0000, end: 0xe007f, script: Script.Common },\n\t// Variation Selectors Supplement\n\t{ start: 0xe0100, end: 0xe01ef, script: Script.Inherited },\n\t// Supplementary Private Use Area-A\n\t{ start: 0xf0000, end: 0xfffff, script: Script.Unknown },\n\t// Supplementary Private Use Area-B\n\t{ start: 0x100000, end: 0x10ffff, script: Script.Unknown },\n];\n\n/**\n * Get script for a codepoint using binary search\n * @param cp Unicode codepoint to check\n * @returns The script for the given codepoint\n */\nexport function getScript(cp: number): Script {\n\tlet left = 0;\n\tlet right = SCRIPT_RANGES.length - 1;\n\n\twhile (left <= right) {\n\t\tconst mid = (left + right) >>> 1;\n\t\tconst range = SCRIPT_RANGES[mid];\n\n\t\tif (cp < range.start) {\n\t\t\tright = mid - 1;\n\t\t} else if (cp > range.end) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\treturn range.script;\n\t\t}\n\t}\n\n\treturn Script.Unknown;\n}\n\n/**\n * Get script for a string (returns the dominant non-Common/Inherited script)\n * @param text Text string to analyze\n * @returns The dominant script found in the text (most frequent non-Common/Inherited script)\n */\nexport function detectScript(text: string): Script {\n\tconst counts = new Map<Script, number>();\n\n\tconst chars = [...text];\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tconst script = getScript(cp);\n\n\t\t// Skip Common and Inherited scripts\n\t\tif (script === Script.Common || script === Script.Inherited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounts.set(script, (counts.get(script) ?? 0) + 1);\n\t}\n\n\tif (counts.size === 0) {\n\t\treturn Script.Common;\n\t}\n\n\t// Return the most frequent script\n\tlet maxScript = Script.Common;\n\tlet maxCount = 0;\n\n\tconst entries = [...counts];\n\tfor (let i = 0; i < entries.length; i++) {\n\t\tconst [script, count] = entries[i]!;\n\t\tif (count > maxCount) {\n\t\t\tmaxCount = count;\n\t\t\tmaxScript = script;\n\t\t}\n\t}\n\n\treturn maxScript;\n}\n\n/**\n * Get all scripts present in text\n * @param text Text string to analyze\n * @returns Array of all scripts found in the text\n */\nexport function getScripts(text: string): Script[] {\n\tconst scripts = new Set<Script>();\n\n\tconst chars = [...text];\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tconst script = getScript(cp);\n\t\tscripts.add(script);\n\t}\n\n\treturn [...scripts];\n}\n\n/**\n * Check if text contains only characters from a specific script\n * (Common and Inherited are allowed)\n * @param text Text string to check\n * @param script Script to check against\n * @returns True if text contains only characters from the specified script (plus Common/Inherited)\n */\nexport function isScript(text: string, script: Script): boolean {\n\tconst chars = [...text];\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tconst charScript = getScript(cp);\n\n\t\tif (\n\t\t\tcharScript !== script &&\n\t\t\tcharScript !== Script.Common &&\n\t\t\tcharScript !== Script.Inherited\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Script run - a contiguous sequence of characters with the same script\n */\nexport interface ScriptRun {\n\tscript: Script;\n\tstart: number;\n\tend: number;\n\ttext: string;\n}\n\n/**\n * Split text into script runs\n * @param text Text string to split\n * @returns Array of script runs, where each run is a contiguous sequence of characters with the same script\n */\nexport function getScriptRuns(text: string): ScriptRun[] {\n\tconst runs: ScriptRun[] = [];\n\tif (text.length === 0) return runs;\n\n\tlet currentScript: Script | null = null;\n\tlet runStart = 0;\n\tconst _charIndex = 0;\n\n\tconst chars = [...text];\n\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tconst cp = char.codePointAt(0) ?? 0;\n\t\tlet script = getScript(cp);\n\n\t\t// Treat Common and Inherited as part of the current run\n\t\tif (script === Script.Common || script === Script.Inherited) {\n\t\t\tif (currentScript !== null) {\n\t\t\t\tscript = currentScript;\n\t\t\t}\n\t\t}\n\n\t\tif (currentScript === null) {\n\t\t\tcurrentScript = script;\n\t\t\trunStart = i;\n\t\t} else if (\n\t\t\tscript !== currentScript &&\n\t\t\tscript !== Script.Common &&\n\t\t\tscript !== Script.Inherited\n\t\t) {\n\t\t\t// End current run\n\t\t\truns.push({\n\t\t\t\tscript: currentScript,\n\t\t\t\tstart: runStart,\n\t\t\t\tend: i,\n\t\t\t\ttext: chars.slice(runStart, i).join(\"\"),\n\t\t\t});\n\t\t\tcurrentScript = script;\n\t\t\trunStart = i;\n\t\t}\n\t}\n\n\t// Add final run\n\tif (currentScript !== null) {\n\t\truns.push({\n\t\t\tscript: currentScript,\n\t\t\tstart: runStart,\n\t\t\tend: chars.length,\n\t\t\ttext: chars.slice(runStart).join(\"\"),\n\t\t});\n\t}\n\n\treturn runs;\n}\n\n/**\n * Get OpenType script tag for a Unicode script\n * @param script Unicode script to convert\n * @returns OpenType script tag (4-character string like \"latn\", \"arab\", etc.)\n */\nexport function getScriptTag(script: Script): string {\n\t// Map Script enum to OpenType script tags\n\tconst tagMap: Record<Script, string> = {\n\t\t[Script.Common]: \"DFLT\",\n\t\t[Script.Inherited]: \"DFLT\",\n\t\t[Script.Unknown]: \"DFLT\",\n\t\t[Script.Latin]: \"latn\",\n\t\t[Script.Greek]: \"grek\",\n\t\t[Script.Cyrillic]: \"cyrl\",\n\t\t[Script.Armenian]: \"armn\",\n\t\t[Script.Hebrew]: \"hebr\",\n\t\t[Script.Arabic]: \"arab\",\n\t\t[Script.Syriac]: \"syrc\",\n\t\t[Script.Thaana]: \"thaa\",\n\t\t[Script.Devanagari]: \"deva\",\n\t\t[Script.Bengali]: \"beng\",\n\t\t[Script.Gurmukhi]: \"guru\",\n\t\t[Script.Gujarati]: \"gujr\",\n\t\t[Script.Oriya]: \"orya\",\n\t\t[Script.Tamil]: \"taml\",\n\t\t[Script.Telugu]: \"telu\",\n\t\t[Script.Kannada]: \"knda\",\n\t\t[Script.Malayalam]: \"mlym\",\n\t\t[Script.Sinhala]: \"sinh\",\n\t\t[Script.Thai]: \"thai\",\n\t\t[Script.Lao]: \"lao \",\n\t\t[Script.Tibetan]: \"tibt\",\n\t\t[Script.Myanmar]: \"mymr\",\n\t\t[Script.Georgian]: \"geor\",\n\t\t[Script.Hangul]: \"hang\",\n\t\t[Script.Ethiopic]: \"ethi\",\n\t\t[Script.Cherokee]: \"cher\",\n\t\t[Script.CanadianAboriginal]: \"cans\",\n\t\t[Script.Ogham]: \"ogam\",\n\t\t[Script.Runic]: \"runr\",\n\t\t[Script.Khmer]: \"khmr\",\n\t\t[Script.Mongolian]: \"mong\",\n\t\t[Script.Hiragana]: \"kana\",\n\t\t[Script.Katakana]: \"kana\",\n\t\t[Script.Bopomofo]: \"bopo\",\n\t\t[Script.Han]: \"hani\",\n\t\t[Script.Yi]: \"yi  \",\n\t\t[Script.OldItalic]: \"ital\",\n\t\t[Script.Gothic]: \"goth\",\n\t\t[Script.Deseret]: \"dsrt\",\n\t\t[Script.Tagalog]: \"tglg\",\n\t\t[Script.Hanunoo]: \"hano\",\n\t\t[Script.Buhid]: \"buhd\",\n\t\t[Script.Tagbanwa]: \"tagb\",\n\t\t[Script.Limbu]: \"limb\",\n\t\t[Script.TaiLe]: \"tale\",\n\t\t[Script.LinearB]: \"linb\",\n\t\t[Script.Ugaritic]: \"ugar\",\n\t\t[Script.Shavian]: \"shaw\",\n\t\t[Script.Osmanya]: \"osma\",\n\t\t[Script.Cypriot]: \"cprt\",\n\t\t[Script.Braille]: \"brai\",\n\t\t[Script.Buginese]: \"bugi\",\n\t\t[Script.Coptic]: \"copt\",\n\t\t[Script.NewTaiLue]: \"talu\",\n\t\t[Script.Glagolitic]: \"glag\",\n\t\t[Script.Tifinagh]: \"tfng\",\n\t\t[Script.SylotiNagri]: \"sylo\",\n\t\t[Script.OldPersian]: \"xpeo\",\n\t\t[Script.Kharoshthi]: \"khar\",\n\t\t[Script.Balinese]: \"bali\",\n\t\t[Script.Cuneiform]: \"xsux\",\n\t\t[Script.Phoenician]: \"phnx\",\n\t\t[Script.PhagsPa]: \"phag\",\n\t\t[Script.Nko]: \"nko \",\n\t\t[Script.Sundanese]: \"sund\",\n\t\t[Script.Lepcha]: \"lepc\",\n\t\t[Script.OlChiki]: \"olck\",\n\t\t[Script.Vai]: \"vai \",\n\t\t[Script.Saurashtra]: \"saur\",\n\t\t[Script.KayahLi]: \"kali\",\n\t\t[Script.Rejang]: \"rjng\",\n\t\t[Script.Lycian]: \"lyci\",\n\t\t[Script.Carian]: \"cari\",\n\t\t[Script.Lydian]: \"lydi\",\n\t\t[Script.Cham]: \"cham\",\n\t\t[Script.TaiTham]: \"lana\",\n\t\t[Script.TaiViet]: \"tavt\",\n\t\t[Script.Avestan]: \"avst\",\n\t\t[Script.EgyptianHieroglyphs]: \"egyp\",\n\t\t[Script.Samaritan]: \"samr\",\n\t\t[Script.Lisu]: \"lisu\",\n\t\t[Script.Bamum]: \"bamu\",\n\t\t[Script.Javanese]: \"java\",\n\t\t[Script.MeeteiMayek]: \"mtei\",\n\t\t[Script.ImperialAramaic]: \"armi\",\n\t\t[Script.OldSouthArabian]: \"sarb\",\n\t\t[Script.InscriptionalParthian]: \"prti\",\n\t\t[Script.InscriptionalPahlavi]: \"phli\",\n\t\t[Script.OldTurkic]: \"orkh\",\n\t\t[Script.Kaithi]: \"kthi\",\n\t\t[Script.Batak]: \"batk\",\n\t\t[Script.Brahmi]: \"brah\",\n\t\t[Script.Mandaic]: \"mand\",\n\t\t[Script.Chakma]: \"cakm\",\n\t\t[Script.MeroiticCursive]: \"merc\",\n\t\t[Script.MeroiticHieroglyphs]: \"mero\",\n\t\t[Script.Miao]: \"plrd\",\n\t\t[Script.Sharada]: \"shrd\",\n\t\t[Script.SoraSompeng]: \"sora\",\n\t\t[Script.Takri]: \"takr\",\n\t\t[Script.CaucasianAlbanian]: \"aghb\",\n\t\t[Script.BassaVah]: \"bass\",\n\t\t[Script.Duployan]: \"dupl\",\n\t\t[Script.Elbasan]: \"elba\",\n\t\t[Script.Grantha]: \"gran\",\n\t\t[Script.PahawhHmong]: \"hmng\",\n\t\t[Script.Khojki]: \"khoj\",\n\t\t[Script.LinearA]: \"lina\",\n\t\t[Script.Mahajani]: \"mahj\",\n\t\t[Script.Manichaean]: \"mani\",\n\t\t[Script.MendeKikakui]: \"mend\",\n\t\t[Script.Modi]: \"modi\",\n\t\t[Script.Mro]: \"mroo\",\n\t\t[Script.OldNorthArabian]: \"narb\",\n\t\t[Script.Nabataean]: \"nbat\",\n\t\t[Script.Palmyrene]: \"palm\",\n\t\t[Script.PauCinHau]: \"pauc\",\n\t\t[Script.OldPermic]: \"perm\",\n\t\t[Script.PsalterPahlavi]: \"phlp\",\n\t\t[Script.Siddham]: \"sidd\",\n\t\t[Script.Khudawadi]: \"sind\",\n\t\t[Script.Tirhuta]: \"tirh\",\n\t\t[Script.WarangCiti]: \"wara\",\n\t\t[Script.Ahom]: \"ahom\",\n\t\t[Script.AnatolianHieroglyphs]: \"hluw\",\n\t\t[Script.Hatran]: \"hatr\",\n\t\t[Script.Multani]: \"mult\",\n\t\t[Script.OldHungarian]: \"hung\",\n\t\t[Script.SignWriting]: \"sgnw\",\n\t\t[Script.Adlam]: \"adlm\",\n\t\t[Script.Bhaiksuki]: \"bhks\",\n\t\t[Script.Marchen]: \"marc\",\n\t\t[Script.Newa]: \"newa\",\n\t\t[Script.Osage]: \"osge\",\n\t\t[Script.Tangut]: \"tang\",\n\t\t[Script.MasaramGondi]: \"gonm\",\n\t\t[Script.Nushu]: \"nshu\",\n\t\t[Script.Soyombo]: \"soyo\",\n\t\t[Script.ZanabazarSquare]: \"zanb\",\n\t\t[Script.Dogra]: \"dogr\",\n\t\t[Script.GunjalaGondi]: \"gong\",\n\t\t[Script.Makasar]: \"maka\",\n\t\t[Script.Medefaidrin]: \"medf\",\n\t\t[Script.HanifiRohingya]: \"rohg\",\n\t\t[Script.Sogdian]: \"sogd\",\n\t\t[Script.OldSogdian]: \"sogo\",\n\t\t[Script.Elymaic]: \"elym\",\n\t\t[Script.Nandinagari]: \"nand\",\n\t\t[Script.NyiakengPuachueHmong]: \"hmnp\",\n\t\t[Script.Wancho]: \"wcho\",\n\t\t[Script.Yezidi]: \"yezi\",\n\t\t[Script.Chorasmian]: \"chrs\",\n\t\t[Script.DivesAkuru]: \"diak\",\n\t\t[Script.KhitanSmallScript]: \"kits\",\n\t\t[Script.Vithkuqi]: \"vith\",\n\t\t[Script.OldUyghur]: \"ougr\",\n\t\t[Script.Cypro_Minoan]: \"cpmn\",\n\t\t[Script.Tangsa]: \"tnsa\",\n\t\t[Script.Toto]: \"toto\",\n\t\t[Script.Kawi]: \"kawi\",\n\t\t[Script.NagMundari]: \"nagm\",\n\t};\n\n\treturn tagMap[script] ?? \"DFLT\";\n}\n\n/** Static set of complex scripts (created once at module load) */\nconst COMPLEX_SCRIPTS = new Set([\n\tScript.Arabic,\n\tScript.Syriac,\n\tScript.Hebrew,\n\tScript.Thaana,\n\tScript.Nko,\n\tScript.Devanagari,\n\tScript.Bengali,\n\tScript.Gurmukhi,\n\tScript.Gujarati,\n\tScript.Oriya,\n\tScript.Tamil,\n\tScript.Telugu,\n\tScript.Kannada,\n\tScript.Malayalam,\n\tScript.Sinhala,\n\tScript.Thai,\n\tScript.Lao,\n\tScript.Tibetan,\n\tScript.Myanmar,\n\tScript.Khmer,\n\tScript.Mongolian,\n\tScript.Hangul,\n]);\n\n/** Static set of RTL scripts (created once at module load) */\nconst RTL_SCRIPTS = new Set([\n\tScript.Arabic,\n\tScript.Hebrew,\n\tScript.Syriac,\n\tScript.Thaana,\n\tScript.Nko,\n\tScript.Samaritan,\n\tScript.Mandaic,\n\tScript.ImperialAramaic,\n\tScript.Phoenician,\n\tScript.OldSouthArabian,\n\tScript.OldNorthArabian,\n\tScript.Avestan,\n\tScript.InscriptionalParthian,\n\tScript.InscriptionalPahlavi,\n\tScript.PsalterPahlavi,\n\tScript.Hatran,\n\tScript.Lydian,\n\tScript.Nabataean,\n\tScript.Palmyrene,\n\tScript.Manichaean,\n\tScript.MendeKikakui,\n\tScript.HanifiRohingya,\n\tScript.Yezidi,\n\tScript.OldSogdian,\n\tScript.Sogdian,\n\tScript.Elymaic,\n\tScript.Chorasmian,\n\tScript.OldUyghur,\n\tScript.Adlam,\n]);\n\n/**\n * Check if a script requires complex shaping\n * @param script Script to check\n * @returns True if the script requires complex shaping (e.g., Arabic, Devanagari, Thai)\n */\nexport function isComplexScript(script: Script): boolean {\n\treturn COMPLEX_SCRIPTS.has(script);\n}\n\n/**\n * Get script direction (LTR or RTL)\n * @param script Script to check\n * @returns Direction of the script: \"ltr\" for left-to-right or \"rtl\" for right-to-left\n */\nexport function getScriptDirection(script: Script): \"ltr\" | \"rtl\" {\n\treturn RTL_SCRIPTS.has(script) ? \"rtl\" : \"ltr\";\n}\n",
    "/**\n * Unicode Text Segmentation (UAX #29)\n * Grapheme cluster and word boundaries\n */\n\nimport type { GlyphInfo } from \"../types.ts\";\n\n/**\n * Grapheme cluster break property\n */\nexport enum GraphemeBreakProperty {\n\tOther = 0,\n\tCR = 1,\n\tLF = 2,\n\tControl = 3,\n\tExtend = 4,\n\tZWJ = 5,\n\tRegional_Indicator = 6,\n\tPrepend = 7,\n\tSpacingMark = 8,\n\tL = 9, // Hangul L\n\tV = 10, // Hangul V\n\tT = 11, // Hangul T\n\tLV = 12, // Hangul LV\n\tLVT = 13, // Hangul LVT\n\tExtended_Pictographic = 14,\n}\n\n/**\n * Word break property\n */\nexport enum WordBreakProperty {\n\tOther = 0,\n\tCR = 1,\n\tLF = 2,\n\tNewline = 3,\n\tExtend = 4,\n\tZWJ = 5,\n\tRegional_Indicator = 6,\n\tFormat = 7,\n\tKatakana = 8,\n\tHebrew_Letter = 9,\n\tALetter = 10,\n\tSingle_Quote = 11,\n\tDouble_Quote = 12,\n\tMidNumLet = 13,\n\tMidLetter = 14,\n\tMidNum = 15,\n\tNumeric = 16,\n\tExtendNumLet = 17,\n\tWSegSpace = 18,\n\tExtended_Pictographic = 19,\n}\n\n/**\n * Get grapheme break property for codepoint\n * @param cp Unicode codepoint to check\n * @returns Grapheme break property for the codepoint\n */\nexport function getGraphemeBreakProperty(cp: number): GraphemeBreakProperty {\n\t// CR, LF\n\tif (cp === 0x000d) return GraphemeBreakProperty.CR;\n\tif (cp === 0x000a) return GraphemeBreakProperty.LF;\n\n\t// Control characters\n\tif (cp >= 0x0000 && cp <= 0x001f && cp !== 0x000a && cp !== 0x000d)\n\t\treturn GraphemeBreakProperty.Control;\n\tif (cp >= 0x007f && cp <= 0x009f) return GraphemeBreakProperty.Control;\n\tif (cp === 0x00ad) return GraphemeBreakProperty.Control; // Soft hyphen\n\tif (cp === 0x061c) return GraphemeBreakProperty.Control; // ALM\n\tif (cp === 0x180e) return GraphemeBreakProperty.Control;\n\tif (cp === 0x200b) return GraphemeBreakProperty.Control; // ZWSP\n\tif (cp >= 0x200e && cp <= 0x200f) return GraphemeBreakProperty.Control; // LRM, RLM\n\tif (cp >= 0x2028 && cp <= 0x202e) return GraphemeBreakProperty.Control;\n\tif (cp >= 0x2060 && cp <= 0x206f) return GraphemeBreakProperty.Control;\n\tif (cp === 0xfeff) return GraphemeBreakProperty.Control; // BOM\n\tif (cp >= 0xfff0 && cp <= 0xfffb) return GraphemeBreakProperty.Control;\n\n\t// ZWJ\n\tif (cp === 0x200d) return GraphemeBreakProperty.ZWJ;\n\n\t// Regional Indicator\n\tif (cp >= 0x1f1e0 && cp <= 0x1f1ff)\n\t\treturn GraphemeBreakProperty.Regional_Indicator;\n\n\t// Prepend\n\tif (\n\t\tcp === 0x0600 ||\n\t\tcp === 0x0601 ||\n\t\tcp === 0x0602 ||\n\t\tcp === 0x0603 ||\n\t\tcp === 0x0604 ||\n\t\tcp === 0x0605 ||\n\t\tcp === 0x06dd ||\n\t\tcp === 0x070f ||\n\t\tcp === 0x0890 ||\n\t\tcp === 0x0891 ||\n\t\tcp === 0x08e2 ||\n\t\tcp === 0x110bd ||\n\t\tcp === 0x110cd\n\t)\n\t\treturn GraphemeBreakProperty.Prepend;\n\n\t// Hangul L (Leading consonants)\n\tif (cp >= 0x1100 && cp <= 0x115f) return GraphemeBreakProperty.L;\n\tif (cp >= 0xa960 && cp <= 0xa97c) return GraphemeBreakProperty.L;\n\n\t// Hangul V (Vowels)\n\tif (cp >= 0x1160 && cp <= 0x11a7) return GraphemeBreakProperty.V;\n\tif (cp >= 0xd7b0 && cp <= 0xd7c6) return GraphemeBreakProperty.V;\n\n\t// Hangul T (Trailing consonants)\n\tif (cp >= 0x11a8 && cp <= 0x11ff) return GraphemeBreakProperty.T;\n\tif (cp >= 0xd7cb && cp <= 0xd7fb) return GraphemeBreakProperty.T;\n\n\t// Hangul syllables\n\tif (cp >= 0xac00 && cp <= 0xd7a3) {\n\t\tconst sIndex = cp - 0xac00;\n\t\tif (sIndex % 28 === 0) return GraphemeBreakProperty.LV;\n\t\treturn GraphemeBreakProperty.LVT;\n\t}\n\n\t// Extended Pictographic (Emoji)\n\tif (cp >= 0x1f300 && cp <= 0x1f9ff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1fa00 && cp <= 0x1faff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2600 && cp <= 0x26ff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2700 && cp <= 0x27bf)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp === 0x00a9 || cp === 0x00ae)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2300 && cp <= 0x23ff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f000 && cp <= 0x1f02f)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f0a0 && cp <= 0x1f0ff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f100 && cp <= 0x1f1ff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1f200 && cp <= 0x1f2ff)\n\t\treturn GraphemeBreakProperty.Extended_Pictographic;\n\n\t// Spacing Mark\n\tif (cp >= 0x0903 && cp <= 0x0903) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x093b && cp <= 0x093b) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x093e && cp <= 0x0940) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0949 && cp <= 0x094c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x094e && cp <= 0x094f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0982 && cp <= 0x0983) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x09be && cp <= 0x09c0) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x09c7 && cp <= 0x09cc) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x09d7) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0a03 && cp <= 0x0a03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0a3e && cp <= 0x0a40) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0a83 && cp <= 0x0a83) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0abe && cp <= 0x0ac0) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0ac9) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0acb && cp <= 0x0acc) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0b02 && cp <= 0x0b03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0b3e) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0b40) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0b47 && cp <= 0x0b4c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0b57) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0bbe && cp <= 0x0bbf) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0bc1 && cp <= 0x0bcc) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0bd7) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0c01 && cp <= 0x0c03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0c41 && cp <= 0x0c44) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0c82 && cp <= 0x0c83) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0cbe) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0cc0 && cp <= 0x0cc4) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0cc7 && cp <= 0x0ccb) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0cd5 && cp <= 0x0cd6) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d02 && cp <= 0x0d03) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d3e && cp <= 0x0d40) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d46 && cp <= 0x0d4c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0d57) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0d82 && cp <= 0x0d83) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0dcf && cp <= 0x0dd1) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0dd8 && cp <= 0x0ddf) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x0df2 && cp <= 0x0df3) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0f3e || cp === 0x0f3f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x0f7f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x102b && cp <= 0x102c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x1031) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x1038) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x103b && cp <= 0x103c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1056 && cp <= 0x1057) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x1062) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1067 && cp <= 0x1068) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1083 && cp <= 0x1084) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1087 && cp <= 0x108c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp === 0x108f) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x109a && cp <= 0x109c) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x17b6 && cp <= 0x17b6) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x17be && cp <= 0x17c5) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x17c7 && cp <= 0x17c8) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1923 && cp <= 0x1926) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1929 && cp <= 0x192b) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1930 && cp <= 0x1931) return GraphemeBreakProperty.SpacingMark;\n\tif (cp >= 0x1933 && cp <= 0x1938) return GraphemeBreakProperty.SpacingMark;\n\n\t// Extend (combining marks, etc.)\n\tif (cp >= 0x0300 && cp <= 0x036f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0483 && cp <= 0x0489) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0591 && cp <= 0x05bd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x05bf) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x05c1 && cp <= 0x05c2) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x05c4 && cp <= 0x05c5) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x05c7) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0610 && cp <= 0x061a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x064b && cp <= 0x065f) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0670) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06d6 && cp <= 0x06dc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06df && cp <= 0x06e4) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06e7 && cp <= 0x06e8) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x06ea && cp <= 0x06ed) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0711) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0730 && cp <= 0x074a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x07a6 && cp <= 0x07b0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x07eb && cp <= 0x07f3) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x07fd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0816 && cp <= 0x0819) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x081b && cp <= 0x0823) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0825 && cp <= 0x0827) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0829 && cp <= 0x082d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0859 && cp <= 0x085b) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x08d3 && cp <= 0x08e1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x08e3 && cp <= 0x0902) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x093a) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x093c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0941 && cp <= 0x0948) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x094d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0951 && cp <= 0x0957) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0962 && cp <= 0x0963) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0981) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x09bc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x09c1 && cp <= 0x09c4) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x09cd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x09e2 && cp <= 0x09e3) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x09fe) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a01 && cp <= 0x0a02) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0a3c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a41 && cp <= 0x0a42) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a47 && cp <= 0x0a48) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a4b && cp <= 0x0a4d) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0a51) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a70 && cp <= 0x0a71) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0a75) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0a81 && cp <= 0x0a82) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0abc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ac1 && cp <= 0x0ac5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ac7 && cp <= 0x0ac8) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0acd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ae2 && cp <= 0x0ae3) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0afa && cp <= 0x0aff) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b01) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b3c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b3f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0b41 && cp <= 0x0b44) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b4d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0b55 && cp <= 0x0b56) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0b62 && cp <= 0x0b63) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0b82) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0bc0) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0bcd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0c00) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0c04) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c3e && cp <= 0x0c40) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c46 && cp <= 0x0c48) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c4a && cp <= 0x0c4d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c55 && cp <= 0x0c56) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0c62 && cp <= 0x0c63) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0c81) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0cbc) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0cbf) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0cc6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ccc && cp <= 0x0ccd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ce2 && cp <= 0x0ce3) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d00 && cp <= 0x0d01) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d3b && cp <= 0x0d3c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d41 && cp <= 0x0d44) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0d4d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0d62 && cp <= 0x0d63) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0d81) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0dca) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0dd2 && cp <= 0x0dd4) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0dd6) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0e31) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0e34 && cp <= 0x0e3a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0e47 && cp <= 0x0e4e) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0eb1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0eb4 && cp <= 0x0ebc) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0ec8 && cp <= 0x0ecd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f18 && cp <= 0x0f19) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0f35) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0f37) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0f39) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f71 && cp <= 0x0f7e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f80 && cp <= 0x0f84) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f86 && cp <= 0x0f87) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f8d && cp <= 0x0f97) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x0f99 && cp <= 0x0fbc) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x0fc6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x102d && cp <= 0x1030) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1032 && cp <= 0x1037) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1039 && cp <= 0x103a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x103d && cp <= 0x103e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1058 && cp <= 0x1059) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x105e && cp <= 0x1060) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1071 && cp <= 0x1074) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1082) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1085 && cp <= 0x1086) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x108d) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x109d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x135d && cp <= 0x135f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1712 && cp <= 0x1714) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1732 && cp <= 0x1734) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1752 && cp <= 0x1753) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1772 && cp <= 0x1773) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x17b4 && cp <= 0x17b5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x17b7 && cp <= 0x17bd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x17c6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x17c9 && cp <= 0x17d3) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x17dd) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x180b && cp <= 0x180d) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x180f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1885 && cp <= 0x1886) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x18a9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1920 && cp <= 0x1922) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1927 && cp <= 0x1928) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1932) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1939 && cp <= 0x193b) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a17 && cp <= 0x1a18) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a1b) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a56) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a58 && cp <= 0x1a5e) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a60) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a62) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a65 && cp <= 0x1a6c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1a73 && cp <= 0x1a7c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1a7f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ab0 && cp <= 0x1ace) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b00 && cp <= 0x1b03) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1b34) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b36 && cp <= 0x1b3a) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1b3c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1b42) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b6b && cp <= 0x1b73) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1b80 && cp <= 0x1b81) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ba2 && cp <= 0x1ba5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ba8 && cp <= 0x1ba9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1bab && cp <= 0x1bad) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1be6) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1be8 && cp <= 0x1be9) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1bed) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1bef && cp <= 0x1bf1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1c2c && cp <= 0x1c33) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1c36 && cp <= 0x1c37) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1cd0 && cp <= 0x1cd2) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1cd4 && cp <= 0x1ce0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1ce2 && cp <= 0x1ce8) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1ced) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x1cf4) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1cf8 && cp <= 0x1cf9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1dc0 && cp <= 0x1dff) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x20d0 && cp <= 0x20f0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x2cef && cp <= 0x2cf1) return GraphemeBreakProperty.Extend;\n\tif (cp === 0x2d7f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x2de0 && cp <= 0x2dff) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x302a && cp <= 0x302f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x3099 && cp <= 0x309a) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa66f && cp <= 0xa672) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa674 && cp <= 0xa67d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa69e && cp <= 0xa69f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa6f0 && cp <= 0xa6f1) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa802) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa806) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa80b) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa825 && cp <= 0xa826) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa82c) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa8c4 && cp <= 0xa8c5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa8e0 && cp <= 0xa8f1) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa8ff) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa926 && cp <= 0xa92d) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa947 && cp <= 0xa951) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa980 && cp <= 0xa982) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa9b3) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa9b6 && cp <= 0xa9b9) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xa9bc && cp <= 0xa9bd) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xa9e5) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaa29 && cp <= 0xaa2e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaa31 && cp <= 0xaa32) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaa35 && cp <= 0xaa36) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaa43) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaa4c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaa7c) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaab0) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaab2 && cp <= 0xaab4) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaab7 && cp <= 0xaab8) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaabe && cp <= 0xaabf) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaac1) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xaaec && cp <= 0xaaed) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xaaf6) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xabe5) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xabe8) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xabed) return GraphemeBreakProperty.Extend;\n\tif (cp === 0xfb1e) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xfe00 && cp <= 0xfe0f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0xfe20 && cp <= 0xfe2f) return GraphemeBreakProperty.Extend;\n\tif (cp >= 0x1f3fb && cp <= 0x1f3ff) return GraphemeBreakProperty.Extend; // Emoji modifiers\n\tif (cp >= 0xe0100 && cp <= 0xe01ef) return GraphemeBreakProperty.Extend; // Variation selectors\n\n\treturn GraphemeBreakProperty.Other;\n}\n\n/**\n * Get word break property for codepoint\n * @param cp Unicode codepoint to check\n * @returns Word break property for the codepoint\n */\nexport function getWordBreakProperty(cp: number): WordBreakProperty {\n\t// CR, LF, Newline\n\tif (cp === 0x000d) return WordBreakProperty.CR;\n\tif (cp === 0x000a) return WordBreakProperty.LF;\n\tif (\n\t\tcp === 0x000b ||\n\t\tcp === 0x000c ||\n\t\tcp === 0x0085 ||\n\t\tcp === 0x2028 ||\n\t\tcp === 0x2029\n\t)\n\t\treturn WordBreakProperty.Newline;\n\n\t// ZWJ\n\tif (cp === 0x200d) return WordBreakProperty.ZWJ;\n\n\t// Format characters\n\tif (cp === 0x00ad) return WordBreakProperty.Format;\n\tif (cp === 0x061c) return WordBreakProperty.Format;\n\tif (cp === 0x200b) return WordBreakProperty.Format;\n\tif (cp >= 0x200e && cp <= 0x200f) return WordBreakProperty.Format;\n\tif (cp >= 0x2060 && cp <= 0x206f) return WordBreakProperty.Format;\n\tif (cp === 0xfeff) return WordBreakProperty.Format;\n\n\t// Regional Indicator\n\tif (cp >= 0x1f1e0 && cp <= 0x1f1ff)\n\t\treturn WordBreakProperty.Regional_Indicator;\n\n\t// Extended Pictographic\n\tif (cp >= 0x1f300 && cp <= 0x1f9ff)\n\t\treturn WordBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x1fa00 && cp <= 0x1faff)\n\t\treturn WordBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2600 && cp <= 0x26ff)\n\t\treturn WordBreakProperty.Extended_Pictographic;\n\tif (cp >= 0x2700 && cp <= 0x27bf)\n\t\treturn WordBreakProperty.Extended_Pictographic;\n\n\t// Hebrew Letter\n\tif (cp >= 0x05d0 && cp <= 0x05ea) return WordBreakProperty.Hebrew_Letter;\n\tif (cp >= 0xfb1d && cp <= 0xfb4f) return WordBreakProperty.Hebrew_Letter;\n\n\t// Katakana\n\tif (cp >= 0x30a0 && cp <= 0x30ff) return WordBreakProperty.Katakana;\n\tif (\n\t\tcp === 0x3031 ||\n\t\tcp === 0x3032 ||\n\t\tcp === 0x3033 ||\n\t\tcp === 0x3034 ||\n\t\tcp === 0x3035\n\t)\n\t\treturn WordBreakProperty.Katakana;\n\tif (cp === 0x309b || cp === 0x309c) return WordBreakProperty.Katakana;\n\tif (cp >= 0x31f0 && cp <= 0x31ff) return WordBreakProperty.Katakana;\n\tif (cp >= 0x32d0 && cp <= 0x32fe) return WordBreakProperty.Katakana;\n\tif (cp >= 0x3300 && cp <= 0x3357) return WordBreakProperty.Katakana;\n\tif (cp >= 0xff66 && cp <= 0xff9d) return WordBreakProperty.Katakana;\n\n\t// Single Quote\n\tif (cp === 0x0027) return WordBreakProperty.Single_Quote;\n\n\t// Double Quote\n\tif (cp === 0x0022) return WordBreakProperty.Double_Quote;\n\n\t// MidNumLet\n\tif (cp === 0x002e) return WordBreakProperty.MidNumLet; // .\n\tif (cp === 0x2018 || cp === 0x2019) return WordBreakProperty.MidNumLet;\n\tif (cp === 0x2024) return WordBreakProperty.MidNumLet;\n\tif (cp === 0xfe52) return WordBreakProperty.MidNumLet;\n\tif (cp === 0xff07) return WordBreakProperty.MidNumLet;\n\tif (cp === 0xff0e) return WordBreakProperty.MidNumLet;\n\n\t// MidLetter\n\tif (cp === 0x003a) return WordBreakProperty.MidLetter; // :\n\tif (cp === 0x00b7) return WordBreakProperty.MidLetter;\n\tif (cp === 0x0387) return WordBreakProperty.MidLetter;\n\tif (cp === 0x05f4) return WordBreakProperty.MidLetter;\n\tif (cp === 0x2027) return WordBreakProperty.MidLetter;\n\tif (cp === 0xfe13) return WordBreakProperty.MidLetter;\n\tif (cp === 0xfe55) return WordBreakProperty.MidLetter;\n\tif (cp === 0xff1a) return WordBreakProperty.MidLetter;\n\n\t// MidNum\n\tif (cp === 0x002c) return WordBreakProperty.MidNum; // ,\n\tif (cp === 0x003b) return WordBreakProperty.MidNum; // ;\n\tif (cp === 0x037e) return WordBreakProperty.MidNum;\n\tif (cp === 0x0589) return WordBreakProperty.MidNum;\n\tif (cp === 0x060c || cp === 0x060d) return WordBreakProperty.MidNum;\n\tif (cp === 0x066c) return WordBreakProperty.MidNum;\n\tif (cp === 0x07f8) return WordBreakProperty.MidNum;\n\tif (cp === 0x2044) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe10) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe14) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe50) return WordBreakProperty.MidNum;\n\tif (cp === 0xfe54) return WordBreakProperty.MidNum;\n\tif (cp === 0xff0c) return WordBreakProperty.MidNum;\n\tif (cp === 0xff1b) return WordBreakProperty.MidNum;\n\n\t// Numeric\n\tif (cp >= 0x0030 && cp <= 0x0039) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0660 && cp <= 0x0669) return WordBreakProperty.Numeric;\n\tif (cp >= 0x06f0 && cp <= 0x06f9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x07c0 && cp <= 0x07c9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0966 && cp <= 0x096f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x09e6 && cp <= 0x09ef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0a66 && cp <= 0x0a6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0ae6 && cp <= 0x0aef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0b66 && cp <= 0x0b6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0be6 && cp <= 0x0bef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0c66 && cp <= 0x0c6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0ce6 && cp <= 0x0cef) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0d66 && cp <= 0x0d6f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0de6 && cp <= 0x0def) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0e50 && cp <= 0x0e59) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0ed0 && cp <= 0x0ed9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x0f20 && cp <= 0x0f29) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1040 && cp <= 0x1049) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1090 && cp <= 0x1099) return WordBreakProperty.Numeric;\n\tif (cp >= 0x17e0 && cp <= 0x17e9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1810 && cp <= 0x1819) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1946 && cp <= 0x194f) return WordBreakProperty.Numeric;\n\tif (cp >= 0x19d0 && cp <= 0x19d9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1a80 && cp <= 0x1a89) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1a90 && cp <= 0x1a99) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1b50 && cp <= 0x1b59) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1bb0 && cp <= 0x1bb9) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1c40 && cp <= 0x1c49) return WordBreakProperty.Numeric;\n\tif (cp >= 0x1c50 && cp <= 0x1c59) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa620 && cp <= 0xa629) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa8d0 && cp <= 0xa8d9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa900 && cp <= 0xa909) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa9d0 && cp <= 0xa9d9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xa9f0 && cp <= 0xa9f9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xaa50 && cp <= 0xaa59) return WordBreakProperty.Numeric;\n\tif (cp >= 0xabf0 && cp <= 0xabf9) return WordBreakProperty.Numeric;\n\tif (cp >= 0xff10 && cp <= 0xff19) return WordBreakProperty.Numeric;\n\n\t// ExtendNumLet\n\tif (cp === 0x005f) return WordBreakProperty.ExtendNumLet; // _\n\tif (cp === 0x202f) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0x2040) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0x2054) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0xfe33 || cp === 0xfe34) return WordBreakProperty.ExtendNumLet;\n\tif (cp >= 0xfe4d && cp <= 0xfe4f) return WordBreakProperty.ExtendNumLet;\n\tif (cp === 0xff3f) return WordBreakProperty.ExtendNumLet;\n\n\t// WSegSpace\n\tif (cp === 0x0020) return WordBreakProperty.WSegSpace;\n\tif (cp === 0x1680) return WordBreakProperty.WSegSpace;\n\tif (cp >= 0x2000 && cp <= 0x200a && cp !== 0x2007)\n\t\treturn WordBreakProperty.WSegSpace;\n\tif (cp === 0x205f) return WordBreakProperty.WSegSpace;\n\tif (cp === 0x3000) return WordBreakProperty.WSegSpace;\n\n\t// Extend (same as grapheme extend)\n\tconst gbp = getGraphemeBreakProperty(cp);\n\tif (gbp === GraphemeBreakProperty.Extend) return WordBreakProperty.Extend;\n\n\t// ALetter (alphabetic)\n\tif (cp >= 0x0041 && cp <= 0x005a) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0061 && cp <= 0x007a) return WordBreakProperty.ALetter;\n\tif (cp >= 0x00c0 && cp <= 0x00d6) return WordBreakProperty.ALetter;\n\tif (cp >= 0x00d8 && cp <= 0x00f6) return WordBreakProperty.ALetter;\n\tif (cp >= 0x00f8 && cp <= 0x024f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0250 && cp <= 0x02af) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0370 && cp <= 0x03ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0400 && cp <= 0x04ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0500 && cp <= 0x052f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0531 && cp <= 0x0556) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0560 && cp <= 0x0588) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0600 && cp <= 0x06ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0900 && cp <= 0x097f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0980 && cp <= 0x09ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0a00 && cp <= 0x0a7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0a80 && cp <= 0x0aff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0b00 && cp <= 0x0b7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0b80 && cp <= 0x0bff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0c00 && cp <= 0x0c7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0c80 && cp <= 0x0cff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0d00 && cp <= 0x0d7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0e00 && cp <= 0x0e7f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x0e80 && cp <= 0x0eff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x1000 && cp <= 0x109f) return WordBreakProperty.ALetter;\n\tif (cp >= 0x10a0 && cp <= 0x10ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x1100 && cp <= 0x11ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x1780 && cp <= 0x17ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x3040 && cp <= 0x309f) return WordBreakProperty.ALetter; // Hiragana\n\tif (cp >= 0x1f00 && cp <= 0x1fff) return WordBreakProperty.ALetter;\n\tif (cp >= 0x2c00 && cp <= 0x2c5f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa000 && cp <= 0xa48f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa4d0 && cp <= 0xa4ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa500 && cp <= 0xa63f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa640 && cp <= 0xa69f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xa720 && cp <= 0xa7ff) return WordBreakProperty.ALetter;\n\tif (cp >= 0xab00 && cp <= 0xab6f) return WordBreakProperty.ALetter;\n\tif (cp >= 0xac00 && cp <= 0xd7af) return WordBreakProperty.ALetter; // Hangul\n\tif (cp >= 0xfb00 && cp <= 0xfb06) return WordBreakProperty.ALetter;\n\tif (cp >= 0xff21 && cp <= 0xff3a) return WordBreakProperty.ALetter;\n\tif (cp >= 0xff41 && cp <= 0xff5a) return WordBreakProperty.ALetter;\n\n\treturn WordBreakProperty.Other;\n}\n\n/**\n * Grapheme cluster boundary result\n */\nexport interface GraphemeBoundaries {\n\t/** Boundary positions (indices where clusters end) */\n\tboundaries: number[];\n\t/** Grapheme break properties */\n\tproperties: GraphemeBreakProperty[];\n}\n\n/**\n * Find grapheme cluster boundaries in codepoints\n * @param codepoints Array of Unicode codepoints\n * @returns Object containing boundary positions and grapheme break properties\n */\nexport function findGraphemeBoundaries(\n\tcodepoints: number[],\n): GraphemeBoundaries {\n\tconst len = codepoints.length;\n\tconst properties: GraphemeBreakProperty[] = [];\n\tconst boundaries: number[] = [];\n\n\tfor (let i = 0; i < codepoints.length; i++) {\n\t\tconst cp = codepoints[i]!;\n\t\tproperties.push(getGraphemeBreakProperty(cp));\n\t}\n\n\tif (len === 0) return { boundaries, properties };\n\n\t// GB1: Break at the start of text\n\t// (implicitly handled)\n\n\t// Track state for RI pairs\n\tlet riCount = 0;\n\tlet inExtendedPictographicSequence = false;\n\n\tfor (let i = 1; i < len; i++) {\n\t\tconst prev = properties[i - 1];\n\t\tconst curr = properties[i];\n\n\t\tlet shouldBreak = true;\n\n\t\t// GB3: Do not break between a CR and LF\n\t\tif (\n\t\t\tprev === GraphemeBreakProperty.CR &&\n\t\t\tcurr === GraphemeBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB4: Break after controls\n\t\telse if (\n\t\t\tprev === GraphemeBreakProperty.Control ||\n\t\t\tprev === GraphemeBreakProperty.CR ||\n\t\t\tprev === GraphemeBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t}\n\t\t// GB5: Break before controls\n\t\telse if (\n\t\t\tcurr === GraphemeBreakProperty.Control ||\n\t\t\tcurr === GraphemeBreakProperty.CR ||\n\t\t\tcurr === GraphemeBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t}\n\t\t// GB6: Do not break Hangul syllable sequences\n\t\telse if (\n\t\t\tprev === GraphemeBreakProperty.L &&\n\t\t\t(curr === GraphemeBreakProperty.L ||\n\t\t\t\tcurr === GraphemeBreakProperty.V ||\n\t\t\t\tcurr === GraphemeBreakProperty.LV ||\n\t\t\t\tcurr === GraphemeBreakProperty.LVT)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB7\n\t\telse if (\n\t\t\t(prev === GraphemeBreakProperty.LV || prev === GraphemeBreakProperty.V) &&\n\t\t\t(curr === GraphemeBreakProperty.V || curr === GraphemeBreakProperty.T)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB8\n\t\telse if (\n\t\t\t(prev === GraphemeBreakProperty.LVT ||\n\t\t\t\tprev === GraphemeBreakProperty.T) &&\n\t\t\tcurr === GraphemeBreakProperty.T\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB9: Do not break before extending characters or ZWJ\n\t\telse if (\n\t\t\tcurr === GraphemeBreakProperty.Extend ||\n\t\t\tcurr === GraphemeBreakProperty.ZWJ\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB9a: Do not break before SpacingMarks\n\t\telse if (curr === GraphemeBreakProperty.SpacingMark) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB9b: Do not break after Prepend characters\n\t\telse if (prev === GraphemeBreakProperty.Prepend) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB11: Do not break within emoji modifier sequences or emoji ZWJ sequences\n\t\telse if (\n\t\t\tinExtendedPictographicSequence &&\n\t\t\tprev === GraphemeBreakProperty.ZWJ &&\n\t\t\tcurr === GraphemeBreakProperty.Extended_Pictographic\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// GB12-13: Do not break within emoji flag sequences\n\t\telse if (\n\t\t\tprev === GraphemeBreakProperty.Regional_Indicator &&\n\t\t\tcurr === GraphemeBreakProperty.Regional_Indicator\n\t\t) {\n\t\t\t// Only break after even number of RIs\n\t\t\tif (riCount % 2 === 1) {\n\t\t\t\tshouldBreak = false;\n\t\t\t}\n\t\t}\n\n\t\t// Track extended pictographic state\n\t\tif (curr === GraphemeBreakProperty.Extended_Pictographic) {\n\t\t\tinExtendedPictographicSequence = true;\n\t\t} else if (\n\t\t\tcurr !== GraphemeBreakProperty.Extend &&\n\t\t\tcurr !== GraphemeBreakProperty.ZWJ\n\t\t) {\n\t\t\tinExtendedPictographicSequence = false;\n\t\t}\n\n\t\t// Track RI count\n\t\tif (curr === GraphemeBreakProperty.Regional_Indicator) {\n\t\t\triCount++;\n\t\t} else {\n\t\t\triCount = 0;\n\t\t}\n\n\t\tif (shouldBreak) {\n\t\t\tboundaries.push(i);\n\t\t}\n\t}\n\n\t// GB2: Break at the end of text\n\tboundaries.push(len);\n\n\treturn { boundaries, properties };\n}\n\n/**\n * Word boundary result\n */\nexport interface WordBoundaries {\n\t/** Boundary positions */\n\tboundaries: number[];\n\t/** Word break properties */\n\tproperties: WordBreakProperty[];\n}\n\n/**\n * Find word boundaries in codepoints\n * @param codepoints Array of Unicode codepoints\n * @returns Object containing boundary positions and word break properties\n */\nexport function findWordBoundaries(codepoints: number[]): WordBoundaries {\n\tconst len = codepoints.length;\n\tconst properties: WordBreakProperty[] = [];\n\tconst boundaries: number[] = [];\n\n\tfor (let i = 0; i < codepoints.length; i++) {\n\t\tconst cp = codepoints[i]!;\n\t\tproperties.push(getWordBreakProperty(cp));\n\t}\n\n\tif (len === 0) return { boundaries, properties };\n\n\t// WB1: Break at the start\n\tboundaries.push(0);\n\n\tlet riCount = 0;\n\n\tfor (let i = 1; i < len; i++) {\n\t\tconst prev = properties[i - 1];\n\t\tconst curr = properties[i];\n\n\t\tlet shouldBreak = true;\n\n\t\t// WB3: Do not break within CRLF\n\t\tif (prev === WordBreakProperty.CR && curr === WordBreakProperty.LF) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB3a-b: Break before and after Newlines\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Newline ||\n\t\t\tprev === WordBreakProperty.CR ||\n\t\t\tprev === WordBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t} else if (\n\t\t\tcurr === WordBreakProperty.Newline ||\n\t\t\tcurr === WordBreakProperty.CR ||\n\t\t\tcurr === WordBreakProperty.LF\n\t\t) {\n\t\t\tshouldBreak = true;\n\t\t}\n\t\t// WB3c: Do not break within emoji ZWJ sequences\n\t\telse if (\n\t\t\tprev === WordBreakProperty.ZWJ &&\n\t\t\tcurr === WordBreakProperty.Extended_Pictographic\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB3d: Keep horizontal whitespace together\n\t\telse if (\n\t\t\tprev === WordBreakProperty.WSegSpace &&\n\t\t\tcurr === WordBreakProperty.WSegSpace\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB4: Ignore Format and Extend characters\n\t\telse if (\n\t\t\tcurr === WordBreakProperty.Format ||\n\t\t\tcurr === WordBreakProperty.Extend ||\n\t\t\tcurr === WordBreakProperty.ZWJ\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB5: Do not break between most letters\n\t\telse if (\n\t\t\t(prev === WordBreakProperty.ALetter ||\n\t\t\t\tprev === WordBreakProperty.Hebrew_Letter) &&\n\t\t\t(curr === WordBreakProperty.ALetter ||\n\t\t\t\tcurr === WordBreakProperty.Hebrew_Letter)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB6-7: Do not break letters across certain punctuation\n\t\telse if (\n\t\t\t(prev === WordBreakProperty.ALetter ||\n\t\t\t\tprev === WordBreakProperty.Hebrew_Letter) &&\n\t\t\t(curr === WordBreakProperty.MidLetter ||\n\t\t\t\tcurr === WordBreakProperty.MidNumLet ||\n\t\t\t\tcurr === WordBreakProperty.Single_Quote)\n\t\t) {\n\t\t\t// Look ahead\n\t\t\tif (i + 1 < len) {\n\t\t\t\tconst next = properties[i + 1];\n\t\t\t\tif (\n\t\t\t\t\tnext === WordBreakProperty.ALetter ||\n\t\t\t\t\tnext === WordBreakProperty.Hebrew_Letter\n\t\t\t\t) {\n\t\t\t\t\tshouldBreak = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// WB8-10: Do not break within sequences of digits\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Numeric &&\n\t\t\tcurr === WordBreakProperty.Numeric\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t} else if (\n\t\t\t(prev === WordBreakProperty.ALetter ||\n\t\t\t\tprev === WordBreakProperty.Hebrew_Letter) &&\n\t\t\tcurr === WordBreakProperty.Numeric\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t} else if (\n\t\t\tprev === WordBreakProperty.Numeric &&\n\t\t\t(curr === WordBreakProperty.ALetter ||\n\t\t\t\tcurr === WordBreakProperty.Hebrew_Letter)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB11-12: Do not break within sequences with numeric separators\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Numeric &&\n\t\t\t(curr === WordBreakProperty.MidNum ||\n\t\t\t\tcurr === WordBreakProperty.MidNumLet ||\n\t\t\t\tcurr === WordBreakProperty.Single_Quote)\n\t\t) {\n\t\t\tif (i + 1 < len && properties[i + 1] === WordBreakProperty.Numeric) {\n\t\t\t\tshouldBreak = false;\n\t\t\t}\n\t\t}\n\t\t// WB13: Do not break between Katakana\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Katakana &&\n\t\t\tcurr === WordBreakProperty.Katakana\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB13a-b: ExtendNumLet binding\n\t\telse if (\n\t\t\t(prev === WordBreakProperty.ALetter ||\n\t\t\t\tprev === WordBreakProperty.Hebrew_Letter ||\n\t\t\t\tprev === WordBreakProperty.Numeric ||\n\t\t\t\tprev === WordBreakProperty.Katakana ||\n\t\t\t\tprev === WordBreakProperty.ExtendNumLet) &&\n\t\t\tcurr === WordBreakProperty.ExtendNumLet\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t} else if (\n\t\t\tprev === WordBreakProperty.ExtendNumLet &&\n\t\t\t(curr === WordBreakProperty.ALetter ||\n\t\t\t\tcurr === WordBreakProperty.Hebrew_Letter ||\n\t\t\t\tcurr === WordBreakProperty.Numeric ||\n\t\t\t\tcurr === WordBreakProperty.Katakana)\n\t\t) {\n\t\t\tshouldBreak = false;\n\t\t}\n\t\t// WB15-16: Do not break within emoji flag sequences\n\t\telse if (\n\t\t\tprev === WordBreakProperty.Regional_Indicator &&\n\t\t\tcurr === WordBreakProperty.Regional_Indicator\n\t\t) {\n\t\t\tif (riCount % 2 === 1) {\n\t\t\t\tshouldBreak = false;\n\t\t\t}\n\t\t}\n\n\t\t// Track RI count\n\t\tif (curr === WordBreakProperty.Regional_Indicator) {\n\t\t\triCount++;\n\t\t} else {\n\t\t\triCount = 0;\n\t\t}\n\n\t\tif (shouldBreak) {\n\t\t\tboundaries.push(i);\n\t\t}\n\t}\n\n\t// WB2: Break at the end\n\tboundaries.push(len);\n\n\treturn { boundaries, properties };\n}\n\n/**\n * Split text into grapheme clusters\n * @param text Text string to split\n * @returns Array of grapheme cluster strings\n */\nexport function splitGraphemes(text: string): string[] {\n\tconst codepoints: number[] = [];\n\tconst chars = [...text];\n\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t}\n\n\tconst { boundaries } = findGraphemeBoundaries(codepoints);\n\tconst graphemes: string[] = [];\n\n\tlet start = 0;\n\tfor (let i = 0; i < boundaries.length; i++) {\n\t\tconst end = boundaries[i]!;\n\t\tif (end > start) {\n\t\t\tgraphemes.push(chars.slice(start, end).join(\"\"));\n\t\t}\n\t\tstart = end;\n\t}\n\n\treturn graphemes;\n}\n\n/**\n * Split text into words\n * @param text Text string to split\n * @returns Array of word strings (whitespace-only segments are filtered out)\n */\nexport function splitWords(text: string): string[] {\n\tconst codepoints: number[] = [];\n\tconst chars = [...text];\n\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t}\n\n\tconst { boundaries, properties } = findWordBoundaries(codepoints);\n\tconst words: string[] = [];\n\n\tfor (let i = 0; i < boundaries.length - 1; i++) {\n\t\tconst start = boundaries[i]!;\n\t\tconst end = boundaries[i + 1]!;\n\n\t\t// Skip whitespace-only segments\n\t\tlet hasContent = false;\n\t\tfor (let j = start; j < end; j++) {\n\t\t\tconst prop = properties[j];\n\t\t\tif (\n\t\t\t\tprop !== WordBreakProperty.WSegSpace &&\n\t\t\t\tprop !== WordBreakProperty.CR &&\n\t\t\t\tprop !== WordBreakProperty.LF &&\n\t\t\t\tprop !== WordBreakProperty.Newline\n\t\t\t) {\n\t\t\t\thasContent = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hasContent) {\n\t\t\twords.push(chars.slice(start, end).join(\"\"));\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Count grapheme clusters in text\n * @param text Text string to analyze\n * @returns Number of grapheme clusters in the text\n */\nexport function countGraphemes(text: string): number {\n\tconst codepoints: number[] = [];\n\tconst chars = [...text];\n\tfor (let i = 0; i < chars.length; i++) {\n\t\tconst char = chars[i]!;\n\t\tcodepoints.push(char.codePointAt(0) ?? 0);\n\t}\n\tconst { boundaries } = findGraphemeBoundaries(codepoints);\n\treturn boundaries.length;\n}\n\n/**\n * Analyze grapheme boundaries for glyph infos\n * @param infos Array of glyph information objects\n * @returns Object containing boundary positions and grapheme break properties\n */\nexport function analyzeGraphemesForGlyphs(\n\tinfos: GlyphInfo[],\n): GraphemeBoundaries {\n\tconst codepoints = infos.map((info) => info.codepoint);\n\treturn findGraphemeBoundaries(codepoints);\n}\n\n/**\n * Analyze word boundaries for glyph infos\n * @param infos Array of glyph information objects\n * @returns Object containing boundary positions and word break properties\n */\nexport function analyzeWordsForGlyphs(infos: GlyphInfo[]): WordBoundaries {\n\tconst codepoints = infos.map((info) => info.codepoint);\n\treturn findWordBoundaries(codepoints);\n}\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8OO,SAAS,YAAY,CAC3B,OACA,QACA,YAAuB,cACd;AAAA,EACT,IAAI;AAAA,EACJ,QAAQ;AAAA,SACF;AAAA,MACJ,gBAAgB,IAAI;AAAA,MACpB;AAAA,SACI;AAAA,MACJ,gBAAgB;AAAA,MAChB;AAAA,SACI;AAAA,SACA;AAAA,MACJ,gBAAgB;AAAA,MAChB;AAAA,SACI;AAAA,MACJ,gBAAgB;AAAA,MAChB;AAAA;AAAA,EAGF,MAAM,QACL,cAAc,eAAiB,KAAK,KAAK,QAAQ,CAAC,IAAI,QAAQ;AAAA,EAE/D,OAAO;AAAA,IACN,QAAQ,IAAI,WAAW,QAAQ,MAAM;AAAA,IACrC;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,UAAU,cAAc,eAAiB,IAAI;AAAA,EAC9C;AAAA;AAOM,SAAS,WAAW,CAAC,QAAsB;AAAA,EACjD,OAAO,OAAO,KAAK,CAAC;AAAA;AAYd,SAAS,oBAAoB,CACnC,OACA,QACA,YAAuB,cACd;AAAA,EACT,MAAM,SAAS,aAAa,OAAO,QAAQ,SAAS;AAAA,EAEpD,OAAO,QAAQ,CAAC,OAAO;AAAA,EACvB,OAAO;AAAA;AAAA,IAjSI,WAgDA;AAAA;AAAA,GAhDL,CAAK,eAAL;AAAA,IAEN,gCAAO,KAAP;AAAA,IAEA,gCAAO,KAAP;AAAA,IAEA,+BAAM,KAAN;AAAA,IAEA,iCAAQ,KAAR;AAAA,IAEA,gCAAO,KAAP;AAAA,KAVW;AAAA,GAgDL,CAAK,cAAL;AAAA,IAEN,iCAAU,KAAV;AAAA,IAEA,iCAAU,KAAV;AAAA,KAJW;AAAA;;;ICnDC,gBAqGA;AAAA;AAAA,EArGA,iBAAiB,IAAI,WAAW;AAAA,IAG5C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACzE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAEhB;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAEjC;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAGjC;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAErE;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAEH;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAE/D;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAE/D;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAEhB;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAC1E;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAC1E;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAC1E;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAE5D;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAC1E;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IACxE;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAAI;AAAA,IAEhE;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC3E;AAAA,IAAG;AAAA,IAAG;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CA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EA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AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;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;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EAEzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EAEzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,KAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EAEzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,KAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAAC,IAAQ,GAAM,CAAC;AAAA,EACzB,CAAC,MAAQ,CAA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A;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAE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AC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,OAAO;AAAA,IAAS,OAAO;AAAA,EAC3B,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAC3C,IAAI,MAAM,UAAW,MAAM;AAAA,IAAS,OAAO;AAAA,EAG3C,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO,QAAU,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC3C,IAAI,OAAO,QAAU,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAG1B,IAAI,OAAO,SAAU,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,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AO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO,QAAU,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC3C,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EAGzC,IAAI,MAAM,OAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EA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,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EAGzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO,SAAU,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC3C,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAG1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,MAAM,QAAU,MAAM,QAAU,OAAO;AAAA,IAC1C,OAAO;AAAA,EACR,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAC1B,IAAI,OAAO;AAAA,IAAQ,OAAO;AAAA,EAG1B,MAAM,MAAM,yBAAyB,EAAE;AAAA,EACvC,IAAI,QAAQ;AAAA,IAA8B,OAAO;AAAA,EAGjD,IAAI,MAAM,MAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,MAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,OAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,OAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,OAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,OAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,OAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,QAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EACzC,IAAI,MAAM,SAAU,MAAM;AAAA,IAAQ,OAAO;AAAA,EAEzC,OAAO;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",
  "debugId": "7AB40BE30542535E64756E2164756E21",
  "names": []
}